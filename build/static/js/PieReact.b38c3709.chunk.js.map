{"version":3,"sources":["../static/js/PieReact.b38c3709.chunk.js","../node_modules/zrender/lib/config.js","../node_modules/zrender/lib/container/Group.js","../node_modules/echarts/lib/view/Chart.js","../node_modules/echarts/lib/data/DataDiffer.js","../node_modules/echarts/lib/scale/Scale.js","../node_modules/echarts/lib/component/axisPointer/modelHelper.js","../node_modules/echarts/lib/model/mixin/makeStyleMapper.js","../node_modules/echarts/lib/coord/Axis.js","../node_modules/echarts/lib/chart/helper/createListFromArray.js","../node_modules/zrender/lib/graphic/Displayable.js","../node_modules/zrender/lib/graphic/Gradient.js","../node_modules/echarts/lib/util/throttle.js","../node_modules/echarts/lib/scale/Interval.js","../node_modules/echarts/lib/component/axis/AxisBuilder.js","../node_modules/echarts/lib/component/axis/AxisView.js","../node_modules/zrender/lib/graphic/helper/image.js","../node_modules/echarts/lib/util/component.js","../node_modules/zrender/lib/core/timsort.js","../node_modules/echarts/lib/coord/axisModelCommonMixin.js","../node_modules/echarts/lib/component/dataZoom/DataZoomModel.js","../node_modules/echarts/lib/component/dataZoom/helper.js","../node_modules/echarts/lib/component/dataZoom/DataZoomView.js","../node_modules/echarts/lib/component/axisPointer.js","../node_modules/echarts/lib/component/axisPointer/viewHelper.js","../node_modules/zrender/lib/mixin/Transformable.js","../node_modules/zrender/lib/core/log.js","../node_modules/zrender/lib/graphic/helper/text.js","../node_modules/zrender/lib/graphic/Image.js","../node_modules/echarts/lib/view/Component.js","../node_modules/echarts/lib/component/helper/sliderMove.js","../node_modules/zrender/lib/core/LRU.js","../node_modules/zrender/lib/graphic/Style.js","../node_modules/zrender/lib/Element.js","../node_modules/zrender/lib/core/guid.js","../node_modules/zrender/lib/animation/Animator.js","../node_modules/zrender/lib/graphic/helper/roundRect.js","../node_modules/zrender/lib/contain/util.js","../node_modules/zrender/lib/graphic/Pattern.js","../node_modules/zrender/lib/graphic/helper/poly.js","../node_modules/echarts/lib/model/mixin/colorPalette.js","../node_modules/zrender/lib/animation/requestAnimationFrame.js","../node_modules/echarts/lib/scale/helper.js","../node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js","../node_modules/echarts/lib/component/axisPointer/globalListener.js","../node_modules/echarts/lib/component/helper/listComponent.js","../node_modules/echarts/lib/component/dataZoom/history.js","../node_modules/zrender/lib/core/bbox.js","../node_modules/zrender/lib/graphic/helper/fixClipWithShadow.js","../node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js","../node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js","../node_modules/echarts/lib/component/axis/cartesianAxisHelper.js","../node_modules/echarts/lib/component/legend/LegendModel.js","../node_modules/echarts/lib/component/legend/LegendView.js","../node_modules/echarts/lib/component/helper/BrushController.js","../node_modules/echarts/lib/component/helper/cursorHelper.js","../node_modules/zrender/lib/graphic/mixin/RectText.js","../node_modules/zrender/lib/contain/line.js","../node_modules/zrender/lib/contain/quadratic.js","../node_modules/zrender/lib/contain/windingLine.js","../node_modules/zrender/lib/graphic/Text.js","../node_modules/zrender/lib/graphic/LinearGradient.js","../node_modules/zrender/lib/zrender.js","../node_modules/echarts/lib/component/tooltip.js","../node_modules/echarts/lib/component/legend.js","../node_modules/echarts/lib/processor/dataFilter.js","../node_modules/echarts/lib/component/toolbox.js","../node_modules/echarts/lib/component/helper/interactionMutex.js","../node_modules/echarts/lib/component/helper/BrushTargetManager.js","../node_modules/echarts/lib/component/helper/brushHelper.js","../node_modules/echarts/lib/component/dataZoom/typeDefaulter.js","../node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js","../node_modules/echarts/lib/component/dataZoom/dataZoomAction.js","../node_modules/echarts/lib/model/Global.js","../node_modules/echarts/lib/model/mixin/lineStyle.js","../node_modules/echarts/lib/model/mixin/areaStyle.js","../node_modules/echarts/lib/model/mixin/textStyle.js","../node_modules/zrender/lib/tool/path.js","../node_modules/zrender/lib/mixin/Animatable.js","../node_modules/zrender/lib/animation/Clip.js","../node_modules/zrender/lib/animation/easing.js","../node_modules/zrender/lib/contain/path.js","../node_modules/zrender/lib/contain/cubic.js","../node_modules/zrender/lib/contain/arc.js","../node_modules/zrender/lib/tool/transformPath.js","../node_modules/zrender/lib/graphic/shape/Circle.js","../node_modules/zrender/lib/graphic/shape/Sector.js","../node_modules/zrender/lib/graphic/shape/Ring.js","../node_modules/zrender/lib/graphic/shape/Polygon.js","../node_modules/zrender/lib/graphic/helper/smoothSpline.js","../node_modules/zrender/lib/graphic/helper/smoothBezier.js","../node_modules/zrender/lib/graphic/shape/Polyline.js","../node_modules/zrender/lib/graphic/shape/Rect.js","../node_modules/zrender/lib/graphic/shape/Line.js","../node_modules/zrender/lib/graphic/shape/BezierCurve.js","../node_modules/zrender/lib/graphic/shape/Arc.js","../node_modules/zrender/lib/graphic/CompoundPath.js","../node_modules/zrender/lib/graphic/RadialGradient.js","../node_modules/echarts/lib/model/mixin/itemStyle.js","../node_modules/echarts/lib/model/mixin/boxLayout.js","../node_modules/echarts/lib/model/globalDefault.js","../node_modules/echarts/lib/ExtensionAPI.js","../node_modules/echarts/lib/model/OptionManager.js","../node_modules/echarts/lib/preprocessor/backwardCompat.js","../node_modules/echarts/lib/preprocessor/helper/compatStyle.js","../node_modules/zrender/lib/Handler.js","../node_modules/zrender/lib/mixin/Draggable.js","../node_modules/zrender/lib/Storage.js","../node_modules/zrender/lib/animation/Animation.js","../node_modules/zrender/lib/dom/HandlerProxy.js","../node_modules/zrender/lib/core/GestureMgr.js","../node_modules/zrender/lib/Painter.js","../node_modules/zrender/lib/Layer.js","../node_modules/echarts/lib/visual/seriesColor.js","../node_modules/echarts/lib/loading/default.js","../node_modules/echarts/lib/scale/Ordinal.js","../node_modules/echarts/lib/scale/Time.js","../node_modules/echarts/lib/scale/Log.js","../node_modules/echarts/lib/helper.js","../node_modules/echarts/lib/component/axisPointer/axisTrigger.js","../node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js","../node_modules/echarts/lib/component/axisPointer/AxisPointerView.js","../node_modules/echarts/lib/component/tooltip/TooltipModel.js","../node_modules/echarts/lib/component/tooltip/TooltipView.js","../node_modules/echarts/lib/component/tooltip/TooltipContent.js","../node_modules/echarts/lib/component/legend/legendAction.js","../node_modules/echarts/lib/component/legend/legendFilter.js","../node_modules/echarts/lib/component/helper/selectableMixin.js","../node_modules/echarts/lib/visual/dataColor.js","../node_modules/echarts/lib/component/toolbox/ToolboxModel.js","../node_modules/echarts/lib/component/toolbox/ToolboxView.js","../node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js","../node_modules/echarts/lib/component/toolbox/feature/MagicType.js","../node_modules/echarts/lib/component/toolbox/feature/DataView.js","../node_modules/echarts/lib/component/toolbox/feature/DataZoom.js","../node_modules/echarts/lib/component/dataZoomSelect.js","../node_modules/echarts/lib/component/dataZoom/AxisProxy.js","../node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js","../node_modules/echarts/lib/component/dataZoom/SelectZoomView.js","../node_modules/echarts/lib/component/toolbox/feature/Restore.js","../node_modules/echarts/lib/action/createDataSelectAction.js","../node_modules/echarts/lib/chart/pie.js","../node_modules/echarts/lib/chart/pie/PieSeries.js","../node_modules/echarts/lib/chart/pie/PieView.js","../node_modules/echarts/lib/chart/pie/pieLayout.js","../node_modules/echarts/lib/chart/pie/labelLayout.js","Echarts/PieReact.js","../node_modules/zrender/lib/core/util.js","../node_modules/echarts/lib/echarts.js","../node_modules/echarts/lib/util/graphic.js","../node_modules/echarts/lib/util/number.js","../node_modules/echarts/lib/util/model.js","../node_modules/zrender/lib/core/vector.js","../node_modules/echarts/lib/util/format.js","../node_modules/zrender/lib/core/env.js","../node_modules/echarts/lib/model/Model.js","../node_modules/zrender/lib/graphic/Path.js","../node_modules/echarts/lib/util/layout.js","../node_modules/zrender/lib/core/BoundingRect.js","../node_modules/echarts/lib/model/Component.js","../node_modules/echarts/lib/util/clazz.js","../node_modules/zrender/lib/contain/text.js","../node_modules/zrender/lib/core/matrix.js","../node_modules/echarts/lib/data/List.js","../node_modules/echarts/lib/coord/axisHelper.js","../node_modules/echarts/lib/component/toolbox/featureManager.js","../node_modules/zrender/lib/core/event.js","../node_modules/zrender/lib/core/curve.js","../node_modules/zrender/lib/mixin/Eventful.js","../node_modules/zrender/lib/tool/color.js","../node_modules/echarts/lib/model/Series.js","../node_modules/echarts/lib/data/helper/completeDimensions.js","../node_modules/echarts/lib/util/symbol.js","../node_modules/echarts/lib/lang.js","../node_modules/echarts/lib/CoordinateSystem.js","../node_modules/zrender/lib/core/PathProxy.js"],"names":["webpackJsonp","1000","module","exports","dpr","window","Math","max","devicePixelRatio","config","debugMode","1001","__webpack_require__","zrUtil","Element","BoundingRect","Group","opts","call","this","key","hasOwnProperty","_children","__storage","__dirty","prototype","constructor","isGroup","type","silent","children","slice","childAt","idx","childOfName","name","i","length","childCount","add","child","parent","push","_doAdd","addBefore","nextSibling","indexOf","splice","remove","storage","zr","__zr","addToStorage","addChildrenToStorage","refresh","delFromStorage","delChildrenFromStorage","removeAll","eachChild","cb","context","traverse","dirty","getBoundingRect","includeChildren","rect","tmpRect","tmpMat","ignore","invisible","childRect","transform","getLocalTransform","copy","applyTransform","clone","union","inherits","1002","Chart","group","uid","componentUtil","getUID","elSetState","el","state","trigger","toggleHighlight","data","payload","dataIndex","modelUtil","queryDataIndex","each","normalizeToArray","dataIdx","getItemGraphicEl","eachItemGraphicEl","clazzUtil","init","ecModel","api","render","seriesModel","highlight","getData","downplay","dispose","chartProto","updateView","updateLayout","updateVisual","enableClassExtend","enableClassManagement","registerWhenExtend","1003","defaultKeyGetter","item","DataDiffer","oldArr","newArr","oldKeyGetter","newKeyGetter","_old","_new","_oldKeyGetter","_newKeyGetter","initIndexMap","arr","map","keyArr","keyGetterName","dataDiffer","existence","func","_add","update","_update","_remove","execute","oldDataIndexMap","newDataIndexMap","oldDataKeyArr","newDataKeyArr","len","unshift","j","1004","Scale","setting","_setting","_extent","Infinity","_interval","apply","arguments","scaleProto","parse","val","getSetting","contain","extent","normalize","scale","unionExtent","other","unionExtentFromData","dim","getDataExtent","getExtent","setExtent","start","end","thisExtent","isNaN","getTicksLabels","labels","ticks","getTicks","getLabel","isBlank","_isBlank","setBlank","1005","collectAxesInfo","result","globalTooltipModel","getComponent","globalAxisPointerModel","linksOption","get","linkGroups","getCoordinateSystems","coordSys","saveTooltipAxisInfo","fromTooltip","triggerTooltip","axis","axisPointerModel","model","getModel","axisPointerShow","isHandleTrigger","makeAxisPointerModel","baseTooltipModel","snap","makeKey","involveSeries","axisInfo","axesInfo","useHandle","seriesModels","axesInfoInCoordSys","seriesInvolved","groupIndex","getLinkGroupIndex","linkGroup","mapper","axisPointerEnabled","coordSysKey","coordSysAxesInfo","coordSysMap","coordSysModel","getAxes","curry","getTooltipAxes","triggerAxis","cross","tooltipAxes","baseAxes","otherAxes","tooltipAxisPointerModel","volatileOption","field","labelOption","label","show","crossStyle","lineStyle","defaults","textStyle","Model","collectSeriesInfo","eachSeries","coordinateSystem","seriesTooltipTrigger","seriesTooltipShow","getAxis","seriesDataCount","count","axisModel","linkOption","checkPropInLink","id","componentIndex","linkPropValue","axisPropValue","isArray","helper","collect","fixValue","getAxisInfo","option","status","value","reverse","getAxisPointerModel","1006","properties","excludes","includes","style","propName","getShallow","1007","fixExtentWithBands","nTick","size","margin","numberUtil","linearMap","axisHelper","normalizedExtent","Axis","inverse","onBand","_labelInterval","coord","min","containData","dataToCoord","getPixelPrecision","dataExtent","clamp","coordToData","t","pointToData","point","getTicksCoords","alignWithLabel","bands","getBands","coords","getLabelsCoords","span","getBandWidth","axisExtent","abs","getLabelInterval","labelInterval","labelModel","interval","isHorizontal","getAxisLabelInterval","getFormattedLabels","getFont","1008","firstDataNotNull","ifNeedCompleteOrdinalData","sampleItem","getDataItemValue","createListFromArray","__DEV__","Error","coordSysName","creator","creators","registeredCoordSys","CoordinateSystem","completeDimOpt","encodeDef","dimsDef","dimensions","getDimensionsInfo","completeDimensions","categoryIndex","list","List","nameList","createNameList","categories","dimValueGetter","itemOpt","dimName","dimIndex","isDataItemOption","hasItemOption","converDataValue","categoryAxesModels","getCategories","initData","isStackable","axisType","getDimTypeByAxis","categoryAxisModel","categoryDim","dataLen","cartesian2d","axesModels","queryComponents","mainType","index","xAxisModel","yAxisModel","retrieve","xAxisType","yAxisType","stackable","isXAxisCateogry","isYAxisCategory","x","y","singleAxis","singleAxisModel","singleAxisType","isCategory","single","polar","polarModel","angleAxisModel","findAxisModel","radiusAxisModel","radiusAxisType","angleAxisType","isAngleAxisCateogry","isRadiusAxisCateogry","radius","angle","geo","1009","Displayable","Style","_rect","__clipPaths","RectText","z","z2","zlevel","draggable","dragging","culling","cursor","rectHover","progressive","beforeBrush","ctx","afterBrush","brush","prevEl","rectContain","transformCoordToLocal","animateStyle","loop","animate","attrKV","set","setStyle","useStyle","obj","mixin","1010","Gradient","colorStops","addColorStop","offset","color","1011","lib","ORIGIN_METHOD","RATE","throttle","fn","delay","debounce","exec","lastExec","Date","getTime","timer","scope","args","currCall","diff","debounceNextCall","lastCall","thisDelay","thisDebounce","clearTimeout","setTimeout","clear","debounceDelay","createOrUpdate","fnAttr","rate","throttleType","originFn","lastThrottleType","1012","formatUtil","roundNumber","round","IntervalScale","extend","_intervalPrecision","parseFloat","getInterval","setInterval","_niceExtent","getIntervalPrecision","intervalScaleGetTicks","opt","precision","getPrecisionSafe","addCommas","niceTicks","splitNumber","minInterval","maxInterval","isFinite","intervalScaleNiceTicks","intervalPrecision","niceTickExtent","niceExtent","expandSize","fixMax","fixMin","floor","ceil","create","1013","makeAxisEventDataBase","eventData","componentType","endTextLayout","textPosition","textRotate","textAlign","textVerticalAlign","rotationDiff","remRadian","rotation","onLeft","isRadianAroundZero","PI","isSilent","tooltipOpt","fixMinMaxLabelShow","labelEls","tickEls","showMinLabel","showMaxLabel","firstLabel","nextLabel","lastLabel","prevLabel","firstTick","nextTick","lastTick","prevTick","ignoreEl","isTwoLabelOverlapped","current","next","labelLayout","firstRect","nextRect","mRotationBack","matrix","identity","rotate","mul","intersect","isNameLocationCenter","nameLocation","buildAxisTick","axisBuilder","tickModel","lineStyleModel","tickLen","tickInterval","ticksCoords","pt1","pt2","_transform","ticksCnt","ifIgnoreOnTick","tickCoord","tickDirection","v2ApplyTransform","tickEl","graphic","Line","subPixelOptimizeLine","anid","shape","x1","y1","x2","y2","getLineStyle","stroke","buildAxisLabel","axisLabelShow","labelMargin","labelRotation","labelRotate","innerTextLayout","labelDirection","categoryData","triggerEvent","tickVal","itemLabelModel","textColor","getTextColor","pos","labelOffset","labelStr","textEl","Text","position","setTextStyle","text","textFill","targetType","_dumbGroup","updateTransform","decomposeTransform","vec2","AxisBuilder","nameDirection","dumbGroup","hasBuilder","builders","getGroup","axisLine","lineCap","strokeContainThreshold","axisTickLabel","axisName","textStyleModel","gap","gapSignal","nameRotation","axisNameAvailableWidth","sin","textFont","truncateOpt","ellipsis","maxWidth","nameTruncateMaxWidth","truncatedText","truncateText","minChar","placeholder","formatterParams","$vars","__fullText","__truncatedText","tooltip","content","formatter","axisRotation","textRotation","direction","rawTick","1014","updateAxisPointer","axisView","forceRender","Clazz","AxisView","getAxisPointerClass","axisPointerClass","axisPointerModelHelper","_axisPointer","disposeAxisPointer","axisPointer","extendComponentView","superApply","force","axisPointerClazz","registerAxisPointerClass","clazz","1015","imageOnLoad","cachedImgObj","__cachedImgObj","onload","pending","pendingWrap","cbPayload","hostEl","LRU","globalImageCache","findExistImage","newImageOrSrc","image","createOrUpdateImage","__zrImageSrc","isImageReady","Image","put","src","width","height","1016","parseClassType","base","random","join","enableSubTypeDefaulter","entity","subTypeDefaulters","registerSubTypeDefaulter","defaulter","main","determineSubType","componentTypeMain","hasSubTypes","enableTopologicalTravel","dependencyGetter","makeDepndencyGraph","fullNameList","graph","noEntryList","thisItem","createDependencyGraphItem","originalDeps","availableDeps","getAvailableDependencies","entryCount","dependentName","predecessor","thatItem","successor","dep","topologicalTravel","targetNameList","callback","removeEdge","succComponentType","stack","removeEdgeAndAdd","targetNameSet","currComponentType","pop","currVertex","isInTargetNameSet","1017","minRunLength","n","r","DEFAULT_MIN_MERGE","makeAscendingRun","array","lo","hi","compare","runHi","reverseRun","binaryInsertionSort","mid","pivot","left","right","gallopLeft","hint","lastOffset","maxOffset","tmp","m","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","length2","k","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","sort","remaining","ts","minRun","1018","getName","isObject","getMin","origin","rangeStart","eqNaN","getMax","rangeEnd","getNeedCrossZero","getCoordSysModel","noop","setRange","resetRange","1019","retrieveRaw","ret","updateRangeUse","dataZoomModel","rawOption","rangePropMode","_rangePropMode","rangeModeInOption","names","percentSpecified","valueSpecified","env","echarts","AxisProxy","eachAxisDim","DataZoomModel","extendComponentModel","dependencies","defaultOption","orient","xAxisIndex","yAxisIndex","filterMode","startValue","endValue","minSpan","maxSpan","minValueSpan","maxValueSpan","rangeMode","parentModel","_dataIntervalByAxis","_dataInfo","_axisProxies","_autoThrottle","mergeDefaultAndTheme","doInit","mergeOption","newOption","merge","thisOption","canvasSupported","realtime","_setDefaultThrottle","_resetTarget","_giveAxisProxies","axisProxies","eachTargetAxis","dimNames","axisIndex","dependentModels","axisProxy","__dzAxisProxy","autoMode","_judgeAutoMode","axisIndexName","_autoSetAxisIndex","_autoSetOrient","hasIndexSpecified","autoAxisIndex","singleAxisIndex","axisIndices","axisModels","_isSeriesHasAllAxesTypeOf","axisId","is","seriesAxisIndex","globalOption","animation","animationDurationUpdate","getFirstTargetAxisModel","firstAxisModel","indices","getAxisProxy","getAxisModel","setRawRange","ignoreUpdateRangeUsg","getPercentRange","findRepresentativeAxisProxy","getDataPercentWindow","getValueRange","axisDimName","getDataValueWindow","hostedBy","getRangePropMode","1020","AXIS_DIMS","COORDS","isCoordSupported","coordType","createNameEach","attrs","capitalNames","capitalFirst","capitalAttrs","nameObj","capital","createLinkedNodesFinder","forEachNode","forEachEdgeType","edgeIdGetter","isNodeAbsorded","node","nodes","isLinked","hasLink","edgeType","edgeId","records","absorb","sourceNode","processSingleNode","existsLink","1021","ComponentView","getTargetCoordInfo","save","coordModel","store","coordIndex","coordSysLists","1022","axisTrigger","registerPreprocessor","link","registerProcessor","PRIORITY","PROCESSOR","STATISTIC","registerAction","event","1023","confineInContainer","viewWidth","getWidth","viewHeight","getHeight","textContain","buildElStyle","axisPointerType","styleModel","fill","getAreaStyle","buildLabelElOption","elOption","labelPos","getValueLabel","paddings","normalizeCssArray","font","textRect","align","verticalAlign","bgColor","lineWidth","shadowBlur","shadowColor","shadowOffsetX","shadowOffsetY","seriesDataIndices","params","getAxisRawValue","seriesData","idxItem","series","getSeriesByIndex","seriesIndex","dataIndexInside","dataParams","getDataParams","isString","replace","isFunction","getTransformedPosition","layoutInfo","translate","buildCartesianSingleLabelElOption","textLayout","makeLineShape","p1","p2","xDimIndex","makeRectShape","xy","wh","makeSectorShape","cx","cy","r0","startAngle","endAngle","clockwise","1024","isNotAroundZero","EPSILON","vector","mIdentity","Transformable","transformableProto","needLocalTransform","parentHasTransform","invTransform","invert","setTransform","restoreTransform","tmpTransform","sx","sy","sqrt","atan2","getGlobalScale","v2","transformCoordToGlobal","target","1025","console","log","1026","normalizeStyle","makeFont","VALID_TEXT_ALIGN","textBaseline","VALID_TEXT_VERTICAL_ALIGN","textPadding","util","renderPlainText","setCtx","DEFAULT_FONT","contentBlock","__textCotentBlock","parsePlainText","truncate","outerHeight","textLines","lines","lineHeight","boxPos","getBoxPosition","baseX","baseY","applyTextRotation","boxY","adjustTextY","textX","textY","needDrawBg","needDrawBackground","textWidth","outerWidth","boxX","adjustTextX","drawBackground","getTextXForPadding","textShadowBlur","textShadowColor","textShadowOffsetX","textShadowOffsetY","textStrokeWidth","textStroke","getStroke","getFill","strokeText","fillText","renderRichText","parseRichText","drawRichText","contentWidth","xLeft","lineTop","xRight","token","line","tokens","tokenCount","usedWidth","leftIndex","lineXLeft","lineXRight","rightIndex","placeToken","textOrigin","tokenStyle","rich","styleName","isLineHolder","textHeight","retrieve3","retrieve2","textBackgroundColor","textBorderWidth","textBorderColor","isPlainBg","textBoxShadowBlur","textBoxShadowColor","textBoxShadowOffsetX","textBoxShadowOffsetY","beginPath","textBorderRadius","roundRectHelper","buildPath","closePath","imageHelper","onBgImageLoaded","drawImage","blockHeiht","Array","parsePercent","res","adjustTextPositionOnRect","textDistance","textOffset","prop","maxValue","lastIndexOf","center","top","bottom","middle","normalizeTextStyle","renderText","needDrawText","1027","ZImage","bind","_image","aspect","sWidth","sHeight","drawRectText","1028","Component","componentModel","componentProto","1029","getSpanSign","handleEnds","handleIndex","dist","sign","restrict","delta","extentSpan","originalDistSign","extentMinSpan","realExtent","currDistSign","1030","LinkedList","head","tail","_len","linkedListProto","insert","entry","Entry","insertEntry","prev","maxSize","_list","_map","_maxSize","_lastRemovedEntry","LRUProto","removed","leastUsedEntry","1031","createLinearGradient","global","createRadialGradient","STYLE_COMMON_PROPS","host","extendFrom","opacity","lineDash","lineDashOffset","strokeNoScale","fontStyle","fontWeight","fontSize","fontFamily","textTag","textLineHeight","transformText","blend","prevStyle","firstDraw","fillStyle","strokeStyle","globalAlpha","globalCompositeOperation","hasStroke","getLineScale","hasFill","otherStyle","overwrite","newStyle","getGradient","method","canvasGradient","styleProto","1032","guid","Eventful","Animatable","clipPath","drift","dx","dy","beforeUpdate","afterUpdate","hide","attr","setClipPath","addSelfToZr","removeClipPath","__clipTarget","removeSelfFromZr","animators","addAnimator","removeAnimator","1033","idStart","1034","defaultGetter","defaultSetter","interpolateNumber","p0","percent","interpolateString","interpolateArray","out","arrDim","len2","fillArr","arr0","arr1","arr0Len","arr1Len","arraySlice","isArraySame","catmullRomInterpolateArray","p3","t2","t3","catmullRomInterpolate","v0","v1","cloneValue","isArrayLike","rgba2String","rgba","getArrayDim","keyframes","lastValue","createTrackClip","animator","easing","oneTrackDone","forceAnimate","getter","_getter","setter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","a","b","time","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","_target","w","lastFrame","lastFramePercent","onframe","frame","range","clip","Clip","life","_loop","_delay","ondestroy","Animator","_tracks","_clipCount","_doneList","_onframeList","_clipList","when","props","tracks","during","pause","_paused","resume","isPaused","_doneCallback","doneList","lastClip","self","clipCount","addClip","oldOnFrame","stop","forwardToLast","clipList","removeClip","done","getClips","1035","r1","r2","r3","r4","total","moveTo","lineTo","quadraticCurveTo","1036","PI2","normalizeRadian","1037","Pattern","repeat","getCanvasPattern","createPattern","1038","smoothSpline","smoothBezier","points","smooth","controlPoints","smoothConstraint","cp1","cp2","p","bezierCurveTo","l","1039","classUtil","clearColorPalette","getColorFromPalette","colorIdx","colorNameMap","colorPalette","1040","requestAnimationFrame","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","1041","nice","fixExtent","tick","1042","finder","getTooltipPosition","dataToPoint","getValues","coordDimToDataDim","1043","initGlobalListeners","useHandler","eventType","on","e","dis","makeDispatchAction","record","dispatchAction","dispatchTooltipFinally","pendings","initialized","doEnter","onLeave","actuallyPayload","showLen","showTip","hideLen","hideTip","handler","currTrigger","pendingList","makeGetter","globalListener","register","getZr","unregister","1044","layout","boxLayoutParams","getBoxLayoutParams","padding","viewportSize","getLayoutRect","box","positionElement","makeBackground","getItemStyle","Rect","1045","giveStore","ATTR","history","newSnapshot","batchItem","dataZoomId","subType","percentRange","snapshot","1048","curve","bbox","mathMin","mathMax","mathSin","mathCos","cos","extremity","fromPoints","fromLine","x0","y0","xDim","yDim","fromCubic","x3","y3","cubicExtrema","cubicAt","fromQuadratic","quadraticExtremum","quadraticAt","tx","ty","fromArc","rx","ry","anticlockwise","vec2Min","vec2Max","1049","shadowTemp","orignalBrush","browser","ie","version","modified","clipPaths","1050","getCartesian","grid","getAxisDimIndex","BaseAxisPointer","viewHelper","cartesianAxisHelper","CartesianAxisPointer","makeElOption","otherExtent","getOtherAxis","getGlobalExtent","pixelValue","toGlobalCoord","elStyle","pointerOption","pointerShapeBuilder","graphicKey","pointer","getHandleTransform","labelInside","updateHandleTransform","currPosition","cursorOtherValue","cursorPoint","tooltipOptions","tooltipOption","targetShape","shadow","bandWidth","1051","updateProps","animationModel","moveAnimation","propsEqual","lastProp","stopAnimation","lastProps","newProps","equals","updateLabelShowHide","labelEl","getHandleTransProps","trans","updateMandatoryProps","eventTool","_group","_lastGraphicKey","_handle","_dragging","_lastValue","_lastStatus","_payloadInfo","animationThreshold","_axisModel","_axisPointerModel","_api","handle","_moveAnimation","determineAnimation","doUpdateProps","updatePointerEl","updateLabelEl","createPointerEl","createLabelEl","_renderHandle","isCategoryAxis","useSnap","pointerEl","handleModel","isInit","createIcon","onmousemove","onmousedown","_onHandleDragMove","ondragend","_onHandleDragEnd","includeStyles","handleSize","_moveHandleToValue","_doDispatchAxisPointer","payloadInfo","axisDim","doClear","buildLabel","1052","gridModel","rawAxisPosition","axisPosition","onZero","getRect","rectBound","axisOffset","posBound","otherAxis","onZeroAxisIndex","onZeroCoord","dirMap","1053","LegendModel","layoutMode","ignoreSize","selected","superCall","optionUpdated","_updateData","legendData","_data","hasSelected","isSelected","select","dataItem","availableNames","getSeries","legendDataProvider","concat","mapArray","_availableNames","unSelect","toggleSelected","backgroundColor","borderColor","borderRadius","borderWidth","itemGap","itemWidth","itemHeight","inactiveColor","selectedMode","1054","dispatchSelectAction","dispatchHighlightAction","dataName","getDisplayList","useHoverLayer","seriesName","dispatchDownplayAction","symbolCreator","listComponentHelper","layoutUtil","newlineDisabled","_contentGroup","_backgroundEl","getContentGroup","legendModel","resetInner","itemAlign","renderInner","positionInfo","mainRect","layoutInner","layoutRect","contentGroup","legendDrawnMap","createHashMap","selectMode","itemModel","newline","getSeriesByName","getVisual","legendSymbolType","symbolType","_createItem","eachRawSeries","indexOfName","getItemVisual","warn","itemGroup","itemIcon","tooltipModel","legendGlobalTooltipModel","createSymbol","hitRect","legendIndex","setHoverStyle","__legendDataIndex","contentRect","1055","BrushController","assert","_zr","_brushType","_brushOption","_panels","_track","_covers","_creatingCover","_creatingPanel","_enableGlobalPan","_mounted","_uid","baseUID","_handlers","mouseHandlers","eventName","doEnableBrush","controller","brushOption","interactionMutex","take","MUTEX_RESOURCE_KEY","brushType","DEFAULT_BRUSH_OPT","doDisableBrush","release","off","createCover","cover","coverRenderers","__brushOption","updateZ","endCreating","creatingCover","coverRenderer","getCoverRenderer","updateCoverShape","COVER_Z","updateCoverAfterCreation","updateCommon","getPanelByPoint","localCursorPoint","panels","panel","pn","isTargetByCursor","getPanelByCover","panelId","clearCovers","covers","originalLength","areas","isEnd","removeOnClick","shouldShowCover","track","mathPow","UNSELECT_THRESHOLD","getTrackEnds","createBaseRectCover","doDrift","edgeNames","makeStyle","updateBaseRect","localRange","brushStyle","MIN_RESIZE_LINE_WIDTH","xa","ya","x2a","y2a","widtha","heighta","updateRectShape","transformable","mainEl","globalDir","getGlobalDirection","CURSOR_MAP","h","setShape","pointsToRect","clipByPanel","formatRectRange","getTransform","localDirection","split","s","inverseMap","transformDirection","driftRect","toRectRange","fromRectRange","rectRange","localDelta","toLocalDelta","namePart","ind","DIRECTION_MAP","driftPolygon","thisGroup","localD","localZero","xmin","ymin","resetCursor","currPanel","setCursorStyle","preventDefault","rawE","mainShapeContain","updateCoverByMouse","eventParams","thisBrushOption","brushMode","determineBrushType","getCreatingRange","defaultBrushType","handleDragEnd","offsetX","offsetY","getLineRenderer","xyIndex","localTrack","ends","getLinearBrushOtherExtent","pow","ne","sw","nw","se","enableBrush","setPanels","panelOpts","mount","enableGlobalPan","eachCover","updateCovers","brushOptionList","getKey","tmpIdPrefix","oldGetKey","addOrUpdate","newIndex","oldIndex","newBrushOption","oldCovers","newCovers","unmount","mousedown","mousemove","mouseup","lineX","lineY","polygon","Polyline","Polygon","1056","IRRELEVANT_EXCLUDES","onIrrelevantElement","targetCoordSysModel","getComponentByElement","topTarget","1059","textHelper","restore","1060","containStroke","_l","_a","_b","1061","quadraticProjectPoint","1062","dir","1063","1064","LinearGradient","globalCoord","1065","delInstance","instances","Handler","Storage","Animation","HandlerProxy","useVML","painterCtors","canvas","zrender","dom","ZRender","getInstance","registerPainter","Ctor","rendererType","renderer","vml","painter","handerProxy","getViewportRoot","root","stage","flush","_needsRefresh","oldDelFromStorage","oldAddToStorage","getId","addRoot","delRoot","configLayer","zLevel","refreshImmediately","_needsRefreshHover","refreshHoverImmediately","addHover","refreshHover","removeHover","clearHover","resize","clearAnimation","pathToImage","cursorStyle","findHover","eventHandler","1066","1067","1068","seriesType","legendModels","findComponents","eachSeriesByType","filterSelf","1069","1070","getStore","resourceKey","userKey","isTaken","1071","BrushTargetManager","targetInfoList","_targetInfoList","info","foundCpts","parseFinder","targetInfoBuilders","builder","include","formatMinMax","minMax","includeMainTypes","INCLUDE_FINDER_MAIN_TYPES","axisConvert","axisNameIndex","to","rangeOrCoordRange","values","toLocalCoord","xyMinMax","NaN","axisDiffProcessor","refer","scales","getScales","xyMinMaxCurr","xyMinMaxOrigin","sizeCurr","getSize","sizeOrigin","brushHelper","COORD_CONVERTS","proto","setOutputRanges","matchOutputRanges","area","coordRange","coordRanges","coordConvert","__rangeOffset","diffProcessor","targetInfo","findTargetInfo","coordSyses","setInputRanges","rangeOffset","makePanelOpts","getDefaultBrushType","getPanelRect","makeRectPanelClipPath","makeRectIsTargetByCursor","makeLinearBrushOtherExtent","controlSeries","areaPanelId","targetInfoMatchers","xAxisModels","yAxisModels","gridModels","gridModelMap","xAxesHas","yAxesHas","cartesians","getCartesians","cartesian","panelRectBuilder","xAxisDeclared","yAxisDeclared","geoModels","geoModel","xminymin","xmaxymax","1072","normalizeRect","cursorHelper","graphicUtil","localPoints","clipPointsByRect","specifiedXYIndex","brushWidth","targetModel","1073","1074","resetSingleAxis","reset","filterSingleAxis","filterData","eachComponent","valueRange","1075","linkedNodesFinder","effectedModels","query","1079","mergeTheme","theme","themeItem","ComponentModel","hasClass","initBase","baseOption","OPTION_INNER_KEY","_componentsMap","_seriesIndices","_theme","globalDefault","getComponentsByTypes","componentsMap","types","newCptOption","existComponent","createSeriesIndices","filterBySubType","components","condition","filter","cpt","assertSeriesInitialized","GlobalModel","optionManager","_optionManager","setOption","optionPreprocessorFuncs","resetOption","optionChanged","mountOption","restoreData","timelineOption","getTimelineOption","mediaOptions","getMediaOption","mediaOption","visitComponent","newCptOptionList","mapResult","mappingToExists","makeIdAndName","keyInfo","exist","resultItem","ComponentModelClass","getClass","extraOpt","newCptTypes","componentOption","getAllClassMainTypes","getOption","isIdInner","getTheme","cpts","isIdArray","isNameArray","queryCond","q","indexAttr","idAttr","nameAttr","component","queryResult","oneSeries","getSeriesByType","rawSeriesIndex","eachRawSeriesByType","isSeriesFiltered","getCurrentSeriesIndices","filterSeries","filteredSeries","componentTypes","1080","getLineDash","lineType","dotSize","dashSize","1081","1082","PATH_COLOR","isEmphasis","getTextRect","1083","processArc","fa","fs","psiDeg","cmd","path","psi","xp","yp","lambda","mathSqrt","f","cxp","cyp","theta","vAngle","u","v","dTheta","vRatio","addData","createPathProxyFromString","cs","cc","RegExp","prevCmd","cpx","cpy","PathProxy","CMD","str","c","charAt","shift","ctlPtx","ctlPty","L","M","C","pathData","Q","A","Z","toStatic","createPathOptions","pathProxy","setData","getContext","rebuildPath","transformPath","Path","vMag","acos","createFromString","extendFromString","mergePath","pathEls","pathList","pathEl","createPathProxy","__dirtyPath","pathBundle","appendPath","1084","animatingShape","pathSplitted","animateTo","_animateToShallow","source","objShallow","propertyCount","1085","options","_life","_initialized","onrestart","_pausedTime","easingFuncs","step","globalTime","deltaTime","_startTime","easingFunc","schedule","fire","restart","_needsRemove","remainder","arg","1086","linear","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","sinusoidalOut","sinusoidalInOut","exponentialIn","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","asin","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","1087","isAroundEqual","swapExtrema","extrema","windingCubic","nRoots","cubicRootAt","roots","y0_","y1_","nExtrema","unit","windingQuadratic","quadraticRootAt","y_","x_","windingArc","containPath","isStroke","xi","yi","windingLine","cubic","quadratic","_x","arc","R","1088","cubicProjectPoint","1089","d","1090","nPoint","mathAtan2","1091","inBundle","1092","fixClipWithShadow","unitX","unitY","1093","1094","polyHelper","1095","interpolate","isLoop","distance","segs","w2","w3","1096","v2Min","v2Max","v2Scale","v2Distance","v2Add","constraint","prevPoint","nextPoint","cps","sub","d0","d1","sum","cp0","1097","1098","1099","pointAt","1100","someVectorAt","isTangent","cpx2","cpy2","cubicDerivativeAt","cpx1","cpy1","quadraticDerivativeAt","curveTool","quadraticSubdivide","cubicSubdivide","tangentAt","1101","1102","paths","_updatePathDirty","dirtyPath","setScale","1103","RadialGradient","1104","getBorderLineDash","1105","1106","platform","navigator","match","blendMode","animationDuration","animationEasing","animationEasingUpdate","progressiveThreshold","hoverLayerThreshold","useUTC","1107","ExtensionAPI","chartInstance","echartsAPIList","1108","OptionManager","_timelineOptions","_mediaList","_mediaDefault","_currentMediaIndices","_optionBackup","_newBaseOption","parseRawOption","isNew","mediaDefault","timelineOptions","mediaList","timelineOpt","timeline","media","singleMedia","preProcess","applyMediaQuery","ecWidth","ecHeight","realMap","aspectratio","applicatable","matched","QUERY_REG","operator","realAttr","toLowerCase","real","expect","indicesEquals","indices1","indices2","oldOption","newCptOpt","oldCptOpt","oldOptionBackup","newParsedOption","isRecreate","optionBackup","timelineModel","getCurrentIndex","1109","compatLayoutProperties","LAYOUT_PROPERTIES","compatStyle","COMPATITABLE_COMPONENTS","COMPATITABLE_SERIES","isTheme","seriesOpt","clockWise","pointerColor","dataRange","visualMap","componentName","1110","compatItemStyle","itemStyleOpt","itemStyle","POSSIBLE_STYLES","normalItemStyleOpt","normal","emphasisItemStyleOpt","emphasis","compatTextStyle","labelOptSingle","TEXT_STYLE_OPTIONS","compatLabelTextStyle","labelOpt","processSeries","upperLabel","edgeLabel","markPoint","markLine","markArea","mpData","mlData","toArr","o","toObj","axes","axisOpt","parallel","parallelOpt","parallelAxisDefault","calendar","calendarOpt","radar","radarOpt","geoOpt","regions","regionObj","1111","makeEventPacket","eveType","cancelBubble","zrX","zrY","gestureEvent","pinchX","pinchY","pinchScale","wheelDelta","zrDelta","zrByTouch","which","EmptyProxy","isHover","displayable","SILENT","Draggable","handlerNames","proxy","painterRoot","_hovered","_lastTouchMoment","_lastX","_lastY","lastHovered","lastHoveredTarget","hovered","hoveredTarget","setCursor","dispatchToElement","mouseout","innerDom","element","toElement","relatedTarget","parentNode","nodeType","dispatch","eventArgs","eventPacket","eachOtherLayer","layer","exclude","hoverCheckResult","_downEl","_downPoint","_upEl","1112","_dragStart","_drag","_dragEnd","param","draggingTarget","_draggingTarget","_y","dropTarget","lastDropTarget","_dropTarget","1113","shapeCompareFunc","timsort","_roots","_displayList","_displayListLen","includeIgnore","updateDisplayList","displayList","_updateAndAddDisplayable","userSetClipPath","currentClipPath","parentClipPath","_renderList","displayableSortFunc","1114","Dispatcher","_clips","_running","_time","_pauseStart","clips","deferredEvents","deferredClips","_startLoop","1115","eventNameFix","firefox","processGesture","gestureMgr","_gestureMgr","gestureInfo","recognize","setTouchTimer","instance","_touching","_touchTimer","isPointerFromTouch","pointerType","initDomHandler","makeMouseHandler","touchHandlerNames","domHandlers","pointerHandlerNames","mouseHandlerNames","HandlerDomProxy","mountHandlers","addEventListener","GestureMgr","pointerEventsSupported","touchEventsSupported","removeEventListener","normalizeEvent","pointerEventNames","pointerdown","pointerup","pointermove","pointerout","nm","touchstart","touchmove","touchend","click","handlerDomProxyProto","1116","pointPair","eventUtil","_doTrack","_recognize","touches","trackItem","touch","clientToLocal","recognizers","pinch","pinchEnd","pinchPre","pinchCenter","1117","parseInt10","parseInt","isLayerValid","__builtin__","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","viewRect","isClipPathChanged","prevClipPaths","doClip","createRoot","domRoot","document","createElement","cssText","Layer","Painter","singleCanvas","nodeName","toUpperCase","_opts","_singleCanvas","rootStyle","innerHTML","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","initContext","_domRoot","_getSize","appendChild","_progressiveLayers","_hoverlayer","_hoverElements","getType","isSingleCanvas","getViewportRootOffset","viewportRoot","offsetLeft","offsetTop","paintAll","_paintList","_startProgessive","hoverStyle","__hoverMir","elMirror","__from","hoverElements","from","hoverLayer","getLayer","originalEl","_doPaintEl","_progressiveToken","_doPaintList","_furtherProgressive","_progress","_clearProgressive","_updateLayerStatus","eachBuiltinLayer","flushProgressiveLayer","currentLayer","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","elZLevel","elFrame","__frame","MAX_PROGRESSIVE_LAYER_NUMBER","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","prevClipLayer","prevElClipPaths","insertLayer","layersMap","prevLayer","virtual","prevDom","insertBefore","firstChild","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","elCount","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","_clearLayer","layerConfig","delLayer","removeChild","display","clearLayer","getRenderedCanvas","findAndDrawOtherLayer","smaller","larger","intermediateLayer","renderToCanvas","imageLayer","pixelRatio","clearColor","whIdx","cwh","plt","prb","stl","defaultView","getComputedStyle","shadowBlurSize","leftMargin","rightMargin","topMargin","bottomMargin","clearRect","pathTransform","ImageShape","imgShape","1118","returnFalse","createDom","newDom","newDomStyle","setAttribute","domStyle","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","__currentValues","createBackBuffer","clearAll","haveMotionBLur","clearColorGradientOrPattern","__canvasGradient","fillRect","1119","encodeColor","colorAccessPath","visualColorAccessPath","setVisual","setItemVisual","getItemModel","1120","maskColor","mask","Arc","labelRect","animateShape","1121","OrdinalScale","rank","1122","scaleHelper","intervalScaleProto","mathCeil","mathFloor","bisect","TimeScale","stepLvl","_stepLvl","date","formatTime","ONE_HOUR","getFullYear","getMonth","getDate","approxTickNum","approxInterval","scaleLevelsLen","scaleLevels","level","yearSpan","timezoneOffset","getTimezoneOffset","parseDate","methodName","ONE_SECOND","ONE_MINUTE","ONE_DAY","1123","fixRoundingError","originalVal","roundingErrorFix","mathLog","LogScale","$constructor","_originalScale","originalScale","originalExtent","powVal","__fixMin","__fixMax","quantity","err","1124","symbolUtil","axisModelCommonMixin","createList","createScale","createScaleByModel","niceScaleExtent","mixinAxisModelCommonMethods","1125","illegalPoint","findPointFromSeries","isIllegalPoint","inputAxesInfo","shouldHide","outputFinder","showValueMap","dataByCoordSys","updaters","showPointer","showTooltip","coordSysContainsPoint","containPoint","inputAxisInfo","findInputAxisInfo","processOnAxis","linkTriggers","tarAxisInfo","tarKey","srcAxisInfo","srcKey","srcValItem","makeMapperParam","updateModelActually","dispatchTooltipActually","dispatchHighDownActually","newValue","dontSnap","buildPayloadsBySeries","payloadBatch","snapToValue","minDist","Number","MAX_VALUE","minDiff","seriesNestestValue","dataIndices","dataDim","getAxisTooltipData","nestestValue","indicesOfNearest","getRawIndex","modelHelper","coordSysItem","coordSysId","coordSysIndex","coordSysType","coordSysMainType","dataByAxis","valueLabelOpt","outputAxesInfo","valItem","escapeConnect","lastHighlights","newHighlights","toHighlight","toDownplay","batch","1126","AxisPointerModel","triggerOn","shadowStyle","icon","1127","AxisPonterView","disopse","_model","1128","showContent","alwaysShowContent","displayMode","confine","showDelay","hideDelay","transitionDuration","enterable","extraCssText","1129","buildTooltipModel","modelCascade","resultModel","refixTooltipPosition","gapH","gapV","getOuterSize","confineTooltipPosition","clientWidth","clientHeight","paddingLeft","paddingRight","borderLeftWidth","borderRightWidth","paddingTop","paddingBottom","borderTopWidth","borderBottomWidth","calcTooltipPosition","contentSize","domWidth","domHeight","rectWidth","rectHeight","isCenterAlign","TooltipContent","axisPointerViewHelper","proxyRect","tooltipContent","getDom","_tooltipContent","_tooltipModel","_ecModel","_lastDataByCoordSys","_alwaysShowContent","setEnterable","_initGlobalListener","_keepShow","_tryShow","_hide","_refreshUpdateTimeout","manuallyShowTip","_ticket","_manuallyAxisShowTip","pointInfo","manuallyHideTip","hideLater","_showAxisTooltip","_showSeriesItemTooltip","_showComponentItemTooltip","_showOrMove","_showTimout","singleDefaultHTML","singleParamsList","singleTooltipModel","itemCoordSys","axisValue","seriesDefaultHTML","valueLabel","axisValueLabel","formatTooltip","firstLine","encodeHTML","positionExpr","_updateContentNotChangedOnAxis","_updatePosition","_showTooltipContent","dataModel","dataType","tooltipTrigger","defaultHtml","asyncTicket","subTooltipModel","html","formatTpl","cbTicket","setContent","vAlign","viewSize","lastCoordSys","contentNotChanged","lastItemCoordSys","indexCoordSys","lastDataByAxis","thisItemCoordSys","thisDataByAxis","lastItem","indexAxis","lastIndices","newIndices","lastIdxItem","newIdxItem","1130","assembleTransition","duration","transitionText","vendors","vendorPrefix","assembleFont","assembleCssText","zrColor","toHex","borderName","camelCase","toCamelCase","container","_container","_show","_hideTimeout","onmouseenter","_enterable","_inContent","onmouseleave","_hideDelay","currentStyle","viewportRootOffset","isShow","1131","legendSelectActionHandler","selectedMap","isToggleSelect","isItemSelected","1132","1133","updateSelectedMap","targetList","_targetList","_selectTargetMap","reduce","targetMap","1134","paletteScope","dataAll","getRawData","idxMap","rawIdx","filteredIdx","singleDataColor","1135","featureManager","ToolboxModel","feature","featureOpt","featureName","Feature","itemSize","showTitle","iconStyle","1136","isUserFeatureName","toolboxModel","process","featureNames","oldName","featureOpts","featureModel","onclick","features","unusable","createIconPaths","setIconStatus","iconName","iconPaths","iconStatus","iconStyleModel","icons","getIcons","titles","title","iconStr","__title","_features","_featureNames","titleText","needPutOnTop","topOffset","1137","SaveAsImage","lang","toolbox","saveAsImage","excludeComponents","$a","download","url","getConnectedDataURL","href","MouseEvent","edge","msSaveOrOpenBlob","bstr","atob","u8arr","Uint8Array","charCodeAt","blob","Blob","tab","open","write","evt","view","bubbles","cancelable","dispatchEvent","1138","MagicType","magicType","bar","tiled","availableIcons","seriesOptGenreator","seriesId","radioTypes","generateNewSeriesTypes","newSeriesOpt","categoryAxis","getAxesByScale","boundaryGap","radio","currentType","1139","groupSeries","seriesGroupByCategoryAxis","otherSeries","meta","baseAxis","getBaseAxis","valueAxis","assembleSeriesWithCategoryAxis","tables","valueAxisDim","headers","columns","ITEM_SPLITER","items","BLOCK_SPLITER","assembleOtherSeries","vals","argLen","getContentFromModel","trim","isTSVFormat","block","parseTSVContents","tsv","tsvLines","itemSplitRegex","header","parseListContents","hasName","parseContents","blockMetaList","blocks","blockMeta","axisKey","DataView","_dom","tryMergeDataOption","newData","originalData","newVal","original","dataView","readOnly","optionToContent","contentToOption","textareaColor","textareaBorderColor","buttonColor","buttonTextColor","close","viewMain","textarea","htmlOrDom","isDom","buttonContainer","buttonStyle","closeButton","refreshButton","keyCode","selectionStart","selectionEnd","substring","newSeriesOptList","1140","DataZoom","_brushController","_onBrush","_isZoomActive","retrieveAxisSetting","updateBackBtnStatus","updateZoomBtnStatus","zoomActive","dataZoomSelectActive","brushTargetManager","sliderMove","dataZoom","DATA_ZOOM_ID_BASE","zoom","back","handlers","nextActive","_dispatchZoomAction","setBatch","findDataZoom","minMaxSpan","getMinMaxSpan","found","dzModel","addForAxis","dataZoomOpt","axisIndicesName","givenAxisIndices","forEachComponent","newOpt","$fromToolbox","dataZoomOpts","toolboxOpt","1141","1142","calculateDataExtent","seriesExtent","fixExtentByAxis","axisDataLen","setAxisModel","isRestore","percentWindow","_percentWindow","valueWindow","_valueWindow","useOrigin","toFixed","setMinMaxSpan","_minMaxSpan","_dataZoomModel","valueSpan","_dataExtent","asc","_dimName","_axisIndex","getTargetSeriesModels","getOtherAxisModel","otherAxisDim","coordSysIndexName","isCartesian","foundOtherAxisModel","otherAxisModel","calculateDataWindow","percentExtent","boundValue","boundPercent","dataWindow","isInWindow","dataDims","leftOut","rightOut","hasValue","thisHasValue","thisLeftOut","thisRightOut","1143","1144","1145","Restore","1149","actionInfos","actionInfo","1157","registerVisual","registerLayout","1158","dataSelectableMixin","PieSeries","extendSeriesModel","_defaultLabelLine","getInitialData","valueList","getPercentWithPrecision","hostModel","defaultEmphasis","labelLine","labelLineNormalOpt","labelLineEmphasisOpt","legendHoverLink","hoverAnimation","minAngle","selectedOffset","hoverOffset","avoidLabelOverlap","percentPrecision","stillShowZeroSum","animationType","1159","updateDataSelected","hasAnimation","toggleItemSelected","getItemLayout","midAngle","PiePiece","onEmphasis","polyline","hoverIgnore","onNormal","normalIgnore","sector","Sector","updateData","piePieceProto","firstCreate","sectorShape","initProps","itemStyleModel","visualColor","lineJoin","isAnimationEnabled","_updateLabel","labelText","linePoints","labelHoverModel","labelLineModel","labelLineHoverModel","setLabelStyle","labelFetcher","labelDataIndex","defaultText","autoColor","useInsideStyle","inside","Pie","sectorGroup","_sectorGroup","oldData","isFirstRender","onSectorClick","piePiece","setItemGraphicEl","newIdx","oldIdx","_createClipPath","itemLayout","1160","RADIAN","validDataCount","getSum","unitRadian","roseType","restAngle","valueSumLargerThanMinAngle","currentAngle","setItemLayout","1161","adjustSingleSide","shiftUp","changeX","isDownList","lastDeltaX","deltaY","deltaX","lastY","upList","downList","avoidOverlap","labelLayoutList","leftList","rightList","hasLabelRotate","labelPosition","labelLineLen","labelLineLen2","isLabelInside","getFormattedLabel","968","__webpack_exports__","_classCallCheck","Constructor","TypeError","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","Object","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","__WEBPACK_IMPORTED_MODULE_0_react__","__WEBPACK_IMPORTED_MODULE_0_react___default","__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts__","__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts___default","__WEBPACK_IMPORTED_MODULE_2_echarts_lib_component_tooltip__","__WEBPACK_IMPORTED_MODULE_3_echarts_lib_component_legend__","__WEBPACK_IMPORTED_MODULE_4_echarts_lib_chart_pie__","__WEBPACK_IMPORTED_MODULE_5_echarts_lib_component_toolbox__","_createClass","defineProperties","descriptor","protoProps","staticProps","PieReact","_React$Component","_this","getPrototypeOf","initPie","_props$option","undefined","myChart","ID","onresize","_this2","_props","_props$width","_props$height","ref","971","typeStr","objToString","TYPED_ARRAY","BUILTIN_OBJECT","isPrimitive","targetProp","sourceProp","isBuiltInObject","mergeAll","targetAndSources","overlay","createCanvas","_ctx","baseClazz","F","clazzPrototype","forEach","nativeForEach","nativeMap","memo","nativeReduce","nativeFilter","find","nativeSlice","ownerDocument","value0","value1","value2","Function","message","setAsPrimitive","primitiveKey","HashMap","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","[object Canvas]","[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]","toString","arrayProto","prefixedKey","removeKey","972","createRegisterEventWithLowercaseName","MessageCenter","ECharts","prioritySortFunc","prio","themeStorage","_throttledZrFlush","backwardCompat","_chartsViews","_chartsMap","_componentsViews","_coordSysMgr","CoordinateSystemManager","createExtensionAPI","_messageCenter","_initEvents","_pendingActions","visualFuncs","dataProcessorFuncs","_onframe","doConvertPixel","coordSysList","updateDirectly","ecIns","callView","__alive","__model","__viewId","doDispatchAction","payloadType","actionWrap","actions","cptType","updateMethod","IN_MAIN_PROCESS","payloads","batched","eventObj","eventObjBatch","isHighDown","action","OPTION_UPDATED","updateMethods","prepareAndUpdate","flushPendingActions","pendingActions","triggerUpdatedEvent","invokeUpdateMethod","chart","updateProgressiveAndBlend","updateHoverLayerStatus","postUpdateFuncs","prepareView","isComponent","viewList","viewMap","viewId","classType","ChartView","__id","__ecComponentInfo","processData","stackSeriesData","stackedDataMap","previousStack","stackedOn","doLayout","visual","isLayout","doVisualEncoding","excludesLayout","doRender","componentView","chartView","frameDrawNum","needProgressive","ecInstance","coordSysMgr","modelInfo","enableConnect","updateConnectedChartsStatus","charts","STATUS_KEY","eventActionMap","actionType","connectedGroups","makeActionFromEvent","otherCharts","otherChart","SeriesModel","colorTool","ACTION_REG","one","echartsProto","notMerge","lazyUpdate","setTheme","getDevicePixelRatio","getDataURL","excludesComponentViews","toDataURL","groupId","canvasList","boundingRect","getBoundingClientRect","targetCanvas","img","convertToPixel","convertFromPixel","containPixel","models","visualType","defaultMainType","indexOfRawIndex","getViewOfComponentModel","getViewOfSeriesModel","colorArr","stringify","background","clearAllVisual","_loadingFX","showLoading","cfg","hideLoading","loadingEffects","weChat","MOUSE_EVENT_NAMES","eveName","isDisposed","_disposed","idBase","groupIdBase","existInstance","getInstanceByDom","connect","disConnect","disconnect","getAttribute","getInstanceById","registerTheme","preprocessorFunc","priority","processorFunc","registerPostUpdate","postUpdateFunc","test","registerCoordinateSystem","getCoordinateSystemDimensions","coordSysCreator","layoutFunc","visualFunc","registerLoading","loadingFx","extendChartView","setCanvasCreator","number","format","FILTER","VISUAL","LAYOUT","GLOBAL","CHART","COMPONENT","BRUSH","973","hasFillOrStroke","fillOrStroke","liftColor","lift","cacheElementStl","__hoverStlDirty","__hoverStl","normalStyle","__normalStl","doSingleEnterHover","__isHover","insideRollbackOpt","rollbackInsideStyle","applyInsideStyle","insideOriginalTextPosition","doSingleLeaveHover","normalStl","doEnterHover","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__hoverSilentOnTouch","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","setTextStyleCommon","EMPTY_OBJ","isRectText","richResult","globalTextStyle","richItemNames","getRichItemNames","richTextStyle","setTokenTextStyle","forceRich","richItemNameMap","isBlock","getAutoColor","originalTextPosition","insideRollback","disableBox","animateOrSetProps","isUpdate","animatableModel","postfix","animationDelay","getAnimationDelayParams","pathTool","Circle","Ring","BezierCurve","CompoundPath","extendShape","extendPath","makePath","resizePath","pathRect","calculateTransform","subPixelOptimize","subPixelOptimizeRect","originX","originY","originWidth","originHeight","positiveOrNegative","doubledPosition","hoverSilentOnTouch","emphasisStyle","normalModel","emphasisModel","normalSpecified","emphasisSpecified","labelDimIndex","showNormal","showEmphasis","baseText","normalStyleText","emphasisStyleText","specifiedTextStyle","setText","defaultColor","gTextStyleModel","ancestor","mat","hBase","vBase","vertex","groupTransition","g1","g2","getAnimatableProps","elMap1","g","elMap","oldEl","newProp","clipRectByRect","targetRect","974","_trim","quantityExponent","LN10","domain","subDomain","subRange","all","returnStr","getPrecision","eIndex","dotIndex","pixelExtent","dataQuantity","sizeQuantity","acc","digits","votesPerQuota","targetSeats","seats","votes","currentSum","NEGATIVE_INFINITY","maxId","MAX_SAFE_INTEGER","radian","pi2","TIME_REG","hour","UTC","nf","exponent","exp10","reformIntervals","littleThan","lg","curr","currClose","isNumeric","975","has","nubmerUtil","subOpts","emphasisOpt","normalOpt","subOptName","dimInfo","dimType","createDataFormatModel","dataFormatMixin","rawValue","getRawValue","rawDataIndex","getRawDataItem","componentSubType","marker","getTooltipMarker","labelProp","exists","newCptOptions","cptOption","idMap","existCpt","idNum","compressBatches","batchA","batchB","makeMap","sourceBatch","otherMap","otherDataIndices","lenj","mapToArray","isData","mapA","mapB","hostObj","parsedKey","queryType","queryParam","dataDimToCoordDim","getDimension","dimItem","getDimensionInfo","coordDim","coordDimIndex","otherDimToDataDim","otherDim","otherDims","976","ArrayCtor","Float32Array","scaleAndAdd","lenSquare","div","dot","distanceSquare","negate","lerp","lengthSquare","distSquare","977","upperCaseFirst","group1","String","TPL_VAR_ALIAS","wrapVar","varName","seriesIdx","tpl","paramsList","encode","seriesLen","alias","formatTplSimple","s2d","isUTC","utc","substr","978","os","ua","userAgent","979","doGet","pathArr","getParent","getParentMethod","ignoreParent","parsePath","thisParentModel","isEmpty","setReadOnly","customizeGetParent","980","pathContain","pathProxyForDraw","hasFillGradient","hasStrokeGradient","hasFillPattern","hasStrokePattern","_fillGradient","_strokeGradient","ctxLineDash","setLineDash","setLineDashOffset","shapeCfg","needsUpdateRect","rectWithStroke","_rectWithStroke","lineScale","localPos","Sub","defaultShape","thisShape","981","boxLayout","maxHeight","currentLineMaxSize","nextX","nextY","nextChild","nextChildRect","moveX","moveY","LOCATION_PARAMS","HV_NAMES","vbox","hbox","getAvailableSize","containerRect","containerWidth","containerHeight","verticalMargin","horizontalMargin","hv","boundingMode","elPos","sizeCalculable","hvIdx","mergeLayoutParam","targetOption","newParams","newValueCount","merged","mergedValueCount","hasProp","hResult","vResult","getLayoutParams","copyLayoutParams","982","lt","rb","lb","rt","maxX","maxY","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","plain","983","getDependencies","deps","getClassesByMainType","arrayPush","inputPositionParams","themeModel","getDefaultOption","hasOwn","optList","Class","getReferringComponents","984","checkClassType","IS_CONTAINER","RootClass","mandatoryMethods","ExtendedClass","makeContainer","registerClass","componentMainType","throwWhenNotFound","originalExtend","985","getTextWidth","textWidthCache","measureText","textWidthCacheCounter","TEXT_CACHE_MAX","getRichTextRect","getPlainTextRect","halfHeight","prepareTruncateOptions","truncateSingleLine","maxIterations","cnCharWidth","ascCharWidth","ellipsisWidth","textLine","subLength","estimateLength","charCode","getLineHeight","truncOuterHeight","truncOuterWidth","lastIndex","STYLE_REG","matchedIndex","pushTokens","contentHeight","stlPadding","truncateWidth","truncateHeight","tokenHeight","tokenWidth","tokenWidthNotSpecified","percentWidth","bgImg","paddingW","remianTruncWidth","isEmptyStr","strs","tokensLen","986","m1","m2","out0","out1","out2","out3","out4","out5","rad","aa","ac","atx","ab","ad","aty","st","ct","vx","vy","det","987","transferProperties","TRANSFERABLE_PROPERTIES","__wrappedMethods","DefaultDataProvider","dataArray","_array","normalizeDimensions","cloneListForMapAndSample","excludeDimensions","allDimensions","_storage","originalStorage","dimStore","globalObj","Float64Array","Int32Array","dataCtors","float","int","ordinal","pure","getItem","dimensionInfos","dimensionNames","dimensionName","dimensionInfo","_dimensionInfos","_nameList","_idList","_optionModels","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_rawData","listProto","isDataArray","nameDimIdx","dimensionInfoMap","idList","nameRepeatCount","itemName","DataCtor","stackedValue","dimData","dimExtent","rawIndex","maxDistance","nearestIndices","dims","dimSize","keep","tmpRetValue","retValue","downSample","dimension","sampleValue","sampleIndex","targetStorage","originalIndices","frameValues","frameIndices","frameSize","otherList","otherIdList","setLayout","getLayout","clearItemLayouts","itemVisual","setItemDataAndSeriesIndex","cloneShallow","dimensionInfoList","wrapMethod","injectFunction","originalMethod","TRANSFERABLE_METHODS","CHANGABLE_METHODS","988","getScaleExtent","scaleType","ifAxisCrossZero","tickCoords","isAxisHorizontal","textSpaceTakenRect","autoLabelInterval","accumulatedLabelInterval","labelFormatter","989","ctor","990","calculate","defaultGetZrXY","layerX","layerY","clientX","clientY","targetTouches","changedTouches","detail","button","MOUSE_EVENT_REG","isDomLevel2","attachEvent","detachEvent","notLeftMouse","stopPropagation","returnValue","991","isAroundZero","onet","B","t1","disc","K","discSqrt","Y1","Y2","ONE_THIRD","T","ASqrt","THREE_SQRT","p01","p12","p23","p012","p123","p0123","d2","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","divider","v2Create","992","arrySlice","_$handlers","_h","newList","triggerWithContext","993","clampCssByte","clampCssAngle","clampCssFloat","parseCssInt","parseCssFloat","cssHueToRgb","lerpNumber","setRgba","copyRgba","putToCache","colorStr","rgbaArr","lastRemovedArr","colorCache","cached","kCSSColorTable","op","ep","fname","alpha","hsla2rgba","iv","hsla","rgba2hsla","H","S","G","vMin","vMax","deltaR","deltaG","deltaB","fastLerp","normalizedValue","colors","leftColor","rightColor","dv","fullOutput","modifyHSL","modifyAlpha","arrColor","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","fastMapToColor","mapToColor","994","colorPaletteMixin","themeSubType","fillDataTextStyle","newSeriesOption","getLinkedData","multipleSeries","formattedValue","setEachItem","dimIdx","valStr","vertially","tooltipName","tooltipDims","colorEl","animationEnabled","995","sysDims","applyDim","OTHER_DIMS","coordDimNameMap","genName","fromZero","dataDimNameMap","dimCount","retrieveValue","sysDimItem","sysDimItemDimsDef","dimDefItem","userDimName","resultDimIdx","availDimIdx","sysDimIndex","sysDimItemOtherDims","extra","extraPrefix","extraFromZero","isExtraCoord","guessOrdinal","996","Triangle","Diamond","Pin","tanX","tanY","cpLen","cpLen2","Arrow","symbolCtors","roundRect","square","circle","diamond","pin","arrow","triangle","symbolShapeMakers","symbolBuildProxies","Symbol","proxySymbol","symbolPathSetColor","symbolStyle","symbolShape","__isEmptyBrush","symbolPath","setColor","997","998","_coordinateSystems","coordinateSystemCreators","coordinateSystems","creater","coordinateSystemCreator","999","min2","max2","mathAbs","hasTypedArray","notSaveData","_saveData","_xi","_yi","_x0","_y0","_ux","_uy","_lineDash","_dashOffset","_dashIdx","_dashSum","exceedUnit","_needsDash","_dashedLineTo","_dashedBezierTo","_dashedQuadraticTo","arcTo","lineDashSum","appendSize","appendPathData","_expandData","_prevCmd","dash","dashSum","nDash","bezierLen","tmpLen","ux","uy","scaleX","scaleY","isEllipse"],"mappings":"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","file":"static/js/PieReact.b38c3709.chunk.js","sourcesContent":["webpackJsonp([2],{\n\n/***/ 1000:\n/***/ (function(module, exports) {\n\n\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config\n     * @exports zrender/config\n     * @author Kener (@Kener-, kener.linfeng@gmail.com)\n     */\n    var config = {\n        /**\n         * debugcatchBrushExceptiontrue\n         * 0 : debug\n         * 1 : \n         * 2 : \n         */\n        debugMode: 0,\n\n        // retina \n        devicePixelRatio: dpr\n    };\n    module.exports = config;\n\n\n\n\n/***/ }),\n\n/***/ 1001:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * GroupGroup\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/lib/container/Group');\n *     var Circle = require('zrender/lib/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n\n    var zrUtil = __webpack_require__(971);\n    var Element = __webpack_require__(1032);\n    var BoundingRect = __webpack_require__(982);\n\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        for (var key in opts) {\n            if (opts.hasOwnProperty(key)) {\n                this[key] = opts[key];\n            }\n        }\n\n        this._children = [];\n\n        this.__storage = null;\n\n        this.__dirty = true;\n    };\n\n    Group.prototype = {\n\n        constructor: Group,\n\n        isGroup: true,\n\n        /**\n         * @type {string}\n         */\n        type: 'group',\n\n        /**\n         * \n         * @name module:/zrender/container/Group#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * @return {Array.<module:zrender/Element>}\n         */\n        children: function () {\n            return this._children.slice();\n        },\n\n        /**\n         *  index \n         * @param  {number} idx\n         * @return {module:zrender/Element}\n         */\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n\n        /**\n         * \n         * @param  {string} name\n         * @return {module:zrender/Element}\n         */\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n             }\n        },\n\n        /**\n         * @return {number}\n         */\n        childCount: function () {\n            return this._children.length;\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n\n                this._children.push(child);\n\n                this._doAdd(child);\n            }\n\n            return this;\n        },\n\n        /**\n         *  nextSibling \n         * @param {module:zrender/Element} child\n         * @param {module:zrender/Element} nextSibling\n         */\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n\n            return this;\n        },\n\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n\n            child.parent = this;\n\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n\n                storage.addToStorage(child);\n\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n\n            child.parent = null;\n\n            if (storage) {\n\n                storage.delFromStorage(child);\n\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n\n            return this;\n        },\n\n        /**\n         * \n         */\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromStorage(child);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToStorage(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromStorage(child);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                // TODO\n                // The boundingRect cacluated by transforming original\n                // rect may be bigger than the actual bundingRect when rotation\n                // is used. (Consider a circle rotated aginst its center, where\n                // the actual boundingRect should be the same as that not be\n                // rotated.) But we can not find better approach to calculate\n                // actual boundingRect yet, considering performance.\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n\n    zrUtil.inherits(Group, Element);\n\n    module.exports = Group;\n\n\n/***/ }),\n\n/***/ 1002:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var Group = __webpack_require__(1001);\n    var componentUtil = __webpack_require__(1016);\n    var clazzUtil = __webpack_require__(984);\n    var modelUtil = __webpack_require__(975);\n    var zrUtil = __webpack_require__(971);\n\n    function Chart() {\n\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewChart');\n    }\n\n    Chart.prototype = {\n\n        type: 'chart',\n\n        /**\n         * Init the chart\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        init: function (ecModel, api) {},\n\n        /**\n         * Render the chart\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        render: function (seriesModel, ecModel, api, payload) {},\n\n        /**\n         * Highlight series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        highlight: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n        },\n\n        /**\n         * Downplay series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        downplay: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'normal');\n        },\n\n        /**\n         * Remove self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        remove: function (ecModel, api) {\n            this.group.removeAll();\n        },\n\n        /**\n         * Dispose self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        dispose: function () {}\n\n        /**\n         * The view contains the given point.\n         * @interface\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        // containPoint: function () {}\n\n    };\n\n    var chartProto = Chart.prototype;\n    chartProto.updateView\n        = chartProto.updateLayout\n        = chartProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            this.render(seriesModel, ecModel, api, payload);\n        };\n\n    /**\n     * Set state of single element\n     * @param  {module:zrender/Element} el\n     * @param  {string} state\n     */\n    function elSetState(el, state) {\n        if (el) {\n            el.trigger(state);\n            if (el.type === 'group') {\n                for (var i = 0; i < el.childCount(); i++) {\n                    elSetState(el.childAt(i), state);\n                }\n            }\n        }\n    }\n    /**\n     * @param  {module:echarts/data/List} data\n     * @param  {Object} payload\n     * @param  {string} state 'normal'|'emphasis'\n     * @inner\n     */\n    function toggleHighlight(data, payload, state) {\n        var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n        if (dataIndex != null) {\n            zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {\n                elSetState(data.getItemGraphicEl(dataIdx), state);\n            });\n        }\n        else {\n            data.eachItemGraphicEl(function (el) {\n                elSetState(el, state);\n            });\n        }\n    }\n\n    // Enable Chart.extend.\n    clazzUtil.enableClassExtend(Chart, ['dispose']);\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Chart, {registerWhenExtend: true});\n\n    module.exports = Chart;\n\n\n/***/ }),\n\n/***/ 1003:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    function defaultKeyGetter(item) {\n        return item;\n    }\n\n    /**\n     * @param {Array} oldArr\n     * @param {Array} newArr\n     * @param {Function} oldKeyGetter\n     * @param {Function} newKeyGetter\n     * @param {Object} [context] Can be visited by this.context in callback.\n     */\n    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context) {\n        this._old = oldArr;\n        this._new = newArr;\n\n        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n\n        this.context = context;\n    }\n\n    DataDiffer.prototype = {\n\n        constructor: DataDiffer,\n\n        /**\n         * Callback function when add a data\n         */\n        add: function (func) {\n            this._add = func;\n            return this;\n        },\n\n        /**\n         * Callback function when update a data\n         */\n        update: function (func) {\n            this._update = func;\n            return this;\n        },\n\n        /**\n         * Callback function when remove a data\n         */\n        remove: function (func) {\n            this._remove = func;\n            return this;\n        },\n\n        execute: function () {\n            var oldArr = this._old;\n            var newArr = this._new;\n\n            var oldDataIndexMap = {};\n            var newDataIndexMap = {};\n            var oldDataKeyArr = [];\n            var newDataKeyArr = [];\n            var i;\n\n            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter', this);\n            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter', this);\n\n            // Travel by inverted order to make sure order consistency\n            // when duplicate keys exists (consider newDataIndex.pop() below).\n            // For performance consideration, these code below do not look neat.\n            for (i = 0; i < oldArr.length; i++) {\n                var key = oldDataKeyArr[i];\n                var idx = newDataIndexMap[key];\n\n                // idx can never be empty array here. see 'set null' logic below.\n                if (idx != null) {\n                    // Consider there is duplicate key (for example, use dataItem.name as key).\n                    // We should make sure every item in newArr and oldArr can be visited.\n                    var len = idx.length;\n                    if (len) {\n                        len === 1 && (newDataIndexMap[key] = null);\n                        idx = idx.unshift();\n                    }\n                    else {\n                        newDataIndexMap[key] = null;\n                    }\n                    this._update && this._update(idx, i);\n                }\n                else {\n                    this._remove && this._remove(i);\n                }\n            }\n\n            for (var i = 0; i < newDataKeyArr.length; i++) {\n                var key = newDataKeyArr[i];\n                if (newDataIndexMap.hasOwnProperty(key)) {\n                    var idx = newDataIndexMap[key];\n                    if (idx == null) {\n                        continue;\n                    }\n                    // idx can never be empty array here. see 'set null' logic above.\n                    if (!idx.length) {\n                        this._add && this._add(idx);\n                    }\n                    else {\n                        for (var j = 0, len = idx.length; j < len; j++) {\n                            this._add && this._add(idx[j]);\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    function initIndexMap(arr, map, keyArr, keyGetterName, dataDiffer) {\n        for (var i = 0; i < arr.length; i++) {\n            // Add prefix to avoid conflict with Object.prototype.\n            var key = '_ec_' + dataDiffer[keyGetterName](arr[i], i);\n            var existence = map[key];\n            if (existence == null) {\n                keyArr.push(key);\n                map[key] = i;\n            }\n            else {\n                if (!existence.length) {\n                    map[key] = existence = [existence];\n                }\n                existence.push(i);\n            }\n        }\n    }\n\n    module.exports = DataDiffer;\n\n\n/***/ }),\n\n/***/ 1004:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * // Scale class management\n * @module echarts/scale/Scale\n */\n\n\n    var clazzUtil = __webpack_require__(984);\n\n    /**\n     * @param {Object} [setting]\n     */\n    function Scale(setting) {\n        this._setting = setting || {};\n\n        /**\n         * Extent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._extent = [Infinity, -Infinity];\n\n        /**\n         * Step is calculated in adjustExtent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._interval = 0;\n\n        this.init && this.init.apply(this, arguments);\n    }\n\n    var scaleProto = Scale.prototype;\n\n    /**\n     * Parse input val to valid inner number.\n     * @param {*} val\n     * @return {number}\n     */\n    scaleProto.parse = function (val) {\n        // Notice: This would be a trap here, If the implementation\n        // of this method depends on extent, and this method is used\n        // before extent set (like in dataZoom), it would be wrong.\n        // Nevertheless, parse does not depend on extent generally.\n        return val;\n    };\n\n    scaleProto.getSetting = function (name) {\n        return this._setting[name];\n    };\n\n    scaleProto.contain = function (val) {\n        var extent = this._extent;\n        return val >= extent[0] && val <= extent[1];\n    };\n\n    /**\n     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.normalize = function (val) {\n        var extent = this._extent;\n        if (extent[1] === extent[0]) {\n            return 0.5;\n        }\n        return (val - extent[0]) / (extent[1] - extent[0]);\n    };\n\n    /**\n     * Scale normalized value\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.scale = function (val) {\n        var extent = this._extent;\n        return val * (extent[1] - extent[0]) + extent[0];\n    };\n\n    /**\n     * Set extent from data\n     * @param {Array.<number>} other\n     */\n    scaleProto.unionExtent = function (other) {\n        var extent = this._extent;\n        other[0] < extent[0] && (extent[0] = other[0]);\n        other[1] > extent[1] && (extent[1] = other[1]);\n        // not setExtent because in log axis it may transformed to power\n        // this.setExtent(extent[0], extent[1]);\n    };\n\n    /**\n     * Set extent from data\n     * @param {module:echarts/data/List} data\n     * @param {string} dim\n     */\n    scaleProto.unionExtentFromData = function (data, dim) {\n        this.unionExtent(data.getDataExtent(dim, true));\n    };\n\n    /**\n     * Get extent\n     * @return {Array.<number>}\n     */\n    scaleProto.getExtent = function () {\n        return this._extent.slice();\n    };\n\n    /**\n     * Set extent\n     * @param {number} start\n     * @param {number} end\n     */\n    scaleProto.setExtent = function (start, end) {\n        var thisExtent = this._extent;\n        if (!isNaN(start)) {\n            thisExtent[0] = start;\n        }\n        if (!isNaN(end)) {\n            thisExtent[1] = end;\n        }\n    };\n\n    /**\n     * @return {Array.<string>}\n     */\n    scaleProto.getTicksLabels = function () {\n        var labels = [];\n        var ticks = this.getTicks();\n        for (var i = 0; i < ticks.length; i++) {\n            labels.push(this.getLabel(ticks[i]));\n        }\n        return labels;\n    };\n\n    /**\n     * When axis extent depends on data and no data exists,\n     * axis ticks should not be drawn, which is named 'blank'.\n     */\n    scaleProto.isBlank = function () {\n        return this._isBlank;\n    },\n\n    /**\n     * When axis extent depends on data and no data exists,\n     * axis ticks should not be drawn, which is named 'blank'.\n     */\n    scaleProto.setBlank = function (isBlank) {\n        this._isBlank = isBlank;\n    };\n\n\n    clazzUtil.enableClassExtend(Scale);\n    clazzUtil.enableClassManagement(Scale, {\n        registerWhenExtend: true\n    });\n\n    module.exports = Scale;\n\n\n/***/ }),\n\n/***/ 1005:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(971);\n    var Model = __webpack_require__(979);\n    var each = zrUtil.each;\n    var curry = zrUtil.curry;\n\n    var helper = {};\n\n    // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n    // allAxesInfo should be updated when setOption performed.\n    helper.collect = function (ecModel, api) {\n        var result = {\n            /**\n             * key: makeKey(axis.model)\n             * value: {\n             *      axis,\n             *      coordSys,\n             *      axisPointerModel,\n             *      triggerTooltip,\n             *      involveSeries,\n             *      snap,\n             *      seriesModels,\n             *      seriesDataCount\n             * }\n             */\n            axesInfo: {},\n            seriesInvolved: false,\n            /**\n             * key: makeKey(coordSys.model)\n             * value: Object: key makeKey(axis.model), value: axisInfo\n             */\n            coordSysAxesInfo: {},\n            coordSysMap: {}\n        };\n\n        collectAxesInfo(result, ecModel, api);\n\n        // Check seriesInvolved for performance, in case too many series in some chart.\n        result.seriesInvolved && collectSeriesInfo(result, ecModel);\n\n        return result;\n    };\n\n    function collectAxesInfo(result, ecModel, api) {\n        var globalTooltipModel = ecModel.getComponent('tooltip');\n        var globalAxisPointerModel = ecModel.getComponent('axisPointer');\n        // links can only be set on global.\n        var linksOption = globalAxisPointerModel.get('link', true) || [];\n        var linkGroups = [];\n\n        // Collect axes info.\n        each(api.getCoordinateSystems(), function (coordSys) {\n            // Some coordinate system do not support axes, like geo.\n            if (!coordSys.axisPointerEnabled) {\n                return;\n            }\n\n            var coordSysKey = makeKey(coordSys.model);\n            var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};\n            result.coordSysMap[coordSysKey] = coordSys;\n\n            // Set tooltip (like 'cross') is a convienent way to show axisPointer\n            // for user. So we enable seting tooltip on coordSys model.\n            var coordSysModel = coordSys.model;\n            var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);\n\n            each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null));\n\n            // If axis tooltip used, choose tooltip axis for each coordSys.\n            // Notice this case: coordSys is `grid` but not `cartesian2D` here.\n            if (coordSys.getTooltipAxes\n                && globalTooltipModel\n                // If tooltip.showContent is set as false, tooltip will not\n                // show but axisPointer will show as normal.\n                && baseTooltipModel.get('show')\n            ) {\n                // Compatible with previous logic. But series.tooltip.trigger: 'axis'\n                // or series.data[n].tooltip.trigger: 'axis' are not support any more.\n                var triggerAxis = baseTooltipModel.get('trigger') === 'axis';\n                var cross = baseTooltipModel.get('axisPointer.type') === 'cross';\n                var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis'));\n                if (triggerAxis || cross) {\n                    each(tooltipAxes.baseAxes, curry(\n                        saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis\n                    ));\n                }\n                if (cross) {\n                    each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, 'cross', false));\n                }\n            }\n\n            // fromTooltip: true | false | 'cross'\n            // triggerTooltip: true | false | null\n            function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {\n                var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);\n\n                var axisPointerShow = axisPointerModel.get('show');\n                if (!axisPointerShow || (\n                    axisPointerShow === 'auto'\n                    && !fromTooltip\n                    && !isHandleTrigger(axisPointerModel)\n                )) {\n                    return;\n                }\n\n                if (triggerTooltip == null) {\n                    triggerTooltip = axisPointerModel.get('triggerTooltip');\n                }\n\n                axisPointerModel = fromTooltip\n                    ? makeAxisPointerModel(\n                        axis, baseTooltipModel, globalAxisPointerModel, ecModel,\n                        fromTooltip, triggerTooltip\n                    )\n                    : axisPointerModel;\n\n                var snap = axisPointerModel.get('snap');\n                var key = makeKey(axis.model);\n                var involveSeries = triggerTooltip || snap || axis.type === 'category';\n\n                // If result.axesInfo[key] exist, override it (tooltip has higher priority).\n                var axisInfo = result.axesInfo[key] = {\n                    key: key,\n                    axis: axis,\n                    coordSys: coordSys,\n                    axisPointerModel: axisPointerModel,\n                    triggerTooltip: triggerTooltip,\n                    involveSeries: involveSeries,\n                    snap: snap,\n                    useHandle: isHandleTrigger(axisPointerModel),\n                    seriesModels: []\n                };\n                axesInfoInCoordSys[key] = axisInfo;\n                result.seriesInvolved |= involveSeries;\n\n                var groupIndex = getLinkGroupIndex(linksOption, axis);\n                if (groupIndex != null) {\n                    var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {axesInfo: {}});\n                    linkGroup.axesInfo[key] = axisInfo;\n                    linkGroup.mapper = linksOption[groupIndex].mapper;\n                    axisInfo.linkGroup = linkGroup;\n                }\n            }\n        });\n    }\n\n    function makeAxisPointerModel(\n        axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip\n    ) {\n        var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');\n        var volatileOption = {};\n\n        each(\n            [\n                'type', 'snap', 'lineStyle', 'shadowStyle', 'label',\n                'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'\n            ],\n            function (field) {\n                volatileOption[field] = zrUtil.clone(tooltipAxisPointerModel.get(field));\n            }\n        );\n\n        // category axis do not auto snap, otherwise some tick that do not\n        // has value can not be hovered. value/time/log axis default snap if\n        // triggered from tooltip and trigger tooltip.\n        volatileOption.snap = axis.type !== 'category' && !!triggerTooltip;\n\n        // Compatibel with previous behavior, tooltip axis do not show label by default.\n        // Only these properties can be overrided from tooltip to axisPointer.\n        if (tooltipAxisPointerModel.get('type') === 'cross') {\n            volatileOption.type = 'line';\n        }\n        var labelOption = volatileOption.label || (volatileOption.label = {});\n        // Follow the convention, do not show label when triggered by tooltip by default.\n        labelOption.show == null && (labelOption.show = false);\n\n        if (fromTooltip === 'cross') {\n            // When 'cross', both axes show labels.\n            labelOption.show = true;\n            // If triggerTooltip, this is a base axis, which should better not use cross style\n            // (cross style is dashed by default)\n            if (!triggerTooltip) {\n                var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');\n                crossStyle && zrUtil.defaults(labelOption, crossStyle.textStyle);\n            }\n        }\n\n        return axis.model.getModel(\n            'axisPointer',\n            new Model(volatileOption, globalAxisPointerModel, ecModel)\n        );\n    }\n\n    function collectSeriesInfo(result, ecModel) {\n        // Prepare data for axis trigger\n        ecModel.eachSeries(function (seriesModel) {\n\n            // Notice this case: this coordSys is `cartesian2D` but not `grid`.\n            var coordSys = seriesModel.coordinateSystem;\n            var seriesTooltipTrigger = seriesModel.get('tooltip.trigger', true);\n            var seriesTooltipShow = seriesModel.get('tooltip.show', true);\n            if (!coordSys\n                || seriesTooltipTrigger === 'none'\n                || seriesTooltipTrigger === false\n                || seriesTooltipTrigger === 'item'\n                || seriesTooltipShow === false\n                || seriesModel.get('axisPointer.show', true) === false\n            ) {\n                return;\n            }\n\n            each(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {\n                var axis = axisInfo.axis;\n                if (coordSys.getAxis(axis.dim) === axis) {\n                    axisInfo.seriesModels.push(seriesModel);\n                    axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);\n                    axisInfo.seriesDataCount += seriesModel.getData().count();\n                }\n            });\n\n        }, this);\n    }\n\n    /**\n     * For example:\n     * {\n     *     axisPointer: {\n     *         links: [{\n     *             xAxisIndex: [2, 4],\n     *             yAxisIndex: 'all'\n     *         }, {\n     *             xAxisId: ['a5', 'a7'],\n     *             xAxisName: 'xxx'\n     *         }]\n     *     }\n     * }\n     */\n    function getLinkGroupIndex(linksOption, axis) {\n        var axisModel = axis.model;\n        var dim = axis.dim;\n        for (var i = 0; i < linksOption.length; i++) {\n            var linkOption = linksOption[i] || {};\n            if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id)\n                || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex)\n                || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)\n            ) {\n                return i;\n            }\n        }\n    }\n\n    function checkPropInLink(linkPropValue, axisPropValue) {\n        return linkPropValue === 'all'\n            || (zrUtil.isArray(linkPropValue) && zrUtil.indexOf(linkPropValue, axisPropValue) >= 0)\n            || linkPropValue === axisPropValue;\n    }\n\n    helper.fixValue = function (axisModel) {\n        var axisInfo = helper.getAxisInfo(axisModel);\n        if (!axisInfo) {\n            return;\n        }\n\n        var axisPointerModel = axisInfo.axisPointerModel;\n        var scale = axisInfo.axis.scale;\n        var option = axisPointerModel.option;\n        var status = axisPointerModel.get('status');\n        var value = axisPointerModel.get('value');\n\n        // Parse init value for category and time axis.\n        if (value != null) {\n            value = scale.parse(value);\n        }\n\n        var useHandle = isHandleTrigger(axisPointerModel);\n        // If `handle` used, `axisPointer` will always be displayed, so value\n        // and status should be initialized.\n        if (status == null) {\n            option.status = useHandle ? 'show' : 'hide';\n        }\n\n        var extent = scale.getExtent().slice();\n        extent[0] > extent[1] && extent.reverse();\n\n        if (// Pick a value on axis when initializing.\n            value == null\n            // If both `handle` and `dataZoom` are used, value may be out of axis extent,\n            // where we should re-pick a value to keep `handle` displaying normally.\n            || value > extent[1]\n        ) {\n            // Make handle displayed on the end of the axis when init, which looks better.\n            value = extent[1];\n        }\n        if (value < extent[0]) {\n            value = extent[0];\n        }\n\n        option.value = value;\n\n        if (useHandle) {\n            option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';\n        }\n    };\n\n    helper.getAxisInfo = function (axisModel) {\n        var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;\n        return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];\n    };\n\n    helper.getAxisPointerModel = function (axisModel) {\n        var axisInfo = helper.getAxisInfo(axisModel);\n        return axisInfo && axisInfo.axisPointerModel;\n    };\n\n    function isHandleTrigger(axisPointerModel) {\n        return !!axisPointerModel.get('handle.show');\n    }\n\n    /**\n     * @param {module:echarts/model/Model} model\n     * @return {string} unique key\n     */\n    var makeKey = helper.makeKey = function (model) {\n        return model.type + '||' + model.id;\n    };\n\n    module.exports = helper;\n\n\n\n/***/ }),\n\n/***/ 1006:\n/***/ (function(module, exports, __webpack_require__) {\n\n// TODO Parse shadow style\n// TODO Only shallow path support\n\n    var zrUtil = __webpack_require__(971);\n\n    module.exports = function (properties) {\n        // Normalize\n        for (var i = 0; i < properties.length; i++) {\n            if (!properties[i][1]) {\n               properties[i][1] = properties[i][0];\n            }\n        }\n        return function (excludes, includes) {\n            var style = {};\n            for (var i = 0; i < properties.length; i++) {\n                var propName = properties[i][1];\n                if ((excludes && zrUtil.indexOf(excludes, propName) >= 0)\n                    || (includes && zrUtil.indexOf(includes, propName) < 0)\n                ) {\n                    continue;\n                }\n                var val = this.getShallow(propName);\n                if (val != null) {\n                    style[properties[i][0]] = val;\n                }\n            }\n            return style;\n        };\n    };\n\n\n/***/ }),\n\n/***/ 1007:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var numberUtil = __webpack_require__(974);\n    var linearMap = numberUtil.linearMap;\n    var zrUtil = __webpack_require__(971);\n    var axisHelper = __webpack_require__(988);\n\n    function fixExtentWithBands(extent, nTick) {\n        var size = extent[1] - extent[0];\n        var len = nTick;\n        var margin = size / len / 2;\n        extent[0] += margin;\n        extent[1] -= margin;\n    }\n\n    var normalizedExtent = [0, 1];\n    /**\n     * @name module:echarts/coord/CartesianAxis\n     * @constructor\n     */\n    var Axis = function (dim, scale, extent) {\n\n        /**\n         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n         * @type {string}\n         */\n        this.dim = dim;\n\n        /**\n         * Axis scale\n         * @type {module:echarts/coord/scale/*}\n         */\n        this.scale = scale;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        this._extent = extent || [0, 0];\n\n        /**\n         * @type {boolean}\n         */\n        this.inverse = false;\n\n        /**\n         * Usually true when axis has a ordinal scale\n         * @type {boolean}\n         */\n        this.onBand = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._labelInterval;\n    };\n\n    Axis.prototype = {\n\n        constructor: Axis,\n\n        /**\n         * If axis extent contain given coord\n         * @param {number} coord\n         * @return {boolean}\n         */\n        contain: function (coord) {\n            var extent = this._extent;\n            var min = Math.min(extent[0], extent[1]);\n            var max = Math.max(extent[0], extent[1]);\n            return coord >= min && coord <= max;\n        },\n\n        /**\n         * If axis extent contain given data\n         * @param {number} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.contain(this.dataToCoord(data));\n        },\n\n        /**\n         * Get coord extent.\n         * @return {Array.<number>}\n         */\n        getExtent: function () {\n            return this._extent.slice();\n        },\n\n        /**\n         * Get precision used for formatting\n         * @param {Array.<number>} [dataExtent]\n         * @return {number}\n         */\n        getPixelPrecision: function (dataExtent) {\n            return numberUtil.getPixelPrecision(\n                dataExtent || this.scale.getExtent(),\n                this._extent\n            );\n        },\n\n        /**\n         * Set coord extent\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var extent = this._extent;\n            extent[0] = start;\n            extent[1] = end;\n        },\n\n        /**\n         * Convert data to coord. Data is the rank if it has a ordinal scale\n         * @param {number} data\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        dataToCoord: function (data, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            data = scale.normalize(data);\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            return linearMap(data, normalizedExtent, extent, clamp);\n        },\n\n        /**\n         * Convert coord to data. Data is the rank if it has a ordinal scale\n         * @param {number} coord\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        coordToData: function (coord, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\n            return this.scale.scale(t);\n        },\n\n        /**\n         * Convert pixel point to data in axis\n         * @param {Array.<number>} point\n         * @param  {boolean} clamp\n         * @return {number} data\n         */\n        pointToData: function (point, clamp) {\n            // Should be implemented in derived class if necessary.\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicksCoords: function (alignWithLabel) {\n            if (this.onBand && !alignWithLabel) {\n                var bands = this.getBands();\n                var coords = [];\n                for (var i = 0; i < bands.length; i++) {\n                    coords.push(bands[i][0]);\n                }\n                if (bands[i - 1]) {\n                    coords.push(bands[i - 1][1]);\n                }\n                return coords;\n            }\n            else {\n                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n            }\n        },\n\n        /**\n         * Coords of labels are on the ticks or on the middle of bands\n         * @return {Array.<number>}\n         */\n        getLabelsCoords: function () {\n            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n        },\n\n        /**\n         * Get bands.\n         *\n         * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n         * |---1---|---2---|---3---|---4---|.\n         *\n         * @return {Array}\n         */\n         // FIXME Situation when labels is on ticks\n        getBands: function () {\n            var extent = this.getExtent();\n            var bands = [];\n            var len = this.scale.count();\n            var start = extent[0];\n            var end = extent[1];\n            var span = end - start;\n\n            for (var i = 0; i < len; i++) {\n                bands.push([\n                    span * i / len + start,\n                    span * (i + 1) / len + start\n                ]);\n            }\n            return bands;\n        },\n\n        /**\n         * Get width of band\n         * @return {number}\n         */\n        getBandWidth: function () {\n            var axisExtent = this._extent;\n            var dataExtent = this.scale.getExtent();\n\n            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n            // Fix #2728, avoid NaN when only one data.\n            len === 0 && (len = 1);\n\n            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\n            return Math.abs(size) / len;\n        },\n\n        /**\n         * Get interval of the axis label.\n         * @return {number}\n         */\n        getLabelInterval: function () {\n            var labelInterval = this._labelInterval;\n            if (!labelInterval) {\n                var axisModel = this.model;\n                var labelModel = axisModel.getModel('axisLabel');\n                var interval = labelModel.get('interval');\n                if (!(this.type === 'category' && interval === 'auto')) {\n                    labelInterval = interval === 'auto' ? 0 : interval;\n                }\n                else if (this.isHorizontal){\n                    labelInterval = axisHelper.getAxisLabelInterval(\n                        zrUtil.map(this.scale.getTicks(), this.dataToCoord, this),\n                        axisModel.getFormattedLabels(),\n                        labelModel.getFont(),\n                        this.isHorizontal()\n                    );\n                }\n                this._labelInterval = labelInterval;\n            }\n            return labelInterval;\n        }\n\n    };\n\n    module.exports = Axis;\n\n\n/***/ }),\n\n/***/ 1008:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var List = __webpack_require__(987);\n    var completeDimensions = __webpack_require__(995);\n    var zrUtil = __webpack_require__(971);\n    var modelUtil = __webpack_require__(975);\n    var CoordinateSystem = __webpack_require__(998);\n    var getDataItemValue = modelUtil.getDataItemValue;\n    var converDataValue = modelUtil.converDataValue;\n\n    function firstDataNotNull(data) {\n        var i = 0;\n        while (i < data.length && data[i] == null) {\n            i++;\n        }\n        return data[i];\n    }\n    function ifNeedCompleteOrdinalData(data) {\n        var sampleItem = firstDataNotNull(data);\n        return sampleItem != null\n            && !zrUtil.isArray(getDataItemValue(sampleItem));\n    }\n\n    /**\n     * Helper function to create a list from option data\n     */\n    function createListFromArray(data, seriesModel, ecModel) {\n        // If data is undefined\n        data = data || [];\n\n        if (__DEV__) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        var coordSysName = seriesModel.get('coordinateSystem');\n        var creator = creators[coordSysName];\n        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n        var completeDimOpt = {\n            encodeDef: seriesModel.get('encode'),\n            dimsDef: seriesModel.get('dimensions')\n        };\n\n        // FIXME\n        var axesInfo = creator && creator(data, seriesModel, ecModel, completeDimOpt);\n        var dimensions = axesInfo && axesInfo.dimensions;\n        if (!dimensions) {\n            // Get dimensions from registered coordinate system\n            dimensions = (registeredCoordSys && (\n                registeredCoordSys.getDimensionsInfo\n                    ? registeredCoordSys.getDimensionsInfo()\n                    : registeredCoordSys.dimensions.slice()\n            )) || ['x', 'y'];\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n        }\n\n        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\n        var list = new List(dimensions, seriesModel);\n\n        var nameList = createNameList(axesInfo, data);\n\n        var categories = {};\n        var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data))\n            ? function (itemOpt, dimName, dataIndex, dimIndex) {\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                // Use dataIndex as ordinal value in categoryAxis\n                return dimIndex === categoryIndex\n                    ? dataIndex\n                    : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n            }\n            : function (itemOpt, dimName, dataIndex, dimIndex) {\n                var value = getDataItemValue(itemOpt);\n                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n                if (categoryAxesModels && categoryAxesModels[dimName]) {\n                    // If given value is a category string\n                    if (typeof val === 'string') {\n                        // Lazy get categories\n                        categories[dimName] = categories[dimName]\n                            || categoryAxesModels[dimName].getCategories();\n                        val = zrUtil.indexOf(categories[dimName], val);\n                        if (val < 0 && !isNaN(val)) {\n                            // In case some one write '1', '2' istead of 1, 2\n                            val = +val;\n                        }\n                    }\n                }\n                return val;\n            };\n\n        list.hasItemOption = false;\n        list.initData(data, nameList, dimValueGetter);\n\n        return list;\n    }\n\n    function isStackable(axisType) {\n        return axisType !== 'category' && axisType !== 'time';\n    }\n\n    function getDimTypeByAxis(axisType) {\n        return axisType === 'category'\n            ? 'ordinal'\n            : axisType === 'time'\n            ? 'time'\n            : 'float';\n    }\n\n    /**\n     * Creaters for each coord system.\n     */\n    var creators = {\n\n        cartesian2d: function (data, seriesModel, ecModel, completeDimOpt) {\n\n            var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n                return ecModel.queryComponents({\n                    mainType: name,\n                    index: seriesModel.get(name + 'Index'),\n                    id: seriesModel.get(name + 'Id')\n                })[0];\n            });\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            if (__DEV__) {\n                if (!xAxisModel) {\n                    throw new Error('xAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('xAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n                if (!yAxisModel) {\n                    throw new Error('yAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('yAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n\n            var xAxisType = xAxisModel.get('type');\n            var yAxisType = yAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'x',\n                    type: getDimTypeByAxis(xAxisType),\n                    stackable: isStackable(xAxisType)\n                },\n                {\n                    name: 'y',\n                    // If two category axes\n                    type: getDimTypeByAxis(yAxisType),\n                    stackable: isStackable(yAxisType)\n                }\n            ];\n\n            var isXAxisCateogry = xAxisType === 'category';\n            var isYAxisCategory = yAxisType === 'category';\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isXAxisCateogry) {\n                categoryAxesModels.x = xAxisModel;\n            }\n            if (isYAxisCategory) {\n                categoryAxesModels.y = yAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        singleAxis: function (data, seriesModel, ecModel, completeDimOpt) {\n\n            var singleAxisModel = ecModel.queryComponents({\n                mainType: 'singleAxis',\n                index: seriesModel.get('singleAxisIndex'),\n                id: seriesModel.get('singleAxisId')\n            })[0];\n\n            if (__DEV__) {\n                if (!singleAxisModel) {\n                    throw new Error('singleAxis should be specified.');\n                }\n            }\n\n            var singleAxisType = singleAxisModel.get('type');\n            var isCategory = singleAxisType === 'category';\n\n            var dimensions = [{\n                name: 'single',\n                type: getDimTypeByAxis(singleAxisType),\n                stackable: isStackable(singleAxisType)\n            }];\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isCategory) {\n                categoryAxesModels.single = singleAxisModel;\n            }\n\n            return {\n                dimensions: dimensions,\n                categoryIndex: isCategory ? 0 : -1,\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        polar: function (data, seriesModel, ecModel, completeDimOpt) {\n            var polarModel = ecModel.queryComponents({\n                mainType: 'polar',\n                index: seriesModel.get('polarIndex'),\n                id: seriesModel.get('polarId')\n            })[0];\n\n            var angleAxisModel = polarModel.findAxisModel('angleAxis');\n            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\n            if (__DEV__) {\n                if (!angleAxisModel) {\n                    throw new Error('angleAxis option not found');\n                }\n                if (!radiusAxisModel) {\n                    throw new Error('radiusAxis option not found');\n                }\n            }\n\n            var radiusAxisType = radiusAxisModel.get('type');\n            var angleAxisType = angleAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'radius',\n                    type: getDimTypeByAxis(radiusAxisType),\n                    stackable: isStackable(radiusAxisType)\n                },\n                {\n                    name: 'angle',\n                    type: getDimTypeByAxis(angleAxisType),\n                    stackable: isStackable(angleAxisType)\n                }\n            ];\n            var isAngleAxisCateogry = angleAxisType === 'category';\n            var isRadiusAxisCateogry = radiusAxisType === 'category';\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isRadiusAxisCateogry) {\n                categoryAxesModels.radius = radiusAxisModel;\n            }\n            if (isAngleAxisCateogry) {\n                categoryAxesModels.angle = angleAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        geo: function (data, seriesModel, ecModel, completeDimOpt) {\n            // TODO Region\n            // \n            return {\n                dimensions: completeDimensions([\n                    {name: 'lng'},\n                    {name: 'lat'}\n                ], data, completeDimOpt)\n            };\n        }\n    };\n\n    function createNameList(result, data) {\n        var nameList = [];\n\n        var categoryDim = result && result.dimensions[result.categoryIndex];\n        var categoryAxisModel;\n        if (categoryDim) {\n            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n        }\n\n        if (categoryAxisModel) {\n            // FIXME Two category axis\n            var categories = categoryAxisModel.getCategories();\n            if (categories) {\n                var dataLen = data.length;\n                // Ordered data is given explicitly like\n                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n                // or given scatter data,\n                // pick the category\n                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n                    nameList = [];\n                    for (var i = 0; i < dataLen; i++) {\n                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n                    }\n                }\n                else {\n                    nameList = categories.slice(0);\n                }\n            }\n        }\n\n        return nameList;\n    }\n\n    module.exports = createListFromArray;\n\n\n\n/***/ }),\n\n/***/ 1009:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n\n    var zrUtil = __webpack_require__(971);\n\n    var Style = __webpack_require__(1031);\n\n    var Element = __webpack_require__(1032);\n    var RectText = __webpack_require__(1059);\n    // var Stateful = require('./mixin/Stateful');\n\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        // Extend properties\n        for (var name in opts) {\n            if (\n                opts.hasOwnProperty(name) &&\n                name !== 'style'\n            ) {\n                this[name] = opts[name];\n            }\n        }\n\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style, this);\n\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];\n\n        // FIXME Stateful must be mixined after style is setted\n        // Stateful.call(this, opts);\n    }\n\n    Displayable.prototype = {\n\n        constructor: Displayable,\n\n        type: 'displayable',\n\n        /**\n         * Displayable Painter \n         * Dirty flag. From which painter will determine if this displayable object needs brush\n         * @name module:zrender/graphic/Displayable#__dirty\n         * @type {boolean}\n         */\n        __dirty: true,\n\n        /**\n         * true\n         * If ignore drawing of the displayable object. Mouse event will still be triggered\n         * @name module:/zrender/graphic/Displayable#invisible\n         * @type {boolean}\n         * @default false\n         */\n        invisible: false,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z: 0,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z2: 0,\n\n        /**\n         * zlevelcanvas\n         * @name module:/zrender/graphic/Displayable#zlevel\n         * @type {number}\n         * @default 0\n         */\n        zlevel: 0,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        draggable: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        dragging: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * If enable culling\n         * @type {boolean}\n         * @default false\n         */\n        culling: false,\n\n        /**\n         * Mouse cursor when hovered\n         * @name module:/zrender/graphic/Displayable#cursor\n         * @type {string}\n         */\n        cursor: 'pointer',\n\n        /**\n         * If hover area is bounding rect\n         * @name module:/zrender/graphic/Displayable#rectHover\n         * @type {string}\n         */\n        rectHover: false,\n\n        /**\n         * Render the element progressively when the value >= 0,\n         * usefull for large data.\n         * @type {number}\n         */\n        progressive: -1,\n\n        beforeBrush: function (ctx) {},\n\n        afterBrush: function (ctx) {},\n\n        /**\n         * \n         * @param {CanvasRenderingContext2D} ctx\n         */\n        // Interface\n        brush: function (ctx, prevEl) {},\n\n        /**\n         * \n         * @return {module:zrender/core/BoundingRect}\n         */\n        // Interface\n        getBoundingRect: function () {},\n\n        /**\n         *  x, y \n         * If displayable element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n\n        /**\n         *  x, y \n         * If bounding rect of element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n\n        /**\n         * \n         * Mark displayable element dirty and refresh next frame\n         */\n        dirty: function () {\n            this.__dirty = true;\n\n            this._rect = null;\n\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * \n         * If displayable object binded any event\n         * @return {boolean}\n         */\n        // TODO,  bind \n        // isSilent: function () {\n        //     return !(\n        //         this.hoverable || this.draggable\n        //         || this.onmousemove || this.onmouseover || this.onmouseout\n        //         || this.onmousedown || this.onmouseup || this.onclick\n        //         || this.ondragenter || this.ondragover || this.ondragleave\n        //         || this.ondrop\n        //     );\n        // },\n        /**\n         * Alias for animate('style')\n         * @param {boolean} loop\n         */\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                this.style.set(value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n\n        /**\n         * Use given style object\n         * @param  {Object} obj\n         */\n        useStyle: function (obj) {\n            this.style = new Style(obj, this);\n            this.dirty(false);\n            return this;\n        }\n    };\n\n    zrUtil.inherits(Displayable, Element);\n\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n\n    module.exports = Displayable;\n\n\n/***/ }),\n\n/***/ 1010:\n/***/ (function(module, exports) {\n\n\n\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n\n        this.colorStops = colorStops || [];\n\n    };\n\n    Gradient.prototype = {\n\n        constructor: Gradient,\n\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n\n                offset: offset,\n\n                color: color\n            });\n        }\n\n    };\n\n    module.exports = Gradient;\n\n\n/***/ }),\n\n/***/ 1011:\n/***/ (function(module, exports) {\n\n\n\n    var lib = {};\n\n    var ORIGIN_METHOD = '\\0__throttleOriginMethod';\n    var RATE = '\\0__throttleRate';\n    var THROTTLE_TYPE = '\\0__throttleType';\n\n    /**\n     * @public\n     * @param {(Function)} fn\n     * @param {number} [delay=0] Unit: ms.\n     * @param {boolean} [debounce=false]\n     *        true: If call interval less than `delay`, only the last call works.\n     *        false: If call interval less than `delay, call works on fixed rate.\n     * @return {(Function)} throttled fn.\n     */\n    lib.throttle = function (fn, delay, debounce) {\n\n        var currCall;\n        var lastCall = 0;\n        var lastExec = 0;\n        var timer = null;\n        var diff;\n        var scope;\n        var args;\n        var debounceNextCall;\n\n        delay = delay || 0;\n\n        function exec() {\n            lastExec = (new Date()).getTime();\n            timer = null;\n            fn.apply(scope, args || []);\n        }\n\n        var cb = function () {\n            currCall = (new Date()).getTime();\n            scope = this;\n            args = arguments;\n            var thisDelay = debounceNextCall || delay;\n            var thisDebounce = debounceNextCall || debounce;\n            debounceNextCall = null;\n            diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;\n\n            clearTimeout(timer);\n\n            if (thisDebounce) {\n                timer = setTimeout(exec, thisDelay);\n            }\n            else {\n                if (diff >= 0) {\n                    exec();\n                }\n                else {\n                    timer = setTimeout(exec, -diff);\n                }\n            }\n\n            lastCall = currCall;\n        };\n\n        /**\n         * Clear throttle.\n         * @public\n         */\n        cb.clear = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n        };\n\n        /**\n         * Enable debounce once.\n         */\n        cb.debounceNextCall = function (debounceDelay) {\n            debounceNextCall = debounceDelay;\n        };\n\n        return cb;\n    };\n\n    /**\n     * Create throttle method or update throttle rate.\n     *\n     * @example\n     * ComponentView.prototype.render = function () {\n     *     ...\n     *     throttle.createOrUpdate(\n     *         this,\n     *         '_dispatchAction',\n     *         this.model.get('throttle'),\n     *         'fixRate'\n     *     );\n     * };\n     * ComponentView.prototype.remove = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     * ComponentView.prototype.dispose = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     * @param {number} [rate]\n     * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'\n     * @return {Function} throttled function.\n     */\n    lib.createOrUpdate = function (obj, fnAttr, rate, throttleType) {\n        var fn = obj[fnAttr];\n\n        if (!fn) {\n            return;\n        }\n\n        var originFn = fn[ORIGIN_METHOD] || fn;\n        var lastThrottleType = fn[THROTTLE_TYPE];\n        var lastRate = fn[RATE];\n\n        if (lastRate !== rate || lastThrottleType !== throttleType) {\n            if (rate == null || !throttleType) {\n                return (obj[fnAttr] = originFn);\n            }\n\n            fn = obj[fnAttr] = lib.throttle(\n                originFn, rate, throttleType === 'debounce'\n            );\n            fn[ORIGIN_METHOD] = originFn;\n            fn[THROTTLE_TYPE] = throttleType;\n            fn[RATE] = rate;\n        }\n\n        return fn;\n    };\n\n    /**\n     * Clear throttle. Example see throttle.createOrUpdate.\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     */\n    lib.clear = function (obj, fnAttr) {\n        var fn = obj[fnAttr];\n        if (fn && fn[ORIGIN_METHOD]) {\n            obj[fnAttr] = fn[ORIGIN_METHOD];\n        }\n    };\n\n    module.exports = lib;\n\n\n\n/***/ }),\n\n/***/ 1012:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Interval scale\n * @module echarts/scale/Interval\n */\n\n\n\n    var numberUtil = __webpack_require__(974);\n    var formatUtil = __webpack_require__(977);\n    var Scale = __webpack_require__(1004);\n    var helper = __webpack_require__(1041);\n\n    var roundNumber = numberUtil.round;\n\n    /**\n     * @alias module:echarts/coord/scale/Interval\n     * @constructor\n     */\n    var IntervalScale = Scale.extend({\n\n        type: 'interval',\n\n        _interval: 0,\n\n        _intervalPrecision: 2,\n\n        setExtent: function (start, end) {\n            var thisExtent = this._extent;\n            //start,end may be a Number like '25',so...\n            if (!isNaN(start)) {\n                thisExtent[0] = parseFloat(start);\n            }\n            if (!isNaN(end)) {\n                thisExtent[1] = parseFloat(end);\n            }\n        },\n\n        unionExtent: function (other) {\n            var extent = this._extent;\n            other[0] < extent[0] && (extent[0] = other[0]);\n            other[1] > extent[1] && (extent[1] = other[1]);\n\n            // unionExtent may called by it's sub classes\n            IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n        },\n        /**\n         * Get interval\n         */\n        getInterval: function () {\n            return this._interval;\n        },\n\n        /**\n         * Set interval\n         */\n        setInterval: function (interval) {\n            this._interval = interval;\n            // Dropped auto calculated niceExtent and use user setted extent\n            // We assume user wan't to set both interval, min, max to get a better result\n            this._niceExtent = this._extent.slice();\n\n            this._intervalPrecision = helper.getIntervalPrecision(interval);\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            return helper.intervalScaleGetTicks(\n                this._interval, this._extent, this._niceExtent, this._intervalPrecision\n            );\n        },\n\n        /**\n         * @return {Array.<string>}\n         */\n        getTicksLabels: function () {\n            var labels = [];\n            var ticks = this.getTicks();\n            for (var i = 0; i < ticks.length; i++) {\n                labels.push(this.getLabel(ticks[i]));\n            }\n            return labels;\n        },\n\n        /**\n         * @param {number} data\n         * @param {Object} [opt]\n         * @param {number|string} [opt.precision] If 'auto', use nice presision.\n         * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.\n         * @return {string}\n         */\n        getLabel: function (data, opt) {\n            if (data == null) {\n                return '';\n            }\n\n            var precision = opt && opt.precision;\n\n            if (precision == null) {\n                precision = numberUtil.getPrecisionSafe(data) || 0;\n            }\n            else if (precision === 'auto') {\n                // Should be more precise then tick.\n                precision = this._intervalPrecision;\n            }\n\n            // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n            // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n            data = roundNumber(data, precision, true);\n\n            return formatUtil.addCommas(data);\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         *\n         * @param {number} [splitNumber = 5] Desired number of ticks\n         * @param {number} [minInterval]\n         * @param {number} [maxInterval]\n         */\n        niceTicks: function (splitNumber, minInterval, maxInterval) {\n            splitNumber = splitNumber || 5;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (!isFinite(span)) {\n                return;\n            }\n            // User may set axis min 0 and data are all negative\n            // FIXME If it needs to reverse ?\n            if (span < 0) {\n                span = -span;\n                extent.reverse();\n            }\n\n            var result = helper.intervalScaleNiceTicks(\n                extent, splitNumber, minInterval, maxInterval\n            );\n\n            this._intervalPrecision = result.intervalPrecision;\n            this._interval = result.interval;\n            this._niceExtent = result.niceTickExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {Object} opt\n         * @param {number} [opt.splitNumber = 5] Given approx tick number\n         * @param {boolean} [opt.fixMin=false]\n         * @param {boolean} [opt.fixMax=false]\n         * @param {boolean} [opt.minInterval]\n         * @param {boolean} [opt.maxInterval]\n         */\n        niceExtent: function (opt) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                if (extent[0] !== 0) {\n                    // Expand extent\n                    var expandSize = extent[0];\n                    // In the fowllowing case\n                    //      Axis has been fixed max 100\n                    //      Plus data are all 100 and axis extent are [100, 100].\n                    // Extend to the both side will cause expanded max is larger than fixed max.\n                    // So only expand to the smaller side.\n                    if (!opt.fixMax) {\n                        extent[1] += expandSize / 2;\n                        extent[0] -= expandSize / 2;\n                    }\n                    else {\n                        extent[0] -= expandSize / 2;\n                    }\n                }\n                else {\n                    extent[1] = 1;\n                }\n            }\n            var span = extent[1] - extent[0];\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (!isFinite(span)) {\n                extent[0] = 0;\n                extent[1] = 1;\n            }\n\n            this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!opt.fixMin) {\n                extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n            }\n            if (!opt.fixMax) {\n                extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n            }\n        }\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    IntervalScale.create = function () {\n        return new IntervalScale();\n    };\n\n    module.exports = IntervalScale;\n\n\n\n/***/ }),\n\n/***/ 1013:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(971);\n    var formatUtil = __webpack_require__(977);\n    var graphic = __webpack_require__(973);\n    var Model = __webpack_require__(979);\n    var numberUtil = __webpack_require__(974);\n    var remRadian = numberUtil.remRadian;\n    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n    var vec2 = __webpack_require__(976);\n    var matrix = __webpack_require__(986);\n    var v2ApplyTransform = vec2.applyTransform;\n    var retrieve = zrUtil.retrieve;\n\n    var PI = Math.PI;\n\n    function makeAxisEventDataBase(axisModel) {\n        var eventData = {\n            componentType: axisModel.mainType\n        };\n        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n        return eventData;\n    }\n\n    /**\n     * A final axis is translated and rotated from a \"standard axis\".\n     * So opt.position and opt.rotation is required.\n     *\n     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n     * for example: (0, 0) ------------> (0, 50)\n     *\n     * nameDirection or tickDirection or labelDirection is 1 means tick\n     * or label is below the standard axis, whereas is -1 means above\n     * the standard axis. labelOffset means offset between label and axis,\n     * which is useful when 'onZero', where axisLabel is in the grid and\n     * label in outside grid.\n     *\n     * Tips: like always,\n     * positive rotation represents anticlockwise, and negative rotation\n     * represents clockwise.\n     * The direction of position coordinate is the same as the direction\n     * of screen coordinate.\n     *\n     * Do not need to consider axis 'inverse', which is auto processed by\n     * axis extent.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} axisModel\n     * @param {Object} opt Standard axis parameters.\n     * @param {Array.<number>} opt.position [x, y]\n     * @param {number} opt.rotation by radian\n     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.\n     * @param {number} [opt.tickDirection=1] 1 or -1\n     * @param {number} [opt.labelDirection=1] 1 or -1\n     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n     * @param {string} [opt.axisLabelShow] default get from axisModel.\n     * @param {string} [opt.axisName] default get from axisModel.\n     * @param {number} [opt.axisNameAvailableWidth]\n     * @param {number} [opt.labelRotate] by degree, default get from axisModel.\n     * @param {number} [opt.labelInterval] Default label interval when label\n     *                                     interval from model is null or 'auto'.\n     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n     * @param {number} [opt.nameTruncateMaxWidth]\n     */\n    var AxisBuilder = function (axisModel, opt) {\n\n        /**\n         * @readOnly\n         */\n        this.opt = opt;\n\n        /**\n         * @readOnly\n         */\n        this.axisModel = axisModel;\n\n        // Default value\n        zrUtil.defaults(\n            opt,\n            {\n                labelOffset: 0,\n                nameDirection: 1,\n                tickDirection: 1,\n                labelDirection: 1,\n                silent: true\n            }\n        );\n\n        /**\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n\n        // FIXME Not use a seperate text group?\n        var dumbGroup = new graphic.Group({\n            position: opt.position.slice(),\n            rotation: opt.rotation\n        });\n\n        // this.group.add(dumbGroup);\n        // this._dumbGroup = dumbGroup;\n\n        dumbGroup.updateTransform();\n        this._transform = dumbGroup.transform;\n\n        this._dumbGroup = dumbGroup;\n    };\n\n    AxisBuilder.prototype = {\n\n        constructor: AxisBuilder,\n\n        hasBuilder: function (name) {\n            return !!builders[name];\n        },\n\n        add: function (name) {\n            builders[name].call(this);\n        },\n\n        getGroup: function () {\n            return this.group;\n        }\n\n    };\n\n    var builders = {\n\n        /**\n         * @private\n         */\n        axisLine: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n\n            if (!axisModel.get('axisLine.show')) {\n                return;\n            }\n\n            var extent = this.axisModel.axis.getExtent();\n\n            var matrix = this._transform;\n            var pt1 = [extent[0], 0];\n            var pt2 = [extent[1], 0];\n            if (matrix) {\n                v2ApplyTransform(pt1, pt1, matrix);\n                v2ApplyTransform(pt2, pt2, matrix);\n            }\n\n            this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                // Id for animation\n                anid: 'line',\n\n                shape: {\n                    x1: pt1[0],\n                    y1: pt1[1],\n                    x2: pt2[0],\n                    y2: pt2[1]\n                },\n                style: zrUtil.extend(\n                    {lineCap: 'round'},\n                    axisModel.getModel('axisLine.lineStyle').getLineStyle()\n                ),\n                strokeContainThreshold: opt.strokeContainThreshold || 5,\n                silent: true,\n                z2: 1\n            })));\n        },\n\n        /**\n         * @private\n         */\n        axisTickLabel: function () {\n            var axisModel = this.axisModel;\n            var opt = this.opt;\n\n            var tickEls = buildAxisTick(this, axisModel, opt);\n            var labelEls = buildAxisLabel(this, axisModel, opt);\n\n            fixMinMaxLabelShow(axisModel, labelEls, tickEls);\n        },\n\n        /**\n         * @private\n         */\n        axisName: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var name = retrieve(opt.axisName, axisModel.get('name'));\n\n            if (!name) {\n                return;\n            }\n\n            var nameLocation = axisModel.get('nameLocation');\n            var nameDirection = opt.nameDirection;\n            var textStyleModel = axisModel.getModel('nameTextStyle');\n            var gap = axisModel.get('nameGap') || 0;\n\n            var extent = this.axisModel.axis.getExtent();\n            var gapSignal = extent[0] > extent[1] ? -1 : 1;\n            var pos = [\n                nameLocation === 'start'\n                    ? extent[0] - gapSignal * gap\n                    : nameLocation === 'end'\n                    ? extent[1] + gapSignal * gap\n                    : (extent[0] + extent[1]) / 2, // 'middle'\n                // Reuse labelOffset.\n                isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0\n            ];\n\n            var labelLayout;\n\n            var nameRotation = axisModel.get('nameRotate');\n            if (nameRotation != null) {\n                nameRotation = nameRotation * PI / 180; // To radian.\n            }\n\n            var axisNameAvailableWidth;\n\n            if (isNameLocationCenter(nameLocation)) {\n                labelLayout = innerTextLayout(\n                    opt.rotation,\n                    nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n                    nameDirection\n                );\n            }\n            else {\n                labelLayout = endTextLayout(\n                    opt, nameLocation, nameRotation || 0, extent\n                );\n\n                axisNameAvailableWidth = opt.axisNameAvailableWidth;\n                if (axisNameAvailableWidth != null) {\n                    axisNameAvailableWidth = Math.abs(\n                        axisNameAvailableWidth / Math.sin(labelLayout.rotation)\n                    );\n                    !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n                }\n            }\n\n            var textFont = textStyleModel.getFont();\n\n            var truncateOpt = axisModel.get('nameTruncate', true) || {};\n            var ellipsis = truncateOpt.ellipsis;\n            var maxWidth = retrieve(\n                opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth\n            );\n            // FIXME\n            // truncate rich text? (consider performance)\n            var truncatedText = (ellipsis != null && maxWidth != null)\n                ? formatUtil.truncateText(\n                    name, maxWidth, textFont, ellipsis,\n                    {minChar: 2, placeholder: truncateOpt.placeholder}\n                )\n                : name;\n\n            var tooltipOpt = axisModel.get('tooltip', true);\n\n            var mainType = axisModel.mainType;\n            var formatterParams = {\n                componentType: mainType,\n                name: name,\n                $vars: ['name']\n            };\n            formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\n            var textEl = new graphic.Text({\n                // Id for animation\n                anid: 'name',\n\n                __fullText: name,\n                __truncatedText: truncatedText,\n\n                position: pos,\n                rotation: labelLayout.rotation,\n                silent: isSilent(axisModel),\n                z2: 1,\n                tooltip: (tooltipOpt && tooltipOpt.show)\n                    ? zrUtil.extend({\n                        content: name,\n                        formatter: function () {\n                            return name;\n                        },\n                        formatterParams: formatterParams\n                    }, tooltipOpt)\n                    : null\n            });\n\n            graphic.setTextStyle(textEl.style, textStyleModel, {\n                text: truncatedText,\n                textFont: textFont,\n                textFill: textStyleModel.getTextColor()\n                    || axisModel.get('axisLine.lineStyle.color'),\n                textAlign: labelLayout.textAlign,\n                textVerticalAlign: labelLayout.textVerticalAlign\n            });\n\n            if (axisModel.get('triggerEvent')) {\n                textEl.eventData = makeAxisEventDataBase(axisModel);\n                textEl.eventData.targetType = 'axisName';\n                textEl.eventData.name = name;\n            }\n\n            // FIXME\n            this._dumbGroup.add(textEl);\n            textEl.updateTransform();\n\n            this.group.add(textEl);\n\n            textEl.decomposeTransform();\n        }\n\n    };\n\n    /**\n     * @public\n     * @static\n     * @param {Object} opt\n     * @param {number} axisRotation in radian\n     * @param {number} textRotation in radian\n     * @param {number} direction\n     * @return {Object} {\n     *  rotation, // according to axis\n     *  textAlign,\n     *  textVerticalAlign\n     * }\n     */\n    var innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n        var rotationDiff = remRadian(textRotation - axisRotation);\n        var textAlign;\n        var textVerticalAlign;\n\n        if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line.\n            textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI)) { // Label is inverse parallel with axis line.\n            textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else {\n            textVerticalAlign = 'middle';\n\n            if (rotationDiff > 0 && rotationDiff < PI) {\n                textAlign = direction > 0 ? 'right' : 'left';\n            }\n            else {\n                textAlign = direction > 0 ? 'left' : 'right';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    };\n\n    function endTextLayout(opt, textPosition, textRotate, extent) {\n        var rotationDiff = remRadian(textRotate - opt.rotation);\n        var textAlign;\n        var textVerticalAlign;\n        var inverse = extent[0] > extent[1];\n        var onLeft = (textPosition === 'start' && !inverse)\n            || (textPosition !== 'start' && inverse);\n\n        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n            textVerticalAlign = onLeft ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n            textVerticalAlign = onLeft ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else {\n            textVerticalAlign = 'middle';\n            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n                textAlign = onLeft ? 'left' : 'right';\n            }\n            else {\n                textAlign = onLeft ? 'right' : 'left';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    }\n\n    function isSilent(axisModel) {\n        var tooltipOpt = axisModel.get('tooltip');\n        return axisModel.get('silent')\n            // Consider mouse cursor, add these restrictions.\n            || !(\n                axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show)\n            );\n    }\n\n    function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n        // If min or max are user set, we need to check\n        // If the tick on min(max) are overlap on their neighbour tick\n        // If they are overlapped, we need to hide the min(max) tick label\n        var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n        var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n\n        // FIXME\n        // Have not consider onBand yet, where tick els is more than label els.\n\n        labelEls = labelEls || [];\n        tickEls = tickEls || [];\n\n        var firstLabel = labelEls[0];\n        var nextLabel = labelEls[1];\n        var lastLabel = labelEls[labelEls.length - 1];\n        var prevLabel = labelEls[labelEls.length - 2];\n\n        var firstTick = tickEls[0];\n        var nextTick = tickEls[1];\n        var lastTick = tickEls[tickEls.length - 1];\n        var prevTick = tickEls[tickEls.length - 2];\n\n        if (showMinLabel === false) {\n            ignoreEl(firstLabel);\n            ignoreEl(firstTick);\n        }\n        else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n            if (showMinLabel) {\n                ignoreEl(nextLabel);\n                ignoreEl(nextTick);\n            }\n            else {\n                ignoreEl(firstLabel);\n                ignoreEl(firstTick);\n            }\n        }\n\n        if (showMaxLabel === false) {\n            ignoreEl(lastLabel);\n            ignoreEl(lastTick);\n        }\n        else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n            if (showMaxLabel) {\n                ignoreEl(prevLabel);\n                ignoreEl(prevTick);\n            }\n            else {\n                ignoreEl(lastLabel);\n                ignoreEl(lastTick);\n            }\n        }\n    }\n\n    function ignoreEl(el) {\n        el && (el.ignore = true);\n    }\n\n    function isTwoLabelOverlapped(current, next, labelLayout) {\n        // current and next has the same rotation.\n        var firstRect = current && current.getBoundingRect().clone();\n        var nextRect = next && next.getBoundingRect().clone();\n\n        if (!firstRect || !nextRect) {\n            return;\n        }\n\n        // When checking intersect of two rotated labels, we use mRotationBack\n        // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n        var mRotationBack = matrix.identity([]);\n        matrix.rotate(mRotationBack, mRotationBack, -current.rotation);\n\n        firstRect.applyTransform(matrix.mul([], mRotationBack, current.getLocalTransform()));\n        nextRect.applyTransform(matrix.mul([], mRotationBack, next.getLocalTransform()));\n\n        return firstRect.intersect(nextRect);\n    }\n\n    function isNameLocationCenter(nameLocation) {\n        return nameLocation === 'middle' || nameLocation === 'center';\n    }\n\n    /**\n     * @static\n     */\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (\n        axis,\n        i,\n        interval,\n        ticksCnt,\n        showMinLabel,\n        showMaxLabel\n    ) {\n        if (i === 0 && showMinLabel || i === ticksCnt - 1 && showMaxLabel) {\n            return false;\n        }\n\n        // FIXME\n        // Have not consider label overlap (if label is too long) yet.\n\n        var rawTick;\n        var scale = axis.scale;\n        return scale.type === 'ordinal'\n            && (\n                typeof interval === 'function'\n                    ? (\n                        rawTick = scale.getTicks()[i],\n                        !interval(rawTick, scale.getLabel(rawTick))\n                    )\n                    : i % (interval + 1)\n            );\n    };\n\n    /**\n     * @static\n     */\n    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n        var interval = model.get('interval');\n        if (interval == null || interval == 'auto') {\n            interval = labelInterval;\n        }\n        return interval;\n    };\n\n    function buildAxisTick(axisBuilder, axisModel, opt) {\n        var axis = axisModel.axis;\n\n        if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {\n            return;\n        }\n\n        var tickModel = axisModel.getModel('axisTick');\n\n        var lineStyleModel = tickModel.getModel('lineStyle');\n        var tickLen = tickModel.get('length');\n\n        var tickInterval = getInterval(tickModel, opt.labelInterval);\n        var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n        // FIXME\n        // Corresponds to ticksCoords ?\n        var ticks = axis.scale.getTicks();\n\n        var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n        var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n\n        var pt1 = [];\n        var pt2 = [];\n        var matrix = axisBuilder._transform;\n\n        var tickEls = [];\n\n        var ticksCnt = ticksCoords.length;\n        for (var i = 0; i < ticksCnt; i++) {\n            // Only ordinal scale support tick interval\n            if (ifIgnoreOnTick(\n                axis, i, tickInterval, ticksCnt,\n                showMinLabel, showMaxLabel\n            )) {\n                continue;\n            }\n\n            var tickCoord = ticksCoords[i];\n\n            pt1[0] = tickCoord;\n            pt1[1] = 0;\n            pt2[0] = tickCoord;\n            pt2[1] = opt.tickDirection * tickLen;\n\n            if (matrix) {\n                v2ApplyTransform(pt1, pt1, matrix);\n                v2ApplyTransform(pt2, pt2, matrix);\n            }\n            // Tick line, Not use group transform to have better line draw\n            var tickEl = new graphic.Line(graphic.subPixelOptimizeLine({\n                // Id for animation\n                anid: 'tick_' + ticks[i],\n\n                shape: {\n                    x1: pt1[0],\n                    y1: pt1[1],\n                    x2: pt2[0],\n                    y2: pt2[1]\n                },\n                style: zrUtil.defaults(\n                    lineStyleModel.getLineStyle(),\n                    {\n                        stroke: axisModel.get('axisLine.lineStyle.color')\n                    }\n                ),\n                z2: 2,\n                silent: true\n            }));\n            axisBuilder.group.add(tickEl);\n            tickEls.push(tickEl);\n        }\n\n        return tickEls;\n    }\n\n    function buildAxisLabel(axisBuilder, axisModel, opt) {\n        var axis = axisModel.axis;\n        var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n        if (!show || axis.scale.isBlank()) {\n            return;\n        }\n\n        var labelModel = axisModel.getModel('axisLabel');\n        var labelMargin = labelModel.get('margin');\n        var ticks = axis.scale.getTicks();\n        var labels = axisModel.getFormattedLabels();\n\n        // Special label rotate.\n        var labelRotation = (\n            retrieve(opt.labelRotate, labelModel.get('rotate')) || 0\n        ) * PI / 180;\n\n        var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n        var categoryData = axisModel.get('data');\n\n        var labelEls = [];\n        var silent = isSilent(axisModel);\n        var triggerEvent = axisModel.get('triggerEvent');\n\n        var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n        var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n\n        zrUtil.each(ticks, function (tickVal, index) {\n            if (ifIgnoreOnTick(\n                axis, index, opt.labelInterval, ticks.length,\n                showMinLabel, showMaxLabel\n            )) {\n                    return;\n            }\n\n            var itemLabelModel = labelModel;\n            if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {\n                itemLabelModel = new Model(\n                    categoryData[tickVal].textStyle, labelModel, axisModel.ecModel\n                );\n            }\n\n            var textColor = itemLabelModel.getTextColor()\n                || axisModel.get('axisLine.lineStyle.color');\n\n            var tickCoord = axis.dataToCoord(tickVal);\n            var pos = [\n                tickCoord,\n                opt.labelOffset + opt.labelDirection * labelMargin\n            ];\n            var labelStr = axis.scale.getLabel(tickVal);\n\n            var textEl = new graphic.Text({\n                // Id for animation\n                anid: 'label_' + tickVal,\n                position: pos,\n                rotation: labelLayout.rotation,\n                silent: silent,\n                z2: 10\n            });\n\n            graphic.setTextStyle(textEl.style, itemLabelModel, {\n                text: labels[index],\n                textAlign: itemLabelModel.getShallow('align', true)\n                    || labelLayout.textAlign,\n                textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true)\n                    || itemLabelModel.getShallow('baseline', true)\n                    || labelLayout.textVerticalAlign,\n                textFill: typeof textColor === 'function'\n                    ? textColor(\n                        // (1) In category axis with data zoom, tick is not the original\n                        // index of axis.data. So tick should not be exposed to user\n                        // in category axis.\n                        // (2) Compatible with previous version, which always returns labelStr.\n                        // But in interval scale labelStr is like '223,445', which maked\n                        // user repalce ','. So we modify it to return original val but remain\n                        // it as 'string' to avoid error in replacing.\n                        axis.type === 'category' ? labelStr : axis.type === 'value' ? tickVal + '' : tickVal,\n                        index\n                    )\n                    : textColor\n            });\n\n            // Pack data for mouse event\n            if (triggerEvent) {\n                textEl.eventData = makeAxisEventDataBase(axisModel);\n                textEl.eventData.targetType = 'axisLabel';\n                textEl.eventData.value = labelStr;\n            }\n\n            // FIXME\n            axisBuilder._dumbGroup.add(textEl);\n            textEl.updateTransform();\n\n            labelEls.push(textEl);\n            axisBuilder.group.add(textEl);\n\n            textEl.decomposeTransform();\n\n        });\n\n        return labelEls;\n    }\n\n\n    module.exports = AxisBuilder;\n\n\n\n/***/ }),\n\n/***/ 1014:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var axisPointerModelHelper = __webpack_require__(1005);\n\n    /**\n     * Base class of AxisView.\n     */\n    var AxisView = __webpack_require__(972).extendComponentView({\n\n        type: 'axis',\n\n        /**\n         * @private\n         */\n        _axisPointer: null,\n\n        /**\n         * @protected\n         * @type {string}\n         */\n        axisPointerClass: null,\n\n        /**\n         * @override\n         */\n        render: function (axisModel, ecModel, api, payload) {\n            // FIXME\n            // This process should proformed after coordinate systems updated\n            // (axis scale updated), and should be performed each time update.\n            // So put it here temporarily, although it is not appropriate to\n            // put a model-writing procedure in `view`.\n            this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel);\n\n            AxisView.superApply(this, 'render', arguments);\n\n            updateAxisPointer(this, axisModel, ecModel, api, payload, true);\n        },\n\n        /**\n         * Action handler.\n         * @public\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/model/Global} ecModel\n         * @param {module:echarts/ExtensionAPI} api\n         * @param {Object} payload\n         */\n        updateAxisPointer: function (axisModel, ecModel, api, payload, force) {\n            updateAxisPointer(this, axisModel, ecModel, api, payload, false);\n        },\n\n        /**\n         * @override\n         */\n        remove: function (ecModel, api) {\n            var axisPointer = this._axisPointer;\n            axisPointer && axisPointer.remove(api);\n            AxisView.superApply(this, 'remove', arguments);\n        },\n\n        /**\n         * @override\n         */\n        dispose: function (ecModel, api) {\n            disposeAxisPointer(this, api);\n            AxisView.superApply(this, 'dispose', arguments);\n        }\n\n    });\n\n    function updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {\n        var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);\n        if (!Clazz) {\n            return;\n        }\n        var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);\n        axisPointerModel\n            ? (axisView._axisPointer || (axisView._axisPointer = new Clazz()))\n                .render(axisModel, axisPointerModel, api, forceRender)\n            : disposeAxisPointer(axisView, api);\n    }\n\n    function disposeAxisPointer(axisView, ecModel, api) {\n        var axisPointer = axisView._axisPointer;\n        axisPointer && axisPointer.dispose(ecModel, api);\n        axisView._axisPointer = null;\n    }\n\n    var axisPointerClazz = [];\n\n    AxisView.registerAxisPointerClass = function (type, clazz) {\n        if (__DEV__) {\n            if (axisPointerClazz[type]) {\n                throw new Error('axisPointer ' + type + ' exists');\n            }\n        }\n        axisPointerClazz[type] = clazz;\n    };\n\n    AxisView.getAxisPointerClass = function (type) {\n        return type && axisPointerClazz[type];\n    };\n\n    module.exports = AxisView;\n\n\n/***/ }),\n\n/***/ 1015:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var LRU = __webpack_require__(1030);\n    var globalImageCache = new LRU(50);\n\n    var helper = {};\n\n    /**\n     * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n     * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n     */\n    helper.findExistImage = function (newImageOrSrc) {\n        if (typeof newImageOrSrc === 'string') {\n            var cachedImgObj = globalImageCache.get(newImageOrSrc);\n            return cachedImgObj && cachedImgObj.image;\n        }\n        else {\n            return newImageOrSrc;\n        }\n    };\n\n    /**\n     * Caution: User should cache loaded images, but not just count on LRU.\n     * Consider if required images more than LRU size, will dead loop occur?\n     *\n     * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n     * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.\n     * @param {module:zrender/Element} [hostEl] For calling `dirty`.\n     * @param {Function} [cb] params: (image, cbPayload)\n     * @param {Object} [cbPayload] Payload on cb calling.\n     * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n     */\n    helper.createOrUpdateImage = function (newImageOrSrc, image, hostEl, cb, cbPayload) {\n        if (!newImageOrSrc) {\n            return image;\n        }\n        else if (typeof newImageOrSrc === 'string') {\n\n            // Image should not be loaded repeatly.\n            if ((image && image.__zrImageSrc === newImageOrSrc) || !hostEl) {\n                return image;\n            }\n\n            // Only when there is no existent image or existent image src\n            // is different, this method is responsible for load.\n            var cachedImgObj = globalImageCache.get(newImageOrSrc);\n\n            var pendingWrap = {hostEl: hostEl, cb: cb, cbPayload: cbPayload};\n\n            if (cachedImgObj) {\n                image = cachedImgObj.image;\n                !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);\n            }\n            else {\n                !image && (image = new Image());\n                image.onload = imageOnLoad;\n\n                globalImageCache.put(\n                    newImageOrSrc,\n                    image.__cachedImgObj = {\n                        image: image,\n                        pending: [pendingWrap]\n                    }\n                );\n\n                image.src = image.__zrImageSrc = newImageOrSrc;\n            }\n\n            return image;\n        }\n        // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas\n        else {\n            return newImageOrSrc;\n        }\n    };\n\n    function imageOnLoad() {\n        var cachedImgObj = this.__cachedImgObj;\n        this.onload = this.__cachedImgObj = null;\n\n        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n            var pendingWrap = cachedImgObj.pending[i];\n            var cb = pendingWrap.cb;\n            cb && cb(this, pendingWrap.cbPayload);\n            pendingWrap.hostEl.dirty();\n        }\n        cachedImgObj.pending.length = 0;\n    }\n\n    var isImageReady = helper.isImageReady = function (image) {\n        return image && image.width && image.height;\n    };\n\n    module.exports = helper;\n\n\n\n/***/ }),\n\n/***/ 1016:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(971);\n    var clazz = __webpack_require__(984);\n\n    var parseClassType = clazz.parseClassType;\n\n    var base = 0;\n\n    var componentUtil = {};\n\n    var DELIMITER = '_';\n\n    /**\n     * @public\n     * @param {string} type\n     * @return {string}\n     */\n    componentUtil.getUID = function (type) {\n        // Considering the case of crossing js context,\n        // use Math.random to make id as unique as possible.\n        return [(type || ''), base++, Math.random()].join(DELIMITER);\n    };\n\n    /**\n     * @inner\n     */\n    componentUtil.enableSubTypeDefaulter = function (entity) {\n\n        var subTypeDefaulters = {};\n\n        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n            componentType = parseClassType(componentType);\n            subTypeDefaulters[componentType.main] = defaulter;\n        };\n\n        entity.determineSubType = function (componentType, option) {\n            var type = option.type;\n            if (!type) {\n                var componentTypeMain = parseClassType(componentType).main;\n                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n                    type = subTypeDefaulters[componentTypeMain](option);\n                }\n            }\n            return type;\n        };\n\n        return entity;\n    };\n\n    /**\n     * Topological travel on Activity Network (Activity On Vertices).\n     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n     *\n     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n     *\n     * If there is circle dependencey, Error will be thrown.\n     *\n     */\n    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\n        /**\n         * @public\n         * @param {Array.<string>} targetNameList Target Component type list.\n         *                                           Can be ['aa', 'bb', 'aa.xx']\n         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n         * @param {Function} callback Params: componentType, dependencies.\n         * @param {Object} context Scope of callback.\n         */\n        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n            if (!targetNameList.length) {\n                return;\n            }\n\n            var result = makeDepndencyGraph(fullNameList);\n            var graph = result.graph;\n            var stack = result.noEntryList;\n\n            var targetNameSet = {};\n            zrUtil.each(targetNameList, function (name) {\n                targetNameSet[name] = true;\n            });\n\n            while (stack.length) {\n                var currComponentType = stack.pop();\n                var currVertex = graph[currComponentType];\n                var isInTargetNameSet = !!targetNameSet[currComponentType];\n                if (isInTargetNameSet) {\n                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n                    delete targetNameSet[currComponentType];\n                }\n                zrUtil.each(\n                    currVertex.successor,\n                    isInTargetNameSet ? removeEdgeAndAdd : removeEdge\n                );\n            }\n\n            zrUtil.each(targetNameSet, function () {\n                throw new Error('Circle dependency may exists');\n            });\n\n            function removeEdge(succComponentType) {\n                graph[succComponentType].entryCount--;\n                if (graph[succComponentType].entryCount === 0) {\n                    stack.push(succComponentType);\n                }\n            }\n\n            // Consider this case: legend depends on series, and we call\n            // chart.setOption({series: [...]}), where only series is in option.\n            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n            // not be called, but only sereis.mergeOption is called. Thus legend\n            // have no chance to update its local record about series (like which\n            // name of series is available in legend).\n            function removeEdgeAndAdd(succComponentType) {\n                targetNameSet[succComponentType] = true;\n                removeEdge(succComponentType);\n            }\n        };\n\n        /**\n         * DepndencyGraph: {Object}\n         * key: conponentType,\n         * value: {\n         *     successor: [conponentTypes...],\n         *     originalDeps: [conponentTypes...],\n         *     entryCount: {number}\n         * }\n         */\n        function makeDepndencyGraph(fullNameList) {\n            var graph = {};\n            var noEntryList = [];\n\n            zrUtil.each(fullNameList, function (name) {\n\n                var thisItem = createDependencyGraphItem(graph, name);\n                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\n                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n                thisItem.entryCount = availableDeps.length;\n                if (thisItem.entryCount === 0) {\n                    noEntryList.push(name);\n                }\n\n                zrUtil.each(availableDeps, function (dependentName) {\n                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n                        thisItem.predecessor.push(dependentName);\n                    }\n                    var thatItem = createDependencyGraphItem(graph, dependentName);\n                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n                        thatItem.successor.push(name);\n                    }\n                });\n            });\n\n            return {graph: graph, noEntryList: noEntryList};\n        }\n\n        function createDependencyGraphItem(graph, name) {\n            if (!graph[name]) {\n                graph[name] = {predecessor: [], successor: []};\n            }\n            return graph[name];\n        }\n\n        function getAvailableDependencies(originalDeps, fullNameList) {\n            var availableDeps = [];\n            zrUtil.each(originalDeps, function (dep) {\n                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n            });\n            return availableDeps;\n        }\n    };\n\n    module.exports = componentUtil;\n\n\n/***/ }),\n\n/***/ 1017:\n/***/ (function(module, exports) {\n\n// https://github.com/mziccard/node-timsort\n\n    var DEFAULT_MIN_MERGE = 32;\n\n    var DEFAULT_MIN_GALLOPING = 7;\n\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\n    function minRunLength(n) {\n        var r = 0;\n\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n\n        return n + r;\n    }\n\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n\n        if (runHi === hi) {\n            return 1;\n        }\n\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n\n            reverseRun(array, lo, runHi);\n        }\n        else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n\n        return runHi - lo;\n    }\n\n    function reverseRun(array, lo, hi) {\n        hi--;\n\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n\n        for (; start < hi; start++) {\n            var pivot = array[start];\n\n            var left = lo;\n            var right = start;\n            var mid;\n\n            while (left < right) {\n                mid = left + right >>> 1;\n\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n\n            var n = start - left;\n\n            switch (n) {\n                case 3:\n                    array[left + 3] = array[left + 2];\n\n                case 2:\n                    array[left + 2] = array[left + 1];\n\n                case 1:\n                    array[left + 1] = array[left];\n                    break;\n                default:\n                    while (n > 0) {\n                        array[left + n] = array[left + n - 1];\n                        n--;\n                    }\n            }\n\n            array[left] = pivot;\n        }\n    }\n\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n        else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            }\n            else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        else {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n\n        lastOffset++;\n\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            }\n            else {\n                lastOffset = m + 1;\n            }\n        }\n\n        return offset;\n    }\n\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n\n        length = array.length;\n\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n\n        var tmp = [];\n\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\n        runStart = [];\n        runLength = [];\n\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                }\n                else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n\n                mergeAt(n);\n            }\n        }\n\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n\n            runLength[i] = length1 + length2;\n\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n\n            stackSize--;\n\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n\n            if (length1 === 0) {\n                return;\n            }\n\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n            if (length2 === 0) {\n                return;\n            }\n\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            }\n            else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n\n            array[dest++] = array[cursor2++];\n\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest++] = array[cursor2++];\n\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            minGallop < 1 && (minGallop = 1);\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            }\n            else if (length1 === 0) {\n                throw new Error();\n                // throw new Error('mergeLow preconditions were not respected');\n            }\n            else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n\n        function mergeHigh (start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n\n            array[dest--] = array[cursor1--];\n\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n\n                return;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n                return;\n            }\n\n            var _minGallop = minGallop;\n\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = tmp[cursor2--];\n\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = array[cursor1--];\n\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n            }\n            else if (length2 === 0) {\n                throw new Error();\n                // throw new Error('mergeHigh preconditions were not respected');\n            }\n            else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n\n        var remaining = hi - lo;\n\n        if (remaining < 2) {\n            return;\n        }\n\n        var runLength = 0;\n\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n\n        var ts = new TimSort(array, compare);\n\n        var minRun = minRunLength(remaining);\n\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n\n        ts.forceMergeRuns();\n    }\n\n    module.exports = sort;\n\n\n/***/ }),\n\n/***/ 1018:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(971);\n    var axisHelper = __webpack_require__(988);\n\n    function getName(obj) {\n        if (zrUtil.isObject(obj) && obj.value != null) {\n            return obj.value;\n        }\n        else {\n            return obj + '';\n        }\n    }\n\n    module.exports = {\n\n        /**\n         * Format labels\n         * @return {Array.<string>}\n         */\n        getFormattedLabels: function () {\n            return axisHelper.getFormattedLabels(\n                this.axis,\n                this.get('axisLabel.formatter')\n            );\n        },\n\n        /**\n         * Get categories\n         */\n        getCategories: function () {\n            return this.get('type') === 'category'\n                && zrUtil.map(this.get('data'), getName);\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN\n         */\n        getMin: function (origin) {\n            var option = this.option;\n            var min = (!origin && option.rangeStart != null)\n                ? option.rangeStart : option.min;\n\n            if (this.axis\n                && min != null\n                && min !== 'dataMin'\n                && typeof min !== 'function'\n                && !zrUtil.eqNaN(min)\n            ) {\n                min = this.axis.scale.parse(min);\n            }\n            return min;\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN\n         */\n        getMax: function (origin) {\n            var option = this.option;\n            var max = (!origin && option.rangeEnd != null)\n                ? option.rangeEnd : option.max;\n\n            if (this.axis\n                && max != null\n                && max !== 'dataMax'\n                && typeof max !== 'function'\n                && !zrUtil.eqNaN(max)\n            ) {\n                max = this.axis.scale.parse(max);\n            }\n            return max;\n        },\n\n        /**\n         * @return {boolean}\n         */\n        getNeedCrossZero: function () {\n            var option = this.option;\n            return (option.rangeStart != null || option.rangeEnd != null)\n                ? false : !option.scale;\n        },\n\n        /**\n         * Should be implemented by each axis model if necessary.\n         * @return {module:echarts/model/Component} coordinate system model\n         */\n        getCoordSysModel: zrUtil.noop,\n\n        /**\n         * @param {number} rangeStart Can only be finite number or null/undefined or NaN.\n         * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.\n         */\n        setRange: function (rangeStart, rangeEnd) {\n            this.option.rangeStart = rangeStart;\n            this.option.rangeEnd = rangeEnd;\n        },\n\n        /**\n         * Reset range\n         */\n        resetRange: function () {\n            // rangeStart and rangeEnd is readonly.\n            this.option.rangeStart = this.option.rangeEnd = null;\n        }\n    };\n\n\n/***/ }),\n\n/***/ 1019:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @file Data zoom model\n */\n\n\n    var zrUtil = __webpack_require__(971);\n    var env = __webpack_require__(978);\n    var echarts = __webpack_require__(972);\n    var modelUtil = __webpack_require__(975);\n    var helper = __webpack_require__(1020);\n    var AxisProxy = __webpack_require__(1142);\n    var each = zrUtil.each;\n    var eachAxisDim = helper.eachAxisDim;\n\n    var DataZoomModel = echarts.extendComponentModel({\n\n        type: 'dataZoom',\n\n        dependencies: [\n            'xAxis', 'yAxis', 'zAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series'\n        ],\n\n        /**\n         * @protected\n         */\n        defaultOption: {\n            zlevel: 0,\n            z: 4,                   // Higher than normal component (z: 2).\n            orient: null,           // Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.\n            xAxisIndex: null,       // Default the first horizontal category axis.\n            yAxisIndex: null,       // Default the first vertical category axis.\n\n            filterMode: 'filter',   // Possible values: 'filter' or 'empty' or 'weakFilter'.\n                                    // 'filter': data items which are out of window will be removed. This option is\n                                    //          applicable when filtering outliers. For each data item, it will be\n                                    //          filtered if one of the relevant dimensions is out of the window.\n                                    // 'weakFilter': data items which are out of window will be removed. This option\n                                    //          is applicable when filtering outliers. For each data item, it will be\n                                    //          filtered only if all  of the relevant dimensions are out of the same\n                                    //          side of the window.\n                                    // 'empty': data items which are out of window will be set to empty.\n                                    //          This option is applicable when user should not neglect\n                                    //          that there are some data items out of window.\n                                    // 'none': Do not filter.\n                                    // Taking line chart as an example, line will be broken in\n                                    // the filtered points when filterModel is set to 'empty', but\n                                    // be connected when set to 'filter'.\n\n            throttle: null,         // Dispatch action by the fixed rate, avoid frequency.\n                                    // default 100. Do not throttle when use null/undefined.\n                                    // If animation === true and animationDurationUpdate > 0,\n                                    // default value is 100, otherwise 20.\n            start: 0,               // Start percent. 0 ~ 100\n            end: 100,               // End percent. 0 ~ 100\n            startValue: null,       // Start value. If startValue specified, start is ignored.\n            endValue: null,         // End value. If endValue specified, end is ignored.\n            minSpan: null,          // 0 ~ 100\n            maxSpan: null,          // 0 ~ 100\n            minValueSpan: null,     // The range of dataZoom can not be smaller than that.\n            maxValueSpan: null,     // The range of dataZoom can not be larger than that.\n            rangeMode: null         // Array, can be 'value' or 'percent'.\n        },\n\n        /**\n         * @override\n         */\n        init: function (option, parentModel, ecModel) {\n\n            /**\n             * key like x_0, y_1\n             * @private\n             * @type {Object}\n             */\n            this._dataIntervalByAxis = {};\n\n            /**\n             * @private\n             */\n            this._dataInfo = {};\n\n            /**\n             * key like x_0, y_1\n             * @private\n             */\n            this._axisProxies = {};\n\n            /**\n             * @readOnly\n             */\n            this.textStyleModel;\n\n            /**\n             * @private\n             */\n            this._autoThrottle = true;\n\n            /**\n             * 'percent' or 'value'\n             * @private\n             */\n            this._rangePropMode = ['percent', 'percent'];\n\n            var rawOption = retrieveRaw(option);\n\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            this.doInit(rawOption);\n        },\n\n        /**\n         * @override\n         */\n        mergeOption: function (newOption) {\n            var rawOption = retrieveRaw(newOption);\n\n            //FIX #2591\n            zrUtil.merge(this.option, newOption, true);\n\n            this.doInit(rawOption);\n        },\n\n        /**\n         * @protected\n         */\n        doInit: function (rawOption) {\n            var thisOption = this.option;\n\n            // Disable realtime view update if canvas is not supported.\n            if (!env.canvasSupported) {\n                thisOption.realtime = false;\n            }\n\n            this._setDefaultThrottle(rawOption);\n\n            updateRangeUse(this, rawOption);\n\n            each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n                // start/end has higher priority over startValue/endValue if they\n                // both set, but we should make chart.setOption({endValue: 1000})\n                // effective, rather than chart.setOption({endValue: 1000, end: null}).\n                if (this._rangePropMode[index] === 'value') {\n                    thisOption[names[0]] = null;\n                }\n                // Otherwise do nothing and use the merge result.\n            }, this);\n\n            this.textStyleModel = this.getModel('textStyle');\n\n            this._resetTarget();\n\n            this._giveAxisProxies();\n        },\n\n        /**\n         * @private\n         */\n        _giveAxisProxies: function () {\n            var axisProxies = this._axisProxies;\n\n            this.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel, ecModel) {\n                var axisModel = this.dependentModels[dimNames.axis][axisIndex];\n\n                // If exists, share axisProxy with other dataZoomModels.\n                var axisProxy = axisModel.__dzAxisProxy || (\n                    // Use the first dataZoomModel as the main model of axisProxy.\n                    axisModel.__dzAxisProxy = new AxisProxy(\n                        dimNames.name, axisIndex, this, ecModel\n                    )\n                );\n                // FIXME\n                // dispose __dzAxisProxy\n\n                axisProxies[dimNames.name + '_' + axisIndex] = axisProxy;\n            }, this);\n        },\n\n        /**\n         * @private\n         */\n        _resetTarget: function () {\n            var thisOption = this.option;\n\n            var autoMode = this._judgeAutoMode();\n\n            eachAxisDim(function (dimNames) {\n                var axisIndexName = dimNames.axisIndex;\n                thisOption[axisIndexName] = modelUtil.normalizeToArray(\n                    thisOption[axisIndexName]\n                );\n            }, this);\n\n            if (autoMode === 'axisIndex') {\n                this._autoSetAxisIndex();\n            }\n            else if (autoMode === 'orient') {\n                this._autoSetOrient();\n            }\n        },\n\n        /**\n         * @private\n         */\n        _judgeAutoMode: function () {\n            // Auto set only works for setOption at the first time.\n            // The following is user's reponsibility. So using merged\n            // option is OK.\n            var thisOption = this.option;\n\n            var hasIndexSpecified = false;\n            eachAxisDim(function (dimNames) {\n                // When user set axisIndex as a empty array, we think that user specify axisIndex\n                // but do not want use auto mode. Because empty array may be encountered when\n                // some error occured.\n                if (thisOption[dimNames.axisIndex] != null) {\n                    hasIndexSpecified = true;\n                }\n            }, this);\n\n            var orient = thisOption.orient;\n\n            if (orient == null && hasIndexSpecified) {\n                return 'orient';\n            }\n            else if (!hasIndexSpecified) {\n                if (orient == null) {\n                    thisOption.orient = 'horizontal';\n                }\n                return 'axisIndex';\n            }\n        },\n\n        /**\n         * @private\n         */\n        _autoSetAxisIndex: function () {\n            var autoAxisIndex = true;\n            var orient = this.get('orient', true);\n            var thisOption = this.option;\n            var dependentModels = this.dependentModels;\n\n            if (autoAxisIndex) {\n                // Find axis that parallel to dataZoom as default.\n                var dimName = orient === 'vertical' ? 'y' : 'x';\n\n                if (dependentModels[dimName + 'Axis'].length) {\n                    thisOption[dimName + 'AxisIndex'] = [0];\n                    autoAxisIndex = false;\n                }\n                else {\n                    each(dependentModels.singleAxis, function (singleAxisModel) {\n                        if (autoAxisIndex && singleAxisModel.get('orient', true) === orient) {\n                            thisOption.singleAxisIndex = [singleAxisModel.componentIndex];\n                            autoAxisIndex = false;\n                        }\n                    });\n                }\n            }\n\n            if (autoAxisIndex) {\n                // Find the first category axis as default. (consider polar)\n                eachAxisDim(function (dimNames) {\n                    if (!autoAxisIndex) {\n                        return;\n                    }\n                    var axisIndices = [];\n                    var axisModels = this.dependentModels[dimNames.axis];\n                    if (axisModels.length && !axisIndices.length) {\n                        for (var i = 0, len = axisModels.length; i < len; i++) {\n                            if (axisModels[i].get('type') === 'category') {\n                                axisIndices.push(i);\n                            }\n                        }\n                    }\n                    thisOption[dimNames.axisIndex] = axisIndices;\n                    if (axisIndices.length) {\n                        autoAxisIndex = false;\n                    }\n                }, this);\n            }\n\n            if (autoAxisIndex) {\n                // FIXME\n                // ec2xAxisIndexyAxisIndexscatterdataZoom\n                // Grid.js#getScaleByOptiontimelogaxis type\n\n                // If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified,\n                // dataZoom component auto adopts series that reference to\n                // both xAxis and yAxis which type is 'value'.\n                this.ecModel.eachSeries(function (seriesModel) {\n                    if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) {\n                        eachAxisDim(function (dimNames) {\n                            var axisIndices = thisOption[dimNames.axisIndex];\n\n                            var axisIndex = seriesModel.get(dimNames.axisIndex);\n                            var axisId = seriesModel.get(dimNames.axisId);\n\n                            var axisModel = seriesModel.ecModel.queryComponents({\n                                mainType: dimNames.axis,\n                                index: axisIndex,\n                                id: axisId\n                            })[0];\n\n                            if (__DEV__) {\n                                if (!axisModel) {\n                                    throw new Error(\n                                        dimNames.axis + ' \"' + zrUtil.retrieve(\n                                            axisIndex,\n                                            axisId,\n                                            0\n                                        ) + '\" not found'\n                                    );\n                                }\n                            }\n                            axisIndex = axisModel.componentIndex;\n\n                            if (zrUtil.indexOf(axisIndices, axisIndex) < 0) {\n                                axisIndices.push(axisIndex);\n                            }\n                        });\n                    }\n                }, this);\n            }\n        },\n\n        /**\n         * @private\n         */\n        _autoSetOrient: function () {\n            var dim;\n\n            // Find the first axis\n            this.eachTargetAxis(function (dimNames) {\n                !dim && (dim = dimNames.name);\n            }, this);\n\n            this.option.orient = dim === 'y' ? 'vertical' : 'horizontal';\n        },\n\n        /**\n         * @private\n         */\n        _isSeriesHasAllAxesTypeOf: function (seriesModel, axisType) {\n            // FIXME\n            // seriesxAxisIndexyAxisIndex\n            // series.type === scatter\n\n            var is = true;\n            eachAxisDim(function (dimNames) {\n                var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);\n                var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];\n\n                if (!axisModel || axisModel.get('type') !== axisType) {\n                    is = false;\n                }\n            }, this);\n            return is;\n        },\n\n        /**\n         * @private\n         */\n        _setDefaultThrottle: function (rawOption) {\n            // When first time user set throttle, auto throttle ends.\n            if (rawOption.hasOwnProperty('throttle')) {\n                this._autoThrottle = false;\n            }\n            if (this._autoThrottle) {\n                var globalOption = this.ecModel.option;\n                this.option.throttle =\n                    (globalOption.animation && globalOption.animationDurationUpdate > 0)\n                    ? 100 : 20;\n            }\n        },\n\n        /**\n         * @public\n         */\n        getFirstTargetAxisModel: function () {\n            var firstAxisModel;\n            eachAxisDim(function (dimNames) {\n                if (firstAxisModel == null) {\n                    var indices = this.get(dimNames.axisIndex);\n                    if (indices.length) {\n                        firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];\n                    }\n                }\n            }, this);\n\n            return firstAxisModel;\n        },\n\n        /**\n         * @public\n         * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel\n         */\n        eachTargetAxis: function (callback, context) {\n            var ecModel = this.ecModel;\n            eachAxisDim(function (dimNames) {\n                each(\n                    this.get(dimNames.axisIndex),\n                    function (axisIndex) {\n                        callback.call(context, dimNames, axisIndex, this, ecModel);\n                    },\n                    this\n                );\n            }, this);\n        },\n\n        /**\n         * @param {string} dimName\n         * @param {number} axisIndex\n         * @return {module:echarts/component/dataZoom/AxisProxy} If not found, return null/undefined.\n         */\n        getAxisProxy: function (dimName, axisIndex) {\n            return this._axisProxies[dimName + '_' + axisIndex];\n        },\n\n        /**\n         * @param {string} dimName\n         * @param {number} axisIndex\n         * @return {module:echarts/model/Model} If not found, return null/undefined.\n         */\n        getAxisModel: function (dimName, axisIndex) {\n            var axisProxy = this.getAxisProxy(dimName, axisIndex);\n            return axisProxy && axisProxy.getAxisModel();\n        },\n\n        /**\n         * If not specified, set to undefined.\n         *\n         * @public\n         * @param {Object} opt\n         * @param {number} [opt.start]\n         * @param {number} [opt.end]\n         * @param {number} [opt.startValue]\n         * @param {number} [opt.endValue]\n         * @param {boolean} [ignoreUpdateRangeUsg=false]\n         */\n        setRawRange: function (opt, ignoreUpdateRangeUsg) {\n            each(['start', 'end', 'startValue', 'endValue'], function (name) {\n                // If any of those prop is null/undefined, we should alos set\n                // them, because only one pair between start/end and\n                // startValue/endValue can work.\n                this.option[name] = opt[name];\n            }, this);\n\n            !ignoreUpdateRangeUsg && updateRangeUse(this, opt);\n        },\n\n        /**\n         * @public\n         * @return {Array.<number>} [startPercent, endPercent]\n         */\n        getPercentRange: function () {\n            var axisProxy = this.findRepresentativeAxisProxy();\n            if (axisProxy) {\n                return axisProxy.getDataPercentWindow();\n            }\n        },\n\n        /**\n         * @public\n         * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);\n         *\n         * @param {string} [axisDimName]\n         * @param {number} [axisIndex]\n         * @return {Array.<number>} [startValue, endValue] value can only be '-' or finite number.\n         */\n        getValueRange: function (axisDimName, axisIndex) {\n            if (axisDimName == null && axisIndex == null) {\n                var axisProxy = this.findRepresentativeAxisProxy();\n                if (axisProxy) {\n                    return axisProxy.getDataValueWindow();\n                }\n            }\n            else {\n                return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();\n            }\n        },\n\n        /**\n         * @public\n         * @param {module:echarts/model/Model} [axisModel] If axisModel given, find axisProxy\n         *      corresponding to the axisModel\n         * @return {module:echarts/component/dataZoom/AxisProxy}\n         */\n        findRepresentativeAxisProxy: function (axisModel) {\n            if (axisModel) {\n                return axisModel.__dzAxisProxy;\n            }\n\n            // Find the first hosted axisProxy\n            var axisProxies = this._axisProxies;\n            for (var key in axisProxies) {\n                if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {\n                    return axisProxies[key];\n                }\n            }\n\n            // If no hosted axis find not hosted axisProxy.\n            // Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis,\n            // and the option.start or option.end settings are different. The percentRange\n            // should follow axisProxy.\n            // (We encounter this problem in toolbox data zoom.)\n            for (var key in axisProxies) {\n                if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {\n                    return axisProxies[key];\n                }\n            }\n        },\n\n        /**\n         * @return {Array.<string>}\n         */\n        getRangePropMode: function () {\n            return this._rangePropMode.slice();\n        }\n\n    });\n\n    function retrieveRaw(option) {\n        var ret = {};\n        each(\n            ['start', 'end', 'startValue', 'endValue', 'throttle'],\n            function (name) {\n                option.hasOwnProperty(name) && (ret[name] = option[name]);\n            }\n        );\n        return ret;\n    }\n\n    function updateRangeUse(dataZoomModel, rawOption) {\n        var rangePropMode = dataZoomModel._rangePropMode;\n        var rangeModeInOption = dataZoomModel.get('rangeMode');\n\n        each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n            var percentSpecified = rawOption[names[0]] != null;\n            var valueSpecified = rawOption[names[1]] != null;\n            if (percentSpecified && !valueSpecified) {\n                rangePropMode[index] = 'percent';\n            }\n            else if (!percentSpecified && valueSpecified) {\n                rangePropMode[index] = 'value';\n            }\n            else if (rangeModeInOption) {\n                rangePropMode[index] = rangeModeInOption[index];\n            }\n            else if (percentSpecified) { // percentSpecified && valueSpecified\n                rangePropMode[index] = 'percent';\n            }\n            // else remain its original setting.\n        });\n    }\n\n    module.exports = DataZoomModel;\n\n\n\n/***/ }),\n\n/***/ 1020:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    var formatUtil = __webpack_require__(977);\n    var zrUtil = __webpack_require__(971);\n\n    var helper = {};\n\n    var AXIS_DIMS = ['x', 'y', 'z', 'radius', 'angle', 'single'];\n    // Supported coords.\n    var COORDS = ['cartesian2d', 'polar', 'singleAxis'];\n\n    /**\n     * @param {string} coordType\n     * @return {boolean}\n     */\n    helper.isCoordSupported = function (coordType) {\n        return zrUtil.indexOf(COORDS, coordType) >= 0;\n    };\n\n    /**\n     * Create \"each\" method to iterate names.\n     *\n     * @pubilc\n     * @param  {Array.<string>} names\n     * @param  {Array.<string>=} attrs\n     * @return {Function}\n     */\n    helper.createNameEach = function (names, attrs) {\n        names = names.slice();\n        var capitalNames = zrUtil.map(names, formatUtil.capitalFirst);\n        attrs = (attrs || []).slice();\n        var capitalAttrs = zrUtil.map(attrs, formatUtil.capitalFirst);\n\n        return function (callback, context) {\n            zrUtil.each(names, function (name, index) {\n                var nameObj = {name: name, capital: capitalNames[index]};\n\n                for (var j = 0; j < attrs.length; j++) {\n                    nameObj[attrs[j]] = name + capitalAttrs[j];\n                }\n\n                callback.call(context, nameObj);\n            });\n        };\n    };\n\n    /**\n     * Iterate each dimension name.\n     *\n     * @public\n     * @param {Function} callback The parameter is like:\n     *                            {\n     *                                name: 'angle',\n     *                                capital: 'Angle',\n     *                                axis: 'angleAxis',\n     *                                axisIndex: 'angleAixs',\n     *                                index: 'angleIndex'\n     *                            }\n     * @param {Object} context\n     */\n    helper.eachAxisDim = helper.createNameEach(AXIS_DIMS, ['axisIndex', 'axis', 'index', 'id']);\n\n    /**\n     * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'.\n     * dataZoomModels and 'links' make up one or more graphics.\n     * This function finds the graphic where the source dataZoomModel is in.\n     *\n     * @public\n     * @param {Function} forEachNode Node iterator.\n     * @param {Function} forEachEdgeType edgeType iterator\n     * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id.\n     * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}}\n     */\n    helper.createLinkedNodesFinder = function (forEachNode, forEachEdgeType, edgeIdGetter) {\n\n        return function (sourceNode) {\n            var result = {\n                nodes: [],\n                records: {} // key: edgeType.name, value: Object (key: edge id, value: boolean).\n            };\n\n            forEachEdgeType(function (edgeType) {\n                result.records[edgeType.name] = {};\n            });\n\n            if (!sourceNode) {\n                return result;\n            }\n\n            absorb(sourceNode, result);\n\n            var existsLink;\n            do {\n                existsLink = false;\n                forEachNode(processSingleNode);\n            }\n            while (existsLink);\n\n            function processSingleNode(node) {\n                if (!isNodeAbsorded(node, result) && isLinked(node, result)) {\n                    absorb(node, result);\n                    existsLink = true;\n                }\n            }\n\n            return result;\n        };\n\n        function isNodeAbsorded(node, result) {\n            return zrUtil.indexOf(result.nodes, node) >= 0;\n        }\n\n        function isLinked(node, result) {\n            var hasLink = false;\n            forEachEdgeType(function (edgeType) {\n                zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n                    result.records[edgeType.name][edgeId] && (hasLink = true);\n                });\n            });\n            return hasLink;\n        }\n\n        function absorb(node, result) {\n            result.nodes.push(node);\n            forEachEdgeType(function (edgeType) {\n                zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n                    result.records[edgeType.name][edgeId] = true;\n                });\n            });\n        }\n    };\n\n    module.exports = helper;\n\n\n/***/ }),\n\n/***/ 1021:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var ComponentView = __webpack_require__(1028);\n\n    module.exports = ComponentView.extend({\n\n        type: 'dataZoom',\n\n        render: function (dataZoomModel, ecModel, api, payload) {\n            this.dataZoomModel = dataZoomModel;\n            this.ecModel = ecModel;\n            this.api = api;\n        },\n\n        /**\n         * Find the first target coordinate system.\n         *\n         * @protected\n         * @return {Object} {\n         *                   grid: [\n         *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},\n         *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},\n         *                       ...\n         *                   ],  // cartesians must not be null/undefined.\n         *                   polar: [\n         *                       {model: coord0, axisModels: [axis4], coordIndex: 0},\n         *                       ...\n         *                   ],  // polars must not be null/undefined.\n         *                   singleAxis: [\n         *                       {model: coord0, axisModels: [], coordIndex: 0}\n         *                   ]\n         */\n        getTargetCoordInfo: function () {\n            var dataZoomModel = this.dataZoomModel;\n            var ecModel = this.ecModel;\n            var coordSysLists = {};\n\n            dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n                var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);\n                if (axisModel) {\n                    var coordModel = axisModel.getCoordSysModel();\n                    coordModel && save(\n                        coordModel,\n                        axisModel,\n                        coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []),\n                        coordModel.componentIndex\n                    );\n                }\n            }, this);\n\n            function save(coordModel, axisModel, store, coordIndex) {\n                var item;\n                for (var i = 0; i < store.length; i++) {\n                    if (store[i].model === coordModel) {\n                        item = store[i];\n                        break;\n                    }\n                }\n                if (!item) {\n                    store.push(item = {\n                        model: coordModel, axisModels: [], coordIndex: coordIndex\n                    });\n                }\n                item.axisModels.push(axisModel);\n            }\n\n            return coordSysLists;\n        }\n\n    });\n\n\n\n/***/ }),\n\n/***/ 1022:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var echarts = __webpack_require__(972);\n    var axisPointerModelHelper = __webpack_require__(1005);\n    var axisTrigger = __webpack_require__(1125);\n    var zrUtil = __webpack_require__(971);\n\n    __webpack_require__(1126);\n    __webpack_require__(1127);\n\n    // CartesianAxisPointer is not supposed to be required here. But consider\n    // echarts.simple.js and online build tooltip, which only require gridSimple,\n    // CartesianAxisPointer should be able to required somewhere.\n    __webpack_require__(1050);\n\n    echarts.registerPreprocessor(function (option) {\n        // Always has a global axisPointerModel for default setting.\n        if (option) {\n            (!option.axisPointer || option.axisPointer.length === 0)\n                && (option.axisPointer = {});\n\n            var link = option.axisPointer.link;\n            // Normalize to array to avoid object mergin. But if link\n            // is not set, remain null/undefined, otherwise it will\n            // override existent link setting.\n            if (link && !zrUtil.isArray(link)) {\n                option.axisPointer.link = [link];\n            }\n        }\n    });\n\n    // This process should proformed after coordinate systems created\n    // and series data processed. So put it on statistic processing stage.\n    echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {\n        // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n        // allAxesInfo should be updated when setOption performed.\n        ecModel.getComponent('axisPointer').coordSysAxesInfo\n            = axisPointerModelHelper.collect(ecModel, api);\n    });\n\n    // Broadcast to all views.\n    echarts.registerAction({\n        type: 'updateAxisPointer',\n        event: 'updateAxisPointer',\n        update: ':updateAxisPointer'\n    }, axisTrigger);\n\n\n\n/***/ }),\n\n/***/ 1023:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(971);\n    var graphic = __webpack_require__(973);\n    var textContain = __webpack_require__(985);\n    var formatUtil = __webpack_require__(977);\n    var matrix = __webpack_require__(986);\n    var axisHelper = __webpack_require__(988);\n    var AxisBuilder = __webpack_require__(1013);\n\n    var helper = {};\n\n    /**\n     * @param {module:echarts/model/Model} axisPointerModel\n     */\n    helper.buildElStyle = function (axisPointerModel) {\n        var axisPointerType = axisPointerModel.get('type');\n        var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');\n        var style;\n        if (axisPointerType === 'line') {\n            style = styleModel.getLineStyle();\n            style.fill = null;\n        }\n        else if (axisPointerType === 'shadow') {\n            style = styleModel.getAreaStyle();\n            style.stroke = null;\n        }\n        return style;\n    };\n\n    /**\n     * @param {Function} labelPos {align, verticalAlign, position}\n     */\n    helper.buildLabelElOption = function (\n        elOption, axisModel, axisPointerModel, api, labelPos\n    ) {\n        var value = axisPointerModel.get('value');\n        var text = helper.getValueLabel(\n            value, axisModel.axis, axisModel.ecModel,\n            axisPointerModel.get('seriesDataIndices'),\n            {\n                precision: axisPointerModel.get('label.precision'),\n                formatter: axisPointerModel.get('label.formatter')\n            }\n        );\n        var labelModel = axisPointerModel.getModel('label');\n        var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0);\n\n        var font = labelModel.getFont();\n        var textRect = textContain.getBoundingRect(text, font);\n\n        var position = labelPos.position;\n        var width = textRect.width + paddings[1] + paddings[3];\n        var height = textRect.height + paddings[0] + paddings[2];\n\n        // Adjust by align.\n        var align = labelPos.align;\n        align === 'right' && (position[0] -= width);\n        align === 'center' && (position[0] -= width / 2);\n        var verticalAlign = labelPos.verticalAlign;\n        verticalAlign === 'bottom' && (position[1] -= height);\n        verticalAlign === 'middle' && (position[1] -= height / 2);\n\n        // Not overflow ec container\n        confineInContainer(position, width, height, api);\n\n        var bgColor = labelModel.get('backgroundColor');\n        if (!bgColor || bgColor === 'auto') {\n            bgColor = axisModel.get('axisLine.lineStyle.color');\n        }\n\n        elOption.label = {\n            shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},\n            position: position.slice(),\n            // TODO: rich\n            style: {\n                text: text,\n                textFont: font,\n                textFill: labelModel.getTextColor(),\n                textPosition: 'inside',\n                fill: bgColor,\n                stroke: labelModel.get('borderColor') || 'transparent',\n                lineWidth: labelModel.get('borderWidth') || 0,\n                shadowBlur: labelModel.get('shadowBlur'),\n                shadowColor: labelModel.get('shadowColor'),\n                shadowOffsetX: labelModel.get('shadowOffsetX'),\n                shadowOffsetY: labelModel.get('shadowOffsetY')\n            },\n            // Lable should be over axisPointer.\n            z2: 10\n        };\n    };\n\n    // Do not overflow ec container\n    function confineInContainer(position, width, height, api) {\n        var viewWidth = api.getWidth();\n        var viewHeight = api.getHeight();\n        position[0] = Math.min(position[0] + width, viewWidth) - width;\n        position[1] = Math.min(position[1] + height, viewHeight) - height;\n        position[0] = Math.max(position[0], 0);\n        position[1] = Math.max(position[1], 0);\n    }\n\n    /**\n     * @param {number} value\n     * @param {module:echarts/coord/Axis} axis\n     * @param {module:echarts/model/Global} ecModel\n     * @param {Object} opt\n     * @param {Array.<Object>} seriesDataIndices\n     * @param {number|string} opt.precision 'auto' or a number\n     * @param {string|Function} opt.formatter label formatter\n     */\n    helper.getValueLabel = function (value, axis, ecModel, seriesDataIndices, opt) {\n        var text = axis.scale.getLabel(\n            // If `precision` is set, width can be fixed (like '12.00500'), which\n            // helps to debounce when when moving label.\n            value, {precision: opt.precision}\n        );\n        var formatter = opt.formatter;\n\n        if (formatter) {\n            var params = {\n                value: axisHelper.getAxisRawValue(axis, value),\n                seriesData: []\n            };\n            zrUtil.each(seriesDataIndices, function (idxItem) {\n                var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n                var dataIndex = idxItem.dataIndexInside;\n                var dataParams = series && series.getDataParams(dataIndex);\n                dataParams && params.seriesData.push(dataParams);\n            });\n\n            if (zrUtil.isString(formatter)) {\n                text = formatter.replace('{value}', text);\n            }\n            else if (zrUtil.isFunction(formatter)) {\n                text = formatter(params);\n            }\n        }\n\n        return text;\n    };\n\n    /**\n     * @param {module:echarts/coord/Axis} axis\n     * @param {number} value\n     * @param {Object} layoutInfo {\n     *  rotation, position, labelOffset, labelDirection, labelMargin\n     * }\n     */\n    helper.getTransformedPosition = function (axis, value, layoutInfo) {\n        var transform = matrix.create();\n        matrix.rotate(transform, transform, layoutInfo.rotation);\n        matrix.translate(transform, transform, layoutInfo.position);\n\n        return graphic.applyTransform([\n            axis.dataToCoord(value),\n            (layoutInfo.labelOffset || 0)\n                + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)\n        ], transform);\n    };\n\n    helper.buildCartesianSingleLabelElOption = function (\n        value, elOption, layoutInfo, axisModel, axisPointerModel, api\n    ) {\n        var textLayout = AxisBuilder.innerTextLayout(\n            layoutInfo.rotation, 0, layoutInfo.labelDirection\n        );\n        layoutInfo.labelMargin = axisPointerModel.get('label.margin');\n        helper.buildLabelElOption(elOption, axisModel, axisPointerModel, api, {\n            position: helper.getTransformedPosition(axisModel.axis, value, layoutInfo),\n            align: textLayout.textAlign,\n            verticalAlign: textLayout.textVerticalAlign\n        });\n    };\n\n    /**\n     * @param {Array.<number>} p1\n     * @param {Array.<number>} p2\n     * @param {number} [xDimIndex=0] or 1\n     */\n    helper.makeLineShape = function (p1, p2, xDimIndex) {\n        xDimIndex = xDimIndex || 0;\n        return {\n            x1: p1[xDimIndex],\n            y1: p1[1 - xDimIndex],\n            x2: p2[xDimIndex],\n            y2: p2[1 - xDimIndex]\n        };\n    };\n\n    /**\n     * @param {Array.<number>} xy\n     * @param {Array.<number>} wh\n     * @param {number} [xDimIndex=0] or 1\n     */\n    helper.makeRectShape = function (xy, wh, xDimIndex) {\n        xDimIndex = xDimIndex || 0;\n        return {\n            x: xy[xDimIndex],\n            y: xy[1 - xDimIndex],\n            width: wh[xDimIndex],\n            height: wh[1 - xDimIndex]\n        };\n    };\n\n    helper.makeSectorShape = function (cx, cy, r0, r, startAngle, endAngle) {\n        return {\n            cx: cx,\n            cy: cy,\n            r0: r0,\n            r: r,\n            startAngle: startAngle,\n            endAngle: endAngle,\n            clockwise: true\n        };\n    };\n\n    module.exports = helper;\n\n\n/***/ }),\n\n/***/ 1024:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * \n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\n    var matrix = __webpack_require__(986);\n    var vector = __webpack_require__(976);\n    var mIdentity = matrix.identity;\n\n    var EPSILON = 5e-5;\n\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [0, 0];\n        }\n        if (opts.rotation == null) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [1, 1];\n        }\n        /**\n         * \n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n\n    /**\n     * \n     * , position, rotation, scaletransformtransform\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation)\n            || isNotAroundZero(this.position[0])\n            || isNotAroundZero(this.position[1])\n            || isNotAroundZero(this.scale[0] - 1)\n            || isNotAroundZero(this.scale[1] - 1);\n    };\n\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n\n        m = m || matrix.create();\n\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        }\n        else {\n            mIdentity(m);\n        }\n\n        // \n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            }\n            else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // \n        this.transform = m;\n\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n\n    transformableProto.getLocalTransform = function (m) {\n        return Transformable.getLocalTransform(this, m);\n    };\n\n    /**\n     * transformcontext\n     * @param {CanvasRenderingContext2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {        \n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        }\n        else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n\n    transformableProto.restoreTransform = function (ctx) {\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    };\n\n    var tmpTransform = [];\n\n    /**\n     * `transform``position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [1, 1];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [sx, sy];\n    };\n    /**\n     *  shape \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [x, y];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n\n    /**\n     * \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [x, y];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n\n    /**\n     * @static\n     * @param {Object} target\n     * @param {Array.<number>} target.origin\n     * @param {number} target.rotation\n     * @param {Array.<number>} target.position\n     * @param {Array.<number>} [m]\n     */\n    Transformable.getLocalTransform = function (target, m) {\n        m = m || [];\n        mIdentity(m);\n\n        var origin = target.origin;\n        var scale = target.scale || [1, 1];\n        var rotation = target.rotation || 0;\n        var position = target.position || [0, 0];\n\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n\n        m[4] += position[0];\n        m[5] += position[1];\n\n        return m;\n    };\n\n    module.exports = Transformable;\n\n\n\n/***/ }),\n\n/***/ 1025:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n        var config = __webpack_require__(1000);\n\n        /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-, kener.linfeng@gmail.com)\n         */\n        module.exports = function() {\n            if (config.debugMode === 0) {\n                return;\n            }\n            else if (config.debugMode == 1) {\n                for (var k in arguments) {\n                    throw new Error(arguments[k]);\n                }\n            }\n            else if (config.debugMode > 1) {\n                for (var k in arguments) {\n                    console.log(arguments[k]);\n                }\n            }\n        };\n\n        /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>'\n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n    \n\n\n/***/ }),\n\n/***/ 1026:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var textContain = __webpack_require__(985);\n    var util = __webpack_require__(971);\n    var roundRectHelper = __webpack_require__(1035);\n    var imageHelper = __webpack_require__(1015);\n\n    var retrieve3 = util.retrieve3;\n    var retrieve2 = util.retrieve2;\n\n    // TODO: Have not support 'start', 'end' yet.\n    var VALID_TEXT_ALIGN = {left: 1, right: 1, center: 1};\n    var VALID_TEXT_VERTICAL_ALIGN = {top: 1, bottom: 1, middle: 1};\n\n    var helper = {};\n\n    /**\n     * @param {module:zrender/graphic/Style} style\n     * @return {module:zrender/graphic/Style} The input style.\n     */\n    helper.normalizeTextStyle = function (style) {\n        normalizeStyle(style);\n        util.each(style.rich, normalizeStyle);\n        return style;\n    };\n\n    function normalizeStyle(style) {\n        if (style) {\n\n            style.font = textContain.makeFont(style);\n\n            var textAlign = style.textAlign;\n            textAlign === 'middle' && (textAlign = 'center');\n            style.textAlign = (\n                textAlign == null || VALID_TEXT_ALIGN[textAlign]\n            ) ? textAlign : 'left';\n\n            // Compatible with textBaseline.\n            var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n            textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n            style.textVerticalAlign = (\n                textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign]\n            ) ? textVerticalAlign : 'top';\n\n            var textPadding = style.textPadding;\n            if (textPadding) {\n                style.textPadding = util.normalizeCssArray(style.textPadding);\n            }\n        }\n    }\n\n    /**\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {string} text\n     * @param {module:zrender/graphic/Style} style\n     * @param {Object|boolean} [rect] {x, y, width, height}\n     *                  If set false, rect text is not used.\n     */\n    helper.renderText = function (hostEl, ctx, text, style, rect) {\n        style.rich\n            ? renderRichText(hostEl, ctx, text, style, rect)\n            : renderPlainText(hostEl, ctx, text, style, rect);\n    };\n\n    function renderPlainText(hostEl, ctx, text, style, rect) {\n        var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);\n\n        var textPadding = style.textPadding;\n\n        var contentBlock = hostEl.__textCotentBlock;\n        if (!contentBlock || hostEl.__dirty) {\n            contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(\n                text, font, textPadding, style.truncate\n            );\n        }\n\n        var outerHeight = contentBlock.outerHeight;\n\n        var textLines = contentBlock.lines;\n        var lineHeight = contentBlock.lineHeight;\n\n        var boxPos = getBoxPosition(outerHeight, style, rect);\n        var baseX = boxPos.baseX;\n        var baseY = boxPos.baseY;\n        var textAlign = boxPos.textAlign;\n        var textVerticalAlign = boxPos.textVerticalAlign;\n\n        // Origin of textRotation should be the base point of text drawing.\n        applyTextRotation(ctx, style, rect, baseX, baseY);\n\n        var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n        var textX = baseX;\n        var textY = boxY;\n\n        var needDrawBg = needDrawBackground(style);\n        if (needDrawBg || textPadding) {\n            // Consider performance, do not call getTextWidth util necessary.\n            var textWidth = textContain.getWidth(text, font);\n            var outerWidth = textWidth;\n            textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n            var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n\n            needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n            if (textPadding) {\n                textX = getTextXForPadding(baseX, textAlign, textPadding);\n                textY += textPadding[0];\n            }\n        }\n\n        setCtx(ctx, 'textAlign', textAlign || 'left');\n        // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n        // text will offset downward a little bit in font \"Microsoft YaHei\".\n        setCtx(ctx, 'textBaseline', 'middle');\n\n        // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n        setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);\n        setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');\n        setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);\n        setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0);\n\n        // `textBaseline` is set as 'middle'.\n        textY += lineHeight / 2;\n\n        var textStrokeWidth = style.textStrokeWidth;\n        var textStroke = getStroke(style.textStroke, textStrokeWidth);\n        var textFill = getFill(style.textFill);\n\n        if (textStroke) {\n            setCtx(ctx, 'lineWidth', textStrokeWidth);\n            setCtx(ctx, 'strokeStyle', textStroke);\n        }\n        if (textFill) {\n            setCtx(ctx, 'fillStyle', textFill);\n        }\n\n        for (var i = 0; i < textLines.length; i++) {\n            // Fill after stroke so the outline will not cover the main part.\n            textStroke && ctx.strokeText(textLines[i], textX, textY);\n            textFill && ctx.fillText(textLines[i], textX, textY);\n            textY += lineHeight;\n        }\n    }\n\n    function renderRichText(hostEl, ctx, text, style, rect) {\n        var contentBlock = hostEl.__textCotentBlock;\n\n        if (!contentBlock || hostEl.__dirty) {\n            contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n        }\n\n        drawRichText(hostEl, ctx, contentBlock, style, rect);\n    }\n\n    function drawRichText(hostEl, ctx, contentBlock, style, rect) {\n        var contentWidth = contentBlock.width;\n        var outerWidth = contentBlock.outerWidth;\n        var outerHeight = contentBlock.outerHeight;\n        var textPadding = style.textPadding;\n\n        var boxPos = getBoxPosition(outerHeight, style, rect);\n        var baseX = boxPos.baseX;\n        var baseY = boxPos.baseY;\n        var textAlign = boxPos.textAlign;\n        var textVerticalAlign = boxPos.textVerticalAlign;\n\n        // Origin of textRotation should be the base point of text drawing.\n        applyTextRotation(ctx, style, rect, baseX, baseY);\n\n        var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n        var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n        var xLeft = boxX;\n        var lineTop = boxY;\n        if (textPadding) {\n            xLeft += textPadding[3];\n            lineTop += textPadding[0];\n        }\n        var xRight = xLeft + contentWidth;\n\n        needDrawBackground(style) && drawBackground(\n            hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight\n        );\n\n        for (var i = 0; i < contentBlock.lines.length; i++) {\n            var line = contentBlock.lines[i];\n            var tokens = line.tokens;\n            var tokenCount = tokens.length;\n            var lineHeight = line.lineHeight;\n            var usedWidth = line.width;\n\n            var leftIndex = 0;\n            var lineXLeft = xLeft;\n            var lineXRight = xRight;\n            var rightIndex = tokenCount - 1;\n            var token;\n\n            while (\n                leftIndex < tokenCount\n                && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')\n            ) {\n                placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n                usedWidth -= token.width;\n                lineXLeft += token.width;\n                leftIndex++;\n            }\n\n            while (\n                rightIndex >= 0\n                && (token = tokens[rightIndex], token.textAlign === 'right')\n            ) {\n                placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n                usedWidth -= token.width;\n                lineXRight -= token.width;\n                rightIndex--;\n            }\n\n            // The other tokens are placed as textAlign 'center' if there is enough space.\n            lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n            while (leftIndex <= rightIndex) {\n                token = tokens[leftIndex];\n                // Consider width specified by user, use 'center' rather than 'left'.\n                placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n                lineXLeft += token.width;\n                leftIndex++;\n            }\n\n            lineTop += lineHeight;\n        }\n    }\n\n    function applyTextRotation(ctx, style, rect, x, y) {\n        // textRotation only apply in RectText.\n        if (rect && style.textRotation) {\n            var origin = style.textOrigin;\n            if (origin === 'center') {\n                x = rect.width / 2 + rect.x;\n                y = rect.height / 2 + rect.y;\n            }\n            else if (origin) {\n                x = origin[0] + rect.x;\n                y = origin[1] + rect.y;\n            }\n\n            ctx.translate(x, y);\n            // Positive: anticlockwise\n            ctx.rotate(-style.textRotation);\n            ctx.translate(-x, -y);\n        }\n    }\n\n    function placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n        var tokenStyle = style.rich[token.styleName] || {};\n\n        // 'ctx.textBaseline' is always set as 'middle', for sake of\n        // the bias of \"Microsoft YaHei\".\n        var textVerticalAlign = token.textVerticalAlign;\n        var y = lineTop + lineHeight / 2;\n        if (textVerticalAlign === 'top') {\n            y = lineTop + token.height / 2;\n        }\n        else if (textVerticalAlign === 'bottom') {\n            y = lineTop + lineHeight - token.height / 2;\n        }\n\n        !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(\n            hostEl,\n            ctx,\n            tokenStyle,\n            textAlign === 'right'\n                ? x - token.width\n                : textAlign === 'center'\n                ? x - token.width / 2\n                : x,\n            y - token.height / 2,\n            token.width,\n            token.height\n        );\n\n        var textPadding = token.textPadding;\n        if (textPadding) {\n            x = getTextXForPadding(x, textAlign, textPadding);\n            y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n        }\n\n        setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n        setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n        setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n        setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n\n        setCtx(ctx, 'textAlign', textAlign);\n        // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n        // text will offset downward a little bit in font \"Microsoft YaHei\".\n        setCtx(ctx, 'textBaseline', 'middle');\n\n        setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);\n\n        var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n        var textFill = getFill(tokenStyle.textFill || style.textFill);\n        var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth);\n\n        // Fill after stroke so the outline will not cover the main part.\n        if (textStroke) {\n            setCtx(ctx, 'lineWidth', textStrokeWidth);\n            setCtx(ctx, 'strokeStyle', textStroke);\n            ctx.strokeText(token.text, x, y);\n        }\n        if (textFill) {\n            setCtx(ctx, 'fillStyle', textFill);\n            ctx.fillText(token.text, x, y);\n        }\n    }\n\n    function needDrawBackground(style) {\n        return style.textBackgroundColor\n            || (style.textBorderWidth && style.textBorderColor);\n    }\n\n    // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}\n    // shape: {x, y, width, height}\n    function drawBackground(hostEl, ctx, style, x, y, width, height) {\n        var textBackgroundColor = style.textBackgroundColor;\n        var textBorderWidth = style.textBorderWidth;\n        var textBorderColor = style.textBorderColor;\n        var isPlainBg = util.isString(textBackgroundColor);\n\n        setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n        setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n        setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n        setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\n        if (isPlainBg || (textBorderWidth && textBorderColor)) {\n            ctx.beginPath();\n            var textBorderRadius = style.textBorderRadius;\n            if (!textBorderRadius) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, {\n                    x: x, y: y, width: width, height: height, r: textBorderRadius\n                });\n            }\n            ctx.closePath();\n        }\n\n        if (isPlainBg) {\n            setCtx(ctx, 'fillStyle', textBackgroundColor);\n            ctx.fill();\n        }\n        else if (util.isObject(textBackgroundColor)) {\n            var image = textBackgroundColor.image;\n\n            image = imageHelper.createOrUpdateImage(\n                image, null, hostEl, onBgImageLoaded, textBackgroundColor\n            );\n            if (image && imageHelper.isImageReady(image)) {\n                ctx.drawImage(image, x, y, width, height);\n            }\n        }\n\n        if (textBorderWidth && textBorderColor) {\n            setCtx(ctx, 'lineWidth', textBorderWidth);\n            setCtx(ctx, 'strokeStyle', textBorderColor);\n            ctx.stroke();\n        }\n    }\n\n    function onBgImageLoaded(image, textBackgroundColor) {\n        // Replace image, so that `contain/text.js#parseRichText`\n        // will get correct result in next tick.\n        textBackgroundColor.image = image;\n    }\n\n    function getBoxPosition(blockHeiht, style, rect) {\n        var baseX = style.x || 0;\n        var baseY = style.y || 0;\n        var textAlign = style.textAlign;\n        var textVerticalAlign = style.textVerticalAlign;\n\n        // Text position represented by coord\n        if (rect) {\n            var textPosition = style.textPosition;\n            if (textPosition instanceof Array) {\n                // Percent\n                baseX = rect.x + parsePercent(textPosition[0], rect.width);\n                baseY = rect.y + parsePercent(textPosition[1], rect.height);\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, style.textDistance\n                );\n                baseX = res.x;\n                baseY = res.y;\n                // Default align and baseline when has textPosition\n                textAlign = textAlign || res.textAlign;\n                textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n            }\n\n            // textOffset is only support in RectText, otherwise\n            // we have to adjust boundingRect for textOffset.\n            var textOffset = style.textOffset;\n            if (textOffset) {\n                baseX += textOffset[0];\n                baseY += textOffset[1];\n            }\n        }\n\n        return {\n            baseX: baseX,\n            baseY: baseY,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    }\n\n    function setCtx(ctx, prop, value) {\n        // FIXME ??? performance try\n        // if (ctx.__currentValues[prop] !== value) {\n            // ctx[prop] = ctx.__currentValues[prop] = value;\n        ctx[prop] = value;\n        // }\n        return ctx[prop];\n    }\n\n    /**\n     * @param {string} [stroke] If specified, do not check style.textStroke.\n     * @param {string} [lineWidth] If specified, do not check style.textStroke.\n     * @param {number} style\n     */\n    var getStroke = helper.getStroke = function (stroke, lineWidth) {\n        return (stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none')\n            ? null\n            // TODO pattern and gradient?\n            : (stroke.image || stroke.colorStops)\n            ? '#000'\n            : stroke;\n    };\n\n    var getFill = helper.getFill = function (fill) {\n        return (fill == null || fill === 'none')\n            ? null\n            // TODO pattern and gradient?\n            : (fill.image || fill.colorStops)\n            ? '#000'\n            : fill;\n    };\n\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    function getTextXForPadding(x, textAlign, textPadding) {\n        return textAlign === 'right'\n            ? (x - textPadding[1])\n            : textAlign === 'center'\n            ? (x + textPadding[3] / 2 - textPadding[1] / 2)\n            : (x + textPadding[3]);\n    }\n\n    /**\n     * @param {string} text\n     * @param {module:zrender/Style} style\n     * @return {boolean}\n     */\n    helper.needDrawText = function (text, style) {\n        return text != null\n            && (text\n                || style.textBackgroundColor\n                || (style.textBorderWidth && style.textBorderColor)\n                || style.textPadding\n            );\n    };\n\n    module.exports = helper;\n\n\n\n\n/***/ }),\n\n/***/ 1027:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Image element\n * @module zrender/graphic/Image\n */\n\n\n\n    var Displayable = __webpack_require__(1009);\n    var BoundingRect = __webpack_require__(982);\n    var zrUtil = __webpack_require__(971);\n    var imageHelper = __webpack_require__(1015);\n\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n\n    ZImage.prototype = {\n\n        constructor: ZImage,\n\n        type: 'image',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n\n            var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this);\n\n            if (!image || !imageHelper.isImageReady(image)) {\n                return;\n            }\n\n            // \n            // if (image.nodeName.toUpperCase() == 'IMG') {\n            //     if (!image.complete) {\n            //         return;\n            //     }\n            // }\n            // Else is canvas\n\n            var x = style.x || 0;\n            var y = style.y || 0;\n            var width = style.width;\n            var height = style.height;\n            var aspect = image.width / image.height;\n            if (width == null && height != null) {\n                // Keep image/height ratio\n                width = height * aspect;\n            }\n            else if (height == null && width != null) {\n                height = width / aspect;\n            }\n            else if (width == null && height == null) {\n                width = image.width;\n                height = image.height;\n            }\n\n            // transform\n            this.setTransform(ctx);\n\n            if (style.sWidth && style.sHeight) {\n                var sx = style.sx || 0;\n                var sy = style.sy || 0;\n                ctx.drawImage(\n                    image,\n                    sx, sy, style.sWidth, style.sHeight,\n                    x, y, width, height\n                );\n            }\n            else if (style.sx && style.sy) {\n                var sx = style.sx;\n                var sy = style.sy;\n                var sWidth = width - sx;\n                var sHeight = height - sy;\n                ctx.drawImage(\n                    image,\n                    sx, sy, sWidth, sHeight,\n                    x, y, width, height\n                );\n            }\n            else {\n                ctx.drawImage(image, x, y, width, height);\n            }\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (! this._rect) {\n                this._rect = new BoundingRect(\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n                );\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(ZImage, Displayable);\n\n    module.exports = ZImage;\n\n\n/***/ }),\n\n/***/ 1028:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var Group = __webpack_require__(1001);\n    var componentUtil = __webpack_require__(1016);\n    var clazzUtil = __webpack_require__(984);\n\n    var Component = function () {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewComponent');\n    };\n\n    Component.prototype = {\n\n        constructor: Component,\n\n        init: function (ecModel, api) {},\n\n        render: function (componentModel, ecModel, api, payload) {},\n\n        dispose: function () {}\n\n    };\n\n    var componentProto = Component.prototype;\n    componentProto.updateView\n        = componentProto.updateLayout\n        = componentProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            // Do nothing;\n        };\n    // Enable Component.extend.\n    clazzUtil.enableClassExtend(Component);\n\n    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Component, {registerWhenExtend: true});\n\n    module.exports = Component;\n\n\n/***/ }),\n\n/***/ 1029:\n/***/ (function(module, exports) {\n\n\n\n    /**\n     * Calculate slider move result.\n     * Usage:\n     * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as\n     * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.\n     * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.\n     *\n     * @param {number} delta Move length.\n     * @param {Array.<number>} handleEnds handleEnds[0] can be bigger then handleEnds[1].\n     *              handleEnds will be modified in this method.\n     * @param {Array.<number>} extent handleEnds is restricted by extent.\n     *              extent[0] should less or equals than extent[1].\n     * @param {number|string} handleIndex Can be 'all', means that both move the two handleEnds,\n     *              where the input minSpan and maxSpan will not work.\n     * @param {number} [minSpan] The range of dataZoom can not be smaller than that.\n     *              If not set, handle0 and cross handle1. If set as a non-negative\n     *              number (including `0`), handles will push each other when reaching\n     *              the minSpan.\n     * @param {number} [maxSpan] The range of dataZoom can not be larger than that.\n     * @return {Array.<number>} The input handleEnds.\n     */\n    module.exports = function (delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {\n        // Normalize firstly.\n        handleEnds[0] = restrict(handleEnds[0], extent);\n        handleEnds[1] = restrict(handleEnds[1], extent);\n\n        delta = delta || 0;\n\n        var extentSpan = extent[1] - extent[0];\n\n        // Notice maxSpan and minSpan can be null/undefined.\n        if (minSpan != null) {\n            minSpan = restrict(minSpan, [0, extentSpan]);\n        }\n        if (maxSpan != null) {\n            maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);\n        }\n        if (handleIndex === 'all') {\n            minSpan = maxSpan = Math.abs(handleEnds[1] - handleEnds[0]);\n            handleIndex = 0;\n        }\n\n        var originalDistSign = getSpanSign(handleEnds, handleIndex);\n\n        handleEnds[handleIndex] += delta;\n\n        // Restrict in extent.\n        var extentMinSpan = minSpan || 0;\n        var realExtent = extent.slice();\n        originalDistSign.sign < 0 ? (realExtent[0] += extentMinSpan) : (realExtent[1] -= extentMinSpan);\n        handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent);\n\n        // Expand span.\n        var currDistSign = getSpanSign(handleEnds, handleIndex);\n        if (minSpan != null && (\n            currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan\n        )) {\n            // If minSpan exists, 'cross' is forbinden.\n            handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;\n        }\n\n        // Shrink span.\n        var currDistSign = getSpanSign(handleEnds, handleIndex);\n        if (maxSpan != null && currDistSign.span > maxSpan) {\n            handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;\n        }\n\n        return handleEnds;\n    };\n\n    function getSpanSign(handleEnds, handleIndex) {\n        var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex];\n        // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]\n        // is at left of handleEnds[1] for non-cross case.\n        return {span: Math.abs(dist), sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1};\n    }\n\n    function restrict(value, extend) {\n        return Math.min(extend[1], Math.max(extend[0], value));\n    }\n\n\n/***/ }),\n\n/***/ 1030:\n/***/ (function(module, exports) {\n\n// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function () {\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n\n        this._len = 0;\n    };\n\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function (val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function (entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        }\n        else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            entry.next = null;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function (entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        }\n        else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        }\n        else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function () {\n        return this._len;\n    };\n\n    /**\n     * Clear list\n     */\n    linkedListProto.clear = function () {\n        this.head = this.tail = null;\n        this._len = 0;\n    };\n\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function (val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function (maxSize) {\n\n        this._list = new LinkedList();\n\n        this._map = {};\n\n        this._maxSize = maxSize || 10;\n\n        this._lastRemovedEntry = null;\n    };\n\n    var LRUProto = LRU.prototype;\n\n    /**\n     * @param  {string} key\n     * @param  {} value\n     * @return {} Removed value\n     */\n    LRUProto.put = function (key, value) {\n        var list = this._list;\n        var map = this._map;\n        var removed = null;\n        if (map[key] == null) {\n            var len = list.len();\n            // Reuse last removed entry\n            var entry = this._lastRemovedEntry;\n\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n\n                removed = leastUsedEntry.value;\n                this._lastRemovedEntry = leastUsedEntry;\n            }\n\n            if (entry) {\n                entry.value = value;\n            }\n            else {\n                entry = new Entry(value);\n            }\n            entry.key = key;\n            list.insertEntry(entry);\n            map[key] = entry;\n        }\n\n        return removed;\n    };\n\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function (key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n\n            return entry.value;\n        }\n    };\n\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function () {\n        this._list.clear();\n        this._map = {};\n    };\n\n    module.exports = LRU;\n\n\n/***/ }),\n\n/***/ 1031:\n/***/ (function(module, exports) {\n\n/**\n * @module zrender/graphic/Style\n */\n\n\n    var STYLE_COMMON_PROPS = [\n        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n    ];\n\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\n    var Style = function (opts, host) {\n        this.extendFrom(opts, false);\n        this.host = host;\n    };\n\n    function createLinearGradient(ctx, obj, rect) {\n        var x = obj.x == null ? 0 : obj.x;\n        var x2 = obj.x2 == null ? 1 : obj.x2;\n        var y = obj.y == null ? 0 : obj.y;\n        var y2 = obj.y2 == null ? 0 : obj.y2;\n\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n        return canvasGradient;\n    }\n\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n\n        var x = obj.x == null ? 0.5 : obj.x;\n        var y = obj.y == null ? 0.5 : obj.y;\n        var r = obj.r == null ? 0.5 : obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n        return canvasGradient;\n    }\n\n\n    Style.prototype = {\n\n        constructor: Style,\n\n        /**\n         * @type {module:zrender/graphic/Displayable}\n         */\n        host: null,\n\n        /**\n         * @type {string}\n         */\n        fill: '#000',\n\n        /**\n         * @type {string}\n         */\n        stroke: null,\n\n        /**\n         * @type {number}\n         */\n        opacity: 1,\n\n        /**\n         * @type {Array.<number>}\n         */\n        lineDash: null,\n\n        /**\n         * @type {number}\n         */\n        lineDashOffset: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetY: 0,\n\n        /**\n         * @type {number}\n         */\n        lineWidth: 1,\n\n        /**\n         * If stroke ignore scale\n         * @type {Boolean}\n         */\n        strokeNoScale: false,\n\n        // Bounding rect text configuration\n        // Not affected by element transform\n        /**\n         * @type {string}\n         */\n        text: null,\n\n        /**\n         * If `fontSize` or `fontFamily` exists, `font` will be reset by\n         * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.\n         * So do not visit it directly in upper application (like echarts),\n         * but use `contain/text#makeFont` instead.\n         * @type {string}\n         */\n        font: null,\n\n        /**\n         * The same as font. Use font please.\n         * @deprecated\n         * @type {string}\n         */\n        textFont: null,\n\n        /**\n         * It helps merging respectively, rather than parsing an entire font string.\n         * @type {string}\n         */\n        fontStyle: null,\n\n        /**\n         * It helps merging respectively, rather than parsing an entire font string.\n         * @type {string}\n         */\n        fontWeight: null,\n\n        /**\n         * It helps merging respectively, rather than parsing an entire font string.\n         * Should be 12 but not '12px'.\n         * @type {number}\n         */\n        fontSize: null,\n\n        /**\n         * It helps merging respectively, rather than parsing an entire font string.\n         * @type {string}\n         */\n        fontFamily: null,\n\n        /**\n         * Reserved for special functinality, like 'hr'.\n         * @type {string}\n         */\n        textTag: null,\n\n        /**\n         * @type {string}\n         */\n        textFill: '#000',\n\n        /**\n         * @type {string}\n         */\n        textStroke: null,\n\n        /**\n         * @type {number}\n         */\n        textWidth: null,\n\n        /**\n         * Only for textBackground.\n         * @type {number}\n         */\n        textHeight: null,\n\n        /**\n         * textStroke may be set as some color as a default\n         * value in upper applicaion, where the default value\n         * of textStrokeWidth should be 0 to make sure that\n         * user can choose to do not use text stroke.\n         * @type {number}\n         */\n        textStrokeWidth: 0,\n\n        /**\n         * @type {number}\n         */\n        textLineHeight: null,\n\n        /**\n         * 'inside', 'left', 'right', 'top', 'bottom'\n         * [x, y]\n         * Based on x, y of rect.\n         * @type {string|Array.<number>}\n         * @default 'inside'\n         */\n        textPosition: 'inside',\n\n        /**\n         * If not specified, use the boundingRect of a `displayable`.\n         * @type {Object}\n         */\n        textRect: null,\n\n        /**\n         * [x, y]\n         * @type {Array.<number>}\n         */\n        textOffset: null,\n\n        /**\n         * @type {string}\n         */\n        textAlign: null,\n\n        /**\n         * @type {string}\n         */\n        textVerticalAlign: null,\n\n        /**\n         * @type {number}\n         */\n        textDistance: 5,\n\n        /**\n         * @type {string}\n         */\n        textShadowColor: 'transparent',\n\n        /**\n         * @type {number}\n         */\n        textShadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        textShadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        textShadowOffsetY: 0,\n\n        /**\n         * @type {string}\n         */\n        textBoxShadowColor: 'transparent',\n\n        /**\n         * @type {number}\n         */\n        textBoxShadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        textBoxShadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        textBoxShadowOffsetY: 0,\n\n        /**\n         * Whether transform text.\n         * Only useful in Path and Image element\n         * @type {boolean}\n         */\n        transformText: false,\n\n        /**\n         * Text rotate around position of Path or Image\n         * Only useful in Path and Image element and transformText is false.\n         */\n        textRotation: 0,\n\n        /**\n         * Text origin of text rotation, like [10, 40].\n         * Based on x, y of rect.\n         * Useful in label rotation of circular symbol.\n         * By default, this origin is textPosition.\n         * Can be 'center'.\n         * @type {string|Array.<number>}\n         */\n        textOrigin: null,\n\n        /**\n         * @type {string}\n         */\n        textBackgroundColor: null,\n\n        /**\n         * @type {string}\n         */\n        textBorderColor: null,\n\n        /**\n         * @type {number}\n         */\n        textBorderWidth: 0,\n\n        /**\n         * @type {number}\n         */\n        textBorderRadius: 0,\n\n        /**\n         * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`\n         * @type {number|Array.<number>}\n         */\n        textPadding: null,\n\n        /**\n         * Text styles for rich text.\n         * @type {Object}\n         */\n        rich: null,\n\n        /**\n         * {outerWidth, outerHeight, ellipsis, placeholder}\n         * @type {Object}\n         */\n        truncate: null,\n\n        /**\n         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n         * @type {string}\n         */\n        blend: null,\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n\n            if ((firstDraw || style.fill !== prevStyle.fill)) {\n                ctx.fillStyle = style.fill;\n            }\n            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n\n            if ((firstDraw || style.blend !== prevStyle.blend)) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (\n                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n                );\n            }\n        },\n\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n\n        /**\n         * Extend from other style\n         * @param {zrender/graphic/Style} otherStyle\n         * @param {boolean} overwrite true: overwrirte any way.\n         *                            false: overwrite only when !target.hasOwnProperty\n         *                            others: overwrite when property is not null/undefined.\n         */\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name)\n                        && (overwrite === true\n                            || (\n                                overwrite === false\n                                    ? !this.hasOwnProperty(name)\n                                    : otherStyle[name] != null\n                            )\n                        )\n                    ) {\n                        this[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Batch setting style with a given object\n         * @param {Object|string} obj\n         * @param {*} [obj]\n         */\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            }\n            else {\n                this.extendFrom(obj, true);\n            }\n        },\n\n        /**\n         * Clone\n         * @return {zrender/graphic/Style} [description]\n         */\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\n            return canvasGradient;\n        }\n\n    };\n\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n\n    module.exports = Style;\n\n\n/***/ }),\n\n/***/ 1032:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @module zrender/Element\n */\n\n\n    var guid = __webpack_require__(1033);\n    var Eventful = __webpack_require__(992);\n    var Transformable = __webpack_require__(1024);\n    var Animatable = __webpack_require__(1084);\n    var zrUtil = __webpack_require__(971);\n\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n\n        /**\n         * ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n\n    Element.prototype = {\n\n        /**\n         * \n         * Element type\n         * @type {string}\n         */\n        type: 'element',\n\n        /**\n         * \n         * Element name\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * ZRender  element  zrender \n         * ZRender instance will be assigned when element is associated with zrender\n         * @name module:/zrender/Element#__zr\n         * @type {module:zrender/ZRender}\n         */\n        __zr: null,\n\n        /**\n         * true\n         * If ignore drawing and events of the element object\n         * @name module:/zrender/Element#ignore\n         * @type {boolean}\n         * @default false\n         */\n        ignore: false,\n\n        /**\n         * (shape) Group \n         * \n         * @type {module:zrender/graphic/Path}\n         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n         * @readOnly\n         */\n        clipPath: null,\n\n        /**\n         * Drift element\n         * @param  {number} dx dx on the global space\n         * @param  {number} dy dy on the global space\n         */\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n\n        /**\n         * Hook before update\n         */\n        beforeUpdate: function () {},\n        /**\n         * Hook after update\n         */\n        afterUpdate: function () {},\n        /**\n         * Update each frame\n         */\n        update: function () {\n            this.updateTransform();\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {},\n\n        /**\n         * @protected\n         */\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            }\n            else {\n                this[key] = value;\n            }\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * Show the element\n         */\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * @param {string|Object} key\n         * @param {*} value\n         */\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            }\n            else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n\n            this.dirty(false);\n\n            return this;\n        },\n\n        /**\n         * @param {module:zrender/graphic/Path} clipPath\n         */\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n\n            this.dirty(false);\n        },\n\n        /**\n         */\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n\n                this.dirty(false);\n            }\n        },\n\n        /**\n         * Add self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n\n        /**\n         * Remove self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n\n    module.exports = Element;\n\n\n/***/ }),\n\n/***/ 1033:\n/***/ (function(module, exports) {\n\n/**\n * zrender: id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\n\n    var idStart = 0x0907;\n\n    module.exports = function () {\n        return idStart++;\n    };\n\n\n\n/***/ }),\n\n/***/ 1034:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module echarts/animation/Animator\n */\n\n\n    var Clip = __webpack_require__(1085);\n    var color = __webpack_require__(993);\n    var util = __webpack_require__(971);\n    var isArrayLike = util.isArrayLike;\n\n    var arraySlice = Array.prototype.slice;\n\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        }\n        else {\n            var len2 = len && p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(\n                        p0[i][j], p1[i][j], percent\n                    );\n                }\n            }\n        }\n    }\n\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            }\n            else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(\n                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                    );\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            }\n            else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        }\n        else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(\n        p0, p1, p2, p3, t, t2, t3, out, arrDim\n    ) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(\n                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n                );\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(\n                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                        t, t2, t3\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n\n            return arraySlice.call(value);\n        }\n\n        return value;\n    }\n\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n\n    function getArrayDim(keyframes) {\n        var lastValue = keyframes[keyframes.length - 1].value;\n        return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n    }\n\n    function createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n\n        // For vertices morphing\n        var arrDim = isValueArray ? getArrayDim(keyframes) : 0;\n\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function(a, b) {\n            return a.time - b.time;\n        });\n\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n\n            // Check if value is equal, deep check if value is array\n            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n                || (!isValueArray && value === prevValue))) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                }\n                else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (!forceAnimate && isAllValueEqual) {\n            return;\n        }\n\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            }\n            else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n\n        if (isValueColor) {\n            var rgba = [0, 0, 0, 0];\n        }\n\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            }\n            else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            }\n            else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n\n            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n            if (range === 0) {\n                return;\n            }\n            else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(\n                            p0, p1, p2, p3, w, w * w, w * w * w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    }\n                    else {\n                        value = catmullRomInterpolate(\n                            p0, p1, p2, p3, w, w * w, w * w * w\n                        );\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n            else {\n                if (isValueArray) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(\n                            kfValues[frame], kfValues[frame + 1], w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n        };\n\n        var clip = new Clip({\n            target: animator._target,\n            life: trackMaxTime,\n            loop: animator._loop,\n            delay: animator._delay,\n            onframe: onframe,\n            ondestroy: oneTrackDone\n        });\n\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n\n        return clip;\n    }\n\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function(target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n\n        this._loop = loop || false;\n\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n\n        this._clipCount = 0;\n\n        this._delay = 0;\n\n        this._doneList = [];\n\n        this._onframeList = [];\n\n        this._clipList = [];\n    };\n\n    Animator.prototype = {\n        /**\n         * \n         * @param  {number} time ms\n         * @param  {Object} props key-value\n         * @return {module:zrender/animation/Animator}\n         */\n        when: function(time /* ms */, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} callback\n         * @return {module:zrender/animation/Animator}\n         */\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n\n        pause: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].pause();\n            }\n            this._paused = true;\n        },\n\n        resume: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].resume();\n            }\n            this._paused = false;\n        },\n\n        isPaused: function () {\n            return !!this._paused;\n        },\n\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        /**\n         * \n         * @param  {string|Function} [easing]\n         *         {@link module:zrender/animation/easing}\n         * @param  {boolean} forceAnimate\n         * @return {module:zrender/animation/Animator}\n         */\n        start: function (easing, forceAnimate) {\n\n            var self = this;\n            var clipCount = 0;\n\n            var oneTrackDone = function() {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n\n            var lastClip;\n            for (var propName in this._tracks) {\n                if (!this._tracks.hasOwnProperty(propName)) {\n                    continue;\n                }\n                var clip = createTrackClip(\n                    this, easing, oneTrackDone,\n                    this._tracks[propName], propName, forceAnimate\n                );\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n\n                    lastClip = clip;\n                }\n            }\n\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n\n            // This optimization will help the case that in the upper application\n            // the view may be refreshed frequently, where animation will be\n            // called repeatly but nothing changed.\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        /**\n         * \n         * @param  {number} time ms\n         * @return {module:zrender/animation/Animator}\n         */\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} cb\n         * @return {module:zrender/animation/Animator}\n         */\n        done: function(cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n\n        /**\n         * @return {Array.<module:zrender/animation/Clip>}\n         */\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n\n    module.exports = Animator;\n\n\n/***/ }),\n\n/***/ 1035:\n/***/ (function(module, exports) {\n\n\n\n    module.exports = {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            }\n            else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                }\n                else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                }\n                else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                }\n                else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            }\n            else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(\n                x + width, y, x + width, y + r2\n            );\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(\n                x + width, y + height, x + width - r3, y + height\n            );\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(\n                x, y + height, x, y + height - r4\n            );\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n\n\n/***/ }),\n\n/***/ 1036:\n/***/ (function(module, exports) {\n\n\n\n    var PI2 = Math.PI * 2;\n    module.exports = {\n        normalizeRadian: function(angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n\n\n/***/ }),\n\n/***/ 1037:\n/***/ (function(module, exports) {\n\n\n\n    var Pattern = function (image, repeat) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {image: ...}`, where this constructor will not be called.\n\n        this.image = image;\n        this.repeat = repeat;\n\n        // Can be cloned\n        this.type = 'pattern';\n    };\n\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n        return ctx.createPattern(this.image, this.repeat || 'repeat');\n    };\n\n    module.exports = Pattern;\n\n\n/***/ }),\n\n/***/ 1038:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var smoothSpline = __webpack_require__(1095);\n    var smoothBezier = __webpack_require__(1096);\n\n    module.exports = {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(\n                        points, smooth, closePath, shape.smoothConstraint\n                    );\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                        );\n                    }\n                }\n                else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n\n                closePath && ctx.closePath();\n            }\n        }\n    };\n\n\n/***/ }),\n\n/***/ 1039:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var classUtil = __webpack_require__(984);\n    var set = classUtil.set;\n    var get = classUtil.get;\n\n    module.exports = {\n        clearColorPalette: function () {\n            set(this, 'colorIdx', 0);\n            set(this, 'colorNameMap', {});\n        },\n\n        getColorFromPalette: function (name, scope) {\n            scope = scope || this;\n            var colorIdx = get(scope, 'colorIdx') || 0;\n            var colorNameMap = get(scope, 'colorNameMap') || set(scope, 'colorNameMap', {});\n            // Use `hasOwnProperty` to avoid conflict with Object.prototype.\n            if (colorNameMap.hasOwnProperty(name)) {\n                return colorNameMap[name];\n            }\n            var colorPalette = this.get('color', true) || [];\n            if (!colorPalette.length) {\n                return;\n            }\n\n            var color = colorPalette[colorIdx];\n            if (name) {\n                colorNameMap[name] = color;\n            }\n            set(scope, 'colorIdx', (colorIdx + 1) % colorPalette.length);\n\n            return color;\n        }\n    };\n\n\n/***/ }),\n\n/***/ 1040:\n/***/ (function(module, exports) {\n\n\n\n    module.exports = (typeof window !== 'undefined' &&\n                ((window.requestAnimationFrame && window.requestAnimationFrame.bind(window))\n                // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809\n                || (window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window))\n                || window.mozRequestAnimationFrame\n                || window.webkitRequestAnimationFrame)\n            )\n            || function (func) {\n                setTimeout(func, 16);\n            };\n\n\n\n/***/ }),\n\n/***/ 1041:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * For testable.\n */\n\n\n    var numberUtil = __webpack_require__(974);\n\n    var roundNumber = numberUtil.round;\n\n    var helper = {};\n\n    /**\n     * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.\n     *                                Should be extent[0] < extent[1].\n     * @param {number} splitNumber splitNumber should be >= 1.\n     * @param {number} [minInterval]\n     * @param {number} [maxInterval]\n     * @return {Object} {interval, intervalPrecision, niceTickExtent}\n     */\n    helper.intervalScaleNiceTicks = function (extent, splitNumber, minInterval, maxInterval) {\n        var result = {};\n        var span = extent[1] - extent[0];\n\n        var interval = result.interval = numberUtil.nice(span / splitNumber, true);\n        if (minInterval != null && interval < minInterval) {\n            interval = result.interval = minInterval;\n        }\n        if (maxInterval != null && interval > maxInterval) {\n            interval = result.interval = maxInterval;\n        }\n        // Tow more digital for tick.\n        var precision = result.intervalPrecision = helper.getIntervalPrecision(interval);\n        // Niced extent inside original extent\n        var niceTickExtent = result.niceTickExtent = [\n            roundNumber(Math.ceil(extent[0] / interval) * interval, precision),\n            roundNumber(Math.floor(extent[1] / interval) * interval, precision)\n        ];\n\n        helper.fixExtent(niceTickExtent, extent);\n\n        return result;\n    };\n\n    /**\n     * @param {number} interval\n     * @return {number} interval precision\n     */\n    helper.getIntervalPrecision = function (interval) {\n        // Tow more digital for tick.\n        return numberUtil.getPrecisionSafe(interval) + 2;\n    };\n\n    function clamp(niceTickExtent, idx, extent) {\n        niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);\n    }\n\n    // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.\n    helper.fixExtent = function (niceTickExtent, extent) {\n        !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);\n        !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);\n        clamp(niceTickExtent, 0, extent);\n        clamp(niceTickExtent, 1, extent);\n        if (niceTickExtent[0] > niceTickExtent[1]) {\n            niceTickExtent[0] = niceTickExtent[1];\n        }\n    };\n\n    helper.intervalScaleGetTicks = function (interval, extent, niceTickExtent, intervalPrecision) {\n        var ticks = [];\n\n        // If interval is 0, return [];\n        if (!interval) {\n            return ticks;\n        }\n\n        // Consider this case: using dataZoom toolbox, zoom and zoom.\n        var safeLimit = 10000;\n\n        if (extent[0] < niceTickExtent[0]) {\n            ticks.push(extent[0]);\n        }\n        var tick = niceTickExtent[0];\n\n        while (tick <= niceTickExtent[1]) {\n            ticks.push(tick);\n            // Avoid rounding error\n            tick = roundNumber(tick + interval, intervalPrecision);\n            if (tick === ticks[ticks.length - 1]) {\n                // Consider out of safe float point, e.g.,\n                // -3711126.9907707 + 2e-10 === -3711126.9907707\n                break;\n            }\n            if (ticks.length > safeLimit) {\n                return [];\n            }\n        }\n        // Consider this case: the last item of ticks is smaller\n        // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n        if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1])) {\n            ticks.push(extent[1]);\n        }\n\n        return ticks;\n    };\n\n    module.exports = helper;\n\n\n/***/ }),\n\n/***/ 1042:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(971);\n    var modelUtil = __webpack_require__(975);\n\n    /**\n     * @param {Object} finder contains {seriesIndex, dataIndex, dataIndexInside}\n     * @param {module:echarts/model/Global} ecModel\n     * @return {Object} {point: [x, y], el: ...} point Will not be null.\n     */\n    module.exports = function (finder, ecModel) {\n        var point = [];\n        var seriesIndex = finder.seriesIndex;\n        var seriesModel;\n        if (seriesIndex == null || !(\n            seriesModel = ecModel.getSeriesByIndex(seriesIndex)\n        )) {\n            return {point: []};\n        }\n\n        var data = seriesModel.getData();\n        var dataIndex = modelUtil.queryDataIndex(data, finder);\n        if (dataIndex == null || zrUtil.isArray(dataIndex)) {\n            return {point: []};\n        }\n\n        var el = data.getItemGraphicEl(dataIndex);\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (seriesModel.getTooltipPosition) {\n            point = seriesModel.getTooltipPosition(dataIndex) || [];\n        }\n        else if (coordSys && coordSys.dataToPoint) {\n            point = coordSys.dataToPoint(\n                data.getValues(\n                    zrUtil.map(coordSys.dimensions, function (dim) {\n                        return seriesModel.coordDimToDataDim(dim)[0];\n                    }), dataIndex, true\n                )\n            ) || [];\n        }\n        else if (el) {\n            // Use graphic bounding rect\n            var rect = el.getBoundingRect().clone();\n            rect.applyTransform(el.transform);\n            point = [\n                rect.x + rect.width / 2,\n                rect.y + rect.height / 2\n            ];\n        }\n\n        return {point: point, el: el};\n    };\n\n\n\n\n/***/ }),\n\n/***/ 1043:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var env = __webpack_require__(978);\n    var zrUtil = __webpack_require__(971);\n    var get = __webpack_require__(975).makeGetter();\n\n    var each = zrUtil.each;\n\n    var globalListener = {};\n\n    /**\n     * @param {string} key\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Function} handler\n     *      param: {string} currTrigger\n     *      param: {Array.<number>} point\n     */\n    globalListener.register = function (key, api, handler) {\n        if (env.node) {\n            return;\n        }\n\n        var zr = api.getZr();\n        get(zr).records || (get(zr).records = {});\n\n        initGlobalListeners(zr, api);\n\n        var record = get(zr).records[key] || (get(zr).records[key] = {});\n        record.handler = handler;\n    };\n\n    function initGlobalListeners(zr, api) {\n        if (get(zr).initialized) {\n            return;\n        }\n\n        get(zr).initialized = true;\n\n        useHandler('click', zrUtil.curry(doEnter, 'click'));\n        useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove'));\n        // useHandler('mouseout', onLeave);\n        useHandler('globalout', onLeave);\n\n        function useHandler(eventType, cb) {\n            zr.on(eventType, function (e) {\n                var dis = makeDispatchAction(api);\n\n                each(get(zr).records, function (record) {\n                    record && cb(record, e, dis.dispatchAction);\n                });\n\n                dispatchTooltipFinally(dis.pendings, api);\n            });\n        }\n    }\n\n    function dispatchTooltipFinally(pendings, api) {\n        var showLen = pendings.showTip.length;\n        var hideLen = pendings.hideTip.length;\n\n        var actuallyPayload;\n        if (showLen) {\n            actuallyPayload = pendings.showTip[showLen - 1];\n        }\n        else if (hideLen) {\n            actuallyPayload = pendings.hideTip[hideLen - 1];\n        }\n        if (actuallyPayload) {\n            actuallyPayload.dispatchAction = null;\n            api.dispatchAction(actuallyPayload);\n        }\n    }\n\n    function onLeave(record, e, dispatchAction) {\n        record.handler('leave', null, dispatchAction);\n    }\n\n    function doEnter(currTrigger, record, e, dispatchAction) {\n        record.handler(currTrigger, e, dispatchAction);\n    }\n\n    function makeDispatchAction(api) {\n        var pendings = {\n            showTip: [],\n            hideTip: []\n        };\n        // FIXME\n        // better approach?\n        // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,\n        // which may be conflict, (axisPointer call showTip but tooltip call hideTip);\n        // So we have to add \"final stage\" to merge those dispatched actions.\n        var dispatchAction = function (payload) {\n            var pendingList = pendings[payload.type];\n            if (pendingList) {\n                pendingList.push(payload);\n            }\n            else {\n                payload.dispatchAction = dispatchAction;\n                api.dispatchAction(payload);\n            }\n        };\n\n        return {\n            dispatchAction: dispatchAction,\n            pendings: pendings\n        };\n    }\n\n    /**\n     * @param {string} key\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    globalListener.unregister = function (key, api) {\n        if (env.node) {\n            return;\n        }\n        var zr = api.getZr();\n        var record = (get(zr).records || {})[key];\n        if (record) {\n            get(zr).records[key] = null;\n        }\n    };\n\n    module.exports = globalListener;\n\n\n/***/ }),\n\n/***/ 1044:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    // List layout\n    var layout = __webpack_require__(981);\n    var formatUtil = __webpack_require__(977);\n    var graphic = __webpack_require__(973);\n\n    module.exports = {\n        /**\n         * Layout list like component.\n         * It will box layout each items in group of component and then position the whole group in the viewport\n         * @param {module:zrender/group/Group} group\n         * @param {module:echarts/model/Component} componentModel\n         * @param {module:echarts/ExtensionAPI}\n         */\n        layout: function (group, componentModel, api) {\n            var boxLayoutParams = componentModel.getBoxLayoutParams();\n            var padding = componentModel.get('padding');\n            var viewportSize = {width: api.getWidth(), height: api.getHeight()};\n\n            var rect = layout.getLayoutRect(\n                boxLayoutParams,\n                viewportSize,\n                padding\n            );\n\n            layout.box(\n                componentModel.get('orient'),\n                group,\n                componentModel.get('itemGap'),\n                rect.width,\n                rect.height\n            );\n\n            layout.positionElement(\n                group,\n                boxLayoutParams,\n                viewportSize,\n                padding\n            );\n        },\n\n        makeBackground: function (rect, componentModel) {\n            var padding = formatUtil.normalizeCssArray(\n                componentModel.get('padding')\n            );\n            var style = componentModel.getItemStyle(['color', 'opacity']);\n            style.fill = componentModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                shape: {\n                    x: rect.x - padding[3],\n                    y: rect.y - padding[0],\n                    width: rect.width + padding[1] + padding[3],\n                    height: rect.height + padding[0] + padding[2],\n                    r: componentModel.get('borderRadius')\n                },\n                style: style,\n                silent: true,\n                z2: -1\n            });\n            // FIXME\n            // `subPixelOptimizeRect` may bring some gap between edge of viewpart\n            // and background rect when setting like `left: 0`, `top: 0`.\n            // graphic.subPixelOptimizeRect(rect);\n\n            return rect;\n        }\n    };\n\n\n/***/ }),\n\n/***/ 1045:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @file History manager.\n */\n\n\n    var zrUtil = __webpack_require__(971);\n    var each = zrUtil.each;\n\n    var ATTR = '\\0_ec_hist_store';\n\n    var history = {\n\n        /**\n         * @public\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Object} newSnapshot {dataZoomId, batch: [payloadInfo, ...]}\n         */\n        push: function (ecModel, newSnapshot) {\n            var store = giveStore(ecModel);\n\n            // If previous dataZoom can not be found,\n            // complete an range with current range.\n            each(newSnapshot, function (batchItem, dataZoomId) {\n                var i = store.length - 1;\n                for (; i >= 0; i--) {\n                    var snapshot = store[i];\n                    if (snapshot[dataZoomId]) {\n                        break;\n                    }\n                }\n                if (i < 0) {\n                    // No origin range set, create one by current range.\n                    var dataZoomModel = ecModel.queryComponents(\n                        {mainType: 'dataZoom', subType: 'select', id: dataZoomId}\n                    )[0];\n                    if (dataZoomModel) {\n                        var percentRange = dataZoomModel.getPercentRange();\n                        store[0][dataZoomId] = {\n                            dataZoomId: dataZoomId,\n                            start: percentRange[0],\n                            end: percentRange[1]\n                        };\n                    }\n                }\n            });\n\n            store.push(newSnapshot);\n        },\n\n        /**\n         * @public\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Object} snapshot\n         */\n        pop: function (ecModel) {\n            var store = giveStore(ecModel);\n            var head = store[store.length - 1];\n            store.length > 1 && store.pop();\n\n            // Find top for all dataZoom.\n            var snapshot = {};\n            each(head, function (batchItem, dataZoomId) {\n                for (var i = store.length - 1; i >= 0; i--) {\n                    var batchItem = store[i][dataZoomId];\n                    if (batchItem) {\n                        snapshot[dataZoomId] = batchItem;\n                        break;\n                    }\n                }\n            });\n\n            return snapshot;\n        },\n\n        /**\n         * @public\n         */\n        clear: function (ecModel) {\n            ecModel[ATTR] = null;\n        },\n\n        /**\n         * @public\n         * @param {module:echarts/model/Global} ecModel\n         * @return {number} records. always >= 1.\n         */\n        count: function (ecModel) {\n            return giveStore(ecModel).length;\n        }\n\n    };\n\n    /**\n     * [{key: dataZoomId, value: {dataZoomId, range}}, ...]\n     * History length of each dataZoom may be different.\n     * this._history[0] is used to store origin range.\n     * @type {Array.<Object>}\n     */\n    function giveStore(ecModel) {\n        var store = ecModel[ATTR];\n        if (!store) {\n            store = ecModel[ATTR] = [{}];\n        }\n        return store;\n    }\n\n    module.exports = history;\n\n\n\n/***/ }),\n\n/***/ 1048:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\n\n    var vec2 = __webpack_require__(976);\n    var curve = __webpack_require__(991);\n\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n\n    var PI2 = Math.PI * 2;\n    /**\n     * `min``max`\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points \n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n\n    var xDim = [];\n    var yDim = [];\n    /**\n     * (p0, p1, p2, p3)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function(\n        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n    ) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n\n    /**\n     * (p0, p1, p2)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx =\n            mathMax(\n                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n            );\n        var ty =\n            mathMax(\n                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n            );\n\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n\n    /**\n     * `min``max`\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (\n        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n    ) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n\n        var diff = Math.abs(startAngle - endAngle);\n\n\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n\n    module.exports = bbox;\n\n\n\n/***/ }),\n\n/***/ 1049:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var env = __webpack_require__(978);\n\n    // Fix weird bug in some version of IE11 (like 11.0.9600.178**),\n    // where exception \"unexpected call to method or property access\"\n    // might be thrown when calling ctx.fill or ctx.stroke after a path\n    // whose area size is zero is drawn and ctx.clip() is called and\n    // shadowBlur is set. See #4572, #3112, #5777.\n    // (e.g.,\n    //  ctx.moveTo(10, 10);\n    //  ctx.lineTo(20, 10);\n    //  ctx.closePath();\n    //  ctx.clip();\n    //  ctx.shadowBlur = 10;\n    //  ...\n    //  ctx.fill();\n    // )\n\n    var shadowTemp = [\n        ['shadowBlur', 0],\n        ['shadowColor', '#000'],\n        ['shadowOffsetX', 0],\n        ['shadowOffsetY', 0]\n    ];\n\n    module.exports = function (orignalBrush) {\n\n        // version string can be: '11.0'\n        return (env.browser.ie && env.browser.version >= 11)\n\n            ? function () {\n                var clipPaths = this.__clipPaths;\n                var style = this.style;\n                var modified;\n\n                if (clipPaths) {\n                    for (var i = 0; i < clipPaths.length; i++) {\n                        var clipPath = clipPaths[i];\n                        var shape = clipPath && clipPath.shape;\n                        var type = clipPath && clipPath.type;\n\n                        if (shape && (\n                            (type === 'sector' && shape.startAngle === shape.endAngle)\n                            || (type === 'rect' && (!shape.width || !shape.height))\n                        )) {\n                            for (var j = 0; j < shadowTemp.length; j++) {\n                                // It is save to put shadowTemp static, because shadowTemp\n                                // will be all modified each item brush called.\n                                shadowTemp[j][2] = style[shadowTemp[j][0]];\n                                style[shadowTemp[j][0]] = shadowTemp[j][1];\n                            }\n                            modified = true;\n                            break;\n                        }\n                    }\n                }\n\n                orignalBrush.apply(this, arguments);\n\n                if (modified) {\n                    for (var j = 0; j < shadowTemp.length; j++) {\n                        style[shadowTemp[j][0]] = shadowTemp[j][2];\n                    }\n                }\n            }\n\n            : orignalBrush;\n    };\n\n\n\n/***/ }),\n\n/***/ 1050:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var graphic = __webpack_require__(973);\n    var BaseAxisPointer = __webpack_require__(1051);\n    var viewHelper = __webpack_require__(1023);\n    var cartesianAxisHelper = __webpack_require__(1052);\n    var AxisView = __webpack_require__(1014);\n\n    var CartesianAxisPointer = BaseAxisPointer.extend({\n\n        /**\n         * @override\n         */\n        makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n            var axis = axisModel.axis;\n            var grid = axis.grid;\n            var axisPointerType = axisPointerModel.get('type');\n            var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n            var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));\n\n            if (axisPointerType && axisPointerType !== 'none') {\n                var elStyle = viewHelper.buildElStyle(axisPointerModel);\n                var pointerOption = pointerShapeBuilder[axisPointerType](\n                    axis, pixelValue, otherExtent, elStyle\n                );\n                pointerOption.style = elStyle;\n                elOption.graphicKey = pointerOption.type;\n                elOption.pointer = pointerOption;\n            }\n\n            var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);\n            viewHelper.buildCartesianSingleLabelElOption(\n                value, elOption, layoutInfo, axisModel, axisPointerModel, api\n            );\n        },\n\n        /**\n         * @override\n         */\n        getHandleTransform: function (value, axisModel, axisPointerModel) {\n            var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {\n                labelInside: false\n            });\n            layoutInfo.labelMargin = axisPointerModel.get('handle.margin');\n            return {\n                position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),\n                rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)\n            };\n        },\n\n        /**\n         * @override\n         */\n        updateHandleTransform: function (transform, delta, axisModel, axisPointerModel) {\n            var axis = axisModel.axis;\n            var grid = axis.grid;\n            var axisExtent = axis.getGlobalExtent(true);\n            var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n            var dimIndex = axis.dim === 'x' ? 0 : 1;\n\n            var currPosition = transform.position;\n            currPosition[dimIndex] += delta[dimIndex];\n            currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);\n            currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);\n\n            var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;\n            var cursorPoint = [cursorOtherValue, cursorOtherValue];\n            cursorPoint[dimIndex] = currPosition[dimIndex];\n\n            // Make tooltip do not overlap axisPointer and in the middle of the grid.\n            var tooltipOptions = [{verticalAlign: 'middle'}, {align: 'center'}];\n\n            return {\n                position: currPosition,\n                rotation: transform.rotation,\n                cursorPoint: cursorPoint,\n                tooltipOption: tooltipOptions[dimIndex]\n            };\n        }\n\n    });\n\n    function getCartesian(grid, axis) {\n        var opt = {};\n        opt[axis.dim + 'AxisIndex'] = axis.index;\n        return grid.getCartesian(opt);\n    }\n\n    var pointerShapeBuilder = {\n\n        line: function (axis, pixelValue, otherExtent, elStyle) {\n            var targetShape = viewHelper.makeLineShape(\n                [pixelValue, otherExtent[0]],\n                [pixelValue, otherExtent[1]],\n                getAxisDimIndex(axis)\n            );\n            graphic.subPixelOptimizeLine({\n                shape: targetShape,\n                style: elStyle\n            });\n            return {\n                type: 'Line',\n                shape: targetShape\n            };\n        },\n\n        shadow: function (axis, pixelValue, otherExtent, elStyle) {\n            var bandWidth = axis.getBandWidth();\n            var span = otherExtent[1] - otherExtent[0];\n            return {\n                type: 'Rect',\n                shape: viewHelper.makeRectShape(\n                    [pixelValue - bandWidth / 2, otherExtent[0]],\n                    [bandWidth, span],\n                    getAxisDimIndex(axis)\n                )\n            };\n        }\n    };\n\n    function getAxisDimIndex(axis) {\n        return axis.dim === 'x' ? 0 : 1;\n    }\n\n    AxisView.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);\n\n    module.exports = CartesianAxisPointer;\n\n\n/***/ }),\n\n/***/ 1051:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(971);\n    var clazzUtil = __webpack_require__(984);\n    var graphic = __webpack_require__(973);\n    var get = __webpack_require__(975).makeGetter();\n    var axisPointerModelHelper = __webpack_require__(1005);\n    var eventTool = __webpack_require__(990);\n    var throttle = __webpack_require__(1011);\n\n    var clone = zrUtil.clone;\n    var bind = zrUtil.bind;\n\n    /**\n     * Base axis pointer class in 2D.\n     * Implemenents {module:echarts/component/axis/IAxisPointer}.\n     */\n    function BaseAxisPointer () {\n    }\n\n    BaseAxisPointer.prototype = {\n\n        /**\n         * @private\n         */\n        _group: null,\n\n        /**\n         * @private\n         */\n        _lastGraphicKey: null,\n\n        /**\n         * @private\n         */\n        _handle: null,\n\n        /**\n         * @private\n         */\n        _dragging: false,\n\n        /**\n         * @private\n         */\n        _lastValue: null,\n\n        /**\n         * @private\n         */\n        _lastStatus: null,\n\n        /**\n         * @private\n         */\n        _payloadInfo: null,\n\n        /**\n         * In px, arbitrary value. Do not set too small,\n         * no animation is ok for most cases.\n         * @protected\n         */\n        animationThreshold: 15,\n\n        /**\n         * @implement\n         */\n        render: function (axisModel, axisPointerModel, api, forceRender) {\n            var value = axisPointerModel.get('value');\n            var status = axisPointerModel.get('status');\n\n            // Bind them to `this`, not in closure, otherwise they will not\n            // be replaced when user calling setOption in not merge mode.\n            this._axisModel = axisModel;\n            this._axisPointerModel = axisPointerModel;\n            this._api = api;\n\n            // Optimize: `render` will be called repeatly during mouse move.\n            // So it is power consuming if performing `render` each time,\n            // especially on mobile device.\n            if (!forceRender\n                && this._lastValue === value\n                && this._lastStatus === status\n            ) {\n                return;\n            }\n            this._lastValue = value;\n            this._lastStatus = status;\n\n            var group = this._group;\n            var handle = this._handle;\n\n            if (!status || status === 'hide') {\n                // Do not clear here, for animation better.\n                group && group.hide();\n                handle && handle.hide();\n                return;\n            }\n            group && group.show();\n            handle && handle.show();\n\n            // Otherwise status is 'show'\n            var elOption = {};\n            this.makeElOption(elOption, value, axisModel, axisPointerModel, api);\n\n            // Enable change axis pointer type.\n            var graphicKey = elOption.graphicKey;\n            if (graphicKey !== this._lastGraphicKey) {\n                this.clear(api);\n            }\n            this._lastGraphicKey = graphicKey;\n\n            var moveAnimation = this._moveAnimation =\n                this.determineAnimation(axisModel, axisPointerModel);\n\n            if (!group) {\n                group = this._group = new graphic.Group();\n                this.createPointerEl(group, elOption, axisModel, axisPointerModel);\n                this.createLabelEl(group, elOption, axisModel, axisPointerModel);\n                api.getZr().add(group);\n            }\n            else {\n                var doUpdateProps = zrUtil.curry(updateProps, axisPointerModel, moveAnimation);\n                this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);\n                this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);\n            }\n\n            updateMandatoryProps(group, axisPointerModel, true);\n\n            this._renderHandle(value);\n        },\n\n        /**\n         * @implement\n         */\n        remove: function (api) {\n            this.clear(api);\n        },\n\n        /**\n         * @implement\n         */\n        dispose: function (api) {\n            this.clear(api);\n        },\n\n        /**\n         * @protected\n         */\n        determineAnimation: function (axisModel, axisPointerModel) {\n            var animation = axisPointerModel.get('animation');\n            var axis = axisModel.axis;\n            var isCategoryAxis = axis.type === 'category';\n            var useSnap = axisPointerModel.get('snap');\n\n            // Value axis without snap always do not snap.\n            if (!useSnap && !isCategoryAxis) {\n                return false;\n            }\n\n            if (animation === 'auto' || animation == null) {\n                var animationThreshold = this.animationThreshold;\n                if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {\n                    return true;\n                }\n\n                // It is important to auto animation when snap used. Consider if there is\n                // a dataZoom, animation will be disabled when too many points exist, while\n                // it will be enabled for better visual effect when little points exist.\n                if (useSnap) {\n                    var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount;\n                    var axisExtent = axis.getExtent();\n                    // Approximate band width\n                    return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;\n                }\n\n                return false;\n            }\n\n            return animation === true;\n        },\n\n        /**\n         * add {pointer, label, graphicKey} to elOption\n         * @protected\n         */\n        makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n            // Shoule be implemenented by sub-class.\n        },\n\n        /**\n         * @protected\n         */\n        createPointerEl: function (group, elOption, axisModel, axisPointerModel) {\n            var pointerOption = elOption.pointer;\n            if (pointerOption) {\n                var pointerEl = get(group).pointerEl = new graphic[pointerOption.type](\n                    clone(elOption.pointer)\n                );\n                group.add(pointerEl);\n            }\n        },\n\n        /**\n         * @protected\n         */\n        createLabelEl: function (group, elOption, axisModel, axisPointerModel) {\n            if (elOption.label) {\n                var labelEl = get(group).labelEl = new graphic.Rect(\n                    clone(elOption.label)\n                );\n\n                group.add(labelEl);\n                updateLabelShowHide(labelEl, axisPointerModel);\n            }\n        },\n\n        /**\n         * @protected\n         */\n        updatePointerEl: function (group, elOption, updateProps) {\n            var pointerEl = get(group).pointerEl;\n            if (pointerEl) {\n                pointerEl.setStyle(elOption.pointer.style);\n                updateProps(pointerEl, {shape: elOption.pointer.shape});\n            }\n        },\n\n        /**\n         * @protected\n         */\n        updateLabelEl: function (group, elOption, updateProps, axisPointerModel) {\n            var labelEl = get(group).labelEl;\n            if (labelEl) {\n                labelEl.setStyle(elOption.label.style);\n                updateProps(labelEl, {\n                    // Consider text length change in vertical axis, animation should\n                    // be used on shape, otherwise the effect will be weird.\n                    shape: elOption.label.shape,\n                    position: elOption.label.position\n                });\n\n                updateLabelShowHide(labelEl, axisPointerModel);\n            }\n        },\n\n        /**\n         * @private\n         */\n        _renderHandle: function (value) {\n            if (this._dragging || !this.updateHandleTransform) {\n                return;\n            }\n\n            var axisPointerModel = this._axisPointerModel;\n            var zr = this._api.getZr();\n            var handle = this._handle;\n            var handleModel = axisPointerModel.getModel('handle');\n\n            var status = axisPointerModel.get('status');\n            if (!handleModel.get('show') || !status || status === 'hide') {\n                handle && zr.remove(handle);\n                this._handle = null;\n                return;\n            }\n\n            var isInit;\n            if (!this._handle) {\n                isInit = true;\n                handle = this._handle = graphic.createIcon(\n                    handleModel.get('icon'), \n                    {\n                        cursor: 'move',\n                        draggable: true,\n                        onmousemove: function (e) {\n                            // Fot mobile devicem, prevent screen slider on the button.\n                            eventTool.stop(e.event);\n                        },\n                        onmousedown: bind(this._onHandleDragMove, this, 0, 0),\n                        drift: bind(this._onHandleDragMove, this),\n                        ondragend: bind(this._onHandleDragEnd, this)\n                    }\n                );\n                zr.add(handle);\n            }\n\n            updateMandatoryProps(handle, axisPointerModel, false);\n\n            // update style\n            var includeStyles = [\n                'color', 'borderColor', 'borderWidth', 'opacity',\n                'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'\n            ];\n            handle.setStyle(handleModel.getItemStyle(null, includeStyles));\n\n            // update position\n            var handleSize = handleModel.get('size');\n            if (!zrUtil.isArray(handleSize)) {\n                handleSize = [handleSize, handleSize];\n            }\n            handle.attr('scale', [handleSize[0] / 2, handleSize[1] / 2]);\n\n            throttle.createOrUpdate(\n                this,\n                '_doDispatchAxisPointer',\n                handleModel.get('throttle') || 0,\n                'fixRate'\n            );\n\n            this._moveHandleToValue(value, isInit);\n        },\n\n        /**\n         * @private\n         */\n        _moveHandleToValue: function (value, isInit) {\n            updateProps(\n                this._axisPointerModel,\n                !isInit && this._moveAnimation,\n                this._handle,\n                getHandleTransProps(this.getHandleTransform(\n                    value, this._axisModel, this._axisPointerModel\n                ))\n            );\n        },\n\n        /**\n         * @private\n         */\n        _onHandleDragMove: function (dx, dy) {\n            var handle = this._handle;\n            if (!handle) {\n                return;\n            }\n\n            this._dragging = true;\n\n            // Persistent for throttle.\n            var trans = this.updateHandleTransform(\n                getHandleTransProps(handle),\n                [dx, dy],\n                this._axisModel,\n                this._axisPointerModel\n            );\n            this._payloadInfo = trans;\n\n            handle.stopAnimation();\n            handle.attr(getHandleTransProps(trans));\n            get(handle).lastProp = null;\n\n            this._doDispatchAxisPointer();\n        },\n\n        /**\n         * Throttled method.\n         * @private\n         */\n        _doDispatchAxisPointer: function () {\n            var handle = this._handle;\n            if (!handle) {\n                return;\n            }\n\n            var payloadInfo = this._payloadInfo;\n            var axisModel = this._axisModel;\n            this._api.dispatchAction({\n                type: 'updateAxisPointer',\n                x: payloadInfo.cursorPoint[0],\n                y: payloadInfo.cursorPoint[1],\n                tooltipOption: payloadInfo.tooltipOption,\n                axesInfo: [{\n                    axisDim: axisModel.axis.dim,\n                    axisIndex: axisModel.componentIndex\n                }]\n            });\n        },\n\n        /**\n         * @private\n         */\n        _onHandleDragEnd: function (moveAnimation) {\n            this._dragging = false;\n            var handle = this._handle;\n            if (!handle) {\n                return;\n            }\n\n            var value = this._axisPointerModel.get('value');\n            // Consider snap or categroy axis, handle may be not consistent with\n            // axisPointer. So move handle to align the exact value position when\n            // drag ended.\n            this._moveHandleToValue(value);\n\n            // For the effect: tooltip will be shown when finger holding on handle\n            // button, and will be hidden after finger left handle button.\n            this._api.dispatchAction({\n                type: 'hideTip'\n            });\n        },\n\n        /**\n         * Should be implemenented by sub-class if support `handle`.\n         * @protected\n         * @param {number} value\n         * @param {module:echarts/model/Model} axisModel\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @return {Object} {position: [x, y], rotation: 0}\n         */\n        getHandleTransform: null,\n\n        /**\n         * * Should be implemenented by sub-class if support `handle`.\n         * @protected\n         * @param {Object} transform {position, rotation}\n         * @param {Array.<number>} delta [dx, dy]\n         * @param {module:echarts/model/Model} axisModel\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}\n         */\n        updateHandleTransform: null,\n\n        /**\n         * @private\n         */\n        clear: function (api) {\n            this._lastValue = null;\n            this._lastStatus = null;\n\n            var zr = api.getZr();\n            var group = this._group;\n            var handle = this._handle;\n            if (zr && group) {\n                this._lastGraphicKey = null;\n                group && zr.remove(group);\n                handle && zr.remove(handle);\n                this._group = null;\n                this._handle = null;\n                this._payloadInfo = null;\n            }\n        },\n\n        /**\n         * @protected\n         */\n        doClear: function () {\n            // Implemented by sub-class if necessary.\n        },\n\n        /**\n         * @protected\n         * @param {Array.<number>} xy\n         * @param {Array.<number>} wh\n         * @param {number} [xDimIndex=0] or 1\n         */\n        buildLabel: function (xy, wh, xDimIndex) {\n            xDimIndex = xDimIndex || 0;\n            return {\n                x: xy[xDimIndex],\n                y: xy[1 - xDimIndex],\n                width: wh[xDimIndex],\n                height: wh[1 - xDimIndex]\n            };\n        }\n    };\n\n    BaseAxisPointer.prototype.constructor = BaseAxisPointer;\n\n\n    function updateProps(animationModel, moveAnimation, el, props) {\n        // Animation optimize.\n        if (!propsEqual(get(el).lastProp, props)) {\n            get(el).lastProp = props;\n            moveAnimation\n                ? graphic.updateProps(el, props, animationModel)\n                : (el.stopAnimation(), el.attr(props));\n        }\n    }\n\n    function propsEqual(lastProps, newProps) {\n        if (zrUtil.isObject(lastProps) && zrUtil.isObject(newProps)) {\n            var equals = true;\n            zrUtil.each(newProps, function (item, key) {\n                equals = equals && propsEqual(lastProps[key], item);\n            });\n            return !!equals;\n        }\n        else {\n            return lastProps === newProps;\n        }\n    }\n\n    function updateLabelShowHide(labelEl, axisPointerModel) {\n        labelEl[axisPointerModel.get('label.show') ? 'show' : 'hide']();\n    }\n\n    function getHandleTransProps(trans) {\n        return {\n            position: trans.position.slice(),\n            rotation: trans.rotation || 0\n        };\n    }\n\n    function updateMandatoryProps(group, axisPointerModel, silent) {\n        var z = axisPointerModel.get('z');\n        var zlevel = axisPointerModel.get('zlevel');\n\n        group && group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n                el.silent = silent;\n            }\n        });\n    }\n\n    clazzUtil.enableClassExtend(BaseAxisPointer);\n\n    module.exports = BaseAxisPointer;\n\n\n/***/ }),\n\n/***/ 1052:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(971);\n\n    var helper = {};\n\n    /**\n     * @param {Object} opt {labelInside}\n     * @return {Object} {\n     *  position, rotation, labelDirection, labelOffset,\n     *  tickDirection, labelRotate, labelInterval, z2\n     * }\n     */\n    helper.layout = function (gridModel, axisModel, opt) {\n        opt = opt || {};\n        var grid = gridModel.coordinateSystem;\n        var axis = axisModel.axis;\n        var layout = {};\n\n        var rawAxisPosition = axis.position;\n        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n        var axisDim = axis.dim;\n\n        var rect = grid.getRect();\n        var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n        var idx = {left: 0, right: 1, top: 0, bottom: 1, onZero: 2};\n        var axisOffset = axisModel.get('offset') || 0;\n\n        var posBound = axisDim === 'x'\n            ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset]\n            : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];\n\n        if (axis.onZero) {\n            var otherAxis = grid.getAxis(axisDim === 'x' ? 'y' : 'x', axis.onZeroAxisIndex);\n            var onZeroCoord = otherAxis.toGlobalCoord(otherAxis.dataToCoord(0));\n            posBound[idx['onZero']] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);\n        }\n\n        // Axis position\n        layout.position = [\n            axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0],\n            axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3]\n        ];\n\n        // Axis rotation\n        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n\n        // Tick and label direction, x y is axisDim\n        var dirMap = {top: -1, bottom: 1, left: -1, right: 1};\n\n        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n        layout.labelOffset = axis.onZero ? posBound[idx[rawAxisPosition]] - posBound[idx['onZero']] : 0;\n\n        if (axisModel.get('axisTick.inside')) {\n            layout.tickDirection = -layout.tickDirection;\n        }\n        if (zrUtil.retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) {\n            layout.labelDirection = -layout.labelDirection;\n        }\n\n        // Special label rotation\n        var labelRotate = axisModel.get('axisLabel.rotate');\n        layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate;\n\n        // label interval when auto mode.\n        layout.labelInterval = axis.getLabelInterval();\n\n        // Over splitLine and splitArea\n        layout.z2 = 1;\n\n        return layout;\n    };\n\n    module.exports = helper;\n\n\n\n/***/ }),\n\n/***/ 1053:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(971);\n    var Model = __webpack_require__(979);\n\n    var LegendModel = __webpack_require__(972).extendComponentModel({\n\n        type: 'legend.plain',\n\n        dependencies: ['series'],\n\n        layoutMode: {\n            type: 'box',\n            // legend.width/height are maxWidth/maxHeight actually,\n            // whereas realy width/height is calculated by its content.\n            // (Setting {left: 10, right: 10} does not make sense).\n            // So consider the case:\n            // `setOption({legend: {left: 10});`\n            // then `setOption({legend: {right: 10});`\n            // The previous `left` should be cleared by setting `ignoreSize`.\n            ignoreSize: true\n        },\n\n        init: function (option, parentModel, ecModel) {\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            option.selected = option.selected || {};\n        },\n\n        mergeOption: function (option) {\n            LegendModel.superCall(this, 'mergeOption', option);\n        },\n\n        optionUpdated: function () {\n            this._updateData(this.ecModel);\n\n            var legendData = this._data;\n\n            // If selectedMode is single, try to select one\n            if (legendData[0] && this.get('selectedMode') === 'single') {\n                var hasSelected = false;\n                // If has any selected in option.selected\n                for (var i = 0; i < legendData.length; i++) {\n                    var name = legendData[i].get('name');\n                    if (this.isSelected(name)) {\n                        // Force to unselect others\n                        this.select(name);\n                        hasSelected = true;\n                        break;\n                    }\n                }\n                // Try select the first if selectedMode is single\n                !hasSelected && this.select(legendData[0].get('name'));\n            }\n        },\n\n        _updateData: function (ecModel) {\n            var legendData = zrUtil.map(this.get('data') || [], function (dataItem) {\n                // Can be string or number\n                if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n                    dataItem = {\n                        name: dataItem\n                    };\n                }\n                return new Model(dataItem, this, this.ecModel);\n            }, this);\n            this._data = legendData;\n\n            var availableNames = zrUtil.map(ecModel.getSeries(), function (series) {\n                return series.name;\n            });\n            ecModel.eachSeries(function (seriesModel) {\n                if (seriesModel.legendDataProvider) {\n                    var data = seriesModel.legendDataProvider();\n                    availableNames = availableNames.concat(data.mapArray(data.getName));\n                }\n            });\n            /**\n             * @type {Array.<string>}\n             * @private\n             */\n            this._availableNames = availableNames;\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Model>}\n         */\n        getData: function () {\n            return this._data;\n        },\n\n        /**\n         * @param {string} name\n         */\n        select: function (name) {\n            var selected = this.option.selected;\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                var data = this._data;\n                zrUtil.each(data, function (dataItem) {\n                    selected[dataItem.get('name')] = false;\n                });\n            }\n            selected[name] = true;\n        },\n\n        /**\n         * @param {string} name\n         */\n        unSelect: function (name) {\n            if (this.get('selectedMode') !== 'single') {\n                this.option.selected[name] = false;\n            }\n        },\n\n        /**\n         * @param {string} name\n         */\n        toggleSelected: function (name) {\n            var selected = this.option.selected;\n            // Default is true\n            if (!selected.hasOwnProperty(name)) {\n                selected[name] = true;\n            }\n            this[selected[name] ? 'unSelect' : 'select'](name);\n        },\n\n        /**\n         * @param {string} name\n         */\n        isSelected: function (name) {\n            var selected = this.option.selected;\n            return !(selected.hasOwnProperty(name) && !selected[name])\n                && zrUtil.indexOf(this._availableNames, name) >= 0;\n        },\n\n        defaultOption: {\n            // \n            zlevel: 0,\n            // \n            z: 4,\n            show: true,\n\n            // \n            // 'horizontal' | 'vertical'\n            orient: 'horizontal',\n\n            left: 'center',\n            // right: 'center',\n\n            top: 0,\n            // bottom: null,\n\n            // \n            // 'auto' | 'left' | 'right'\n            //  'auto',  x \n            align: 'auto',\n\n            backgroundColor: 'rgba(0,0,0,0)',\n            // \n            borderColor: '#ccc',\n            borderRadius: 0,\n            // px0\n            borderWidth: 0,\n            // px5\n            // css\n            padding: 5,\n            // itempx10\n            // \n            itemGap: 10,\n            // \n            itemWidth: 25,\n            // \n            itemHeight: 14,\n\n            // \n            inactiveColor: '#ccc',\n\n            textStyle: {\n                // \n                color: '#333'\n            },\n            // formatter: '',\n            // \n            selectedMode: true,\n            // LEGEND.SELECTED\n            // selected: null,\n            // legend.dataitem\n            // data: [],\n\n            // Tooltip \n            tooltip: {\n                show: false\n            }\n        }\n    });\n\n    module.exports = LegendModel;\n\n\n/***/ }),\n\n/***/ 1054:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(971);\n    var symbolCreator = __webpack_require__(996);\n    var graphic = __webpack_require__(973);\n    var listComponentHelper = __webpack_require__(1044);\n    var layoutUtil = __webpack_require__(981);\n\n    var curry = zrUtil.curry;\n    var each = zrUtil.each;\n    var Group = graphic.Group;\n\n    module.exports = __webpack_require__(972).extendComponentView({\n\n        type: 'legend.plain',\n\n        newlineDisabled: false,\n\n        /**\n         * @override\n         */\n        init: function () {\n\n            /**\n             * @private\n             * @type {module:zrender/container/Group}\n             */\n            this.group.add(this._contentGroup = new Group());\n\n            /**\n             * @private\n             * @type {module:zrender/Element}\n             */\n            this._backgroundEl;\n        },\n\n        /**\n         * @protected\n         */\n        getContentGroup: function () {\n            return this._contentGroup;\n        },\n\n        /**\n         * @override\n         */\n        render: function (legendModel, ecModel, api) {\n\n            this.resetInner();\n\n            if (!legendModel.get('show', true)) {\n                return;\n            }\n\n            var itemAlign = legendModel.get('align');\n            if (!itemAlign || itemAlign === 'auto') {\n                itemAlign = (\n                    legendModel.get('left') === 'right'\n                    && legendModel.get('orient') === 'vertical'\n                ) ? 'right' : 'left';\n            }\n\n            this.renderInner(itemAlign, legendModel, ecModel, api);\n\n            // Perform layout.\n            var positionInfo = legendModel.getBoxLayoutParams();\n            var viewportSize = {width: api.getWidth(), height: api.getHeight()};\n            var padding = legendModel.get('padding');\n\n            var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding);\n            var mainRect = this.layoutInner(legendModel, itemAlign, maxSize);\n\n            // Place mainGroup, based on the calculated `mainRect`.\n            var layoutRect = layoutUtil.getLayoutRect(\n                zrUtil.defaults({width: mainRect.width, height: mainRect.height}, positionInfo),\n                viewportSize,\n                padding\n            );\n            this.group.attr('position', [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]);\n\n            // Render background after group is layout.\n            this.group.add(\n                this._backgroundEl = listComponentHelper.makeBackground(mainRect, legendModel)\n            );\n        },\n\n        /**\n         * @protected\n         */\n        resetInner: function () {\n            this.getContentGroup().removeAll();\n            this._backgroundEl && this.group.remove(this._backgroundEl);\n        },\n\n        /**\n         * @protected\n         */\n        renderInner: function (itemAlign, legendModel, ecModel, api) {\n            var contentGroup = this.getContentGroup();\n            var legendDrawnMap = zrUtil.createHashMap();\n            var selectMode = legendModel.get('selectedMode');\n\n            each(legendModel.getData(), function (itemModel, dataIndex) {\n                var name = itemModel.get('name');\n\n                // Use empty string or \\n as a newline string\n                if (!this.newlineDisabled && (name === '' || name === '\\n')) {\n                    contentGroup.add(new Group({\n                        newline: true\n                    }));\n                    return;\n                }\n\n                var seriesModel = ecModel.getSeriesByName(name)[0];\n\n                if (legendDrawnMap.get(name)) {\n                    // Have been drawed\n                    return;\n                }\n\n                // Series legend\n                if (seriesModel) {\n                    var data = seriesModel.getData();\n                    var color = data.getVisual('color');\n\n                    // If color is a callback function\n                    if (typeof color === 'function') {\n                        // Use the first data\n                        color = color(seriesModel.getDataParams(0));\n                    }\n\n                    // Using rect symbol defaultly\n                    var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n                    var symbolType = data.getVisual('symbol');\n\n                    var itemGroup = this._createItem(\n                        name, dataIndex, itemModel, legendModel,\n                        legendSymbolType, symbolType,\n                        itemAlign, color,\n                        selectMode\n                    );\n\n                    itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                        .on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api))\n                        .on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n\n                    legendDrawnMap.set(name, true);\n                }\n                else {\n                    // Data legend of pie, funnel\n                    ecModel.eachRawSeries(function (seriesModel) {\n                        // In case multiple series has same data name\n                        if (legendDrawnMap.get(name)) {\n                            return;\n                        }\n                        if (seriesModel.legendDataProvider) {\n                            var data = seriesModel.legendDataProvider();\n                            var idx = data.indexOfName(name);\n                            if (idx < 0) {\n                                return;\n                            }\n\n                            var color = data.getItemVisual(idx, 'color');\n\n                            var legendSymbolType = 'roundRect';\n\n                            var itemGroup = this._createItem(\n                                name, dataIndex, itemModel, legendModel,\n                                legendSymbolType, null,\n                                itemAlign, color,\n                                selectMode\n                            );\n\n                            itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                                // FIXME Should not specify the series name\n                                .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api))\n                                .on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n\n                            legendDrawnMap.set(name, true);\n                        }\n                    }, this);\n                }\n\n                if (__DEV__) {\n                    if (!legendDrawnMap.get(name)) {\n                        console.warn(name + ' series not exists. Legend data should be same with series name or data name.');\n                    }\n                }\n            }, this);\n        },\n\n        _createItem: function (\n            name, dataIndex, itemModel, legendModel,\n            legendSymbolType, symbolType,\n            itemAlign, color, selectMode\n        ) {\n            var itemWidth = legendModel.get('itemWidth');\n            var itemHeight = legendModel.get('itemHeight');\n            var inactiveColor = legendModel.get('inactiveColor');\n\n            var isSelected = legendModel.isSelected(name);\n            var itemGroup = new Group();\n\n            var textStyleModel = itemModel.getModel('textStyle');\n\n            var itemIcon = itemModel.get('icon');\n\n            var tooltipModel = itemModel.getModel('tooltip');\n            var legendGlobalTooltipModel = tooltipModel.parentModel;\n\n            // Use user given icon first\n            legendSymbolType = itemIcon || legendSymbolType;\n            itemGroup.add(symbolCreator.createSymbol(\n                legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor\n            ));\n\n            // Compose symbols\n            // PENDING\n            if (!itemIcon && symbolType\n                // At least show one symbol, can't be all none\n                && ((symbolType !== legendSymbolType) || symbolType == 'none')\n            ) {\n                var size = itemHeight * 0.8;\n                if (symbolType === 'none') {\n                    symbolType = 'circle';\n                }\n                // Put symbol in the center\n                itemGroup.add(symbolCreator.createSymbol(\n                    symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size,\n                    isSelected ? color : inactiveColor\n                ));\n            }\n\n            var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n            var textAlign = itemAlign;\n\n            var formatter = legendModel.get('formatter');\n            var content = name;\n            if (typeof formatter === 'string' && formatter) {\n                content = formatter.replace('{name}', name != null ? name : '');\n            }\n            else if (typeof formatter === 'function') {\n                content = formatter(name);\n            }\n\n            itemGroup.add(new graphic.Text({\n                style: graphic.setTextStyle({}, textStyleModel, {\n                    text: content,\n                    x: textX,\n                    y: itemHeight / 2,\n                    textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n                    textAlign: textAlign,\n                    textVerticalAlign: 'middle'\n                })\n            }));\n\n            // Add a invisible rect to increase the area of mouse hover\n            var hitRect = new graphic.Rect({\n                shape: itemGroup.getBoundingRect(),\n                invisible: true,\n                tooltip: tooltipModel.get('show') ? zrUtil.extend({\n                    content: name,\n                    // Defaul formatter\n                    formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n                        return name;\n                    },\n                    formatterParams: {\n                        componentType: 'legend',\n                        legendIndex: legendModel.componentIndex,\n                        name: name,\n                        $vars: ['name']\n                    }\n                }, tooltipModel.option) : null\n            });\n            itemGroup.add(hitRect);\n\n            itemGroup.eachChild(function (child) {\n                child.silent = true;\n            });\n\n            hitRect.silent = !selectMode;\n\n            this.getContentGroup().add(itemGroup);\n\n            graphic.setHoverStyle(itemGroup);\n\n            itemGroup.__legendDataIndex = dataIndex;\n\n            return itemGroup;\n        },\n\n        /**\n         * @protected\n         */\n        layoutInner: function (legendModel, itemAlign, maxSize) {\n            var contentGroup = this.getContentGroup();\n\n            // Place items in contentGroup.\n            layoutUtil.box(\n                legendModel.get('orient'),\n                contentGroup,\n                legendModel.get('itemGap'),\n                maxSize.width,\n                maxSize.height\n            );\n\n            var contentRect = contentGroup.getBoundingRect();\n            contentGroup.attr('position', [-contentRect.x, -contentRect.y]);\n\n            return this.group.getBoundingRect();\n        }\n\n    });\n\n    function dispatchSelectAction(name, api) {\n        api.dispatchAction({\n            type: 'legendToggleSelect',\n            name: name\n        });\n    }\n\n    function dispatchHighlightAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'highlight',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n    function dispatchDownplayAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'downplay',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n\n\n/***/ }),\n\n/***/ 1055:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Box selection tool.\n *\n * @module echarts/component/helper/BrushController\n */\n\n\n\n    var Eventful = __webpack_require__(992);\n    var zrUtil = __webpack_require__(971);\n    var graphic = __webpack_require__(973);\n    var interactionMutex = __webpack_require__(1070);\n    var DataDiffer = __webpack_require__(1003);\n\n    var curry = zrUtil.curry;\n    var each = zrUtil.each;\n    var map = zrUtil.map;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathPow = Math.pow;\n\n    var COVER_Z = 10000;\n    var UNSELECT_THRESHOLD = 6;\n    var MIN_RESIZE_LINE_WIDTH = 6;\n    var MUTEX_RESOURCE_KEY = 'globalPan';\n\n    var DIRECTION_MAP = {\n        w: [0, 0],\n        e: [0, 1],\n        n: [1, 0],\n        s: [1, 1]\n    };\n    var CURSOR_MAP = {\n        w: 'ew',\n        e: 'ew',\n        n: 'ns',\n        s: 'ns',\n        ne: 'nesw',\n        sw: 'nesw',\n        nw: 'nwse',\n        se: 'nwse'\n    };\n    var DEFAULT_BRUSH_OPT = {\n        brushStyle: {\n            lineWidth: 2,\n            stroke: 'rgba(0,0,0,0.3)',\n            fill: 'rgba(0,0,0,0.1)'\n        },\n        transformable: true,\n        brushMode: 'single',\n        removeOnClick: false\n    };\n\n    var baseUID = 0;\n\n    /**\n     * @alias module:echarts/component/helper/BrushController\n     * @constructor\n     * @mixin {module:zrender/mixin/Eventful}\n     * @event module:echarts/component/helper/BrushController#brush\n     *        params:\n     *            areas: Array.<Array>, coord relates to container group,\n     *                                    If no container specified, to global.\n     *            opt {\n     *                isEnd: boolean,\n     *                removeOnClick: boolean\n     *            }\n     *\n     * @param {module:zrender/zrender~ZRender} zr\n     */\n    function BrushController(zr) {\n\n        if (__DEV__) {\n            zrUtil.assert(zr);\n        }\n\n        Eventful.call(this);\n\n        /**\n         * @type {module:zrender/zrender~ZRender}\n         * @private\n         */\n        this._zr = zr;\n\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n\n        /**\n         * Only for drawing (after enabledBrush).\n         *     'line', 'rect', 'polygon' or false\n         *     If passing false/null/undefined, disable brush.\n         *     If passing 'auto', determined by panel.defaultBrushType\n         * @private\n         * @type {string}\n         */\n        this._brushType;\n\n        /**\n         * Only for drawing (after enabledBrush).\n         *\n         * @private\n         * @type {Object}\n         */\n        this._brushOption;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._panels;\n\n        /**\n         * @private\n         * @type {Array.<nubmer>}\n         */\n        this._track = [];\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._dragging;\n\n        /**\n         * @private\n         * @type {Array}\n         */\n        this._covers = [];\n\n        /**\n         * @private\n         * @type {moudule:zrender/container/Group}\n         */\n        this._creatingCover;\n\n        /**\n         * `true` means global panel\n         * @private\n         * @type {module:zrender/container/Group|boolean}\n         */\n        this._creatingPanel;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._enableGlobalPan;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        if (__DEV__) {\n            this._mounted;\n        }\n\n        /**\n         * @private\n         * @type {string}\n         */\n        this._uid = 'brushController_' + baseUID++;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._handlers = {};\n        each(mouseHandlers, function (handler, eventName) {\n            this._handlers[eventName] = zrUtil.bind(handler, this);\n        }, this);\n    }\n\n    BrushController.prototype = {\n\n        constructor: BrushController,\n\n        /**\n         * If set to null/undefined/false, select disabled.\n         * @param {Object} brushOption\n         * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false\n         *                          If passing false/null/undefined, disable brush.\n         *                          If passing 'auto', determined by panel.defaultBrushType.\n         *                              ('auto' can not be used in global panel)\n         * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'\n         * @param {boolean} [brushOption.transformable=true]\n         * @param {boolean} [brushOption.removeOnClick=false]\n         * @param {Object} [brushOption.brushStyle]\n         * @param {number} [brushOption.brushStyle.width]\n         * @param {number} [brushOption.brushStyle.lineWidth]\n         * @param {string} [brushOption.brushStyle.stroke]\n         * @param {string} [brushOption.brushStyle.fill]\n         * @param {number} [brushOption.z]\n         */\n        enableBrush: function (brushOption) {\n            if (__DEV__) {\n                zrUtil.assert(this._mounted);\n            }\n\n            this._brushType && doDisableBrush(this);\n            brushOption.brushType && doEnableBrush(this, brushOption);\n\n            return this;\n        },\n\n        /**\n         * @param {Array.<Object>} panelOpts If not pass, it is global brush.\n         *        Each items: {\n         *            panelId, // mandatory.\n         *            clipPath, // mandatory. function.\n         *            isTargetByCursor, // mandatory. function.\n         *            defaultBrushType, // optional, only used when brushType is 'auto'.\n         *            getLinearBrushOtherExtent, // optional. function.\n         *        }\n         */\n        setPanels: function (panelOpts) {\n            if (panelOpts && panelOpts.length) {\n                var panels = this._panels = {};\n                zrUtil.each(panelOpts, function (panelOpts) {\n                    panels[panelOpts.panelId] = zrUtil.clone(panelOpts);\n                });\n            }\n            else {\n                this._panels = null;\n            }\n            return this;\n        },\n\n        /**\n         * @param {Object} [opt]\n         * @return {boolean} [opt.enableGlobalPan=false]\n         */\n        mount: function (opt) {\n            opt = opt || {};\n\n            if (__DEV__) {\n                this._mounted = true; // should be at first.\n            }\n\n            this._enableGlobalPan = opt.enableGlobalPan;\n\n            var thisGroup = this.group;\n            this._zr.add(thisGroup);\n\n            thisGroup.attr({\n                position: opt.position || [0, 0],\n                rotation: opt.rotation || 0,\n                scale: opt.scale || [1, 1]\n            });\n            this._transform = thisGroup.getLocalTransform();\n\n            return this;\n        },\n\n        eachCover: function (cb, context) {\n            each(this._covers, cb, context);\n        },\n\n        /**\n         * Update covers.\n         * @param {Array.<Object>} brushOptionList Like:\n         *        [\n         *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},\n         *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},\n         *            ...\n         *        ]\n         *        `brushType` is required in each cover info. (can not be 'auto')\n         *        `id` is not mandatory.\n         *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.\n         *        If brushOptionList is null/undefined, all covers removed.\n         */\n        updateCovers: function (brushOptionList) {\n            if (__DEV__) {\n                zrUtil.assert(this._mounted);\n            }\n\n            brushOptionList = zrUtil.map(brushOptionList, function (brushOption) {\n                return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n            });\n\n            var tmpIdPrefix = '\\0-brush-index-';\n            var oldCovers = this._covers;\n            var newCovers = this._covers = [];\n            var controller = this;\n            var creatingCover = this._creatingCover;\n\n            (new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey))\n                .add(addOrUpdate)\n                .update(addOrUpdate)\n                .remove(remove)\n                .execute();\n\n            return this;\n\n            function getKey(brushOption, index) {\n                return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index)\n                    + '-' + brushOption.brushType;\n            }\n\n            function oldGetKey(cover, index) {\n                return getKey(cover.__brushOption, index);\n            }\n\n            function addOrUpdate(newIndex, oldIndex) {\n                var newBrushOption = brushOptionList[newIndex];\n                // Consider setOption in event listener of brushSelect,\n                // where updating cover when creating should be forbiden.\n                if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n                    newCovers[newIndex] = oldCovers[oldIndex];\n                }\n                else {\n                    var cover = newCovers[newIndex] = oldIndex != null\n                        ? (\n                            oldCovers[oldIndex].__brushOption = newBrushOption,\n                            oldCovers[oldIndex]\n                        )\n                        : endCreating(controller, createCover(controller, newBrushOption));\n                    updateCoverAfterCreation(controller, cover);\n                }\n            }\n\n            function remove(oldIndex) {\n                if (oldCovers[oldIndex] !== creatingCover) {\n                    controller.group.remove(oldCovers[oldIndex]);\n                }\n            }\n        },\n\n        unmount: function () {\n            if (__DEV__) {\n                if (!this._mounted) {\n                    return;\n                }\n            }\n\n            this.enableBrush(false);\n\n            // container may 'removeAll' outside.\n            clearCovers(this);\n            this._zr.remove(this.group);\n\n            if (__DEV__) {\n                this._mounted = false; // should be at last.\n            }\n\n            return this;\n        },\n\n        dispose: function () {\n            this.unmount();\n            this.off();\n        }\n    };\n\n    zrUtil.mixin(BrushController, Eventful);\n\n    function doEnableBrush(controller, brushOption) {\n        var zr = controller._zr;\n\n        // Consider roam, which takes globalPan too.\n        if (!controller._enableGlobalPan) {\n            interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);\n        }\n\n        each(controller._handlers, function (handler, eventName) {\n            zr.on(eventName, handler);\n        });\n\n        controller._brushType = brushOption.brushType;\n        controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n    }\n\n    function doDisableBrush(controller) {\n        var zr = controller._zr;\n\n        interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);\n\n        each(controller._handlers, function (handler, eventName) {\n            zr.off(eventName, handler);\n        });\n\n        controller._brushType = controller._brushOption = null;\n    }\n\n    function createCover(controller, brushOption) {\n        var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n        cover.__brushOption = brushOption;\n        updateZ(cover, brushOption);\n        controller.group.add(cover);\n        return cover;\n    }\n\n    function endCreating(controller, creatingCover) {\n        var coverRenderer = getCoverRenderer(creatingCover);\n        if (coverRenderer.endCreating) {\n            coverRenderer.endCreating(controller, creatingCover);\n            updateZ(creatingCover, creatingCover.__brushOption);\n        }\n        return creatingCover;\n    }\n\n    function updateCoverShape(controller, cover) {\n        var brushOption = cover.__brushOption;\n        getCoverRenderer(cover).updateCoverShape(\n            controller, cover, brushOption.range, brushOption\n        );\n    }\n\n    function updateZ(cover, brushOption) {\n        var z = brushOption.z;\n        z == null && (z = COVER_Z);\n        cover.traverse(function (el) {\n            el.z = z;\n            el.z2 = z; // Consider in given container.\n        });\n    }\n\n    function updateCoverAfterCreation(controller, cover) {\n        getCoverRenderer(cover).updateCommon(controller, cover);\n        updateCoverShape(controller, cover);\n    }\n\n    function getCoverRenderer(cover) {\n        return coverRenderers[cover.__brushOption.brushType];\n    }\n\n    // return target panel or `true` (means global panel)\n    function getPanelByPoint(controller, e, localCursorPoint) {\n        var panels = controller._panels;\n        if (!panels) {\n            return true; // Global panel\n        }\n        var panel;\n        var transform = controller._transform;\n        each(panels, function (pn) {\n            pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);\n        });\n        return panel;\n    }\n\n    // Return a panel or true\n    function getPanelByCover(controller, cover) {\n        var panels = controller._panels;\n        if (!panels) {\n            return true; // Global panel\n        }\n        var panelId = cover.__brushOption.panelId;\n        // User may give cover without coord sys info,\n        // which is then treated as global panel.\n        return panelId != null ? panels[panelId] : true;\n    }\n\n    function clearCovers(controller) {\n        var covers = controller._covers;\n        var originalLength = covers.length;\n        each(covers, function (cover) {\n            controller.group.remove(cover);\n        }, controller);\n        covers.length = 0;\n\n        return !!originalLength;\n    }\n\n    function trigger(controller, opt) {\n        var areas = map(controller._covers, function (cover) {\n            var brushOption = cover.__brushOption;\n            var range = zrUtil.clone(brushOption.range);\n            return {\n                brushType: brushOption.brushType,\n                panelId: brushOption.panelId,\n                range: range\n            };\n        });\n\n        controller.trigger('brush', areas, {\n            isEnd: !!opt.isEnd,\n            removeOnClick: !!opt.removeOnClick\n        });\n    }\n\n    function shouldShowCover(controller) {\n        var track = controller._track;\n\n        if (!track.length) {\n            return false;\n        }\n\n        var p2 = track[track.length - 1];\n        var p1 = track[0];\n        var dx = p2[0] - p1[0];\n        var dy = p2[1] - p1[1];\n        var dist = mathPow(dx * dx + dy * dy, 0.5);\n\n        return dist > UNSELECT_THRESHOLD;\n    }\n\n    function getTrackEnds(track) {\n        var tail = track.length - 1;\n        tail < 0 && (tail = 0);\n        return [track[0], track[tail]];\n    }\n\n    function createBaseRectCover(doDrift, controller, brushOption, edgeNames) {\n        var cover = new graphic.Group();\n\n        cover.add(new graphic.Rect({\n            name: 'main',\n            style: makeStyle(brushOption),\n            silent: true,\n            draggable: true,\n            cursor: 'move',\n            drift: curry(doDrift, controller, cover, 'nswe'),\n            ondragend: curry(trigger, controller, {isEnd: true})\n        }));\n\n        each(\n            edgeNames,\n            function (name) {\n                cover.add(new graphic.Rect({\n                    name: name,\n                    style: {opacity: 0},\n                    draggable: true,\n                    silent: true,\n                    invisible: true,\n                    drift: curry(doDrift, controller, cover, name),\n                    ondragend: curry(trigger, controller, {isEnd: true})\n                }));\n            }\n        );\n\n        return cover;\n    }\n\n    function updateBaseRect(controller, cover, localRange, brushOption) {\n        var lineWidth = brushOption.brushStyle.lineWidth || 0;\n        var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);\n        var x = localRange[0][0];\n        var y = localRange[1][0];\n        var xa = x - lineWidth / 2;\n        var ya = y - lineWidth / 2;\n        var x2 = localRange[0][1];\n        var y2 = localRange[1][1];\n        var x2a = x2 - handleSize + lineWidth / 2;\n        var y2a = y2 - handleSize + lineWidth / 2;\n        var width = x2 - x;\n        var height = y2 - y;\n        var widtha = width + lineWidth;\n        var heighta = height + lineWidth;\n\n        updateRectShape(controller, cover, 'main', x, y, width, height);\n\n        if (brushOption.transformable) {\n            updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n            updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n            updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n            updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n\n            updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n            updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n            updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n            updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n        }\n    }\n\n    function updateCommon(controller, cover) {\n        var brushOption = cover.__brushOption;\n        var transformable = brushOption.transformable;\n\n        var mainEl = cover.childAt(0);\n        mainEl.useStyle(makeStyle(brushOption));\n        mainEl.attr({\n            silent: !transformable,\n            cursor: transformable ? 'move' : 'default'\n        });\n\n        each(\n            ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'],\n            function (name) {\n                var el = cover.childOfName(name);\n                var globalDir = getGlobalDirection(controller, name);\n\n                el && el.attr({\n                    silent: !transformable,\n                    invisible: !transformable,\n                    cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n                });\n            }\n        );\n    }\n\n    function updateRectShape(controller, cover, name, x, y, w, h) {\n        var el = cover.childOfName(name);\n        el && el.setShape(pointsToRect(\n            clipByPanel(controller, cover, [[x, y], [x + w, y + h]])\n        ));\n    }\n\n    function makeStyle(brushOption) {\n        return zrUtil.defaults({strokeNoScale: true}, brushOption.brushStyle);\n    }\n\n    function formatRectRange(x, y, x2, y2) {\n        var min = [mathMin(x, x2), mathMin(y, y2)];\n        var max = [mathMax(x, x2), mathMax(y, y2)];\n\n        return [\n            [min[0], max[0]], // x range\n            [min[1], max[1]] // y range\n        ];\n    }\n\n    function getTransform(controller) {\n        return graphic.getTransform(controller.group);\n    }\n\n    function getGlobalDirection(controller, localDirection) {\n        if (localDirection.length > 1) {\n            localDirection = localDirection.split('');\n            var globalDir = [\n                getGlobalDirection(controller, localDirection[0]),\n                getGlobalDirection(controller, localDirection[1])\n            ];\n            (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n            return globalDir.join('');\n        }\n        else {\n            var map = {w: 'left', e: 'right', n: 'top', s: 'bottom'};\n            var inverseMap = {left: 'w', right: 'e', top: 'n', bottom: 's'};\n            var globalDir = graphic.transformDirection(\n                map[localDirection], getTransform(controller)\n            );\n            return inverseMap[globalDir];\n        }\n    }\n\n    function driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {\n        var brushOption = cover.__brushOption;\n        var rectRange = toRectRange(brushOption.range);\n        var localDelta = toLocalDelta(controller, dx, dy);\n\n        each(name.split(''), function (namePart) {\n            var ind = DIRECTION_MAP[namePart];\n            rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n        });\n\n        brushOption.range = fromRectRange(formatRectRange(\n            rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]\n        ));\n\n        updateCoverAfterCreation(controller, cover);\n        trigger(controller, {isEnd: false});\n    }\n\n    function driftPolygon(controller, cover, dx, dy, e) {\n        var range = cover.__brushOption.range;\n        var localDelta = toLocalDelta(controller, dx, dy);\n\n        each(range, function (point) {\n            point[0] += localDelta[0];\n            point[1] += localDelta[1];\n        });\n\n        updateCoverAfterCreation(controller, cover);\n        trigger(controller, {isEnd: false});\n    }\n\n    function toLocalDelta(controller, dx, dy) {\n        var thisGroup = controller.group;\n        var localD = thisGroup.transformCoordToLocal(dx, dy);\n        var localZero = thisGroup.transformCoordToLocal(0, 0);\n\n        return [localD[0] - localZero[0], localD[1] - localZero[1]];\n    }\n\n    function clipByPanel(controller, cover, data) {\n        var panel = getPanelByCover(controller, cover);\n\n        return (panel && panel !== true)\n            ? panel.clipPath(data, controller._transform)\n            : zrUtil.clone(data);\n    }\n\n    function pointsToRect(points) {\n        var xmin = mathMin(points[0][0], points[1][0]);\n        var ymin = mathMin(points[0][1], points[1][1]);\n        var xmax = mathMax(points[0][0], points[1][0]);\n        var ymax = mathMax(points[0][1], points[1][1]);\n\n        return {\n            x: xmin,\n            y: ymin,\n            width: xmax - xmin,\n            height: ymax - ymin\n        };\n    }\n\n    function resetCursor(controller, e, localCursorPoint) {\n        // Check active\n        if (!controller._brushType) {\n            return;\n        }\n\n        var zr = controller._zr;\n        var covers = controller._covers;\n        var currPanel = getPanelByPoint(controller, e, localCursorPoint);\n\n        // Check whether in covers.\n        if (!controller._dragging) {\n            for (var i = 0; i < covers.length; i++) {\n                var brushOption = covers[i].__brushOption;\n                if (currPanel\n                    && (currPanel === true || brushOption.panelId === currPanel.panelId)\n                    && coverRenderers[brushOption.brushType].contain(\n                        covers[i], localCursorPoint[0], localCursorPoint[1]\n                    )\n                ) {\n                    // Use cursor style set on cover.\n                    return;\n                }\n            }\n        }\n\n        currPanel && zr.setCursorStyle('crosshair');\n    }\n\n    function preventDefault(e) {\n        var rawE = e.event;\n        rawE.preventDefault && rawE.preventDefault();\n    }\n\n    function mainShapeContain(cover, x, y) {\n        return cover.childOfName('main').contain(x, y);\n    }\n\n    function updateCoverByMouse(controller, e, localCursorPoint, isEnd) {\n        var creatingCover = controller._creatingCover;\n        var panel = controller._creatingPanel;\n        var thisBrushOption = controller._brushOption;\n        var eventParams;\n\n        controller._track.push(localCursorPoint.slice());\n\n        if (shouldShowCover(controller) || creatingCover) {\n\n            if (panel && !creatingCover) {\n                thisBrushOption.brushMode === 'single' && clearCovers(controller);\n                var brushOption = zrUtil.clone(thisBrushOption);\n                brushOption.brushType = determineBrushType(brushOption.brushType, panel);\n                brushOption.panelId = panel === true ? null : panel.panelId;\n                creatingCover = controller._creatingCover = createCover(controller, brushOption);\n                controller._covers.push(creatingCover);\n            }\n\n            if (creatingCover) {\n                var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];\n                var coverBrushOption = creatingCover.__brushOption;\n\n                coverBrushOption.range = coverRenderer.getCreatingRange(\n                    clipByPanel(controller, creatingCover, controller._track)\n                );\n\n                if (isEnd) {\n                    endCreating(controller, creatingCover);\n                    coverRenderer.updateCommon(controller, creatingCover);\n                }\n\n                updateCoverShape(controller, creatingCover);\n\n                eventParams = {isEnd: isEnd};\n            }\n        }\n        else if (\n            isEnd\n            && thisBrushOption.brushMode === 'single'\n            && thisBrushOption.removeOnClick\n        ) {\n            // Help user to remove covers easily, only by a tiny drag, in 'single' mode.\n            // But a single click do not clear covers, because user may have casual\n            // clicks (for example, click on other component and do not expect covers\n            // disappear).\n            // Only some cover removed, trigger action, but not every click trigger action.\n            if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {\n                eventParams = {isEnd: isEnd, removeOnClick: true};\n            }\n        }\n\n        return eventParams;\n    }\n\n    function determineBrushType(brushType, panel) {\n        if (brushType === 'auto') {\n            if (__DEV__) {\n                zrUtil.assert(\n                    panel && panel.defaultBrushType,\n                    'MUST have defaultBrushType when brushType is \"atuo\"'\n                );\n            }\n            return panel.defaultBrushType;\n        }\n        return brushType;\n    }\n\n    var mouseHandlers = {\n\n        mousedown: function (e) {\n            if (this._dragging) {\n                // In case some browser do not support globalOut,\n                // and release mose out side the browser.\n                handleDragEnd.call(this, e);\n            }\n            else if (!e.target || !e.target.draggable) {\n\n                preventDefault(e);\n\n                var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n\n                this._creatingCover = null;\n                var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);\n\n                if (panel) {\n                    this._dragging = true;\n                    this._track = [localCursorPoint.slice()];\n                }\n            }\n        },\n\n        mousemove: function (e) {\n            var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n\n            resetCursor(this, e, localCursorPoint);\n\n            if (this._dragging) {\n\n                preventDefault(e);\n\n                var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);\n\n                eventParams && trigger(this, eventParams);\n            }\n        },\n\n        mouseup: handleDragEnd //,\n\n        // FIXME\n        // in tooltip, globalout should not be triggered.\n        // globalout: handleDragEnd\n    };\n\n    function handleDragEnd(e) {\n        if (this._dragging) {\n\n            preventDefault(e);\n\n            var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n            var eventParams = updateCoverByMouse(this, e, localCursorPoint, true);\n\n            this._dragging = false;\n            this._track = [];\n            this._creatingCover = null;\n\n            // trigger event shoule be at final, after procedure will be nested.\n            eventParams && trigger(this, eventParams);\n        }\n    }\n\n    /**\n     * key: brushType\n     * @type {Object}\n     */\n    var coverRenderers = {\n\n        lineX: getLineRenderer(0),\n\n        lineY: getLineRenderer(1),\n\n        rect: {\n            createCover: function (controller, brushOption) {\n                return createBaseRectCover(\n                    curry(\n                        driftRect,\n                        function (range) {\n                            return range;\n                        },\n                        function (range) {\n                            return range;\n                        }\n                    ),\n                    controller,\n                    brushOption,\n                    ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']\n                );\n            },\n            getCreatingRange: function (localTrack) {\n                var ends = getTrackEnds(localTrack);\n                return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n            },\n            updateCoverShape: function (controller, cover, localRange, brushOption) {\n                updateBaseRect(controller, cover, localRange, brushOption);\n            },\n            updateCommon: updateCommon,\n            contain: mainShapeContain\n        },\n\n        polygon: {\n            createCover: function (controller, brushOption) {\n                var cover = new graphic.Group();\n\n                // Do not use graphic.Polygon because graphic.Polyline do not close the\n                // border of the shape when drawing, which is a better experience for user.\n                cover.add(new graphic.Polyline({\n                    name: 'main',\n                    style: makeStyle(brushOption),\n                    silent: true\n                }));\n\n                return cover;\n            },\n            getCreatingRange: function (localTrack) {\n                return localTrack;\n            },\n            endCreating: function (controller, cover) {\n                cover.remove(cover.childAt(0));\n                // Use graphic.Polygon close the shape.\n                cover.add(new graphic.Polygon({\n                    name: 'main',\n                    draggable: true,\n                    drift: curry(driftPolygon, controller, cover),\n                    ondragend: curry(trigger, controller, {isEnd: true})\n                }));\n            },\n            updateCoverShape: function (controller, cover, localRange, brushOption) {\n                cover.childAt(0).setShape({\n                    points: clipByPanel(controller, cover, localRange)\n                });\n            },\n            updateCommon: updateCommon,\n            contain: mainShapeContain\n        }\n    };\n\n    function getLineRenderer(xyIndex) {\n        return {\n            createCover: function (controller, brushOption) {\n                return createBaseRectCover(\n                    curry(\n                        driftRect,\n                        function (range) {\n                            var rectRange = [range, [0, 100]];\n                            xyIndex && rectRange.reverse();\n                            return rectRange;\n                        },\n                        function (rectRange) {\n                            return rectRange[xyIndex];\n                        }\n                    ),\n                    controller,\n                    brushOption,\n                    [['w', 'e'], ['n', 's']][xyIndex]\n                );\n            },\n            getCreatingRange: function (localTrack) {\n                var ends = getTrackEnds(localTrack);\n                var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);\n                var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);\n\n                return [min, max];\n            },\n            updateCoverShape: function (controller, cover, localRange, brushOption) {\n                var otherExtent;\n                // If brushWidth not specified, fit the panel.\n                var panel = getPanelByCover(controller, cover);\n                if (panel !== true && panel.getLinearBrushOtherExtent) {\n                    otherExtent = panel.getLinearBrushOtherExtent(\n                        xyIndex, controller._transform\n                    );\n                }\n                else {\n                    var zr = controller._zr;\n                    otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];\n                }\n                var rectRange = [localRange, otherExtent];\n                xyIndex && rectRange.reverse();\n\n                updateBaseRect(controller, cover, rectRange, brushOption);\n            },\n            updateCommon: updateCommon,\n            contain: mainShapeContain\n        };\n    }\n\n    module.exports = BrushController;\n\n\n/***/ }),\n\n/***/ 1056:\n/***/ (function(module, exports) {\n\n\n\n    var helper = {};\n\n    var IRRELEVANT_EXCLUDES = {'axisPointer': 1, 'tooltip': 1, 'brush': 1};\n\n    /**\n     * Avoid that: mouse click on a elements that is over geo or graph,\n     * but roam is triggered.\n     */\n    helper.onIrrelevantElement = function (e, api, targetCoordSysModel) {\n        var model = api.getComponentByElement(e.topTarget);\n        // If model is axisModel, it works only if it is injected with coordinateSystem.\n        var coordSys = model && model.coordinateSystem;\n        return model\n            && model !== targetCoordSysModel\n            && !IRRELEVANT_EXCLUDES[model.mainType]\n            && (coordSys && coordSys.model !== targetCoordSysModel);\n    };\n\n    module.exports = helper;\n\n\n/***/ }),\n\n/***/ 1059:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\n\n\n    var textHelper = __webpack_require__(1026);\n    var BoundingRect = __webpack_require__(982);\n\n    var tmpRect = new BoundingRect();\n\n    var RectText = function () {};\n\n    RectText.prototype = {\n\n        constructor: RectText,\n\n        /**\n         * Draw text in a rect with specified position.\n         * @param  {CanvasRenderingContext2D} ctx\n         * @param  {Object} rect Displayable rect\n         */\n        drawRectText: function (ctx, rect) {\n            var style = this.style;\n\n            rect = style.textRect || rect;\n\n            // Optimize, avoid normalize every time.\n            this.__dirty && textHelper.normalizeTextStyle(style, true);\n\n            var text = style.text;\n\n            // Convert to string\n            text != null && (text += '');\n\n            if (!textHelper.needDrawText(text, style)) {\n                return;\n            }\n\n            // FIXME\n            ctx.save();\n\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.transformText) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            }\n            else {\n                this.setTransform(ctx);\n            }\n\n            // transformText and textRotation can not be used at the same time.\n            textHelper.renderText(this, ctx, text, style, rect);\n\n            ctx.restore();\n        }\n    };\n\n    module.exports = RectText;\n\n\n/***/ }),\n\n/***/ 1060:\n/***/ (function(module, exports) {\n\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l)\n                || (y < y0 - _l && y < y1 - _l)\n                || (x > x0 + _l && x > x1 + _l)\n                || (x < x0 - _l && x < x1 - _l)\n            ) {\n                return false;\n            }\n\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n            }\n            else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n\n\n/***/ }),\n\n/***/ 1061:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var curve = __webpack_require__(991);\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(\n                x0, y0, x1, y1, x2, y2,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n/***/ }),\n\n/***/ 1062:\n/***/ (function(module, exports) {\n\n\n    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n\n        var x_ = t * (x1 - x0) + x0;\n\n        return x_ > x ? dir : 0;\n    };\n\n\n/***/ }),\n\n/***/ 1063:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Text element\n * @module zrender/graphic/Text\n *\n * TODO Wrapping\n *\n * Text not support gradient\n */\n\n\n\n    var Displayable = __webpack_require__(1009);\n    var zrUtil = __webpack_require__(971);\n    var textContain = __webpack_require__(985);\n    var textHelper = __webpack_require__(1026);\n\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n\n    Text.prototype = {\n\n        constructor: Text,\n\n        type: 'text',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n\n            // Optimize, avoid normalize every time.\n            this.__dirty && textHelper.normalizeTextStyle(style, true);\n\n            // Use props with prefix 'text'.\n            style.fill = style.stroke = style.shadowBlur = style.shadowColor =\n                style.shadowOffsetX = style.shadowOffsetY = null;\n\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n\n            if (!textHelper.needDrawText(text, style)) {\n                return;\n            }\n\n            this.setTransform(ctx);\n\n            textHelper.renderText(this, ctx, text, style);\n\n            this.restoreTransform(ctx);\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n\n            // Optimize, avoid normalize every time.\n            this.__dirty && textHelper.normalizeTextStyle(style, true);\n\n            if (!this._rect) {\n                var text = style.text;\n                text != null ? (text += '') : (text = '');\n\n                var rect = textContain.getBoundingRect(\n                    style.text + '',\n                    style.font,\n                    style.textAlign,\n                    style.textVerticalAlign,\n                    style.textPadding,\n                    style.rich\n                );\n\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n\n                if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {\n                    var w = style.textStrokeWidth;\n                    rect.x -= w / 2;\n                    rect.y -= w / 2;\n                    rect.width += w;\n                    rect.height += w;\n                }\n\n                this._rect = rect;\n            }\n\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(Text, Displayable);\n\n    module.exports = Text;\n\n\n/***/ }),\n\n/***/ 1064:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(971);\n\n    var Gradient = __webpack_require__(1010);\n\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {type: 'linear', colorStops: ...}`, where\n        // this constructor will not be called.\n\n        this.x = x == null ? 0 : x;\n\n        this.y = y == null ? 0 : y;\n\n        this.x2 = x2 == null ? 1 : x2;\n\n        this.y2 = y2 == null ? 0 : y2;\n\n        // Can be cloned\n        this.type = 'linear';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    LinearGradient.prototype = {\n\n        constructor: LinearGradient\n    };\n\n    zrUtil.inherits(LinearGradient, Gradient);\n\n    module.exports = LinearGradient;\n\n\n/***/ }),\n\n/***/ 1065:\n/***/ (function(module, exports, __webpack_require__) {\n\n/*!\n * ZRender, a high performance 2d drawing library.\n *\n * Copyright (c) 2013, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n */\n// Global defines\n\n    var guid = __webpack_require__(1033);\n    var env = __webpack_require__(978);\n    var zrUtil = __webpack_require__(971);\n\n    var Handler = __webpack_require__(1111);\n    var Storage = __webpack_require__(1113);\n    var Animation = __webpack_require__(1114);\n    var HandlerProxy = __webpack_require__(1115);\n\n    var useVML = !env.canvasSupported;\n\n    var painterCtors = {\n        canvas: __webpack_require__(1117)\n    };\n\n    var instances = {};    // ZRendermap\n\n    var zrender = {};\n\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.6.3';\n\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function (dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        }\n        else {\n            for (var key in instances) {\n                if (instances.hasOwnProperty(key)) {\n                    instances[key].dispose();\n                }\n            }\n            instances = {};\n        }\n\n        return zrender;\n    };\n\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n\n    function delInstance(id) {\n        delete instances[id];\n    }\n\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     */\n    var ZRender = function (id, dom, opts) {\n\n        opts = opts || {};\n\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n\n        /**\n         * @type {string}\n         */\n        this.id = id;\n\n        var self = this;\n        var storage = new Storage();\n\n        var rendererType = opts.renderer;\n        // TODO WebGL\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        }\n        else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n\n        this.storage = storage;\n        this.painter = painter;\n\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: zrUtil.bind(this.flush, this)\n            }\n        });\n        this.animation.start();\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n\n        //  storage.delFromStorage, \n        // FIXME ugly\n        var oldDelFromStorage = storage.delFromStorage;\n        var oldAddToStorage = storage.addToStorage;\n\n        storage.delFromStorage = function (el) {\n            oldDelFromStorage.call(storage, el);\n\n            el && el.removeSelfFromZr(self);\n        };\n\n        storage.addToStorage = function (el) {\n            oldAddToStorage.call(storage, el);\n\n            el.addSelfToZr(self);\n        };\n    };\n\n    ZRender.prototype = {\n\n        constructor: ZRender,\n        /**\n         * \n         * @return {string}\n         */\n        getId: function () {\n            return this.id;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Change configuration of layer\n         * @param {string} zLevel\n         * @param {Object} config\n         * @param {string} [config.clearColor=0] Clear color\n         * @param {string} [config.motionBlur=false] If enable motion blur\n         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n        */\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Repaint the canvas immediately\n         */\n        refreshImmediately: function () {\n            // var start = new Date();\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n            // var end = new Date();\n\n            // var log = document.getElementById('log');\n            // if (log) {\n            //     log.innerHTML = log.innerHTML + '<br>' + (end - start);\n            // }\n        },\n\n        /**\n         * Mark and repaint the canvas in the next frame of browser\n         */\n        refresh: function() {\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Perform all refresh\n         */\n        flush: function () {\n            if (this._needsRefresh) {\n                this.refreshImmediately();\n            }\n            if (this._needsRefreshHover) {\n                this.refreshHoverImmediately();\n            }\n        },\n\n        /**\n         * Add element to hover layer\n         * @param  {module:zrender/Element} el\n         * @param {Object} style\n         */\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Add element from hover layer\n         * @param  {module:zrender/Element} el\n         */\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Clear all hover elements in hover layer\n         * @param  {module:zrender/Element} el\n         */\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Refresh hover in next frame\n         */\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n\n        /**\n         * Refresh hover immediately\n         */\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n\n        /**\n         * Resize the canvas.\n         * Should be invoked when container size is changed\n         * @param {Object} [opts]\n         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n         */\n        resize: function(opts) {\n            opts = opts || {};\n            this.painter.resize(opts.width, opts.height);\n            this.handler.resize();\n        },\n\n        /**\n         * Stop and clear all animation immediately\n         */\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n\n        /**\n         * Get container width\n         */\n        getWidth: function() {\n            return this.painter.getWidth();\n        },\n\n        /**\n         * Get container height\n         */\n        getHeight: function() {\n            return this.painter.getHeight();\n        },\n\n        /**\n         * Export the canvas as Base64 URL\n         * @param {string} type\n         * @param {string} [backgroundColor='#fff']\n         * @return {string} Base64 URL\n         */\n        // toDataURL: function(type, backgroundColor) {\n        //     return this.painter.getRenderedCanvas({\n        //         backgroundColor: backgroundColor\n        //     }).toDataURL(type);\n        // },\n\n        /**\n         * Converting a path to image.\n         * It has much better performance of drawing image rather than drawing a vector path.\n         * @param {module:zrender/graphic/Path} e\n         * @param {number} width\n         * @param {number} height\n         */\n        pathToImage: function(e, dpr) {\n            return this.painter.pathToImage(e, dpr);\n        },\n\n        /**\n         * Set default cursor\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n\n        /**\n         * Find hovered element\n         * @param {number} x\n         * @param {number} y\n         * @return {Object} {target, topTarget}\n         */\n        findHover: function (x, y) {\n            return this.handler.findHover(x, y);\n        },\n\n        /**\n         * Bind event\n         *\n         * @param {string} eventName Event name\n         * @param {Function} eventHandler Handler function\n         * @param {Object} [context] Context object\n         */\n        on: function(eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n\n        /**\n         * Unbind event\n         * @param {string} eventName Event name\n         * @param {Function} [eventHandler] Handler function\n         */\n        off: function(eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n\n        /**\n         * Trigger event manually\n         *\n         * @param {string} eventName Event name\n         * @param {event=} event Event object\n         */\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n\n\n        /**\n         * Clear all objects and the canvas.\n         */\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n\n        /**\n         * Dispose self.\n         */\n        dispose: function () {\n            this.animation.stop();\n\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n\n            this.animation =\n            this.storage =\n            this.painter =\n            this.handler = null;\n\n            delInstance(this.id);\n        }\n    };\n\n    module.exports = zrender;\n\n\n\n/***/ }),\n\n/***/ 1066:\n/***/ (function(module, exports, __webpack_require__) {\n\n// FIXME Better way to pack data in graphic element\n\n\n    __webpack_require__(1022);\n\n    __webpack_require__(1128);\n\n    __webpack_require__(1129);\n\n\n    // Show tip action\n    /**\n     * @action\n     * @property {string} type\n     * @property {number} seriesIndex\n     * @property {number} dataIndex\n     * @property {number} [x]\n     * @property {number} [y]\n     */\n    __webpack_require__(972).registerAction(\n        {\n            type: 'showTip',\n            event: 'showTip',\n            update: 'tooltip:manuallyShowTip'\n        },\n        // noop\n        function () {}\n    );\n    // Hide tip action\n    __webpack_require__(972).registerAction(\n        {\n            type: 'hideTip',\n            event: 'hideTip',\n            update: 'tooltip:manuallyHideTip'\n        },\n        // noop\n        function () {}\n    );\n\n\n/***/ }),\n\n/***/ 1067:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    // Do not contain scrollable legend, for sake of file size.\n\n    __webpack_require__(1053);\n    __webpack_require__(1131);\n    __webpack_require__(1054);\n\n    var echarts = __webpack_require__(972);\n    // Series Filter\n    echarts.registerProcessor(__webpack_require__(1132));\n\n    __webpack_require__(983).registerSubTypeDefaulter('legend', function () {\n        // Default 'plain' when no type specified.\n        return 'plain';\n    });\n\n\n\n/***/ }),\n\n/***/ 1068:\n/***/ (function(module, exports) {\n\n\n    module.exports = function (seriesType, ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (!legendModels || !legendModels.length) {\n            return;\n        }\n        ecModel.eachSeriesByType(seriesType, function (series) {\n            var data = series.getData();\n            data.filterSelf(function (idx) {\n                var name = data.getName(idx);\n                // If in any legend component the status is not selected.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(name)) {\n                        return false;\n                    }\n                }\n                return true;\n            }, this);\n        }, this);\n    };\n\n\n/***/ }),\n\n/***/ 1069:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    __webpack_require__(1135);\n    __webpack_require__(1136);\n\n    __webpack_require__(1137);\n    __webpack_require__(1138);\n    __webpack_require__(1139);\n    __webpack_require__(1140);\n    __webpack_require__(1145);\n\n\n/***/ }),\n\n/***/ 1070:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var ATTR = '\\0_ec_interaction_mutex';\n\n    var interactionMutex = {\n\n        take: function (zr, resourceKey, userKey) {\n            var store = getStore(zr);\n            store[resourceKey] = userKey;\n        },\n\n        release: function (zr, resourceKey, userKey) {\n            var store = getStore(zr);\n            var uKey = store[resourceKey];\n\n            if (uKey === userKey) {\n                store[resourceKey] = null;\n            }\n        },\n\n        isTaken: function (zr, resourceKey) {\n            return !!getStore(zr)[resourceKey];\n        }\n    };\n\n    function getStore(zr) {\n        return zr[ATTR] || (zr[ATTR] = {});\n    }\n\n    /**\n     * payload: {\n     *     type: 'takeGlobalCursor',\n     *     key: 'dataZoomSelect', or 'brush', or ...,\n     *         If no userKey, release global cursor.\n     * }\n     */\n    __webpack_require__(972).registerAction(\n        {type: 'takeGlobalCursor', event: 'globalCursorTaken', update: 'update'},\n        function () {}\n    );\n\n    module.exports = interactionMutex;\n\n\n/***/ }),\n\n/***/ 1071:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(971);\n    var graphic = __webpack_require__(973);\n    var modelUtil = __webpack_require__(975);\n    var brushHelper = __webpack_require__(1072);\n\n    var each = zrUtil.each;\n    var indexOf = zrUtil.indexOf;\n    var curry = zrUtil.curry;\n\n    var COORD_CONVERTS = ['dataToPoint', 'pointToData'];\n\n    // FIXME\n    // how to genarialize to more coordinate systems.\n    var INCLUDE_FINDER_MAIN_TYPES = [\n        'grid', 'xAxis', 'yAxis', 'geo', 'graph',\n        'polar', 'radiusAxis', 'angleAxis', 'bmap'\n    ];\n\n    /**\n     * [option in constructor]:\n     * {\n     *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n     * }\n     *\n     *\n     * [targetInfo]:\n     *\n     * There can be multiple axes in a single targetInfo. Consider the case\n     * of `grid` component, a targetInfo represents a grid which contains one or more\n     * cartesian and one or more axes. And consider the case of parallel system,\n     * which has multiple axes in a coordinate system.\n     * Can be {\n     *     panelId: ...,\n     *     coordSys: <a representitive cartesian in grid (first cartesian by default)>,\n     *     coordSyses: all cartesians.\n     *     gridModel: <grid component>\n     *     xAxes: correspond to coordSyses on index\n     *     yAxes: correspond to coordSyses on index\n     * }\n     * or {\n     *     panelId: ...,\n     *     coordSys: <geo coord sys>\n     *     coordSyses: [<geo coord sys>]\n     *     geoModel: <geo component>\n     * }\n     *\n     *\n     * [panelOpt]:\n     *\n     * Make from targetInfo. Input to BrushController.\n     * {\n     *     panelId: ...,\n     *     rect: ...\n     * }\n     *\n     *\n     * [area]:\n     *\n     * Generated by BrushController or user input.\n     * {\n     *     panelId: Used to locate coordInfo directly. If user inpput, no panelId.\n     *     brushType: determine how to convert to/from coord('rect' or 'polygon' or 'lineX/Y').\n     *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n     *     range: pixel range.\n     *     coordRange: representitive coord range (the first one of coordRanges).\n     *     coordRanges: <Array> coord ranges, used in multiple cartesian in one grid.\n     * }\n     */\n\n    /**\n     * @param {Object} option contains Index/Id/Name of xAxis/yAxis/geo/grid\n     *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}\n     * @param {module:echarts/model/Global} ecModel\n     * @param {Object} [opt]\n     * @param {Array.<string>} [opt.include] include coordinate system types.\n     */\n    function BrushTargetManager(option, ecModel, opt) {\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        var targetInfoList = this._targetInfoList = [];\n        var info = {};\n        var foundCpts = parseFinder(ecModel, option);\n\n        each(targetInfoBuilders, function (builder, type) {\n            if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {\n                builder(foundCpts, targetInfoList, info);\n            }\n        });\n    }\n\n    var proto = BrushTargetManager.prototype;\n\n    proto.setOutputRanges = function (areas, ecModel) {\n        this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n            (area.coordRanges || (area.coordRanges = [])).push(coordRange);\n            // area.coordRange is the first of area.coordRanges\n            if (!area.coordRange) {\n                area.coordRange = coordRange;\n                // In 'category' axis, coord to pixel is not reversible, so we can not\n                // rebuild range by coordRange accrately, which may bring trouble when\n                // brushing only one item. So we use __rangeOffset to rebuilding range\n                // by coordRange. And this it only used in brush component so it is no\n                // need to be adapted to coordRanges.\n                var result = coordConvert[area.brushType](0, coordSys, coordRange);\n                area.__rangeOffset = {\n                    offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n                    xyMinMax: result.xyMinMax\n                };\n            }\n        });\n    };\n\n    proto.matchOutputRanges = function (areas, ecModel, cb) {\n        each(areas, function (area) {\n            var targetInfo = this.findTargetInfo(area, ecModel);\n\n            if (targetInfo && targetInfo !== true) {\n                zrUtil.each(\n                    targetInfo.coordSyses,\n                    function (coordSys) {\n                        var result = coordConvert[area.brushType](1, coordSys, area.range);\n                        cb(area, result.values, coordSys, ecModel);\n                    }\n                );\n            }\n        }, this);\n    };\n\n    proto.setInputRanges = function (areas, ecModel) {\n        each(areas, function (area) {\n            var targetInfo = this.findTargetInfo(area, ecModel);\n\n            if (__DEV__) {\n                zrUtil.assert(\n                    !targetInfo || targetInfo === true || area.coordRange,\n                    'coordRange must be specified when coord index specified.'\n                );\n                zrUtil.assert(\n                    !targetInfo || targetInfo !== true || area.range,\n                    'range must be specified in global brush.'\n                );\n            }\n\n            area.range = area.range || [];\n\n            // convert coordRange to global range and set panelId.\n            if (targetInfo && targetInfo !== true) {\n                area.panelId = targetInfo.panelId;\n                // (1) area.range shoule always be calculate from coordRange but does\n                // not keep its original value, for the sake of the dataZoom scenario,\n                // where area.coordRange remains unchanged but area.range may be changed.\n                // (2) Only support converting one coordRange to pixel range in brush\n                // component. So do not consider `coordRanges`.\n                // (3) About __rangeOffset, see comment above.\n                var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n                var rangeOffset = area.__rangeOffset;\n                area.range = rangeOffset\n                    ? diffProcessor[area.brushType](\n                        result.values,\n                        rangeOffset.offset,\n                        getScales(result.xyMinMax, rangeOffset.xyMinMax)\n                    )\n                    : result.values;\n            }\n        }, this);\n    };\n\n    proto.makePanelOpts = function (api, getDefaultBrushType) {\n        return zrUtil.map(this._targetInfoList, function (targetInfo) {\n            var rect = targetInfo.getPanelRect();\n            return {\n                panelId: targetInfo.panelId,\n                defaultBrushType: getDefaultBrushType && getDefaultBrushType(targetInfo),\n                clipPath: brushHelper.makeRectPanelClipPath(rect),\n                isTargetByCursor: brushHelper.makeRectIsTargetByCursor(\n                    rect, api, targetInfo.coordSysModel\n                ),\n                getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)\n            };\n        });\n    };\n\n    proto.controlSeries = function (area, seriesModel, ecModel) {\n        // Check whether area is bound in coord, and series do not belong to that coord.\n        // If do not do this check, some brush (like lineX) will controll all axes.\n        var targetInfo = this.findTargetInfo(area, ecModel);\n        return targetInfo === true || (\n            targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0\n        );\n    };\n\n    /**\n     * If return Object, a coord found.\n     * If reutrn true, global found.\n     * Otherwise nothing found.\n     *\n     * @param {Object} area\n     * @param {Array} targetInfoList\n     * @return {Object|boolean}\n     */\n    proto.findTargetInfo = function (area, ecModel) {\n        var targetInfoList = this._targetInfoList;\n        var foundCpts = parseFinder(ecModel, area);\n\n        for (var i = 0; i < targetInfoList.length; i++) {\n            var targetInfo = targetInfoList[i];\n            var areaPanelId = area.panelId;\n            if (areaPanelId) {\n                if (targetInfo.panelId === areaPanelId) {\n                    return targetInfo;\n                }\n            }\n            else {\n                for (var i = 0; i < targetInfoMatchers.length; i++) {\n                    if (targetInfoMatchers[i](foundCpts, targetInfo)) {\n                        return targetInfo;\n                    }\n                }\n            }\n        }\n\n        return true;\n    };\n\n    function formatMinMax(minMax) {\n        minMax[0] > minMax[1] && minMax.reverse();\n        return minMax;\n    }\n\n    function parseFinder(ecModel, option) {\n        return modelUtil.parseFinder(\n            ecModel, option, {includeMainTypes: INCLUDE_FINDER_MAIN_TYPES}\n        );\n    }\n\n    var targetInfoBuilders = {\n\n        grid: function (foundCpts, targetInfoList) {\n            var xAxisModels = foundCpts.xAxisModels;\n            var yAxisModels = foundCpts.yAxisModels;\n            var gridModels = foundCpts.gridModels;\n            // Remove duplicated.\n            var gridModelMap = zrUtil.createHashMap();\n            var xAxesHas = {};\n            var yAxesHas = {};\n\n            if (!xAxisModels && !yAxisModels && !gridModels) {\n                return;\n            }\n\n            each(xAxisModels, function (axisModel) {\n                var gridModel = axisModel.axis.grid.model;\n                gridModelMap.set(gridModel.id, gridModel);\n                xAxesHas[gridModel.id] = true;\n            });\n            each(yAxisModels, function (axisModel) {\n                var gridModel = axisModel.axis.grid.model;\n                gridModelMap.set(gridModel.id, gridModel);\n                yAxesHas[gridModel.id] = true;\n            });\n            each(gridModels, function (gridModel) {\n                gridModelMap.set(gridModel.id, gridModel);\n                xAxesHas[gridModel.id] = true;\n                yAxesHas[gridModel.id] = true;\n            });\n\n            gridModelMap.each(function (gridModel) {\n                var grid = gridModel.coordinateSystem;\n                var cartesians = [];\n\n                each(grid.getCartesians(), function (cartesian, index) {\n                    if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0\n                        || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0\n                    ) {\n                        cartesians.push(cartesian);\n                    }\n                });\n                targetInfoList.push({\n                    panelId: 'grid--' + gridModel.id,\n                    gridModel: gridModel,\n                    coordSysModel: gridModel,\n                    // Use the first one as the representitive coordSys.\n                    coordSys: cartesians[0],\n                    coordSyses: cartesians,\n                    getPanelRect: panelRectBuilder.grid,\n                    xAxisDeclared: xAxesHas[gridModel.id],\n                    yAxisDeclared: yAxesHas[gridModel.id]\n                });\n            });\n        },\n\n        geo: function (foundCpts, targetInfoList) {\n            each(foundCpts.geoModels, function (geoModel) {\n                var coordSys = geoModel.coordinateSystem;\n                targetInfoList.push({\n                    panelId: 'geo--' + geoModel.id,\n                    geoModel: geoModel,\n                    coordSysModel: geoModel,\n                    coordSys: coordSys,\n                    coordSyses: [coordSys],\n                    getPanelRect: panelRectBuilder.geo\n                });\n            });\n        }\n    };\n\n    var targetInfoMatchers = [\n\n        // grid\n        function (foundCpts, targetInfo) {\n            var xAxisModel = foundCpts.xAxisModel;\n            var yAxisModel = foundCpts.yAxisModel;\n            var gridModel = foundCpts.gridModel;\n\n            !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n            !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n\n            return gridModel && gridModel === targetInfo.gridModel;\n        },\n\n        // geo\n        function (foundCpts, targetInfo) {\n            var geoModel = foundCpts.geoModel;\n            return geoModel && geoModel === targetInfo.geoModel;\n        }\n    ];\n\n    var panelRectBuilder = {\n\n        grid: function () {\n            // grid is not Transformable.\n            return this.coordSys.grid.getRect().clone();\n        },\n\n        geo: function () {\n            var coordSys = this.coordSys;\n            var rect = coordSys.getBoundingRect().clone();\n            // geo roam and zoom transform\n            rect.applyTransform(graphic.getTransform(coordSys));\n            return rect;\n        }\n    };\n\n    var coordConvert = {\n\n        lineX: curry(axisConvert, 0),\n\n        lineY: curry(axisConvert, 1),\n\n        rect: function (to, coordSys, rangeOrCoordRange) {\n            var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);\n            var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);\n            var values = [\n                formatMinMax([xminymin[0], xmaxymax[0]]),\n                formatMinMax([xminymin[1], xmaxymax[1]])\n            ];\n            return {values: values, xyMinMax: values};\n        },\n\n        polygon: function (to, coordSys, rangeOrCoordRange) {\n            var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n            var values = zrUtil.map(rangeOrCoordRange, function (item) {\n                var p = coordSys[COORD_CONVERTS[to]](item);\n                xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n                xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n                xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n                xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n                return p;\n            });\n            return {values: values, xyMinMax: xyMinMax};\n        }\n    };\n\n    function axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n        if (__DEV__) {\n            zrUtil.assert(\n                coordSys.type === 'cartesian2d',\n                'lineX/lineY brush is available only in cartesian2d.'\n            );\n        }\n\n        var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n        var values = formatMinMax(zrUtil.map([0, 1], function (i) {\n            return to\n                ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i]))\n                : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n        }));\n        var xyMinMax = [];\n        xyMinMax[axisNameIndex] = values;\n        xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n\n        return {values: values, xyMinMax: xyMinMax};\n    }\n\n    var diffProcessor = {\n        lineX: curry(axisDiffProcessor, 0),\n\n        lineY: curry(axisDiffProcessor, 1),\n\n        rect: function (values, refer, scales) {\n            return [\n                [values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]],\n                [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]\n            ];\n        },\n\n        polygon: function (values, refer, scales) {\n            return zrUtil.map(values, function (item, idx) {\n                return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n            });\n        }\n    };\n\n    function axisDiffProcessor(axisNameIndex, values, refer, scales) {\n        return [\n            values[0] - scales[axisNameIndex] * refer[0],\n            values[1] - scales[axisNameIndex] * refer[1]\n        ];\n    }\n\n    // We have to process scale caused by dataZoom manually,\n    // although it might be not accurate.\n    function getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n        var sizeCurr = getSize(xyMinMaxCurr);\n        var sizeOrigin = getSize(xyMinMaxOrigin);\n        var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n        isNaN(scales[0]) && (scales[0] = 1);\n        isNaN(scales[1]) && (scales[1] = 1);\n        return scales;\n    }\n\n    function getSize(xyMinMax) {\n        return xyMinMax\n            ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]]\n            : [NaN, NaN];\n    }\n\n    module.exports = BrushTargetManager;\n\n\n/***/ }),\n\n/***/ 1072:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var cursorHelper = __webpack_require__(1056);\n    var BoundingRect = __webpack_require__(982);\n    var graphicUtil = __webpack_require__(973);\n\n    var helper = {};\n\n    helper.makeRectPanelClipPath = function (rect) {\n        rect = normalizeRect(rect);\n        return function (localPoints, transform) {\n            return graphicUtil.clipPointsByRect(localPoints, rect);\n        };\n    };\n\n    helper.makeLinearBrushOtherExtent = function (rect, specifiedXYIndex) {\n        rect = normalizeRect(rect);\n        return function (xyIndex) {\n            var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;\n            var brushWidth = idx ? rect.width : rect.height;\n            var base = idx ? rect.x : rect.y;\n            return [base, base + (brushWidth || 0)];\n        };\n    };\n\n    helper.makeRectIsTargetByCursor = function (rect, api, targetModel) {\n        rect = normalizeRect(rect);\n        return function (e, localCursorPoint, transform) {\n            return rect.contain(localCursorPoint[0], localCursorPoint[1])\n                && !cursorHelper.onIrrelevantElement(e, api, targetModel);\n        };\n    };\n\n    // Consider width/height is negative.\n    function normalizeRect(rect) {\n        return BoundingRect.create(rect);\n    }\n\n    module.exports = helper;\n\n\n\n/***/ }),\n\n/***/ 1073:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    __webpack_require__(983).registerSubTypeDefaulter('dataZoom', function () {\n        // Default 'slider' when no type specified.\n        return 'slider';\n    });\n\n\n\n/***/ }),\n\n/***/ 1074:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @file Data zoom processor\n */\n\n\n    var echarts = __webpack_require__(972);\n\n    echarts.registerProcessor(function (ecModel, api) {\n\n        ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n            // We calculate window and reset axis here but not in model\n            // init stage and not after action dispatch handler, because\n            // reset should be called after seriesData.restoreData.\n            dataZoomModel.eachTargetAxis(resetSingleAxis);\n\n            // Caution: data zoom filtering is order sensitive when using\n            // percent range and no min/max/scale set on axis.\n            // For example, we have dataZoom definition:\n            // [\n            //      {xAxisIndex: 0, start: 30, end: 70},\n            //      {yAxisIndex: 0, start: 20, end: 80}\n            // ]\n            // In this case, [20, 80] of y-dataZoom should be based on data\n            // that have filtered by x-dataZoom using range of [30, 70],\n            // but should not be based on full raw data. Thus sliding\n            // x-dataZoom will change both ranges of xAxis and yAxis,\n            // while sliding y-dataZoom will only change the range of yAxis.\n            // So we should filter x-axis after reset x-axis immediately,\n            // and then reset y-axis and filter y-axis.\n            dataZoomModel.eachTargetAxis(filterSingleAxis);\n        });\n\n        ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n            // Fullfill all of the range props so that user\n            // is able to get them from chart.getOption().\n            var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n            var percentRange = axisProxy.getDataPercentWindow();\n            var valueRange = axisProxy.getDataValueWindow();\n\n            dataZoomModel.setRawRange({\n                start: percentRange[0],\n                end: percentRange[1],\n                startValue: valueRange[0],\n                endValue: valueRange[1]\n            }, true);\n        });\n    });\n\n    function resetSingleAxis(dimNames, axisIndex, dataZoomModel) {\n        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel);\n    }\n\n    function filterSingleAxis(dimNames, axisIndex, dataZoomModel) {\n        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel);\n    }\n\n\n\n\n/***/ }),\n\n/***/ 1075:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @file Data zoom action\n */\n\n\n    var zrUtil = __webpack_require__(971);\n    var helper = __webpack_require__(1020);\n    var echarts = __webpack_require__(972);\n\n\n    echarts.registerAction('dataZoom', function (payload, ecModel) {\n\n        var linkedNodesFinder = helper.createLinkedNodesFinder(\n            zrUtil.bind(ecModel.eachComponent, ecModel, 'dataZoom'),\n            helper.eachAxisDim,\n            function (model, dimNames) {\n                return model.get(dimNames.axisIndex);\n            }\n        );\n\n        var effectedModels = [];\n\n        ecModel.eachComponent(\n            {mainType: 'dataZoom', query: payload},\n            function (model, index) {\n                effectedModels.push.apply(\n                    effectedModels, linkedNodesFinder(model).nodes\n                );\n            }\n        );\n\n        zrUtil.each(effectedModels, function (dataZoomModel, index) {\n            dataZoomModel.setRawRange({\n                start: payload.start,\n                end: payload.end,\n                startValue: payload.startValue,\n                endValue: payload.endValue\n            });\n        });\n\n    });\n\n\n\n/***/ }),\n\n/***/ 1079:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n\n\n    /**\n     * Caution: If the mechanism should be changed some day, these cases\n     * should be considered:\n     *\n     * (1) In `merge option` mode, if using the same option to call `setOption`\n     * many times, the result should be the same (try our best to ensure that).\n     * (2) In `merge option` mode, if a component has no id/name specified, it\n     * will be merged by index, and the result sequence of the components is\n     * consistent to the original sequence.\n     * (3) `reset` feature (in toolbox). Find detailed info in comments about\n     * `mergeOption` in module:echarts/model/OptionManager.\n     */\n\n    var zrUtil = __webpack_require__(971);\n    var modelUtil = __webpack_require__(975);\n    var Model = __webpack_require__(979);\n    var each = zrUtil.each;\n    var filter = zrUtil.filter;\n    var map = zrUtil.map;\n    var isArray = zrUtil.isArray;\n    var indexOf = zrUtil.indexOf;\n    var isObject = zrUtil.isObject;\n\n    var ComponentModel = __webpack_require__(983);\n\n    var globalDefault = __webpack_require__(1106);\n\n    var OPTION_INNER_KEY = '\\0_ec_inner';\n\n    /**\n     * @alias module:echarts/model/Global\n     *\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {Object} theme\n     */\n    var GlobalModel = Model.extend({\n\n        constructor: GlobalModel,\n\n        init: function (option, parentModel, theme, optionManager) {\n            theme = theme || {};\n\n            this.option = null; // Mark as not initialized.\n\n            /**\n             * @type {module:echarts/model/Model}\n             * @private\n             */\n            this._theme = new Model(theme);\n\n            /**\n             * @type {module:echarts/model/OptionManager}\n             */\n            this._optionManager = optionManager;\n        },\n\n        setOption: function (option, optionPreprocessorFuncs) {\n            zrUtil.assert(\n                !(OPTION_INNER_KEY in option),\n                'please use chart.getOption()'\n            );\n\n            this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n            this.resetOption(null);\n        },\n\n        /**\n         * @param {string} type null/undefined: reset all.\n         *                      'recreate': force recreate all.\n         *                      'timeline': only reset timeline option\n         *                      'media': only reset media query option\n         * @return {boolean} Whether option changed.\n         */\n        resetOption: function (type) {\n            var optionChanged = false;\n            var optionManager = this._optionManager;\n\n            if (!type || type === 'recreate') {\n                var baseOption = optionManager.mountOption(type === 'recreate');\n\n                if (!this.option || type === 'recreate') {\n                    initBase.call(this, baseOption);\n                }\n                else {\n                    this.restoreData();\n                    this.mergeOption(baseOption);\n                }\n                optionChanged = true;\n            }\n\n            if (type === 'timeline' || type === 'media') {\n                this.restoreData();\n            }\n\n            if (!type || type === 'recreate' || type === 'timeline') {\n                var timelineOption = optionManager.getTimelineOption(this);\n                timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n            }\n\n            if (!type || type === 'recreate' || type === 'media') {\n                var mediaOptions = optionManager.getMediaOption(this, this._api);\n                if (mediaOptions.length) {\n                    each(mediaOptions, function (mediaOption) {\n                        this.mergeOption(mediaOption, optionChanged = true);\n                    }, this);\n                }\n            }\n\n            return optionChanged;\n        },\n\n        /**\n         * @protected\n         */\n        mergeOption: function (newOption) {\n            var option = this.option;\n            var componentsMap = this._componentsMap;\n            var newCptTypes = [];\n\n            //  component model  merge\n            each(newOption, function (componentOption, mainType) {\n                if (componentOption == null) {\n                    return;\n                }\n\n                if (!ComponentModel.hasClass(mainType)) {\n                    option[mainType] = option[mainType] == null\n                        ? zrUtil.clone(componentOption)\n                        : zrUtil.merge(option[mainType], componentOption, true);\n                }\n                else {\n                    newCptTypes.push(mainType);\n                }\n            });\n\n            // FIXME OPTION \n            ComponentModel.topologicalTravel(\n                newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this\n            );\n\n            this._seriesIndices = this._seriesIndices || [];\n\n            function visitComponent(mainType, dependencies) {\n                var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\n                var mapResult = modelUtil.mappingToExists(\n                    componentsMap.get(mainType), newCptOptionList\n                );\n\n                modelUtil.makeIdAndName(mapResult);\n\n                // Set mainType and complete subType.\n                each(mapResult, function (item, index) {\n                    var opt = item.option;\n                    if (isObject(opt)) {\n                        item.keyInfo.mainType = mainType;\n                        item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n                    }\n                });\n\n                var dependentModels = getComponentsByTypes(\n                    componentsMap, dependencies\n                );\n\n                option[mainType] = [];\n                componentsMap.set(mainType, []);\n\n                each(mapResult, function (resultItem, index) {\n                    var componentModel = resultItem.exist;\n                    var newCptOption = resultItem.option;\n\n                    zrUtil.assert(\n                        isObject(newCptOption) || componentModel,\n                        'Empty component definition'\n                    );\n\n                    // Consider where is no new option and should be merged using {},\n                    // see removeEdgeAndAdd in topologicalTravel and\n                    // ComponentModel.getAllClassMainTypes.\n                    if (!newCptOption) {\n                        componentModel.mergeOption({}, this);\n                        componentModel.optionUpdated({}, false);\n                    }\n                    else {\n                        var ComponentModelClass = ComponentModel.getClass(\n                            mainType, resultItem.keyInfo.subType, true\n                        );\n\n                        if (componentModel && componentModel instanceof ComponentModelClass) {\n                            componentModel.name = resultItem.keyInfo.name;\n                            componentModel.mergeOption(newCptOption, this);\n                            componentModel.optionUpdated(newCptOption, false);\n                        }\n                        else {\n                            // PENDING Global as parent ?\n                            var extraOpt = zrUtil.extend(\n                                {\n                                    dependentModels: dependentModels,\n                                    componentIndex: index\n                                },\n                                resultItem.keyInfo\n                            );\n                            componentModel = new ComponentModelClass(\n                                newCptOption, this, this, extraOpt\n                            );\n                            zrUtil.extend(componentModel, extraOpt);\n                            componentModel.init(newCptOption, this, this, extraOpt);\n                            // Call optionUpdated after init.\n                            // newCptOption has been used as componentModel.option\n                            // and may be merged with theme and default, so pass null\n                            // to avoid confusion.\n                            componentModel.optionUpdated(null, true);\n                        }\n                    }\n\n                    componentsMap.get(mainType)[index] = componentModel;\n                    option[mainType][index] = componentModel.option;\n                }, this);\n\n                // Backup series for filtering.\n                if (mainType === 'series') {\n                    this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n                }\n            }\n        },\n\n        /**\n         * Get option for output (cloned option and inner info removed)\n         * @public\n         * @return {Object}\n         */\n        getOption: function () {\n            var option = zrUtil.clone(this.option);\n\n            each(option, function (opts, mainType) {\n                if (ComponentModel.hasClass(mainType)) {\n                    var opts = modelUtil.normalizeToArray(opts);\n                    for (var i = opts.length - 1; i >= 0; i--) {\n                        // Remove options with inner id.\n                        if (modelUtil.isIdInner(opts[i])) {\n                            opts.splice(i, 1);\n                        }\n                    }\n                    option[mainType] = opts;\n                }\n            });\n\n            delete option[OPTION_INNER_KEY];\n\n            return option;\n        },\n\n        /**\n         * @return {module:echarts/model/Model}\n         */\n        getTheme: function () {\n            return this._theme;\n        },\n\n        /**\n         * @param {string} mainType\n         * @param {number} [idx=0]\n         * @return {module:echarts/model/Component}\n         */\n        getComponent: function (mainType, idx) {\n            var list = this._componentsMap.get(mainType);\n            if (list) {\n                return list[idx || 0];\n            }\n        },\n\n        /**\n         * If none of index and id and name used, return all components with mainType.\n         * @param {Object} condition\n         * @param {string} condition.mainType\n         * @param {string} [condition.subType] If ignore, only query by mainType\n         * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        queryComponents: function (condition) {\n            var mainType = condition.mainType;\n            if (!mainType) {\n                return [];\n            }\n\n            var index = condition.index;\n            var id = condition.id;\n            var name = condition.name;\n\n            var cpts = this._componentsMap.get(mainType);\n\n            if (!cpts || !cpts.length) {\n                return [];\n            }\n\n            var result;\n\n            if (index != null) {\n                if (!isArray(index)) {\n                    index = [index];\n                }\n                result = filter(map(index, function (idx) {\n                    return cpts[idx];\n                }), function (val) {\n                    return !!val;\n                });\n            }\n            else if (id != null) {\n                var isIdArray = isArray(id);\n                result = filter(cpts, function (cpt) {\n                    return (isIdArray && indexOf(id, cpt.id) >= 0)\n                        || (!isIdArray && cpt.id === id);\n                });\n            }\n            else if (name != null) {\n                var isNameArray = isArray(name);\n                result = filter(cpts, function (cpt) {\n                    return (isNameArray && indexOf(name, cpt.name) >= 0)\n                        || (!isNameArray && cpt.name === name);\n                });\n            }\n            else {\n                // Return all components with mainType\n                result = cpts.slice();\n            }\n\n            return filterBySubType(result, condition);\n        },\n\n        /**\n         * The interface is different from queryComponents,\n         * which is convenient for inner usage.\n         *\n         * @usage\n         * var result = findComponents(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series'},\n         *     function (model, index) {...}\n         * );\n         * // result like [component0, componnet1, ...]\n         *\n         * @param {Object} condition\n         * @param {string} condition.mainType Mandatory.\n         * @param {string} [condition.subType] Optional.\n         * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n         *        where xxx is mainType.\n         *        If query attribute is null/undefined or has no index/id/name,\n         *        do not filtering by query conditions, which is convenient for\n         *        no-payload situations or when target of action is global.\n         * @param {Function} [condition.filter] parameter: component, return boolean.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        findComponents: function (condition) {\n            var query = condition.query;\n            var mainType = condition.mainType;\n\n            var queryCond = getQueryCond(query);\n            var result = queryCond\n                ? this.queryComponents(queryCond)\n                : this._componentsMap.get(mainType);\n\n            return doFilter(filterBySubType(result, condition));\n\n            function getQueryCond(q) {\n                var indexAttr = mainType + 'Index';\n                var idAttr = mainType + 'Id';\n                var nameAttr = mainType + 'Name';\n                return q && (\n                        q[indexAttr] != null\n                        || q[idAttr] != null\n                        || q[nameAttr] != null\n                    )\n                    ? {\n                        mainType: mainType,\n                        // subType will be filtered finally.\n                        index: q[indexAttr],\n                        id: q[idAttr],\n                        name: q[nameAttr]\n                    }\n                    : null;\n            }\n\n            function doFilter(res) {\n                return condition.filter\n                     ? filter(res, condition.filter)\n                     : res;\n            }\n        },\n\n        /**\n         * @usage\n         * eachComponent('legend', function (legendModel, index) {\n         *     ...\n         * });\n         * eachComponent(function (componentType, model, index) {\n         *     // componentType does not include subType\n         *     // (componentType is 'xxx' but not 'xxx.aa')\n         * });\n         * eachComponent(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n         *     function (model, index) {...}\n         * );\n         * eachComponent(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n         *     function (model, index) {...}\n         * );\n         *\n         * @param {string|Object=} mainType When mainType is object, the definition\n         *                                  is the same as the method 'findComponents'.\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachComponent: function (mainType, cb, context) {\n            var componentsMap = this._componentsMap;\n\n            if (typeof mainType === 'function') {\n                context = cb;\n                cb = mainType;\n                componentsMap.each(function (components, componentType) {\n                    each(components, function (component, index) {\n                        cb.call(context, componentType, component, index);\n                    });\n                });\n            }\n            else if (zrUtil.isString(mainType)) {\n                each(componentsMap.get(mainType), cb, context);\n            }\n            else if (isObject(mainType)) {\n                var queryResult = this.findComponents(mainType);\n                each(queryResult, cb, context);\n            }\n        },\n\n        /**\n         * @param {string} name\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByName: function (name) {\n            var series = this._componentsMap.get('series');\n            return filter(series, function (oneSeries) {\n                return oneSeries.name === name;\n            });\n        },\n\n        /**\n         * @param {number} seriesIndex\n         * @return {module:echarts/model/Series}\n         */\n        getSeriesByIndex: function (seriesIndex) {\n            return this._componentsMap.get('series')[seriesIndex];\n        },\n\n        /**\n         * @param {string} subType\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByType: function (subType) {\n            var series = this._componentsMap.get('series');\n            return filter(series, function (oneSeries) {\n                return oneSeries.subType === subType;\n            });\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeries: function () {\n            return this._componentsMap.get('series').slice();\n        },\n\n        /**\n         * After filtering, series may be different\n         * frome raw series.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.get('series')[rawSeriesIndex];\n                cb.call(context, series, rawSeriesIndex);\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeries: function (cb, context) {\n            each(this._componentsMap.get('series'), cb, context);\n        },\n\n        /**\n         * After filtering, series may be different.\n         * frome raw series.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeriesByType: function (subType, cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.get('series')[rawSeriesIndex];\n                if (series.subType === subType) {\n                    cb.call(context, series, rawSeriesIndex);\n                }\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered of given type.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeriesByType: function (subType, cb, context) {\n            return each(this.getSeriesByType(subType), cb, context);\n        },\n\n        /**\n         * @param {module:echarts/model/Series} seriesModel\n         */\n        isSeriesFiltered: function (seriesModel) {\n            assertSeriesInitialized(this);\n            return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getCurrentSeriesIndices: function () {\n            return (this._seriesIndices || []).slice();\n        },\n\n        /**\n         * @param {Function} cb\n         * @param {*} context\n         */\n        filterSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            var filteredSeries = filter(\n                this._componentsMap.get('series'), cb, context\n            );\n            this._seriesIndices = createSeriesIndices(filteredSeries);\n        },\n\n        restoreData: function () {\n            var componentsMap = this._componentsMap;\n\n            this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n\n            var componentTypes = [];\n            componentsMap.each(function (components, componentType) {\n                componentTypes.push(componentType);\n            });\n\n            ComponentModel.topologicalTravel(\n                componentTypes,\n                ComponentModel.getAllClassMainTypes(),\n                function (componentType, dependencies) {\n                    each(componentsMap.get(componentType), function (component) {\n                        component.restoreData();\n                    });\n                }\n            );\n        }\n\n    });\n\n    /**\n     * @inner\n     */\n    function mergeTheme(option, theme) {\n        zrUtil.each(theme, function (themeItem, name) {\n            //  component model  merge  model \n            if (!ComponentModel.hasClass(name)) {\n                if (typeof themeItem === 'object') {\n                    option[name] = !option[name]\n                        ? zrUtil.clone(themeItem)\n                        : zrUtil.merge(option[name], themeItem, false);\n                }\n                else {\n                    if (option[name] == null) {\n                        option[name] = themeItem;\n                    }\n                }\n            }\n        });\n    }\n\n    function initBase(baseOption) {\n        baseOption = baseOption;\n\n        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n        this.option = {};\n        this.option[OPTION_INNER_KEY] = 1;\n\n        /**\n         * Init with series: [], in case of calling findSeries method\n         * before series initialized.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @private\n         */\n        this._componentsMap = zrUtil.createHashMap({series: []});\n\n        /**\n         * Mapping between filtered series list and raw series list.\n         * key: filtered series indices, value: raw series indices.\n         * @type {Array.<nubmer>}\n         * @private\n         */\n        this._seriesIndices = null;\n\n        mergeTheme(baseOption, this._theme.option);\n\n        // TODO Needs clone when merging to the unexisted property\n        zrUtil.merge(baseOption, globalDefault, false);\n\n        this.mergeOption(baseOption);\n    }\n\n    /**\n     * @inner\n     * @param {Array.<string>|string} types model types\n     * @return {Object} key: {string} type, value: {Array.<Object>} models\n     */\n    function getComponentsByTypes(componentsMap, types) {\n        if (!zrUtil.isArray(types)) {\n            types = types ? [types] : [];\n        }\n\n        var ret = {};\n        each(types, function (type) {\n            ret[type] = (componentsMap.get(type) || []).slice();\n        });\n\n        return ret;\n    }\n\n    /**\n     * @inner\n     */\n    function determineSubType(mainType, newCptOption, existComponent) {\n        var subType = newCptOption.type\n            ? newCptOption.type\n            : existComponent\n            ? existComponent.subType\n            // Use determineSubType only when there is no existComponent.\n            : ComponentModel.determineSubType(mainType, newCptOption);\n\n        // tooltip, markline, markpoint may always has no subType\n        return subType;\n    }\n\n    /**\n     * @inner\n     */\n    function createSeriesIndices(seriesModels) {\n        return map(seriesModels, function (series) {\n            return series.componentIndex;\n        }) || [];\n    }\n\n    /**\n     * @inner\n     */\n    function filterBySubType(components, condition) {\n        // Using hasOwnProperty for restrict. Consider\n        // subType is undefined in user payload.\n        return condition.hasOwnProperty('subType')\n            ? filter(components, function (cpt) {\n                return cpt.subType === condition.subType;\n            })\n            : components;\n    }\n\n    /**\n     * @inner\n     */\n    function assertSeriesInitialized(ecModel) {\n        // Components that use _seriesIndices should depends on series component,\n        // which make sure that their initialization is after series.\n        if (__DEV__) {\n            if (!ecModel._seriesIndices) {\n                throw new Error('Option should contains series.');\n            }\n        }\n    }\n\n    zrUtil.mixin(GlobalModel, __webpack_require__(1039));\n\n    module.exports = GlobalModel;\n\n\n/***/ }),\n\n/***/ 1080:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    var getLineStyle = __webpack_require__(1006)(\n        [\n            ['lineWidth', 'width'],\n            ['stroke', 'color'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getLineStyle: function (excludes) {\n            var style = getLineStyle.call(this, excludes);\n            var lineDash = this.getLineDash(style.lineWidth);\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getLineDash: function (lineWidth) {\n            if (lineWidth == null) {\n                lineWidth = 1;\n            }\n            var lineType = this.get('type');\n            var dotSize = Math.max(lineWidth, 2);\n            var dashSize = lineWidth * 4;\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize]);\n        }\n    };\n\n\n/***/ }),\n\n/***/ 1081:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    module.exports = {\n        getAreaStyle: __webpack_require__(1006)(\n            [\n                ['fill', 'color'],\n                ['shadowBlur'],\n                ['shadowOffsetX'],\n                ['shadowOffsetY'],\n                ['opacity'],\n                ['shadowColor']\n            ]\n        )\n    };\n\n\n/***/ }),\n\n/***/ 1082:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var textContain = __webpack_require__(985);\n    var graphicUtil = __webpack_require__(973);\n\n    var PATH_COLOR = ['textStyle', 'color'];\n\n    module.exports = {\n        /**\n         * Get color property or get color from option.textStyle.color\n         * @param {boolean} [isEmphasis]\n         * @return {string}\n         */\n        getTextColor: function (isEmphasis) {\n            var ecModel = this.ecModel;\n            return this.getShallow('color')\n                || (\n                    (!isEmphasis && ecModel) ? ecModel.get(PATH_COLOR) : null\n                );\n        },\n\n        /**\n         * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n         * @return {string}\n         */\n        getFont: function () {\n            return graphicUtil.getFont({\n                fontStyle: this.getShallow('fontStyle'),\n                fontWeight: this.getShallow('fontWeight'),\n                fontSize: this.getShallow('fontSize'),\n                fontFamily: this.getShallow('fontFamily')\n            }, this.ecModel);\n        },\n\n        getTextRect: function (text) {\n            return textContain.getBoundingRect(\n                text,\n                this.getFont(),\n                this.getShallow('align'),\n                this.getShallow('verticalAlign') || this.getShallow('baseline'),\n                this.getShallow('padding'),\n                this.getShallow('rich'),\n                this.getShallow('truncateText')\n            );\n        }\n    };\n\n\n/***/ }),\n\n/***/ 1083:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var Path = __webpack_require__(980);\n    var PathProxy = __webpack_require__(999);\n    var transformPath = __webpack_require__(1090);\n\n    // command chars\n    var cc = [\n        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n    ];\n\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n\n    var vMag = function(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function(u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n                * Math.acos(vRatio(u, v));\n    };\n\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180.0);\n        var xp = mathCos(psi) * (x1 - x2) / 2.0\n                 + mathSin(psi) * (y1 - y2) / 2.0;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n                 + mathCos(psi) * (y1 - y2) / 2.0;\n\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n\n        var f = (fa === fs ? -1 : 1)\n            * mathSqrt((((rx * rx) * (ry * ry))\n                    - ((rx * rx) * (yp * yp))\n                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                    + (ry * ry) * (xp * xp))\n                ) || 0;\n\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n\n        var cx = (x1 + x2) / 2.0\n                 + mathCos(psi) * cxp\n                 - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2.0\n                + mathSin(psi) * cxp\n                + mathCos(psi) * cyp;\n\n        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n        var dTheta = vAngle(u, v);\n\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n\n        // command string\n        var cs = data.replace(/-/g, ' -')\n            .replace(/  /g, ' ')\n            .replace(/ /g, ',')\n            .replace(/,,/g, ',');\n\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n\n                var x1 = cpx;\n                var y1 = cpy;\n\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                    case 'l':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'm':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'l';\n                        break;\n                    case 'M':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'L';\n                        break;\n                    case 'h':\n                        cpx += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'C':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n                        );\n                        cpx = p[off - 2];\n                        cpy = p[off - 1];\n                        break;\n                    case 'c':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy\n                        );\n                        cpx += p[off - 2];\n                        cpy += p[off - 1];\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = cpx + p[off++];\n                        y1 = cpy + p[off++];\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 'Q':\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'q':\n                        x1 = p[off++] + cpx;\n                        y1 = p[off++] + cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                    case 'a':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                }\n            }\n\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n\n            prevCmd = cmd;\n        }\n\n        path.toStatic();\n\n        return path;\n    }\n\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            if (path.setData) {\n                path.setData(pathProxy.data);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            }\n            else {\n                var ctx = path;\n                pathProxy.rebuildPath(ctx);\n            }\n        };\n\n        opts.applyTransform = function (m) {\n            transformPath(pathProxy, m);\n\n            this.dirty(true);\n        };\n\n        return opts;\n    }\n\n    module.exports = {\n        /**\n         * Create a Path object from path string data\n         * http://www.w3.org/TR/SVG/paths.html#PathData\n         * @param  {Object} opts Other options\n         */\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n\n        /**\n         * Create a Path class from path string data\n         * @param  {string} str\n         * @param  {Object} opts Other options\n         */\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n\n        /**\n         * Merge multiple paths\n         */\n        // TODO Apply transform\n        // TODO stroke dash\n        // TODO Optimize double memory cost problem\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (!pathEl.path) {\n                    pathEl.createPathProxy();\n                }\n                if (pathEl.__dirtyPath) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n\n            var pathBundle = new Path(opts);\n            // Need path proxy.\n            pathBundle.createPathProxy();\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n\n            return pathBundle;\n        }\n    };\n\n\n/***/ }),\n\n/***/ 1084:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @module zrender/mixin/Animatable\n */\n\n\n    var Animator = __webpack_require__(1034);\n    var util = __webpack_require__(971);\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = __webpack_require__(1025);\n\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n\n    Animatable.prototype = {\n\n        constructor: Animatable,\n\n        /**\n         * \n         *\n         * @param {string} path The path to fetch value from object, like 'a.b.c'.\n         * @param {boolean} [loop] Whether to loop animation.\n         * @return {module:zrender/animation/Animator}\n         * @example:\n         *     el.animate('style', false)\n         *         .when(1000, {x: 10} )\n         *         .done(function(){ // Animation done })\n         *         .start()\n         */\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            }\n            else {\n                target = el;\n            }\n\n            if (!target) {\n                log(\n                    'Property \"'\n                    + path\n                    + '\" is not existed in element '\n                    + el.id\n                );\n                return;\n            }\n\n            var animators = el.animators;\n\n            var animator = new Animator(target, loop);\n\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            })\n            .done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n\n            animators.push(animator);\n\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n\n            return animator;\n        },\n\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n\n            return this;\n        },\n\n        /**\n         * Caution: this method will stop previous animation.\n         * So do not use this method to one element twice before\n         * animation starts, unless you know what you are doing.\n         * @param {Object} target\n         * @param {number} [time=500] Time in ms\n         * @param {string} [easing='linear']\n         * @param {number} [delay=0]\n         * @param {Function} [callback]\n         * @param {Function} [forceAnimate] Prevent stop animation and callback\n         *        immediently when target values are the same as current values.\n         *\n         * @example\n         *  // Animate position\n         *  el.animateTo({\n         *      position: [10, 10]\n         *  }, function () { // done })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n         *  el.animateTo({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100, 'cubicOut', function () { // done })\n         */\n         // TODO Return animation key\n        animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }\n            // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }\n            // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }\n            // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }\n            // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i]\n                    .done(done)\n                    .start(easing, forceAnimate);\n            }\n        },\n\n        /**\n         * @private\n         * @param {string} path=''\n         * @param {Object} source=this\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         *\n         * @example\n         *  // Animate position\n         *  el._animateToShallow({\n         *      position: [10, 10]\n         *  })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms\n         *  el._animateToShallow({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100)\n         */\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (!target.hasOwnProperty(name)) {\n                    continue;\n                }\n\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(\n                            path ? path + '.' + name : name,\n                            source[name],\n                            target[name],\n                            time,\n                            delay\n                        );\n                    }\n                    else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                }\n                else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    }\n                    else {  // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n\n            if (propertyCount > 0) {\n                this.animate(path, false)\n                    .when(time == null ? 500 : time, objShallow)\n                    .delay(delay || 0);\n            }\n\n            return this;\n        }\n    };\n\n    module.exports = Animatable;\n\n\n/***/ }),\n\n/***/ 1085:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @config target onframe\n * @config life(1000) \n * @config delay(0) \n * @config loop(true)\n * @config gap(0) \n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\n\n    var easingFuncs = __webpack_require__(1086);\n\n    function Clip(options) {\n\n        this._target = options.target;\n\n        // \n        this._life = options.life || 1000;\n        // \n        this._delay = options.delay || 0;\n        // \n        // this._startTime = new Date().getTime() + this._delay;// \n        this._initialized = false;\n\n        // \n        this.loop = options.loop == null ? false : options.loop;\n\n        this.gap = options.gap || 0;\n\n        this.easing = options.easing || 'Linear';\n\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n\n        this._pausedTime = 0;\n        this._paused = false;\n    }\n\n    Clip.prototype = {\n\n        constructor: Clip,\n\n        step: function (globalTime, deltaTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n\n            if (this._paused) {\n                this._pausedTime += deltaTime;\n                return;\n            }\n\n            var percent = (globalTime - this._startTime - this._pausedTime) / this._life;\n\n            // \n            if (percent < 0) {\n                return;\n            }\n\n            percent = Math.min(percent, 1);\n\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n\n            this.fire('frame', schedule);\n\n            // \n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart (globalTime);\n                    // \n                    //  stage.update \n                    return 'restart';\n                }\n\n                // \n                // Animation.update\n                this._needsRemove = true;\n                return 'destroy';\n            }\n\n            return null;\n        },\n\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n            this._pausedTime = 0;\n\n            this._needsRemove = false;\n        },\n\n        fire: function (eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        },\n\n        pause: function () {\n            this._paused = true;\n        },\n\n        resume: function () {\n            this._paused = false;\n        }\n    };\n\n    module.exports = Clip;\n\n\n\n/***/ }),\n\n/***/ 1086:\n/***/ (function(module, exports) {\n\n/**\n *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\n\n    var easing = {\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        linear: function (k) {\n            return k;\n        },\n\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n\n        // t^3\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n\n        // t^4\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n\n        // t^5\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n\n        // sin(t)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n\n        // 2^t\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n\n        // sqrt(1-t^2)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1)) *\n                        Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k) *\n                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    module.exports = easing;\n\n\n\n\n/***/ }),\n\n/***/ 1087:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var CMD = __webpack_require__(999).CMD;\n    var line = __webpack_require__(1060);\n    var cubic = __webpack_require__(1088);\n    var quadratic = __webpack_require__(1061);\n    var arc = __webpack_require__(1089);\n    var normalizeRadian = __webpack_require__(1036).normalizeRadian;\n    var curve = __webpack_require__(991);\n\n    var windingLine = __webpack_require__(1062);\n\n    var containStroke = line.containStroke;\n\n    var PI2 = Math.PI * 2;\n\n    var EPSILON = 1e-4;\n\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    // \n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) { // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                }\n                else {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {   // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            }\n            else {\n                // Remove one endpoint.\n                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {   // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n\n    // TODO\n    // Arc \n    function windingArc(\n        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n    ) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 1e-4) {\n            return 0;\n        }\n        if (diff % PI2 < 1e-4) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (\n                    (angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n                ) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n                //  subpath \n                // if (w !== 0) {\n                //     return true;\n                // }\n            }\n\n            if (i == 1) {\n                //  L, C, Q\n                //  previous point  point\n                //\n                //  Arc \n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo  subpath, \n                    //  closePath \n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // NOTE  L, C, Q  NaN\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    if (isStroke) {\n                        if (cubic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(\n                            xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    if (isStroke) {\n                        if (quadratic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(\n                            xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc \n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    // TODO Arc \n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    var x1 = Math.cos(theta) * rx + cx;\n                    var y1 = Math.sin(theta) * ry + cy;\n                    //  arc \n                    if (i > 1) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        // \n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    // zr scale, x\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (arc.containStroke(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            lineWidth, _x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            _x, y\n                        );\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    var x1 = x0 + width;\n                    var y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n                        ) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // FIXME Clockwise ?\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD.Z:\n                    if (isStroke) {\n                        if (containStroke(\n                            xi, yi, x0, y0, lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // Close a subpath\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                        //  subpath \n                        // FIXME subpaths may overlap\n                        // if (w !== 0) {\n                        //     return true;\n                        // }\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n\n    module.exports = {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n\n\n/***/ }),\n\n/***/ 1088:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var curve = __webpack_require__(991);\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  x3\n         * @param  {number}  y3\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(\n                x0, y0, x1, y1, x2, y2, x3, y3,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n/***/ }),\n\n/***/ 1089:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var normalizeRadian = __webpack_require__(1036).normalizeRadian;\n    var PI2 = Math.PI * 2;\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  cx\n         * @param  {number}  cy\n         * @param  {number}  r\n         * @param  {number}  startAngle\n         * @param  {number}  endAngle\n         * @param  {boolean}  anticlockwise\n         * @param  {number} lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {Boolean}\n         */\n        containStroke: function (\n            cx, cy, r, startAngle, endAngle, anticlockwise,\n            lineWidth, x, y\n        ) {\n\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n\n            if ((d - _l > r) || (d + _l < r)) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n        }\n    };\n\n\n/***/ }),\n\n/***/ 1090:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var CMD = __webpack_require__(999).CMD;\n    var vec2 = __webpack_require__(976);\n    var v2ApplyTransform = vec2.applyTransform;\n\n    var points = [[], [], []];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n\n            switch (cmd) {\n                case M:\n                    nPoint = 1;\n                    break;\n                case L:\n                    nPoint = 1;\n                    break;\n                case C:\n                    nPoint = 3;\n                    break;\n                case Q:\n                    nPoint = 2;\n                    break;\n                case A:\n                    var x = m[4];\n                    var y = m[5];\n                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                    // cx\n                    data[i] *= sx;\n                    data[i++] += x;\n                    // cy\n                    data[i] *= sy;\n                    data[i++] += y;\n                    // Scale rx and ry\n                    // FIXME Assume psi is 0 here\n                    data[i++] *= sx;\n                    data[i++] *= sy;\n\n                    // Start angle\n                    data[i++] += angle;\n                    // end angle\n                    data[i++] += angle;\n                    // FIXME psi\n                    i += 2;\n                    j = i;\n                    break;\n                case R:\n                    // x0, y0\n                    p[0] = data[i++];\n                    p[1] = data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n                    // x1, y1\n                    p[0] += data[i++];\n                    p[1] += data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n            }\n\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n\n    module.exports = transformPath;\n\n\n/***/ }),\n\n/***/ 1091:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * \n * @module zrender/shape/Circle\n */\n\n\n\n    module.exports = __webpack_require__(980).extend({\n\n        type: 'circle',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n\n\n        buildPath : function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // else {\n            //     if (ctx.allocate && !ctx.data.length) {\n            //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n            //     }\n            // }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n\n\n\n/***/ }),\n\n/***/ 1092:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/graphic/shape/Sector\n */\n\n\n\n    var Path = __webpack_require__(980);\n    var fixClipWithShadow = __webpack_require__(1049);\n\n    module.exports = Path.extend({\n\n        type: 'sector',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r0: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        brush: fixClipWithShadow(Path.prototype.brush),\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n            ctx.lineTo(\n                Math.cos(endAngle) * r0 + x,\n                Math.sin(endAngle) * r0 + y\n            );\n\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n\n            ctx.closePath();\n        }\n    });\n\n\n\n/***/ }),\n\n/***/ 1093:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/graphic/shape/Ring\n */\n\n\n    module.exports = __webpack_require__(980).extend({\n\n        type: 'ring',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n\n\n\n/***/ }),\n\n/***/ 1094:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/shape/Polygon\n */\n\n\n    var polyHelper = __webpack_require__(1038);\n\n    module.exports = __webpack_require__(980).extend({\n        \n        type: 'polygon',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n\n\n/***/ }),\n\n/***/ 1095:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Catmull-Rom spline \n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n    var vec2 = __webpack_require__(976);\n\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points \n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    module.exports = function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n\n            var w = pos - idx;\n\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n\n            var w2 = w * w;\n            var w3 = w * w2;\n\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n\n\n\n/***/ }),\n\n/***/ 1096:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n\n    var vec2 = __webpack_require__(976);\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n\n    /**\n     * \n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points \n     * @param {number} smooth , 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint \n     *                            [[0, 0], [100, 100]], \n     *                           \n     * @param {Array} \n     */\n    module.exports = function (points, smooth, isLoop, constraint) {\n        var cps = [];\n\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n\n        var min, max;\n        if (constraint) {\n            min = [Infinity, Infinity];\n            max = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // \n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n\n            vec2.sub(v, nextPoint, prevPoint);\n\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n\n        return cps;\n    };\n\n\n\n/***/ }),\n\n/***/ 1097:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module zrender/graphic/shape/Polyline\n */\n\n\n    var polyHelper = __webpack_require__(1038);\n\n    module.exports = __webpack_require__(980).extend({\n        \n        type: 'polyline',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        style: {\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n\n\n/***/ }),\n\n/***/ 1098:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/graphic/shape/Rect\n */\n\n\n    var roundRectHelper = __webpack_require__(1035);\n\n    module.exports = __webpack_require__(980).extend({\n\n        type: 'rect',\n\n        shape: {\n            // r1r2r3r4\n            // r1          [1, 1, 1, 1]\n            // r[1]        [1, 1, 1, 1]\n            // r[1, 2]     [1, 2, 1, 2]\n            // r[1, 2, 3]  [1, 2, 3, 2]\n            r: 0,\n\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n\n\n\n/***/ }),\n\n/***/ 1099:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/graphic/shape/Line\n */\n\n    module.exports = __webpack_require__(980).extend({\n\n        type: 'line',\n\n        shape: {\n            // Start point\n            x1: 0,\n            y1: 0,\n            // End point\n            x2: 0,\n            y2: 0,\n\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} percent\n         * @return {Array.<number>}\n         */\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n\n\n\n/***/ }),\n\n/***/ 1100:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * \n * @module zrender/shape/BezierCurve\n */\n\n\n    var curveTool = __webpack_require__(991);\n    var vec2 = __webpack_require__(976);\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\n    var out = [];\n\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        }\n        else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    module.exports = __webpack_require__(980).extend({\n\n        type: 'bezier-curve',\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            // cpx2: 0,\n            // cpy2: 0\n\n            // Curve show percent, for animating\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(\n                        x1, cpx1, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(\n                        y1, cpy1, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n\n                ctx.quadraticCurveTo(\n                    cpx1, cpy1,\n                    x2, y2\n                );\n            }\n            else {\n                if (percent < 1) {\n                    cubicSubdivide(\n                        x1, cpx1, cpx2, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(\n                        y1, cpy1, cpy2, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(\n                    cpx1, cpy1,\n                    cpx2, cpy2,\n                    x2, y2\n                );\n            }\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n\n        /**\n         * Get tangent at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n\n\n\n/***/ }),\n\n/***/ 1101:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module zrender/graphic/shape/Arc\n */\n \n\n    module.exports = __webpack_require__(980).extend({\n\n        type: 'arc',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        style: {\n\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n\n\n/***/ }),\n\n/***/ 1102:\n/***/ (function(module, exports, __webpack_require__) {\n\n// CompoundPath to improve performance\n\n\n    var Path = __webpack_require__(980);\n\n    module.exports = Path.extend({\n\n        type: 'compound',\n\n        shape: {\n\n            paths: null\n        },\n\n        _updatePathDirty: function () {\n            var dirtyPath = this.__dirtyPath;\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                // Mark as dirty if any subpath is dirty\n                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n            }\n            this.__dirtyPath = dirtyPath;\n            this.__dirty = this.__dirty || dirtyPath;\n        },\n\n        beforeBrush: function () {\n            this._updatePathDirty();\n            var paths = this.shape.paths || [];\n            var scale = this.getGlobalScale();\n            // Update path scale\n            for (var i = 0; i < paths.length; i++) {\n                if (!paths[i].path) {\n                    paths[i].createPathProxy();\n                }\n                paths[i].path.setScale(scale[0], scale[1]);\n            }\n        },\n\n        buildPath: function (ctx, shape) {\n            var paths = shape.paths || [];\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].buildPath(ctx, paths[i].shape, true);\n            }\n        },\n\n        afterBrush: function () {\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].__dirtyPath = false;\n            }\n        },\n\n        getBoundingRect: function () {\n            this._updatePathDirty();\n            return Path.prototype.getBoundingRect.call(this);\n        }\n    });\n\n\n/***/ }),\n\n/***/ 1103:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(971);\n\n    var Gradient = __webpack_require__(1010);\n\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {type: 'radial', colorStops: ...}`, where\n        // this constructor will not be called.\n\n        this.x = x == null ? 0.5 : x;\n\n        this.y = y == null ? 0.5 : y;\n\n        this.r = r == null ? 0.5 : r;\n\n        // Can be cloned\n        this.type = 'radial';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    RadialGradient.prototype = {\n\n        constructor: RadialGradient\n    };\n\n    zrUtil.inherits(RadialGradient, Gradient);\n\n    module.exports = RadialGradient;\n\n\n/***/ }),\n\n/***/ 1104:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    var getItemStyle = __webpack_require__(1006)(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor'],\n            ['textPosition'],\n            ['textAlign']\n        ]\n    );\n    module.exports = {\n        getItemStyle: function (excludes, includes) {\n            var style = getItemStyle.call(this, excludes, includes);\n            var lineDash = this.getBorderLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getBorderLineDash: function () {\n            var lineType = this.get('borderType');\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [5, 5] : [1, 1]);\n        }\n    };\n\n\n/***/ }),\n\n/***/ 1105:\n/***/ (function(module, exports) {\n\n\n\n    module.exports = {\n        getBoxLayoutParams: function () {\n            return {\n                left: this.get('left'),\n                top: this.get('top'),\n                right: this.get('right'),\n                bottom: this.get('bottom'),\n                width: this.get('width'),\n                height: this.get('height')\n            };\n        }\n    };\n\n\n/***/ }),\n\n/***/ 1106:\n/***/ (function(module, exports) {\n\n\n    var platform = '';\n    // Navigator not exists in node\n    if (typeof navigator !== 'undefined') {\n        platform = navigator.platform || '';\n    }\n    module.exports = {\n        // \n        // backgroundColor: 'rgba(0,0,0,0)',\n\n        // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n        // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n        // \n        // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n        // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n        // \n        color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],\n\n        //  Grid \n        // grid: {},\n        // \n        textStyle: {\n            // color: '#000',\n            // decoration: 'none',\n            // PENDING\n            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n            // fontFamily: 'Arial, Verdana, sans-serif',\n            fontSize: 12,\n            fontStyle: 'normal',\n            fontWeight: 'normal'\n        },\n\n        // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n        // Default is source-over\n        blendMode: null,\n\n        animation: 'auto',\n        animationDuration: 1000,\n        animationDurationUpdate: 300,\n        animationEasing: 'exponentialOut',\n        animationEasingUpdate: 'cubicOut',\n\n        animationThreshold: 2000,\n        // Configuration for progressive/incremental rendering\n        progressiveThreshold: 3000,\n        progressive: 400,\n\n        // Threshold of if use single hover layer to optimize.\n        // It is recommended that `hoverLayerThreshold` is equivalent to or less than\n        // `progressiveThreshold`, otherwise hover will cause restart of progressive,\n        // which is unexpected.\n        // see example <echarts/test/heatmap-large.html>.\n        hoverLayerThreshold: 3000,\n\n        // See: module:echarts/scale/Time\n        useUTC: false\n    };\n\n\n/***/ }),\n\n/***/ 1107:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(971);\n\n    var echartsAPIList = [\n        'getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isDisposed',\n        'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption',\n        'getViewOfComponentModel', 'getViewOfSeriesModel'\n    ];\n    // And `getCoordinateSystems` and `getComponentByElement` will be injected in echarts.js\n\n    function ExtensionAPI(chartInstance) {\n        zrUtil.each(echartsAPIList, function (name) {\n            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n        }, this);\n    }\n\n    module.exports = ExtensionAPI;\n\n\n/***/ }),\n\n/***/ 1108:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * ECharts option manager\n *\n * @module {echarts/model/OptionManager}\n */\n\n\n\n    var zrUtil = __webpack_require__(971);\n    var modelUtil = __webpack_require__(975);\n    var ComponentModel = __webpack_require__(983);\n    var each = zrUtil.each;\n    var clone = zrUtil.clone;\n    var map = zrUtil.map;\n    var merge = zrUtil.merge;\n\n    var QUERY_REG = /^(min|max)?(.+)$/;\n\n    /**\n     * TERM EXPLANATIONS:\n     *\n     * [option]:\n     *\n     *     An object that contains definitions of components. For example:\n     *     var option = {\n     *         title: {...},\n     *         legend: {...},\n     *         visualMap: {...},\n     *         series: [\n     *             {data: [...]},\n     *             {data: [...]},\n     *             ...\n     *         ]\n     *     };\n     *\n     * [rawOption]:\n     *\n     *     An object input to echarts.setOption. 'rawOption' may be an\n     *     'option', or may be an object contains multi-options. For example:\n     *     var option = {\n     *         baseOption: {\n     *             title: {...},\n     *             legend: {...},\n     *             series: [\n     *                 {data: [...]},\n     *                 {data: [...]},\n     *                 ...\n     *             ]\n     *         },\n     *         timeline: {...},\n     *         options: [\n     *             {title: {...}, series: {data: [...]}},\n     *             {title: {...}, series: {data: [...]}},\n     *             ...\n     *         ],\n     *         media: [\n     *             {\n     *                 query: {maxWidth: 320},\n     *                 option: {series: {x: 20}, visualMap: {show: false}}\n     *             },\n     *             {\n     *                 query: {minWidth: 320, maxWidth: 720},\n     *                 option: {series: {x: 500}, visualMap: {show: true}}\n     *             },\n     *             {\n     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n     *             }\n     *         ]\n     *     };\n     *\n     * @alias module:echarts/model/OptionManager\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function OptionManager(api) {\n\n        /**\n         * @private\n         * @type {module:echarts/ExtensionAPI}\n         */\n        this._api = api;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._timelineOptions = [];\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._mediaList = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._mediaDefault;\n\n        /**\n         * -1, means default.\n         * empty means no media.\n         * @private\n         * @type {Array.<number>}\n         */\n        this._currentMediaIndices = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._optionBackup;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._newBaseOption;\n    }\n\n    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n    // rawOption cloned and backuped when timeline changed, which does no\n    // good to performance. What's more, that both timeline and setOption\n    // method supply 'notMerge' brings complex and some problems.\n    // Consider this case:\n    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\n    OptionManager.prototype = {\n\n        constructor: OptionManager,\n\n        /**\n         * @public\n         * @param {Object} rawOption Raw option.\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Array.<Function>} optionPreprocessorFuncs\n         * @return {Object} Init option\n         */\n        setOption: function (rawOption, optionPreprocessorFuncs) {\n            rawOption = clone(rawOption, true);\n\n            // FIXME\n            //  timeline options  media baseOption\n\n            var oldOptionBackup = this._optionBackup;\n            var newParsedOption = parseRawOption.call(\n                this, rawOption, optionPreprocessorFuncs, !oldOptionBackup\n            );\n            this._newBaseOption = newParsedOption.baseOption;\n\n            // For setOption at second time (using merge mode);\n            if (oldOptionBackup) {\n                // Only baseOption can be merged.\n                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\n                // For simplicity, timeline options and media options do not support merge,\n                // that is, if you `setOption` twice and both has timeline options, the latter\n                // timeline opitons will not be merged to the formers, but just substitude them.\n                if (newParsedOption.timelineOptions.length) {\n                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n                }\n                if (newParsedOption.mediaList.length) {\n                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n                }\n                if (newParsedOption.mediaDefault) {\n                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n                }\n            }\n            else {\n                this._optionBackup = newParsedOption;\n            }\n        },\n\n        /**\n         * @param {boolean} isRecreate\n         * @return {Object}\n         */\n        mountOption: function (isRecreate) {\n            var optionBackup = this._optionBackup;\n\n            // TODO\n            // resetclone\n\n            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n            this._mediaList = map(optionBackup.mediaList, clone);\n            this._mediaDefault = clone(optionBackup.mediaDefault);\n            this._currentMediaIndices = [];\n\n            return clone(isRecreate\n                // this._optionBackup.baseOption, which is created at the first `setOption`\n                // called, and is merged into every new option by inner method `mergeOption`\n                // each time `setOption` called, can be only used in `isRecreate`, because\n                // its reliability is under suspicion. In other cases option merge is\n                // performed by `model.mergeOption`.\n                ? optionBackup.baseOption : this._newBaseOption\n            );\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Object}\n         */\n        getTimelineOption: function (ecModel) {\n            var option;\n            var timelineOptions = this._timelineOptions;\n\n            if (timelineOptions.length) {\n                // getTimelineOption can only be called after ecModel inited,\n                // so we can get currentIndex from timelineModel.\n                var timelineModel = ecModel.getComponent('timeline');\n                if (timelineModel) {\n                    option = clone(\n                        timelineOptions[timelineModel.getCurrentIndex()],\n                        true\n                    );\n                }\n            }\n\n            return option;\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Array.<Object>}\n         */\n        getMediaOption: function (ecModel) {\n            var ecWidth = this._api.getWidth();\n            var ecHeight = this._api.getHeight();\n            var mediaList = this._mediaList;\n            var mediaDefault = this._mediaDefault;\n            var indices = [];\n            var result = [];\n\n            // No media defined.\n            if (!mediaList.length && !mediaDefault) {\n                return result;\n            }\n\n            // Multi media may be applied, the latter defined media has higher priority.\n            for (var i = 0, len = mediaList.length; i < len; i++) {\n                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n                    indices.push(i);\n                }\n            }\n\n            // FIXME\n            // mediaDefault\n            if (!indices.length && mediaDefault) {\n                indices = [-1];\n            }\n\n            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n                result = map(indices, function (index) {\n                    return clone(\n                        index === -1 ? mediaDefault.option : mediaList[index].option\n                    );\n                });\n            }\n            // Otherwise return nothing.\n\n            this._currentMediaIndices = indices;\n\n            return result;\n        }\n    };\n\n    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n        var timelineOptions = [];\n        var mediaList = [];\n        var mediaDefault;\n        var baseOption;\n\n        // Compatible with ec2.\n        var timelineOpt = rawOption.timeline;\n\n        if (rawOption.baseOption) {\n            baseOption = rawOption.baseOption;\n        }\n\n        // For timeline\n        if (timelineOpt || rawOption.options) {\n            baseOption = baseOption || {};\n            timelineOptions = (rawOption.options || []).slice();\n        }\n\n        // For media query\n        if (rawOption.media) {\n            baseOption = baseOption || {};\n            var media = rawOption.media;\n            each(media, function (singleMedia) {\n                if (singleMedia && singleMedia.option) {\n                    if (singleMedia.query) {\n                        mediaList.push(singleMedia);\n                    }\n                    else if (!mediaDefault) {\n                        // Use the first media default.\n                        mediaDefault = singleMedia;\n                    }\n                }\n            });\n        }\n\n        // For normal option\n        if (!baseOption) {\n            baseOption = rawOption;\n        }\n\n        // Set timelineOpt to baseOption in ec3,\n        // which is convenient for merge option.\n        if (!baseOption.timeline) {\n            baseOption.timeline = timelineOpt;\n        }\n\n        // Preprocess.\n        each([baseOption].concat(timelineOptions)\n            .concat(zrUtil.map(mediaList, function (media) {\n                return media.option;\n            })),\n            function (option) {\n                each(optionPreprocessorFuncs, function (preProcess) {\n                    preProcess(option, isNew);\n                });\n            }\n        );\n\n        return {\n            baseOption: baseOption,\n            timelineOptions: timelineOptions,\n            mediaDefault: mediaDefault,\n            mediaList: mediaList\n        };\n    }\n\n    /**\n     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n     * Support: width, height, aspectRatio\n     * Can use max or min as prefix.\n     */\n    function applyMediaQuery(query, ecWidth, ecHeight) {\n        var realMap = {\n            width: ecWidth,\n            height: ecHeight,\n            aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n        };\n\n        var applicatable = true;\n\n        zrUtil.each(query, function (value, attr) {\n            var matched = attr.match(QUERY_REG);\n\n            if (!matched || !matched[1] || !matched[2]) {\n                return;\n            }\n\n            var operator = matched[1];\n            var realAttr = matched[2].toLowerCase();\n\n            if (!compare(realMap[realAttr], value, operator)) {\n                applicatable = false;\n            }\n        });\n\n        return applicatable;\n    }\n\n    function compare(real, expect, operator) {\n        if (operator === 'min') {\n            return real >= expect;\n        }\n        else if (operator === 'max') {\n            return real <= expect;\n        }\n        else { // Equals\n            return real === expect;\n        }\n    }\n\n    function indicesEquals(indices1, indices2) {\n        // indices is always order by asc and has only finite number.\n        return indices1.join(',') === indices2.join(',');\n    }\n\n    /**\n     * Consider case:\n     * `chart.setOption(opt1);`\n     * Then user do some interaction like dataZoom, dataView changing.\n     * `chart.setOption(opt2);`\n     * Then user press 'reset button' in toolbox.\n     *\n     * After doing that all of the interaction effects should be reset, the\n     * chart should be the same as the result of invoke\n     * `chart.setOption(opt1); chart.setOption(opt2);`.\n     *\n     * Although it is not able ensure that\n     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n     * `chart.setOption(merge(opt1, opt2));` exactly,\n     * this might be the only simple way to implement that feature.\n     *\n     * MEMO: We've considered some other approaches:\n     * 1. Each model handle its self restoration but not uniform treatment.\n     *     (Too complex in logic and error-prone)\n     * 2. Use a shadow ecModel. (Performace expensive)\n     */\n    function mergeOption(oldOption, newOption) {\n        newOption = newOption || {};\n\n        each(newOption, function (newCptOpt, mainType) {\n            if (newCptOpt == null) {\n                return;\n            }\n\n            var oldCptOpt = oldOption[mainType];\n\n            if (!ComponentModel.hasClass(mainType)) {\n                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n            }\n            else {\n                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\n                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\n                oldOption[mainType] = map(mapResult, function (item) {\n                    return (item.option && item.exist)\n                        ? merge(item.exist, item.option, true)\n                        : (item.exist || item.option);\n                });\n            }\n        });\n    }\n\n    module.exports = OptionManager;\n\n\n/***/ }),\n\n/***/ 1109:\n/***/ (function(module, exports, __webpack_require__) {\n\n// Compatitable with 2.0\n\n\n    var zrUtil = __webpack_require__(971);\n    var compatStyle = __webpack_require__(1110);\n\n    function get(opt, path) {\n        path = path.split(',');\n        var obj = opt;\n        for (var i = 0; i < path.length; i++) {\n            obj = obj && obj[path[i]];\n            if (obj == null) {\n                break;\n            }\n        }\n        return obj;\n    }\n\n    function set(opt, path, val, overwrite) {\n        path = path.split(',');\n        var obj = opt;\n        var key;\n        for (var i = 0; i < path.length - 1; i++) {\n            key = path[i];\n            if (obj[key] == null) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        }\n        if (overwrite || obj[path[i]] == null) {\n            obj[path[i]] = val;\n        }\n    }\n\n    function compatLayoutProperties(option) {\n        each(LAYOUT_PROPERTIES, function (prop) {\n            if (prop[0] in option && !(prop[1] in option)) {\n                option[prop[1]] = option[prop[0]];\n            }\n        });\n    }\n\n    var LAYOUT_PROPERTIES = [\n        ['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']\n    ];\n\n    var COMPATITABLE_COMPONENTS = [\n        'grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'\n    ];\n\n    var COMPATITABLE_SERIES = [\n        'bar', 'boxplot', 'candlestick', 'chord', 'effectScatter',\n        'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel',\n        'pie', 'radar', 'sankey', 'scatter', 'treemap'\n    ];\n\n    var each = zrUtil.each;\n\n    module.exports = function (option, isTheme) {\n        compatStyle(option, isTheme);\n\n        var series = option.series;\n        each(zrUtil.isArray(series) ? series : [series], function (seriesOpt) {\n            if (!zrUtil.isObject(seriesOpt)) {\n                return;\n            }\n\n            var seriesType = seriesOpt.type;\n\n            if (seriesType === 'pie' || seriesType === 'gauge') {\n                if (seriesOpt.clockWise != null) {\n                    seriesOpt.clockwise = seriesOpt.clockWise;\n                }\n            }\n            if (seriesType === 'gauge') {\n                var pointerColor = get(seriesOpt, 'pointer.color');\n                pointerColor != null\n                    && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n            }\n\n            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n                    compatLayoutProperties(seriesOpt);\n                    break;\n                }\n            }\n        });\n\n        // dataRange has changed to visualMap\n        if (option.dataRange) {\n            option.visualMap = option.dataRange;\n        }\n\n        each(COMPATITABLE_COMPONENTS, function (componentName) {\n            var options = option[componentName];\n            if (options) {\n                if (!zrUtil.isArray(options)) {\n                    options = [options];\n                }\n                each(options, function (option) {\n                    compatLayoutProperties(option);\n                });\n            }\n        });\n    };\n\n\n/***/ }),\n\n/***/ 1110:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(971);\n    var modelUtil = __webpack_require__(975);\n\n    var each = zrUtil.each;\n    var isObject = zrUtil.isObject;\n\n    var POSSIBLE_STYLES = [\n        'areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle',\n        'chordStyle', 'label', 'labelLine'\n    ];\n\n    function compatItemStyle(opt) {\n        var itemStyleOpt = opt && opt.itemStyle;\n        if (!itemStyleOpt) {\n            return;\n        }\n        for (var i = 0, len = POSSIBLE_STYLES.length; i < len; i++) {\n            var styleName = POSSIBLE_STYLES[i];\n            var normalItemStyleOpt = itemStyleOpt.normal;\n            var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n            if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n                opt[styleName] = opt[styleName] || {};\n                if (!opt[styleName].normal) {\n                    opt[styleName].normal = normalItemStyleOpt[styleName];\n                }\n                else {\n                    zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n                }\n                normalItemStyleOpt[styleName] = null;\n            }\n            if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n                opt[styleName] = opt[styleName] || {};\n                if (!opt[styleName].emphasis) {\n                    opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n                }\n                else {\n                    zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n                }\n                emphasisItemStyleOpt[styleName] = null;\n            }\n        }\n    }\n\n    function compatTextStyle(opt, propName) {\n        var labelOptSingle = isObject(opt) && opt[propName];\n        var textStyle = isObject(labelOptSingle) && labelOptSingle.textStyle;\n        if (textStyle) {\n            for (var i = 0, len = modelUtil.TEXT_STYLE_OPTIONS.length; i < len; i++) {\n                var propName = modelUtil.TEXT_STYLE_OPTIONS[i];\n                if (textStyle.hasOwnProperty(propName)) {\n                    labelOptSingle[propName] = textStyle[propName];\n                }\n            }\n        }\n    }\n\n    function compatLabelTextStyle(labelOpt) {\n        if (isObject(labelOpt)) {\n            compatTextStyle(labelOpt, 'normal');\n            compatTextStyle(labelOpt, 'emphasis');\n        }\n    }\n\n    function processSeries(seriesOpt) {\n        if (!isObject(seriesOpt)) {\n            return;\n        }\n\n        compatItemStyle(seriesOpt);\n        compatLabelTextStyle(seriesOpt.label);\n        // treemap\n        compatLabelTextStyle(seriesOpt.upperLabel);\n        // graph\n        compatLabelTextStyle(seriesOpt.edgeLabel);\n\n        var markPoint = seriesOpt.markPoint;\n        compatItemStyle(markPoint);\n        compatLabelTextStyle(markPoint && markPoint.label);\n\n        var markLine = seriesOpt.markLine;\n        compatItemStyle(seriesOpt.markLine);\n        compatLabelTextStyle(markLine && markLine.label);\n\n        var markArea = seriesOpt.markArea;\n        compatLabelTextStyle(markArea && markArea.label);\n\n        // For gauge\n        compatTextStyle(seriesOpt, 'axisLabel');\n        compatTextStyle(seriesOpt, 'title');\n        compatTextStyle(seriesOpt, 'detail');\n\n        var data = seriesOpt.data;\n        if (data) {\n            for (var i = 0; i < data.length; i++) {\n                compatItemStyle(data[i]);\n                compatLabelTextStyle(data[i] && data[i].label);\n            }\n        }\n\n        // mark point data\n        var markPoint = seriesOpt.markPoint;\n        if (markPoint && markPoint.data) {\n            var mpData = markPoint.data;\n            for (var i = 0; i < mpData.length; i++) {\n                compatItemStyle(mpData[i]);\n                compatLabelTextStyle(mpData[i] && mpData[i].label);\n            }\n        }\n        // mark line data\n        var markLine = seriesOpt.markLine;\n        if (markLine && markLine.data) {\n            var mlData = markLine.data;\n            for (var i = 0; i < mlData.length; i++) {\n                if (zrUtil.isArray(mlData[i])) {\n                    compatItemStyle(mlData[i][0]);\n                    compatLabelTextStyle(mlData[i][0] && mlData[i][0].label);\n                    compatItemStyle(mlData[i][1]);\n                    compatLabelTextStyle(mlData[i][1] && mlData[i][1].label);\n                }\n                else {\n                    compatItemStyle(mlData[i]);\n                    compatLabelTextStyle(mlData[i] && mlData[i].label);\n                }\n            }\n        }\n    }\n\n    function toArr(o) {\n        return zrUtil.isArray(o) ? o : o ? [o] : [];\n    }\n\n    function toObj(o) {\n        return (zrUtil.isArray(o) ? o[0] : o) || {};\n    }\n\n    module.exports = function (option, isTheme) {\n        each(toArr(option.series), function (seriesOpt) {\n            isObject(seriesOpt) && processSeries(seriesOpt);\n        });\n\n        var axes = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'parallelAxis', 'radar'];\n        isTheme && axes.push('valueAxis', 'categoryAxis', 'logAxis', 'timeAxis');\n\n        each(\n            axes,\n            function (axisName) {\n                each(toArr(option[axisName]), function (axisOpt) {\n                    if (axisOpt) {\n                        compatTextStyle(axisOpt, 'axisLabel');\n                        compatTextStyle(axisOpt.axisPointer, 'label');\n                    }\n                });\n            }\n        );\n\n        each(toArr(option.parallel), function (parallelOpt) {\n            var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;\n            compatTextStyle(parallelAxisDefault, 'axisLabel');\n            compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, 'label');\n        });\n\n        each(toArr(option.calendar), function (calendarOpt) {\n            compatTextStyle(calendarOpt, 'dayLabel');\n            compatTextStyle(calendarOpt, 'monthLabel');\n            compatTextStyle(calendarOpt, 'yearLabel');\n        });\n\n        // radar.name.textStyle\n        each(toArr(option.radar), function (radarOpt) {\n            compatTextStyle(radarOpt, 'name');\n        });\n\n        each(toArr(option.geo), function (geoOpt) {\n            if (isObject(geoOpt)) {\n                compatLabelTextStyle(geoOpt.label);\n                each(toArr(geoOpt.regions), function (regionObj) {\n                    compatLabelTextStyle(regionObj.label);\n                });\n            }\n        });\n\n        compatLabelTextStyle(toObj(option.timeline).label);\n        compatTextStyle(toObj(option.axisPointer), 'label');\n        compatTextStyle(toObj(option.tooltip).axisPointer, 'label');\n    };\n\n\n/***/ }),\n\n/***/ 1111:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\n    var util = __webpack_require__(971);\n    var vec2 = __webpack_require__(976);\n    var Draggable = __webpack_require__(1112);\n\n    var Eventful = __webpack_require__(992);\n\n    var SILENT = 'silent';\n\n    function makeEventPacket(eveType, targetInfo, event) {\n        return {\n            type: eveType,\n            event: event,\n            // target can only be an element that is not silent.\n            target: targetInfo.target,\n            // topTarget can be a silent element.\n            topTarget: targetInfo.topTarget,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta,\n            zrByTouch: event.zrByTouch,\n            which: event.which\n        };\n    }\n\n    function EmptyProxy () {}\n    EmptyProxy.prototype.dispose = function () {};\n\n    var handlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n     */\n    var Handler = function(storage, painter, proxy, painterRoot) {\n        Eventful.call(this);\n\n        this.storage = storage;\n\n        this.painter = painter;\n\n        this.painterRoot = painterRoot;\n\n        proxy = proxy || new EmptyProxy();\n\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n\n        // Attach handler\n        proxy.handler = this;\n\n        /**\n         * {target, topTarget, x, y}\n         * @private\n         * @type {Object}\n         */\n        this._hovered = {};\n\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n\n\n        Draggable.call(this);\n\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n\n    Handler.prototype = {\n\n        constructor: Handler,\n\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n\n            var lastHovered = this._hovered;\n            var lastHoveredTarget = lastHovered.target;\n\n            // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call\n            // (like 'setOption' or 'dispatchAction') in event handlers, we should find\n            // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.\n            // See #6198.\n            if (lastHoveredTarget && !lastHoveredTarget.__zr) {\n                lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n                lastHoveredTarget = lastHovered.target;\n            }\n\n            var hovered = this._hovered = this.findHover(x, y);\n            var hoveredTarget = hovered.target;\n\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default');\n\n            // Mouse out on previous hovered element\n            if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n\n            // Mouse over on a new element\n            if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n\n            // There might be some doms created by upper layer application\n            // at the same level of painter.getViewportRoot() (e.g., tooltip\n            // dom created by echarts), where 'globalout' event should not\n            // be triggered when mouse enters these doms. (But 'mouseout'\n            // should be triggered at the original hovered element as usual).\n            var element = event.toElement || event.relatedTarget;\n            var innerDom;\n            do {\n                element = element && element.parentNode;\n            }\n            while (element && element.nodeType != 9 && !(\n                innerDom = element === this.painterRoot\n            ));\n\n            !innerDom && this.trigger('globalout', {event: event});\n        },\n\n        /**\n         * Resize\n         */\n        resize: function (event) {\n            this._hovered = {};\n        },\n\n        /**\n         * Dispatch event\n         * @param {string} eventName\n         * @param {event=} eventArgs\n         */\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n\n        /**\n         * Dispose\n         */\n        dispose: function () {\n\n            this.proxy.dispose();\n\n            this.storage =\n            this.proxy =\n            this.painter = null;\n        },\n\n        /**\n         * cursor style\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n\n        /**\n         * \n         *\n         * @private\n         * @param {Object} targetInfo {target, topTarget} \n         * @param {string} eventName \n         * @param {Object} event \n         */\n        dispatchToElement: function (targetInfo, eventName, event) {\n            targetInfo = targetInfo || {};\n            var el = targetInfo.target;\n            if (el && el.silent) {\n                return;\n            }\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\n            while (el) {\n                el[eventHandler]\n                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n                el.trigger(eventName, eventPacket);\n\n                el = el.parent;\n\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n\n            if (!eventPacket.cancelBubble) {\n                //  zrender \n                this.trigger(eventName, eventPacket);\n                // \n                //  click  dispose painter \n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof(layer[eventHandler]) == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {number} x\n         * @param {number} y\n         * @param {module:zrender/graphic/Displayable} exclude\n         * @return {model:zrender/Element}\n         * @method\n         */\n        findHover: function(x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            var out = {x: x, y: y};\n\n            for (var i = list.length - 1; i >= 0 ; i--) {\n                var hoverCheckResult;\n                if (list[i] !== exclude\n                    // getDisplayList may include ignored item in VML mode\n                    && !list[i].ignore\n                    && (hoverCheckResult = isHover(list[i], x, y))\n                ) {\n                    !out.topTarget && (out.topTarget = list[i]);\n                    if (hoverCheckResult !== SILENT) {\n                        out.target = list[i];\n                        break;\n                    }\n                }\n            }\n\n            return out;\n        }\n    };\n\n    // Common handlers\n    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY);\n            var hoveredTarget = hovered.target;\n\n            if (name === 'mousedown') {\n                this._downEl = hoveredTarget;\n                this._downPoint = [event.zrX, event.zrY];\n                // In case click triggered before mouseup\n                this._upEl = hoveredTarget;\n            }\n            else if (name === 'mosueup') {\n                this._upEl = hoveredTarget;\n            }\n            else if (name === 'click') {\n                if (this._downEl !== this._upEl\n                    // Original click event is triggered on the whole canvas element,\n                    // including the case that `mousedown` - `mousemove` - `mouseup`,\n                    // which should be filtered, otherwise it will bring trouble to\n                    // pan and zoom.\n                    || !this._downPoint\n                    // Arbitrary value\n                    || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4\n                ) {\n                    return;\n                }\n                this._downPoint = null;\n            }\n\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            var isSilent;\n            while (el) {\n                // If clipped by ancestor.\n                // FIXME: If clipPath has neither stroke nor fill,\n                // el.clipPath.contain(x, y) will always return false.\n                if (el.clipPath && !el.clipPath.contain(x, y))  {\n                    return false;\n                }\n                if (el.silent) {\n                    isSilent = true;\n                }\n                el = el.parent;\n            }\n            return isSilent ? SILENT : true;\n        }\n\n        return false;\n    }\n\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n\n    module.exports = Handler;\n\n\n\n/***/ }),\n\n/***/ 1112:\n/***/ (function(module, exports) {\n\n// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\n\n    function Draggable() {\n\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);\n        // this._dropTarget = null;\n        // this._draggingTarget = null;\n\n        // this._x = 0;\n        // this._y = 0;\n    }\n\n    Draggable.prototype = {\n\n        constructor: Draggable,\n\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n\n                this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n            }\n        },\n\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n\n                var dropTarget = this.findHover(x, y, draggingTarget).target;\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n\n            this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\n            if (this._dropTarget) {\n                this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n            }\n\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n\n    };\n\n    function param(target, e) {\n        return {target: target, topTarget: e && e.topTarget};\n    }\n\n    module.exports = Draggable;\n\n\n/***/ }),\n\n/***/ 1113:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Storage\n * @module zrender/Storage\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n\n\n    var util = __webpack_require__(971);\n    var env = __webpack_require__(978);\n\n    var Group = __webpack_require__(1001);\n\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = __webpack_require__(1017);\n\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     *  (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        this._roots = [];\n\n        this._displayList = [];\n\n        this._displayListLen = 0;\n    };\n\n    Storage.prototype = {\n\n        constructor: Storage,\n\n        /**\n         * @param  {Function} cb\n         *\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} [update=false] \n         * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n         *\n         * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n         * @return {Array.<module:zrender/graphic/Displayable>}\n         */\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n\n        /**\n         * \n         * GroupShapeShape\n         * zlevel > z > \n         * @param {boolean} [includeIgnore=false]  ignore \n         */\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n\n            el.beforeUpdate();\n\n            if (el.__dirty) {\n\n                el.update();\n\n            }\n\n            el.afterUpdate();\n\n            var userSetClipPath = el.clipPath;\n            if (userSetClipPath) {\n\n                // FIXME \n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                }\n                else {\n                    clipPaths = [];\n                }\n\n                var currentClipPath = userSetClipPath;\n                var parentClipPath = el;\n                // Recursively add clip path\n                while (currentClipPath) {\n                    // clipPath  clipPath \n                    currentClipPath.parent = parentClipPath;\n                    currentClipPath.updateTransform();\n\n                    clipPaths.push(currentClipPath);\n\n                    parentClipPath = currentClipPath;\n                    currentClipPath = currentClipPath.clipPath;\n                }\n            }\n\n            if (el.isGroup) {\n                var children = el._children;\n\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n\n                // Mark group clean here\n                el.__dirty = false;\n\n            }\n            else {\n                el.__clipPaths = clipPaths;\n\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {module:zrender/Element} el\n         */\n        addRoot: function (el) {\n            if (el.__storage === this) {\n                return;\n            }\n\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n\n            this.addToStorage(el);\n            this._roots.push(el);\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {string|Array.<string>} [el] Storage\n         */\n        delRoot: function (el) {\n            if (el == null) {\n                // el\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n\n                return;\n            }\n\n            if (el instanceof Array) {\n                for (var i = 0, l = el.length; i < l; i++) {\n                    this.delRoot(el[i]);\n                }\n                return;\n            }\n\n\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromStorage(el);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n\n        addToStorage: function (el) {\n            el.__storage = this;\n            el.dirty(false);\n\n            return this;\n        },\n\n        delFromStorage: function (el) {\n            if (el) {\n                el.__storage = null;\n            }\n\n            return this;\n        },\n\n        /**\n         * Storage\n         */\n        dispose: function () {\n            this._renderList =\n            this._roots = null;\n        },\n\n        displayableSortFunc: shapeCompareFunc\n    };\n\n    module.exports = Storage;\n\n\n\n/***/ }),\n\n/***/ 1114:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * , \n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n\n    var util = __webpack_require__(971);\n    var Dispatcher = __webpack_require__(990).Dispatcher;\n\n    var requestAnimationFrame = __webpack_require__(1040);\n\n    var Animator = __webpack_require__(1034);\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n\n        options = options || {};\n\n        this.stage = options.stage || {};\n\n        this.onframe = options.onframe || function() {};\n\n        // private properties\n        this._clips = [];\n\n        this._running = false;\n\n        this._time;\n\n        this._pausedTime;\n\n        this._pauseStart;\n\n        this._paused = false;\n\n        Dispatcher.call(this);\n    };\n\n    Animation.prototype = {\n\n        constructor: Animation,\n        /**\n         *  clip\n         * @param {module:zrender/animation/Clip} clip\n         */\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        /**\n         *  animator\n         * @param {module:zrender/animation/Animator} animator\n         */\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        /**\n         * \n         * @param {module:zrender/animation/Clip} clip\n         */\n        removeClip: function(clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n\n        /**\n         * \n         * @param {module:zrender/animation/Animator} animator\n         */\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n\n        _update: function() {\n\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time, delta);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n\n            this._time = time;\n\n            this.onframe(delta);\n\n            this.trigger('frame', delta);\n\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n\n        _startLoop: function () {\n            var self = this;\n\n            this._running = true;\n\n            function step() {\n                if (self._running) {\n\n                    requestAnimationFrame(step);\n\n                    !self._paused && self._update();\n                }\n            }\n\n            requestAnimationFrame(step);\n        },\n\n        /**\n         * \n         */\n        start: function () {\n\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n\n            this._startLoop();\n        },\n        /**\n         * \n         */\n        stop: function () {\n            this._running = false;\n        },\n\n        /**\n         * Pause\n         */\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n\n        /**\n         * Resume\n         */\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n                this._paused = false;\n            }\n        },\n\n        /**\n         * \n         */\n        clear: function () {\n            this._clips = [];\n        },\n        /**\n         * animator\n         * @param  {Object} target\n         * @param  {Object} options\n         * @param  {boolean} [options.loop=false] \n         * @param  {Function} [options.getter=null]\n         *         gettergetter\n         * @param  {Function} [options.setter=null]\n         *         settersetter\n         * @return {module:zrender/animation/Animation~Animator}\n         */\n        // TODO Gap\n        animate: function (target, options) {\n            options = options || {};\n\n            var animator = new Animator(\n                target,\n                options.loop,\n                options.getter,\n                options.setter\n            );\n\n            this.addAnimator(animator);\n\n            return animator;\n        }\n    };\n\n    util.mixin(Animation, Dispatcher);\n\n    module.exports = Animation;\n\n\n\n/***/ }),\n\n/***/ 1115:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var eventTool = __webpack_require__(990);\n    var zrUtil = __webpack_require__(971);\n    var Eventful = __webpack_require__(992);\n    var env = __webpack_require__(978);\n    var GestureMgr = __webpack_require__(1116);\n\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n\n    var TOUCH_CLICK_DELAY = 300;\n\n    var mouseHandlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n\n    var touchHandlerNames = [\n        'touchstart', 'touchend', 'touchmove'\n    ];\n\n    var pointerEventNames = {\n        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1\n    };\n\n    var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n        var nm = name.replace('mouse', 'pointer');\n        return pointerEventNames[nm] ? nm : name;\n    });\n\n    function eventNameFix(name) {\n        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n    }\n\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n\n        stage === 'start' && gestureMgr.clear();\n\n        var gestureInfo = gestureMgr.recognize(\n            event,\n            proxy.handler.findHover(event.zrX, event.zrY, null).target,\n            proxy.dom\n        );\n\n        stage === 'end' && gestureMgr.clear();\n\n        // Do not do any preventDefault here. Upper application do that if necessary.\n        if (gestureInfo) {\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n\n            proxy.handler.dispatchToElement({target: gestureInfo.target}, type, gestureInfo.event);\n        }\n    }\n\n    // function onMSGestureChange(proxy, event) {\n    //     if (event.translationX || event.translationY) {\n    //         // mousemove is carried by MSGesture to reduce the sensitivity.\n    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n    //     }\n    //     if (event.scale !== 1) {\n    //         event.pinchX = event.offsetX;\n    //         event.pinchY = event.offsetY;\n    //         event.pinchScale = event.scale;\n    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n    //     }\n    // }\n\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n\n\n    var domHandlers = {\n        /**\n         * Mouse move handler\n         * @inner\n         * @param {Event} event\n         */\n        mousemove: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            this.trigger('mousemove', event);\n        },\n\n        /**\n         * Mouse out handler\n         * @inner\n         * @param {Event} event\n         */\n        mouseout: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            var element = event.toElement || event.relatedTarget;\n            if (element != this.dom) {\n                while (element && element.nodeType != 9) {\n                    // rootdommouseOut\n                    if (element === this.dom) {\n                        return;\n                    }\n\n                    element = element.parentNode;\n                }\n            }\n\n            this.trigger('mouseout', event);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchstart: function (event) {\n            // Default mouse behaviour should not be disabled here.\n            // For example, page may needs to be slided.\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            this._lastTouchMoment = new Date();\n\n            processGesture(this, event, 'start');\n\n            // In touch device, trigger `mousemove`(`mouseover`) should\n            // be triggered, and must before `mousedown` triggered.\n            domHandlers.mousemove.call(this, event);\n\n            domHandlers.mousedown.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchmove: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'change');\n\n            // Mouse move should always be triggered no matter whether\n            // there is gestrue event, because mouse move and pinch may\n            // be used at the same time.\n            domHandlers.mousemove.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchend: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'end');\n\n            domHandlers.mouseup.call(this, event);\n\n            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n            // we can conveniently implement \"hover style\" in both PC and touch device just\n            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n            // to remove \"hover style\" on an element, without any additional code for\n            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n            // style\" will remain for user view)\n\n            // click event should always be triggered no matter whether\n            // there is gestrue event. System click can not be prevented.\n            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                domHandlers.click.call(this, event);\n            }\n\n            setTouchTimer(this);\n        },\n\n        pointerdown: function (event) {\n            domHandlers.mousedown.call(this, event);\n\n            // if (useMSGuesture(this, event)) {\n            //     this._msGesture.addPointer(event.pointerId);\n            // }\n        },\n\n        pointermove: function (event) {\n            // FIXME\n            // pointermove is so sensitive that it always triggered when\n            // tap(click) on touch screen, which affect some judgement in\n            // upper application. So, we dont support mousemove on MS touch\n            // device yet.\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mousemove.call(this, event);\n            }\n        },\n\n        pointerup: function (event) {\n            domHandlers.mouseup.call(this, event);\n        },\n\n        pointerout: function (event) {\n            // pointerout will be triggered when tap on touch screen\n            // (IE11+/Edge on MS Surface) after click event triggered,\n            // which is inconsistent with the mousout behavior we defined\n            // in touchend. So we unify them.\n            // (check domHandlers.touchend for detailed explanation)\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mouseout.call(this, event);\n            }\n        }\n    };\n\n    function isPointerFromTouch(event) {\n        var pointerType = event.pointerType;\n        return pointerType === 'pen' || pointerType === 'touch';\n    }\n\n    // function useMSGuesture(handlerProxy, event) {\n    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n    // }\n\n    // Common handlers\n    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n\n    /**\n     * dom \n     *\n     * @inner\n     * @param {module:zrender/Handler} instance \n     */\n    function initDomHandler(instance) {\n        zrUtil.each(touchHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(pointerHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(mouseHandlerNames, function (name) {\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        });\n\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n\n\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n\n        this.dom = dom;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n\n        this._handlers = {};\n\n        initDomHandler(this);\n\n        if (env.pointerEventsSupported) { // Only IE11+/Edge\n            // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n            // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n            // at the same time.\n            // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n            // screen, which do not occurs in pointer event.\n            // So we use pointer event to both detect touch gesture and mouse behavior.\n            mountHandlers(pointerHandlerNames, this);\n\n            // FIXME\n            // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n            // which does not prevent defuault behavior occasionally (which may cause view port\n            // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n            // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n            // touch screen. And we only support click behavior on MS touch screen now.\n\n            // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n            // We dont support touch on IE on win7.\n            // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n            // if (typeof MSGesture === 'function') {\n            //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n            //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n            // }\n        }\n        else {\n            if (env.touchEventsSupported) {\n                mountHandlers(touchHandlerNames, this);\n                // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n                // addEventListener(root, 'mouseout', this._mouseoutHandler);\n            }\n\n            // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n            // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n            // mouse event can not be handle in those devices.\n            // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n            // mouseevent after touch event triggered, see `setTouchTimer`.\n            mountHandlers(mouseHandlerNames, this);\n        }\n\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n\n    module.exports = HandlerDomProxy;\n\n\n/***/ }),\n\n/***/ 1116:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Only implements needed gestures for mobile.\n */\n\n\n    var eventUtil = __webpack_require__(990);\n\n    var GestureMgr = function () {\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n\n    GestureMgr.prototype = {\n\n        constructor: GestureMgr,\n\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n\n            if (!touches) {\n                return;\n            }\n\n            var trackItem = {\n                points: [],\n                touches: [],\n                target: target,\n                event: event\n            };\n\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch, {});\n                trackItem.points.push([pos.zrX, pos.zrY]);\n                trackItem.touches.push(touch);\n            }\n\n            this._track.push(trackItem);\n        },\n\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n\n    var recognizers = {\n\n        pinch: function (track, event) {\n            var trackLen = track.length;\n\n            if (!trackLen) {\n                return;\n            }\n\n            var pinchEnd = (track[trackLen - 1] || {}).points;\n            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n            if (pinchPre\n                && pinchPre.length > 1\n                && pinchEnd\n                && pinchEnd.length > 1\n            ) {\n                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                !isFinite(pinchScale) && (pinchScale = 1);\n\n                event.pinchScale = pinchScale;\n\n                var pinchCenter = center(pinchEnd);\n                event.pinchX = pinchCenter[0];\n                event.pinchY = pinchCenter[1];\n\n                return {\n                    type: 'pinch',\n                    target: track[0].target,\n                    event: event\n                };\n            }\n        }\n\n        // Only pinch currently.\n    };\n\n    module.exports = GestureMgr;\n\n\n\n/***/ }),\n\n/***/ 1117:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n \n\n    var config = __webpack_require__(1000);\n    var util = __webpack_require__(971);\n    var log = __webpack_require__(1025);\n    var BoundingRect = __webpack_require__(982);\n    var timsort = __webpack_require__(1017);\n\n    var Layer = __webpack_require__(1118);\n\n    var requestAnimationFrame = __webpack_require__(1040);\n\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n\n        if (layer.__builtin__) {\n            return true;\n        }\n\n        if (typeof(layer.resize) !== 'function'\n            || typeof(layer.refresh) !== 'function'\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n            return false;\n        }\n\n        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n\n            clipPath.setTransform(ctx);\n            ctx.beginPath();\n            clipPath.buildPath(ctx, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n\n        // domRoot.onselectstart = returnFalse; // \n        domRoot.style.cssText = [\n            'position:relative',\n            'overflow:hidden',\n            'width:' + width + 'px',\n            'height:' + height + 'px',\n            'padding:0',\n            'margin:0',\n            'border-width:0'\n        ].join(';') + ';';\n\n        return domRoot;\n    }\n\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root \n     * @param {module:zrender/Storage} storage\n     * @param {Object} opts\n     */\n    var Painter = function (root, storage, opts) {\n\n        this.type = 'canvas';\n\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName // In node ?\n            || root.nodeName.toUpperCase() === 'CANVAS';\n\n        this._opts = opts = util.extend({}, opts || {});\n\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * \n         * @type {HTMLElement}\n         */\n        this.root = root;\n\n        var rootStyle = root.style;\n\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] =\n            rootStyle['user-select'] =\n            rootStyle['-webkit-touch-callout'] = 'none';\n\n            root.innerHTML = '';\n        }\n\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n\n        if (!singleCanvas) {\n            this._width = this._getSize(0);\n            this._height = this._getSize(1);\n\n            var domRoot = this._domRoot = createRoot(\n                this._width, this._height\n            );\n            root.appendChild(domRoot);\n        }\n        else {\n            if (opts.width != null) {\n                root.width = opts.width;\n            }\n            if (opts.height != null) {\n                root.height = opts.height;\n            }\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n\n            this._domRoot = root;\n        }\n\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n\n        this._hoverElements = [];\n    };\n\n    Painter.prototype = {\n\n        constructor: Painter,\n\n        getType: function () {\n            return 'canvas';\n        },\n\n        /**\n         * If painter use a single canvas\n         * @return {boolean}\n         */\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._domRoot;\n        },\n\n        getViewportRootOffset: function () {\n            var viewportRoot = this.getViewportRoot();\n            if (viewportRoot) {\n                return {\n                    offsetLeft: viewportRoot.offsetLeft || 0,\n                    offsetTop: viewportRoot.offsetTop || 0\n                };\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} [paintAll=false] displayable\n         */\n        refresh: function (paintAll) {\n\n            var list = this.storage.getDisplayList(true);\n\n            var zlevelList = this._zlevelList;\n\n            this._paintList(list, paintAll);\n\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.__builtin__ && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n\n            this.refreshHover();\n\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n\n            return this;\n        },\n\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                style: el.style,\n                shape: el.shape\n            });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n            }\n\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n\n        _startProgessive: function () {\n            var self = this;\n\n            if (!self._furtherProgressive) {\n                return;\n            }\n\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n\n            self._progress++;\n            requestAnimationFrame(step);\n\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n\n                    self._doPaintList(self.storage.getDisplayList());\n\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    }\n                    else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n\n        _paintList: function (list, paintAll) {\n\n            if (paintAll == null) {\n                paintAll = false;\n            }\n\n            this._updateLayerStatus(list);\n\n            this._clearProgressive();\n\n            this.eachBuiltinLayer(preProcessLayer);\n\n            this._doPaintList(list, paintAll);\n\n            this.eachBuiltinLayer(postProcessLayer);\n        },\n\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n\n            // var invTransform = [];\n            var scope;\n\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\n                var elFrame = el.__frame;\n\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n\n                    // Reset scope\n                    scope = {};\n\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n\n                    if (!currentLayer.__builtin__) {\n                        log(\n                            'ZLevel ' + currentZLevel\n                            + ' has been used by unkown layer ' + currentLayer.id\n                        );\n                    }\n\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[\n                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n                        ];\n\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n\n                        if (currentProgressiveLayer\n                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n                        ) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n\n                        layerProgress = currentProgressiveLayer.__progress;\n\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                }\n                else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n\n                el.__dirty = false;\n            }\n\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if (\n                (currentLayer.__dirty || forcePaint)\n                // Ignore invisible element\n                && !el.invisible\n                // Ignore transparent element\n                && el.style.opacity !== 0\n                // Ignore scale 0 element, in some environment like node-canvas\n                // Draw a scale 0 element can cause all following draw wrong\n                // And setTransform with scale 0 will cause set back transform failed.\n                && !(m && !m[0] && !m[3])\n                // Ignore culled element\n                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n            ) {\n\n                var clipPaths = el.__clipPaths;\n\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer\n                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n                ) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n\n        /**\n         *  zlevel \n         * @param {number} zlevel\n         * @return {module:zrender/Layer}\n         */\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.__builtin__ = true;\n\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n\n                this.insertLayer(zlevel, layer);\n\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n\n            return layer;\n        },\n\n        insertLayer: function (zlevel, layer) {\n\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (\n                        zlevelList[i] < zlevel\n                        && zlevelList[i + 1] > zlevel\n                    ) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n\n            layersMap[zlevel] = layer;\n\n            // Vitual layer will not directly show on the screen.\n            // (It can be a WebGL layer and assigned to a ZImage element)\n            // But it still under management of zrender.\n            if (!layer.virtual) {\n                if (prevLayer) {\n                    var prevDom = prevLayer.dom;\n                    if (prevDom.nextSibling) {\n                        domRoot.insertBefore(\n                            layer.dom,\n                            prevDom.nextSibling\n                        );\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n                else {\n                    if (domRoot.firstChild) {\n                        domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n            }\n        },\n\n        // Iterate each layer\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n\n        // Iterate each buildin layer\n        eachBuiltinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        // Iterate each other layer except buildin layer\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (!layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {Array.<module:zrender/Layer>} [prevLayer]\n         */\n        getLayers: function () {\n            return this._layers;\n        },\n\n        _updateLayerStatus: function (list) {\n\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n\n            this.eachBuiltinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n                                'progressive', this, this.dpr\n                            );\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n\n                    currentProgressiveLayer.__maxProgress = Math.max(\n                        currentProgressiveLayer.__maxProgress, elFrame\n                    );\n\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                }\n                else {\n                    el.__frame = -1;\n\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n\n            // \n            this.eachBuiltinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n\n        /**\n         * hover\n         */\n        clear: function () {\n            this.eachBuiltinLayer(this._clearLayer);\n            return this;\n        },\n\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n\n        /**\n         * zlevel\n         *\n         * @param {string} zlevel\n         * @param {Object} config \n         * @param {string} [config.clearColor=0] \n         * @param {string} [config.motionBlur=false] \n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 alpha\n         */\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n\n                var layer = this._layers[zlevel];\n\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {number} zlevel zlevel\n         */\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n\n        /**\n         * \n         */\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n\n            // Save input w/h\n            var opts = this._opts;\n            width != null && (opts.width = width);\n            height != null && (opts.height = height);\n\n            width = this._getSize(0);\n            height = this._getSize(1);\n\n            domRoot.style.display = '';\n\n            // resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n\n                for (var id in this._layers) {\n                    if (this._layers.hasOwnProperty(id)) {\n                        this._layers[id].resize(width, height);\n                    }\n                }\n                util.each(this._progressiveLayers, function (layer) {\n                    layer.resize(width, height);\n                });\n\n                this.refresh(true);\n            }\n\n            this._width = width;\n            this._height = height;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {number} zlevel\n         */\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n\n        /**\n         * \n         */\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this.root =\n            this.storage =\n\n            this._domRoot =\n            this._layers = null;\n        },\n\n        /**\n         * Get canvas which has all thing rendered\n         * @param {Object} opts\n         * @param {string} [opts.backgroundColor]\n         */\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n\n            var displayList = this.storage.getDisplayList(true);\n\n            var scope = {};\n            var zlevel;\n\n            var self = this;\n            function findAndDrawOtherLayer(smaller, larger) {\n                var zlevelList = self._zlevelList;\n                if (smaller == null) {\n                    smaller = -Infinity;\n                }\n                var intermediateLayer;\n                for (var i = 0; i < zlevelList.length; i++) {\n                    var z = zlevelList[i];\n                    var layer = self._layers[z];\n                    if (!layer.__builtin__ && z > smaller && z < larger) {\n                        intermediateLayer = layer;\n                        break;\n                    }\n                }\n                if (intermediateLayer && intermediateLayer.renderToCanvas) {\n                    imageLayer.ctx.save();\n                    intermediateLayer.renderToCanvas(imageLayer.ctx);\n                    imageLayer.ctx.restore();\n                }\n            }\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n\n                if (el.zlevel !== zlevel) {\n                    findAndDrawOtherLayer(zlevel, el.zlevel);\n                    zlevel = el.zlevel;\n                }\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n\n            findAndDrawOtherLayer(zlevel, Infinity);\n\n            return imageLayer.dom;\n        },\n        /**\n         * \n         */\n        getWidth: function () {\n            return this._width;\n        },\n\n        /**\n         * \n         */\n        getHeight: function () {\n            return this._height;\n        },\n\n        _getSize: function (whIdx) {\n            var opts = this._opts;\n            var wh = ['width', 'height'][whIdx];\n            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n            if (opts[wh] != null && opts[wh] !== 'auto') {\n                return parseFloat(opts[wh]);\n            }\n\n            var root = this.root;\n            // IE8 does not support getComputedStyle, but it use VML.\n            var stl = document.defaultView.getComputedStyle(root);\n\n            return (\n                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n                - (parseInt10(stl[plt]) || 0)\n                - (parseInt10(stl[prb]) || 0)\n            ) | 0;\n        },\n\n        pathToImage: function (path, dpr) {\n            dpr = dpr || this.dpr;\n\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n            var rect = path.getBoundingRect();\n            var style = path.style;\n            var shadowBlurSize = style.shadowBlur;\n            var shadowOffsetX = style.shadowOffsetX;\n            var shadowOffsetY = style.shadowOffsetY;\n            var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n\n            var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n            var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n            var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n            var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n            var width = rect.width + leftMargin + rightMargin;\n            var height = rect.height + topMargin + bottomMargin;\n\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            ctx.scale(dpr, dpr);\n            ctx.clearRect(0, 0, width, height);\n            ctx.dpr = dpr;\n\n            var pathTransform = {\n                position: path.position,\n                rotation: path.rotation,\n                scale: path.scale\n            };\n            path.position = [leftMargin - rect.x, topMargin - rect.y];\n            path.rotation = 0;\n            path.scale = [1, 1];\n            path.updateTransform();\n            if (path) {\n                path.brush(ctx);\n            }\n\n            var ImageShape = __webpack_require__(1027);\n            var imgShape = new ImageShape({\n                style: {\n                    x: 0,\n                    y: 0,\n                    image: canvas\n                }\n            });\n\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n\n            return imgShape;\n        }\n    };\n\n    module.exports = Painter;\n\n\n\n/***/ }),\n\n/***/ 1118:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var util = __webpack_require__(971);\n    var config = __webpack_require__(1000);\n    var Style = __webpack_require__(1031);\n    var Pattern = __webpack_require__(1037);\n\n    function returnFalse() {\n        return false;\n    }\n\n    /**\n     * dom\n     *\n     * @inner\n     * @param {string} id dom id \n     * @param {string} type dom typesuch as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n\n        var newDomStyle = newDom.style;\n        // append~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n\n        // id\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function(id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }\n        // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n\n        var domStyle = dom.style;\n        if (domStyle) { // Not in node\n            dom.onselectstart = returnFalse; // \n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n            domStyle['padding'] = 0;\n            domStyle['margin'] = 0;\n            domStyle['border-width'] = 0;\n        }\n\n        this.domBack = null;\n        this.ctxBack = null;\n\n        this.painter = painter;\n\n        this.config = null;\n\n        // Configs\n        /**\n         * \n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * \n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * alpha\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n\n    Layer.prototype = {\n\n        constructor: Layer,\n\n        elCount: 0,\n\n        __dirty: true,\n\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n            this.ctx.__currentValues = {};\n            this.ctx.dpr = this.dpr;\n        },\n\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n            this.ctxBack.__currentValues = {};\n\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n\n        /**\n         * @param  {number} width\n         * @param  {number} height\n         */\n        resize: function (width, height) {\n            var dpr = this.dpr;\n\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} clearAll Clear all with out motion blur\n         */\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n\n            var dpr = this.dpr;\n\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(\n                    dom, 0, 0,\n                    width / dpr,\n                    height / dpr\n                );\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }\n                // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n\n    module.exports = Layer;\n\n\n/***/ }),\n\n/***/ 1119:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    var Gradient = __webpack_require__(1010);\n    module.exports = function (ecModel) {\n        function encodeColor(seriesModel) {\n            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n            var data = seriesModel.getData();\n            var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n                || seriesModel.getColorFromPalette(seriesModel.get('name'));  // Default color\n\n            // FIXME Set color function or use the platte color\n            data.setVisual('color', color);\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof color === 'function' && !(color instanceof Gradient)) {\n                    data.each(function (idx) {\n                        data.setItemVisual(\n                            idx, 'color', color(seriesModel.getDataParams(idx))\n                        );\n                    });\n                }\n\n                // itemStyle in each data item\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var color = itemModel.get(colorAccessPath, true);\n                    if (color != null) {\n                        data.setItemVisual(idx, 'color', color);\n                    }\n                });\n            }\n        }\n        ecModel.eachRawSeries(encodeColor);\n    };\n\n\n/***/ }),\n\n/***/ 1120:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var graphic = __webpack_require__(973);\n    var zrUtil = __webpack_require__(971);\n    var PI = Math.PI;\n    /**\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Object} [opts]\n     * @param {string} [opts.text]\n     * @param {string} [opts.color]\n     * @param {string} [opts.textColor]\n     * @return {module:zrender/Element}\n     */\n    module.exports = function (api, opts) {\n        opts = opts || {};\n        zrUtil.defaults(opts, {\n            text: 'loading',\n            color: '#c23531',\n            textColor: '#000',\n            maskColor: 'rgba(255, 255, 255, 0.8)',\n            zlevel: 0\n        });\n        var mask = new graphic.Rect({\n            style: {\n                fill: opts.maskColor\n            },\n            zlevel: opts.zlevel,\n            z: 10000\n        });\n        var arc = new graphic.Arc({\n            shape: {\n                startAngle: -PI / 2,\n                endAngle: -PI / 2 + 0.1,\n                r: 10\n            },\n            style: {\n                stroke: opts.color,\n                lineCap: 'round',\n                lineWidth: 5\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n        var labelRect = new graphic.Rect({\n            style: {\n                fill: 'none',\n                text: opts.text,\n                textPosition: 'right',\n                textDistance: 10,\n                textFill: opts.textColor\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n\n        arc.animateShape(true)\n            .when(1000, {\n                endAngle: PI * 3 / 2\n            })\n            .start('circularInOut');\n        arc.animateShape(true)\n            .when(1000, {\n                startAngle: PI * 3 / 2\n            })\n            .delay(300)\n            .start('circularInOut');\n\n        var group = new graphic.Group();\n        group.add(arc);\n        group.add(labelRect);\n        group.add(mask);\n        // Inject resize\n        group.resize = function () {\n            var cx = api.getWidth() / 2;\n            var cy = api.getHeight() / 2;\n            arc.setShape({\n                cx: cx,\n                cy: cy\n            });\n            var r = arc.shape.r;\n            labelRect.setShape({\n                x: cx - r,\n                y: cy - r,\n                width: r * 2,\n                height: r * 2\n            });\n\n            mask.setShape({\n                x: 0,\n                y: 0,\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        };\n        group.resize();\n        return group;\n    };\n\n\n/***/ }),\n\n/***/ 1121:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n\n// FIXME only one data\n\n\n    var zrUtil = __webpack_require__(971);\n    var Scale = __webpack_require__(1004);\n\n    var scaleProto = Scale.prototype;\n\n    var OrdinalScale = Scale.extend({\n\n        type: 'ordinal',\n\n        init: function (data, extent) {\n            this._data = data;\n            this._extent = extent || [0, data.length - 1];\n        },\n\n        parse: function (val) {\n            return typeof val === 'string'\n                ? zrUtil.indexOf(this._data, val)\n                // val might be float.\n                : Math.round(val);\n        },\n\n        contain: function (rank) {\n            rank = this.parse(rank);\n            return scaleProto.contain.call(this, rank)\n                && this._data[rank] != null;\n        },\n\n        /**\n         * Normalize given rank or name to linear [0, 1]\n         * @param {number|string} [val]\n         * @return {number}\n         */\n        normalize: function (val) {\n            return scaleProto.normalize.call(this, this.parse(val));\n        },\n\n        scale: function (val) {\n            return Math.round(scaleProto.scale.call(this, val));\n        },\n\n        /**\n         * @return {Array}\n         */\n        getTicks: function () {\n            var ticks = [];\n            var extent = this._extent;\n            var rank = extent[0];\n\n            while (rank <= extent[1]) {\n                ticks.push(rank);\n                rank++;\n            }\n\n            return ticks;\n        },\n\n        /**\n         * Get item on rank n\n         * @param {number} n\n         * @return {string}\n         */\n        getLabel: function (n) {\n            return this._data[n];\n        },\n\n        /**\n         * @return {number}\n         */\n        count: function () {\n            return this._extent[1] - this._extent[0] + 1;\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, false));\n        },\n\n        niceTicks: zrUtil.noop,\n        niceExtent: zrUtil.noop\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    OrdinalScale.create = function () {\n        return new OrdinalScale();\n    };\n\n    module.exports = OrdinalScale;\n\n\n/***/ }),\n\n/***/ 1122:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Interval scale\n * @module echarts/coord/scale/Time\n */\n\n\n\n    // [About UTC and local time zone]:\n    // In most cases, `number.parseDate` will treat input data string as local time\n    // (except time zone is specified in time string). And `format.formateTime` returns\n    // local time by default. option.useUTC is false by default. This design have\n    // concidered these common case:\n    // (1) Time that is persistent in server is in UTC, but it is needed to be diplayed\n    // in local time by default.\n    // (2) By default, the input data string (e.g., '2011-01-02') should be displayed\n    // as its original time, without any time difference.\n\n    var zrUtil = __webpack_require__(971);\n    var numberUtil = __webpack_require__(974);\n    var formatUtil = __webpack_require__(977);\n    var scaleHelper = __webpack_require__(1041);\n\n    var IntervalScale = __webpack_require__(1012);\n\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var mathCeil = Math.ceil;\n    var mathFloor = Math.floor;\n    var ONE_SECOND = 1000;\n    var ONE_MINUTE = ONE_SECOND * 60;\n    var ONE_HOUR = ONE_MINUTE * 60;\n    var ONE_DAY = ONE_HOUR * 24;\n\n    // FIXME \n    var bisect = function (a, x, lo, hi) {\n        while (lo < hi) {\n            var mid = lo + hi >>> 1;\n            if (a[mid][2] < x) {\n                lo = mid + 1;\n            }\n            else {\n                hi  = mid;\n            }\n        }\n        return lo;\n    };\n\n    /**\n     * @alias module:echarts/coord/scale/Time\n     * @constructor\n     */\n    var TimeScale = IntervalScale.extend({\n        type: 'time',\n\n        /**\n         * @override\n         */\n        getLabel: function (val) {\n            var stepLvl = this._stepLvl;\n\n            var date = new Date(val);\n\n            return formatUtil.formatTime(stepLvl[0], date, this.getSetting('useUTC'));\n        },\n\n        /**\n         * @override\n         */\n        niceExtent: function (opt) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                // Expand extent\n                extent[0] -= ONE_DAY;\n                extent[1] += ONE_DAY;\n            }\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (extent[1] === -Infinity && extent[0] === Infinity) {\n                var d = new Date();\n                extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());\n                extent[0] = extent[1] - ONE_DAY;\n            }\n\n            this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!opt.fixMin) {\n                extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n            }\n            if (!opt.fixMax) {\n                extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n            }\n        },\n\n        /**\n         * @override\n         */\n        niceTicks: function (approxTickNum, minInterval, maxInterval) {\n            approxTickNum = approxTickNum || 10;\n\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            var approxInterval = span / approxTickNum;\n\n            if (minInterval != null && approxInterval < minInterval) {\n                approxInterval = minInterval;\n            }\n            if (maxInterval != null && approxInterval > maxInterval) {\n                approxInterval = maxInterval;\n            }\n\n            var scaleLevelsLen = scaleLevels.length;\n            var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\n            var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n            var interval = level[2];\n            // Same with interval scale if span is much larger than 1 year\n            if (level[0] === 'year') {\n                var yearSpan = span / interval;\n\n                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                // var niceYearSpan = numberUtil.nice(yearSpan, false);\n                var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\n                interval *= yearStep;\n            }\n\n            var timezoneOffset = this.getSetting('useUTC')\n                ? 0 : (new Date(+extent[0] || +extent[1])).getTimezoneOffset() * 60 * 1000;\n            var niceExtent = [\n                Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset),\n                Math.round(mathFloor((extent[1] - timezoneOffset) / interval) * interval + timezoneOffset)\n            ];\n\n            scaleHelper.fixExtent(niceExtent, extent);\n\n            this._stepLvl = level;\n            // Interval will be used in getTicks\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        parse: function (val) {\n            // val might be float.\n            return +numberUtil.parseDate(val);\n        }\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        TimeScale.prototype[methodName] = function (val) {\n            return intervalScaleProto[methodName].call(this, this.parse(val));\n        };\n    });\n\n    // Steps from d3\n    var scaleLevels = [\n        // Format       step    interval\n        ['hh:mm:ss',    1,      ONE_SECOND],           // 1s\n        ['hh:mm:ss',    5,      ONE_SECOND * 5],       // 5s\n        ['hh:mm:ss',    10,     ONE_SECOND * 10],      // 10s\n        ['hh:mm:ss',    15,     ONE_SECOND * 15],      // 15s\n        ['hh:mm:ss',    30,     ONE_SECOND * 30],      // 30s\n        ['hh:mm\\nMM-dd',1,      ONE_MINUTE],          // 1m\n        ['hh:mm\\nMM-dd',5,      ONE_MINUTE * 5],      // 5m\n        ['hh:mm\\nMM-dd',10,     ONE_MINUTE * 10],     // 10m\n        ['hh:mm\\nMM-dd',15,     ONE_MINUTE * 15],     // 15m\n        ['hh:mm\\nMM-dd',30,     ONE_MINUTE * 30],     // 30m\n        ['hh:mm\\nMM-dd',1,      ONE_HOUR],        // 1h\n        ['hh:mm\\nMM-dd',2,      ONE_HOUR * 2],    // 2h\n        ['hh:mm\\nMM-dd',6,      ONE_HOUR * 6],    // 6h\n        ['hh:mm\\nMM-dd',12,     ONE_HOUR * 12],   // 12h\n        ['MM-dd\\nyyyy', 1,      ONE_DAY],   // 1d\n        ['week',        7,      ONE_DAY * 7],        // 7d\n        ['month',       1,      ONE_DAY * 31],       // 1M\n        ['quarter',     3,      ONE_DAY * 380 / 4],  // 3M\n        ['half-year',   6,      ONE_DAY * 380 / 2],  // 6M\n        ['year',        1,      ONE_DAY * 380]       // 1Y\n    ];\n\n    /**\n     * @param {module:echarts/model/Model}\n     * @return {module:echarts/scale/Time}\n     */\n    TimeScale.create = function (model) {\n        return new TimeScale({useUTC: model.ecModel.get('useUTC')});\n    };\n\n    module.exports = TimeScale;\n\n\n/***/ }),\n\n/***/ 1123:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Log scale\n * @module echarts/scale/Log\n */\n\n\n    var zrUtil = __webpack_require__(971);\n    var Scale = __webpack_require__(1004);\n    var numberUtil = __webpack_require__(974);\n\n    // Use some method of IntervalScale\n    var IntervalScale = __webpack_require__(1012);\n\n    var scaleProto = Scale.prototype;\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var mathPow = Math.pow;\n\n    var mathLog = Math.log;\n\n    var LogScale = Scale.extend({\n\n        type: 'log',\n\n        base: 10,\n\n        $constructor: function () {\n            Scale.apply(this, arguments);\n            this._originalScale = new IntervalScale();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            var originalScale = this._originalScale;\n            var extent = this._extent;\n            var originalExtent = originalScale.getExtent();\n\n            return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n                var powVal = numberUtil.round(mathPow(this.base, val));\n\n                // Fix #4158\n                powVal = (val === extent[0] && originalScale.__fixMin)\n                    ? fixRoundingError(powVal, originalExtent[0])\n                    : powVal;\n                powVal = (val === extent[1] && originalScale.__fixMax)\n                    ? fixRoundingError(powVal, originalExtent[1])\n                    : powVal;\n\n                return powVal;\n            }, this);\n        },\n\n        /**\n         * @param {number} val\n         * @return {string}\n         */\n        getLabel: intervalScaleProto.getLabel,\n\n        /**\n         * @param  {number} val\n         * @return {number}\n         */\n        scale: function (val) {\n            val = scaleProto.scale.call(this, val);\n            return mathPow(this.base, val);\n        },\n\n        /**\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var base = this.base;\n            start = mathLog(start) / mathLog(base);\n            end = mathLog(end) / mathLog(base);\n            intervalScaleProto.setExtent.call(this, start, end);\n        },\n\n        /**\n         * @return {number} end\n         */\n        getExtent: function () {\n            var base = this.base;\n            var extent = scaleProto.getExtent.call(this);\n            extent[0] = mathPow(base, extent[0]);\n            extent[1] = mathPow(base, extent[1]);\n\n            // Fix #4158\n            var originalScale = this._originalScale;\n            var originalExtent = originalScale.getExtent();\n            originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n            originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n\n            return extent;\n        },\n\n        /**\n         * @param  {Array.<number>} extent\n         */\n        unionExtent: function (extent) {\n            this._originalScale.unionExtent(extent);\n\n            var base = this.base;\n            extent[0] = mathLog(extent[0]) / mathLog(base);\n            extent[1] = mathLog(extent[1]) / mathLog(base);\n            scaleProto.unionExtent.call(this, extent);\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, true, function (val) {\n                return val > 0;\n            }));\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         * @param  {number} [approxTickNum = 10] Given approx tick number\n         */\n        niceTicks: function (approxTickNum) {\n            approxTickNum = approxTickNum || 10;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (span === Infinity || span <= 0) {\n                return;\n            }\n\n            var interval = numberUtil.quantity(span);\n            var err = approxTickNum / span * interval;\n\n            // Filter ticks to get closer to the desired count.\n            if (err <= 0.5) {\n                interval *= 10;\n            }\n\n            // Interval should be integer\n            while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n                interval *= 10;\n            }\n\n            var niceExtent = [\n                numberUtil.round(mathCeil(extent[0] / interval) * interval),\n                numberUtil.round(mathFloor(extent[1] / interval) * interval)\n            ];\n\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @override\n         */\n        niceExtent: function (opt) {\n            intervalScaleProto.niceExtent.call(this, opt);\n\n            var originalScale = this._originalScale;\n            originalScale.__fixMin = opt.fixMin;\n            originalScale.__fixMax = opt.fixMax;\n        }\n\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        LogScale.prototype[methodName] = function (val) {\n            val = mathLog(val) / mathLog(this.base);\n            return scaleProto[methodName].call(this, val);\n        };\n    });\n\n    LogScale.create = function () {\n        return new LogScale();\n    };\n\n    function fixRoundingError(val, originalVal) {\n        return roundingErrorFix(val, getPrecisionSafe(originalVal));\n    }\n\n    module.exports = LogScale;\n\n\n/***/ }),\n\n/***/ 1124:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var createListFromArray = __webpack_require__(1008);\n    var symbolUtil = __webpack_require__(996);\n    var axisHelper = __webpack_require__(988);\n    var axisModelCommonMixin = __webpack_require__(1018);\n    var Model = __webpack_require__(979);\n    var util = __webpack_require__(971);\n\n    module.exports = {\n        /**\n         * Create a muti dimension List structure from seriesModel.\n         * @param  {module:echarts/model/Model} seriesModel\n         * @return {module:echarts/data/List} list\n         */\n        createList: function (seriesModel) {\n            var data = seriesModel.get('data');\n            return createListFromArray(data, seriesModel, seriesModel.ecModel);\n        },\n\n        /**\n         * @see {module:echarts/data/helper/completeDimensions}\n         */\n        completeDimensions: __webpack_require__(995),\n\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @see http://echarts.baidu.com/option.html#series-scatter.symbol\n         * @param {string} symbolDesc\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: symbolUtil.createSymbol,\n\n        /**\n         * Create scale\n         * @param {Array.<number>} dataExtent\n         * @param {Object|module:echarts/Model} option\n         */\n        createScale: function (dataExtent, option) {\n            var axisModel = option;\n            if (!(option instanceof Model)) {\n                axisModel = new Model(option);\n                util.mixin(axisModel, axisModelCommonMixin);\n            }\n\n            var scale = axisHelper.createScaleByModel(axisModel);\n            scale.setExtent(dataExtent[0], dataExtent[1]);\n\n            axisHelper.niceScaleExtent(scale, axisModel);\n            return scale;\n        },\n\n        /**\n         * Mixin common methods to axis model,\n         *\n         * Inlcude methods\n         * `getFormattedLabels() => Array.<string>`\n         * `getCategories() => Array.<string>`\n         * `getMin(origin: boolean) => number`\n         * `getMax(origin: boolean) => number`\n         * `getNeedCrossZero() => boolean`\n         * `setRange(start: number, end: number)`\n         * `resetRange()`\n         */\n        mixinAxisModelCommonMethods: function (Model) {\n            util.mixin(Model, axisModelCommonMixin);\n        }\n    };\n\n\n/***/ }),\n\n/***/ 1125:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(971);\n    var modelUtil = __webpack_require__(975);\n    var modelHelper = __webpack_require__(1005);\n    var findPointFromSeries = __webpack_require__(1042);\n\n    var each = zrUtil.each;\n    var curry = zrUtil.curry;\n    var get = modelUtil.makeGetter();\n\n    /**\n     * Basic logic: check all axis, if they do not demand show/highlight,\n     * then hide/downplay them.\n     *\n     * @param {Object} coordSysAxesInfo\n     * @param {Object} payload\n     * @param {string} [payload.currTrigger] 'click' | 'mousemove' | 'leave'\n     * @param {Array.<number>} [payload.x] x and y, which are mandatory, specify a point to\n     *              trigger axisPointer and tooltip.\n     * @param {Array.<number>} [payload.y] x and y, which are mandatory, specify a point to\n     *              trigger axisPointer and tooltip.\n     * @param {Object} [payload.seriesIndex] finder, optional, restrict target axes.\n     * @param {Object} [payload.dataIndex] finder, restrict target axes.\n     * @param {Object} [payload.axesInfo] finder, restrict target axes.\n     *        [{\n     *          axisDim: 'x'|'y'|'angle'|...,\n     *          axisIndex: ...,\n     *          value: ...\n     *        }, ...]\n     * @param {Function} [payload.dispatchAction]\n     * @param {Object} [payload.tooltipOption]\n     * @param {Object|Array.<number>|Function} [payload.position] Tooltip position,\n     *        which can be specified in dispatchAction\n     * @param {module:echarts/model/Global} ecModel\n     * @param {module:echarts/ExtensionAPI} api\n     * @return {Object} content of event obj for echarts.connect.\n     */\n    function axisTrigger(payload, ecModel, api) {\n        var currTrigger = payload.currTrigger;\n        var point = [payload.x, payload.y];\n        var finder = payload;\n        var dispatchAction = payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n        var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n        // Pending\n        // See #6121. But we are not able to reproduce it yet.\n        if (!coordSysAxesInfo) {\n            return;\n        }\n\n        if (illegalPoint(point)) {\n            // Used in the default behavior of `connection`: use the sample seriesIndex\n            // and dataIndex. And also used in the tooltipView trigger.\n            point = findPointFromSeries({\n                seriesIndex: finder.seriesIndex,\n                // Do not use dataIndexInside from other ec instance.\n                // FIXME: auto detect it?\n                dataIndex: finder.dataIndex\n            }, ecModel).point;\n        }\n        var isIllegalPoint = illegalPoint(point);\n\n        // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).\n        // Notice: In this case, it is difficult to get the `point` (which is necessary to show\n        // tooltip, so if point is not given, we just use the point found by sample seriesIndex\n        // and dataIndex.\n        var inputAxesInfo = finder.axesInfo;\n\n        var axesInfo = coordSysAxesInfo.axesInfo;\n        var shouldHide = currTrigger === 'leave' || illegalPoint(point);\n        var outputFinder = {};\n\n        var showValueMap = {};\n        var dataByCoordSys = {list: [], map: {}};\n        var updaters = {\n            showPointer: curry(showPointer, showValueMap),\n            showTooltip: curry(showTooltip, dataByCoordSys)\n        };\n\n        // Process for triggered axes.\n        each(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {\n            // If a point given, it must be contained by the coordinate system.\n            var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);\n\n            each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {\n                var axis = axisInfo.axis;\n                var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);\n                // If no inputAxesInfo, no axis is restricted.\n                if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {\n                    var val = inputAxisInfo && inputAxisInfo.value;\n                    if (val == null && !isIllegalPoint) {\n                        val = axis.pointToData(point);\n                    }\n                    val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);\n                }\n            });\n        });\n\n        // Process for linked axes.\n        var linkTriggers = {};\n        each(axesInfo, function (tarAxisInfo, tarKey) {\n            var linkGroup = tarAxisInfo.linkGroup;\n\n            // If axis has been triggered in the previous stage, it should not be triggered by link.\n            if (linkGroup && !showValueMap[tarKey]) {\n                each(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {\n                    var srcValItem = showValueMap[srcKey];\n                    // If srcValItem exist, source axis is triggered, so link to target axis.\n                    if (srcAxisInfo !== tarAxisInfo && srcValItem) {\n                        var val = srcValItem.value;\n                        linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(\n                            val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo)\n                        )));\n                        linkTriggers[tarAxisInfo.key] = val;\n                    }\n                });\n            }\n        });\n        each(linkTriggers, function (val, tarKey) {\n            processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);\n        });\n\n        updateModelActually(showValueMap, axesInfo, outputFinder);\n        dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);\n        dispatchHighDownActually(axesInfo, dispatchAction, api);\n\n        return outputFinder;\n    }\n\n    function processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {\n        var axis = axisInfo.axis;\n\n        if (axis.scale.isBlank() || !axis.containData(newValue)) {\n            return;\n        }\n\n        if (!axisInfo.involveSeries) {\n            updaters.showPointer(axisInfo, newValue);\n            return;\n        }\n\n        // Heavy calculation. So put it after axis.containData checking.\n        var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);\n        var payloadBatch = payloadInfo.payloadBatch;\n        var snapToValue = payloadInfo.snapToValue;\n\n        // Fill content of event obj for echarts.connect.\n        // By defualt use the first involved series data as a sample to connect.\n        if (payloadBatch[0] && outputFinder.seriesIndex == null) {\n            zrUtil.extend(outputFinder, payloadBatch[0]);\n        }\n\n        // If no linkSource input, this process is for collecting link\n        // target, where snap should not be accepted.\n        if (!dontSnap && axisInfo.snap) {\n            if (axis.containData(snapToValue) && snapToValue != null) {\n                newValue = snapToValue;\n            }\n        }\n\n        updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder);\n        // Tooltip should always be snapToValue, otherwise there will be\n        // incorrect \"axis value ~ series value\" mapping displayed in tooltip.\n        updaters.showTooltip(axisInfo, payloadInfo, snapToValue);\n    }\n\n    function buildPayloadsBySeries(value, axisInfo) {\n        var axis = axisInfo.axis;\n        var dim = axis.dim;\n        var snapToValue = value;\n        var payloadBatch = [];\n        var minDist = Number.MAX_VALUE;\n        var minDiff = -1;\n\n        each(axisInfo.seriesModels, function (series, idx) {\n            var dataDim = series.coordDimToDataDim(dim);\n            var seriesNestestValue;\n            var dataIndices;\n\n            if (series.getAxisTooltipData) {\n                var result = series.getAxisTooltipData(dataDim, value, axis);\n                dataIndices = result.dataIndices;\n                seriesNestestValue = result.nestestValue;\n            }\n            else {\n                dataIndices = series.getData().indicesOfNearest(\n                    dataDim[0],\n                    value,\n                    // Add a threshold to avoid find the wrong dataIndex\n                    // when data length is not same.\n                    false, axis.type === 'category' ? 0.5 : null\n                );\n                if (!dataIndices.length) {\n                    return;\n                }\n                seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);\n            }\n\n            if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {\n                return;\n            }\n\n            var diff = value - seriesNestestValue;\n            var dist = Math.abs(diff);\n            // Consider category case\n            if (dist <= minDist) {\n                if (dist < minDist || (diff >= 0 && minDiff < 0)) {\n                    minDist = dist;\n                    minDiff = diff;\n                    snapToValue = seriesNestestValue;\n                    payloadBatch.length = 0;\n                }\n                each(dataIndices, function (dataIndex) {\n                    payloadBatch.push({\n                        seriesIndex: series.seriesIndex,\n                        dataIndexInside: dataIndex,\n                        dataIndex: series.getData().getRawIndex(dataIndex)\n                    });\n                });\n            }\n        });\n\n        return {\n            payloadBatch: payloadBatch,\n            snapToValue: snapToValue\n        };\n    }\n\n    function showPointer(showValueMap, axisInfo, value, payloadBatch) {\n        showValueMap[axisInfo.key] = {value: value, payloadBatch: payloadBatch};\n    }\n\n    function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {\n        var payloadBatch = payloadInfo.payloadBatch;\n        var axis = axisInfo.axis;\n        var axisModel = axis.model;\n        var axisPointerModel = axisInfo.axisPointerModel;\n\n        // If no data, do not create anything in dataByCoordSys,\n        // whose length will be used to judge whether dispatch action.\n        if (!axisInfo.triggerTooltip || !payloadBatch.length) {\n            return;\n        }\n\n        var coordSysModel = axisInfo.coordSys.model;\n        var coordSysKey = modelHelper.makeKey(coordSysModel);\n        var coordSysItem = dataByCoordSys.map[coordSysKey];\n        if (!coordSysItem) {\n            coordSysItem = dataByCoordSys.map[coordSysKey] = {\n                coordSysId: coordSysModel.id,\n                coordSysIndex: coordSysModel.componentIndex,\n                coordSysType: coordSysModel.type,\n                coordSysMainType: coordSysModel.mainType,\n                dataByAxis: []\n            };\n            dataByCoordSys.list.push(coordSysItem);\n        }\n\n        coordSysItem.dataByAxis.push({\n            axisDim: axis.dim,\n            axisIndex: axisModel.componentIndex,\n            axisType: axisModel.type,\n            axisId: axisModel.id,\n            value: value,\n            // Caustion: viewHelper.getValueLabel is actually on \"view stage\", which\n            // depends that all models have been updated. So it should not be performed\n            // here. Considering axisPointerModel used here is volatile, which is hard\n            // to be retrieve in TooltipView, we prepare parameters here.\n            valueLabelOpt: {\n                precision: axisPointerModel.get('label.precision'),\n                formatter: axisPointerModel.get('label.formatter')\n            },\n            seriesDataIndices: payloadBatch.slice()\n        });\n    }\n\n    function updateModelActually(showValueMap, axesInfo, outputFinder) {\n        var outputAxesInfo = outputFinder.axesInfo = [];\n        // Basic logic: If no 'show' required, 'hide' this axisPointer.\n        each(axesInfo, function (axisInfo, key) {\n            var option = axisInfo.axisPointerModel.option;\n            var valItem = showValueMap[key];\n\n            if (valItem) {\n                !axisInfo.useHandle && (option.status = 'show');\n                option.value = valItem.value;\n                // For label formatter param and highlight.\n                option.seriesDataIndices = (valItem.payloadBatch || []).slice();\n            }\n            // When always show (e.g., handle used), remain\n            // original value and status.\n            else {\n                // If hide, value still need to be set, consider\n                // click legend to toggle axis blank.\n                !axisInfo.useHandle && (option.status = 'hide');\n            }\n\n            // If status is 'hide', should be no info in payload.\n            option.status === 'show' && outputAxesInfo.push({\n                axisDim: axisInfo.axis.dim,\n                axisIndex: axisInfo.axis.model.componentIndex,\n                value: option.value\n            });\n        });\n    }\n\n    function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {\n        // Basic logic: If no showTip required, hideTip will be dispatched.\n        if (illegalPoint(point) || !dataByCoordSys.list.length) {\n            dispatchAction({type: 'hideTip'});\n            return;\n        }\n\n        // In most case only one axis (or event one series is used). It is\n        // convinient to fetch payload.seriesIndex and payload.dataIndex\n        // dirtectly. So put the first seriesIndex and dataIndex of the first\n        // axis on the payload.\n        var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};\n\n        dispatchAction({\n            type: 'showTip',\n            escapeConnect: true,\n            x: point[0],\n            y: point[1],\n            tooltipOption: payload.tooltipOption,\n            position: payload.position,\n            dataIndexInside: sampleItem.dataIndexInside,\n            dataIndex: sampleItem.dataIndex,\n            seriesIndex: sampleItem.seriesIndex,\n            dataByCoordSys: dataByCoordSys.list\n        });\n    }\n\n    function dispatchHighDownActually(axesInfo, dispatchAction, api) {\n        // FIXME\n        // highlight status modification shoule be a stage of main process?\n        // (Consider confilct (e.g., legend and axisPointer) and setOption)\n\n        var zr = api.getZr();\n        var highDownKey = 'axisPointerLastHighlights';\n        var lastHighlights = get(zr)[highDownKey] || {};\n        var newHighlights = get(zr)[highDownKey] = {};\n\n        // Update highlight/downplay status according to axisPointer model.\n        // Build hash map and remove duplicate incidentally.\n        each(axesInfo, function (axisInfo, key) {\n            var option = axisInfo.axisPointerModel.option;\n            option.status === 'show' && each(option.seriesDataIndices, function (batchItem) {\n                var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;\n                newHighlights[key] = batchItem;\n            });\n        });\n\n        // Diff.\n        var toHighlight = [];\n        var toDownplay = [];\n        zrUtil.each(lastHighlights, function (batchItem, key) {\n            !newHighlights[key] && toDownplay.push(batchItem);\n        });\n        zrUtil.each(newHighlights, function (batchItem, key) {\n            !lastHighlights[key] && toHighlight.push(batchItem);\n        });\n\n        toDownplay.length && api.dispatchAction({\n            type: 'downplay', escapeConnect: true, batch: toDownplay\n        });\n        toHighlight.length && api.dispatchAction({\n            type: 'highlight', escapeConnect: true, batch: toHighlight\n        });\n    }\n\n    function findInputAxisInfo(inputAxesInfo, axisInfo) {\n        for (var i = 0; i < (inputAxesInfo || []).length; i++) {\n            var inputAxisInfo = inputAxesInfo[i];\n            if (axisInfo.axis.dim === inputAxisInfo.axisDim\n                && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex\n            ) {\n                return inputAxisInfo;\n            }\n        }\n    }\n\n    function makeMapperParam(axisInfo) {\n        var axisModel = axisInfo.axis.model;\n        var item = {};\n        var dim = item.axisDim = axisInfo.axis.dim;\n        item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;\n        item.axisName = item[dim + 'AxisName'] = axisModel.name;\n        item.axisId = item[dim + 'AxisId'] = axisModel.id;\n        return item;\n    }\n\n    function illegalPoint(point) {\n        return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);\n    }\n\n    module.exports = axisTrigger;\n\n\n/***/ }),\n\n/***/ 1126:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var echarts = __webpack_require__(972);\n\n    var AxisPointerModel = echarts.extendComponentModel({\n\n        type: 'axisPointer',\n\n        coordSysAxesInfo: null,\n\n        defaultOption: {\n            // 'auto' means that show when triggered by tooltip or handle.\n            show: 'auto',\n            // 'click' | 'mousemove' | 'none'\n            triggerOn: null, // set default in AxisPonterView.js\n\n            zlevel: 0,\n            z: 50,\n\n            type: 'line',\n            // axispointer triggered by tootip determine snap automatically,\n            // see `modelHelper`.\n            snap: false,\n            triggerTooltip: true,\n\n            value: null,\n            status: null, // Init value depends on whether handle is used.\n\n            // [group0, group1, ...]\n            // Each group can be: {\n            //      mapper: function () {},\n            //      singleTooltip: 'multiple',  // 'multiple' or 'single'\n            //      xAxisId: ...,\n            //      yAxisName: ...,\n            //      angleAxisIndex: ...\n            // }\n            // mapper: can be ignored.\n            //      input: {axisInfo, value}\n            //      output: {axisInfo, value}\n            link: [],\n\n            // Do not set 'auto' here, otherwise global animation: false\n            // will not effect at this axispointer.\n            animation: null,\n            animationDurationUpdate: 200,\n\n            lineStyle: {\n                color: '#aaa',\n                width: 1,\n                type: 'solid'\n            },\n\n            shadowStyle: {\n                color: 'rgba(150,150,150,0.3)'\n            },\n\n            label: {\n                show: true,\n                formatter: null, // string | Function\n                precision: 'auto', // Or a number like 0, 1, 2 ...\n                margin: 3,\n                color: '#fff',\n                padding: [5, 7, 5, 7],\n                backgroundColor: 'auto', // default: axis line color\n                borderColor: null,\n                borderWidth: 0,\n                shadowBlur: 3,\n                shadowColor: '#aaa'\n                // Considering applicability, common style should\n                // better not have shadowOffset.\n                // shadowOffsetX: 0,\n                // shadowOffsetY: 2\n            },\n\n            handle: {\n                show: false,\n                icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z', // jshint ignore:line\n                size: 45,\n                // handle margin is from symbol center to axis, which is stable when circular move.\n                margin: 50,\n                // color: '#1b8bbd'\n                // color: '#2f4554'\n                color: '#333',\n                shadowBlur: 3,\n                shadowColor: '#aaa',\n                shadowOffsetX: 0,\n                shadowOffsetY: 2,\n\n                // For mobile performance\n                throttle: 40\n            }\n        }\n\n    });\n\n    module.exports = AxisPointerModel;\n\n\n\n/***/ }),\n\n/***/ 1127:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var globalListener = __webpack_require__(1043);\n\n    var AxisPonterView = __webpack_require__(972).extendComponentView({\n\n        type: 'axisPointer',\n\n        render: function (globalAxisPointerModel, ecModel, api) {\n            var globalTooltipModel = ecModel.getComponent('tooltip');\n            var triggerOn = globalAxisPointerModel.get('triggerOn')\n                || (globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click');\n\n            // Register global listener in AxisPointerView to enable\n            // AxisPointerView to be independent to Tooltip.\n            globalListener.register(\n                'axisPointer',\n                api,\n                function (currTrigger, e, dispatchAction) {\n                    // If 'none', it is not controlled by mouse totally.\n                    if (triggerOn !== 'none'\n                        && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)\n                    ) {\n                        dispatchAction({\n                            type: 'updateAxisPointer',\n                            currTrigger: currTrigger,\n                            x: e && e.offsetX,\n                            y: e && e.offsetY\n                        });\n                    }\n                }\n            );\n        },\n\n        /**\n         * @override\n         */\n        remove: function (ecModel, api) {\n            globalListener.disopse(api.getZr(), 'axisPointer');\n            AxisPonterView.superApply(this._model, 'remove', arguments);\n        },\n\n        /**\n         * @override\n         */\n        dispose: function (ecModel, api) {\n            globalListener.unregister('axisPointer', api);\n            AxisPonterView.superApply(this._model, 'dispose', arguments);\n        }\n\n    });\n\n\n\n/***/ }),\n\n/***/ 1128:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    __webpack_require__(972).extendComponentModel({\n\n        type: 'tooltip',\n\n        dependencies: ['axisPointer'],\n\n        defaultOption: {\n            zlevel: 0,\n\n            z: 8,\n\n            show: true,\n\n            // tooltip\n            showContent: true,\n\n            // 'trigger' only works on coordinate system.\n            // 'item' | 'axis' | 'none'\n            trigger: 'item',\n\n            // 'click' | 'mousemove' | 'none'\n            triggerOn: 'mousemove|click',\n\n            alwaysShowContent: false,\n\n            displayMode: 'single', // 'single' | 'multipleByCoordSys'\n\n            //  {Array} | {Function}\n            // position: null\n            // Consider triggered from axisPointer handle, verticalAlign should be 'middle'\n            // align: null,\n            // verticalAlign: null,\n\n            //  content  viewRect  false \n            confine: false,\n\n            // {string}Template  {Function}\n            // formatter: null\n\n            showDelay: 0,\n\n            // ms\n            hideDelay: 100,\n\n            // s\n            transitionDuration: 0.4,\n\n            enterable: false,\n\n            // 0.7\n            backgroundColor: 'rgba(50,50,50,0.7)',\n\n            // \n            borderColor: '#333',\n\n            // px4\n            borderRadius: 4,\n\n            // px0\n            borderWidth: 0,\n\n            // px5\n            // css\n            padding: 5,\n\n            // Extra css text\n            extraCssText: '',\n\n            // \n            axisPointer: {\n                // \n                // 'line' | 'shadow' | 'cross'\n                type: 'line',\n\n                // type  line  tooltip line \n                //  'x' | 'y' | 'angle' | 'radius' | 'auto'\n                //  'auto' cateogry  x \n                //  angle \n                axis: 'auto',\n\n                animation: 'auto',\n                animationDurationUpdate: 200,\n                animationEasingUpdate: 'exponentialOut',\n\n                crossStyle: {\n                    color: '#999',\n                    width: 1,\n                    type: 'dashed',\n\n                    // TODO formatter\n                    textStyle: {}\n                }\n\n                // lineStyle and shadowStyle should not be specified here,\n                // otherwise it will always override those styles on option.axisPointer.\n            },\n            textStyle: {\n                color: '#fff',\n                fontSize: 14\n            }\n        }\n    });\n\n\n/***/ }),\n\n/***/ 1129:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var TooltipContent = __webpack_require__(1130);\n    var zrUtil = __webpack_require__(971);\n    var formatUtil = __webpack_require__(977);\n    var numberUtil = __webpack_require__(974);\n    var graphic = __webpack_require__(973);\n    var findPointFromSeries = __webpack_require__(1042);\n    var layoutUtil = __webpack_require__(981);\n    var env = __webpack_require__(978);\n    var Model = __webpack_require__(979);\n    var globalListener = __webpack_require__(1043);\n    var axisHelper = __webpack_require__(988);\n    var axisPointerViewHelper = __webpack_require__(1023);\n\n    var bind = zrUtil.bind;\n    var each = zrUtil.each;\n    var parsePercent = numberUtil.parsePercent;\n\n\n    var proxyRect = new graphic.Rect({\n        shape: {x: -1, y: -1, width: 2, height: 2}\n    });\n\n    __webpack_require__(972).extendComponentView({\n\n        type: 'tooltip',\n\n        init: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            var tooltipContent = new TooltipContent(api.getDom(), api);\n            this._tooltipContent = tooltipContent;\n        },\n\n        render: function (tooltipModel, ecModel, api) {\n            if (env.node) {\n                return;\n            }\n\n            // Reset\n            this.group.removeAll();\n\n            /**\n             * @private\n             * @type {module:echarts/component/tooltip/TooltipModel}\n             */\n            this._tooltipModel = tooltipModel;\n\n            /**\n             * @private\n             * @type {module:echarts/model/Global}\n             */\n            this._ecModel = ecModel;\n\n            /**\n             * @private\n             * @type {module:echarts/ExtensionAPI}\n             */\n            this._api = api;\n\n            /**\n             * Should be cleaned when render.\n             * @private\n             * @type {Array.<Array.<Object>>}\n             */\n            this._lastDataByCoordSys = null;\n\n            /**\n             * @private\n             * @type {boolean}\n             */\n            this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n\n            var tooltipContent = this._tooltipContent;\n            tooltipContent.update();\n            tooltipContent.setEnterable(tooltipModel.get('enterable'));\n\n            this._initGlobalListener();\n\n            this._keepShow();\n        },\n\n        _initGlobalListener: function () {\n            var tooltipModel = this._tooltipModel;\n            var triggerOn = tooltipModel.get('triggerOn');\n\n            globalListener.register(\n                'itemTooltip',\n                this._api,\n                bind(function (currTrigger, e, dispatchAction) {\n                    // If 'none', it is not controlled by mouse totally.\n                    if (triggerOn !== 'none') {\n                        if (triggerOn.indexOf(currTrigger) >= 0) {\n                            this._tryShow(e, dispatchAction);\n                        }\n                        else if (currTrigger === 'leave') {\n                            this._hide(dispatchAction);\n                        }\n                    }\n                }, this)\n            );\n        },\n\n        _keepShow: function () {\n            var tooltipModel = this._tooltipModel;\n            var ecModel = this._ecModel;\n            var api = this._api;\n\n            // Try to keep the tooltip show when refreshing\n            if (this._lastX != null\n                && this._lastY != null\n                // When user is willing to control tooltip totally using API,\n                // self.manuallyShowTip({x, y}) might cause tooltip hide,\n                // which is not expected.\n                && tooltipModel.get('triggerOn') !== 'none'\n            ) {\n                var self = this;\n                clearTimeout(this._refreshUpdateTimeout);\n                this._refreshUpdateTimeout = setTimeout(function () {\n                    // Show tip next tick after other charts are rendered\n                    // In case highlight action has wrong result\n                    // FIXME\n                    self.manuallyShowTip(tooltipModel, ecModel, api, {\n                        x: self._lastX,\n                        y: self._lastY\n                    });\n                });\n            }\n        },\n\n        /**\n         * Show tip manually by\n         * dispatchAction({\n         *     type: 'showTip',\n         *     x: 10,\n         *     y: 10\n         * });\n         * Or\n         * dispatchAction({\n         *      type: 'showTip',\n         *      seriesIndex: 0,\n         *      dataIndex or dataIndexInside or name\n         * });\n         *\n         *  TODO Batch\n         */\n        manuallyShowTip: function (tooltipModel, ecModel, api, payload) {\n            if (payload.from === this.uid || env.node) {\n                return;\n            }\n\n            var dispatchAction = makeDispatchAction(payload, api);\n\n            // Reset ticket\n            this._ticket = '';\n\n            // When triggered from axisPointer.\n            var dataByCoordSys = payload.dataByCoordSys;\n\n            if (payload.tooltip && payload.x != null && payload.y != null) {\n                var el = proxyRect;\n                el.position = [payload.x, payload.y];\n                el.update();\n                el.tooltip = payload.tooltip;\n                // Manually show tooltip while view is not using zrender elements.\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    target: el\n                }, dispatchAction);\n            }\n            else if (dataByCoordSys) {\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    position: payload.position,\n                    event: {},\n                    dataByCoordSys: payload.dataByCoordSys,\n                    tooltipOption: payload.tooltipOption\n                }, dispatchAction);\n            }\n            else if (payload.seriesIndex != null) {\n\n                if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {\n                    return;\n                }\n\n                var pointInfo = findPointFromSeries(payload, ecModel);\n                var cx = pointInfo.point[0];\n                var cy = pointInfo.point[1];\n                if (cx != null && cy != null) {\n                    this._tryShow({\n                        offsetX: cx,\n                        offsetY: cy,\n                        position: payload.position,\n                        target: pointInfo.el,\n                        event: {}\n                    }, dispatchAction);\n                }\n            }\n            else if (payload.x != null && payload.y != null) {\n                // FIXME\n                // should wrap dispatchAction like `axisPointer/globalListener` ?\n                api.dispatchAction({\n                    type: 'updateAxisPointer',\n                    x: payload.x,\n                    y: payload.y\n                });\n\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    position: payload.position,\n                    target: api.getZr().findHover(payload.x, payload.y).target,\n                    event: {}\n                }, dispatchAction);\n            }\n        },\n\n        manuallyHideTip: function (tooltipModel, ecModel, api, payload) {\n            var tooltipContent = this._tooltipContent;\n\n            if (!this._alwaysShowContent) {\n                tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n            }\n\n            this._lastX = this._lastY = null;\n\n            if (payload.from !== this.uid) {\n                this._hide(makeDispatchAction(payload, api));\n            }\n        },\n\n        // Be compatible with previous design, that is, when tooltip.type is 'axis' and\n        // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer\n        // and tooltip.\n        _manuallyAxisShowTip: function (tooltipModel, ecModel, api, payload) {\n            var seriesIndex = payload.seriesIndex;\n            var dataIndex = payload.dataIndex;\n            var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n            if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {\n                return;\n            }\n\n            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n            if (!seriesModel) {\n                return;\n            }\n\n            var data = seriesModel.getData();\n            var tooltipModel = buildTooltipModel([\n                data.getItemModel(dataIndex),\n                seriesModel,\n                (seriesModel.coordinateSystem || {}).model,\n                tooltipModel\n            ]);\n\n            if (tooltipModel.get('trigger') !== 'axis') {\n                return;\n            }\n\n            api.dispatchAction({\n                type: 'updateAxisPointer',\n                seriesIndex: seriesIndex,\n                dataIndex: dataIndex,\n                position: payload.position\n            });\n\n            return true;\n        },\n\n        _tryShow: function (e, dispatchAction) {\n            var el = e.target;\n            var tooltipModel = this._tooltipModel;\n\n            if (!tooltipModel) {\n                return;\n            }\n\n            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n            this._lastX = e.offsetX;\n            this._lastY = e.offsetY;\n\n            var dataByCoordSys = e.dataByCoordSys;\n            if (dataByCoordSys && dataByCoordSys.length) {\n                this._showAxisTooltip(dataByCoordSys, e);\n            }\n            // Always show item tooltip if mouse is on the element with dataIndex\n            else if (el && el.dataIndex != null) {\n                this._lastDataByCoordSys = null;\n                this._showSeriesItemTooltip(e, el, dispatchAction);\n            }\n            // Tooltip provided directly. Like legend.\n            else if (el && el.tooltip) {\n                this._lastDataByCoordSys = null;\n                this._showComponentItemTooltip(e, el, dispatchAction);\n            }\n            else {\n                this._lastDataByCoordSys = null;\n                this._hide(dispatchAction);\n            }\n        },\n\n        _showOrMove: function (tooltipModel, cb) {\n            // showDelay is used in this case: tooltip.enterable is set\n            // as true. User intent to move mouse into tooltip and click\n            // something. `showDelay` makes it easyer to enter the content\n            // but tooltip do not move immediately.\n            var delay = tooltipModel.get('showDelay');\n            cb = zrUtil.bind(cb, this);\n            clearTimeout(this._showTimout);\n            delay > 0\n                ? (this._showTimout = setTimeout(cb, delay))\n                : cb();\n        },\n\n        _showAxisTooltip: function (dataByCoordSys, e) {\n            var ecModel = this._ecModel;\n            var globalTooltipModel = this._tooltipModel;\n            var point = [e.offsetX, e.offsetY];\n            var singleDefaultHTML = [];\n            var singleParamsList = [];\n            var singleTooltipModel = buildTooltipModel([\n                e.tooltipOption,\n                globalTooltipModel\n            ]);\n\n            each(dataByCoordSys, function (itemCoordSys) {\n                // var coordParamList = [];\n                // var coordDefaultHTML = [];\n                // var coordTooltipModel = buildTooltipModel([\n                //     e.tooltipOption,\n                //     itemCoordSys.tooltipOption,\n                //     ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex),\n                //     globalTooltipModel\n                // ]);\n                // var displayMode = coordTooltipModel.get('displayMode');\n                // var paramsList = displayMode === 'single' ? singleParamsList : [];\n\n                each(itemCoordSys.dataByAxis, function (item) {\n                    var axisModel = ecModel.getComponent(item.axisDim + 'Axis', item.axisIndex);\n                    var axisValue = item.value;\n                    var seriesDefaultHTML = [];\n\n                    if (!axisModel || axisValue == null) {\n                        return;\n                    }\n\n                    var valueLabel = axisPointerViewHelper.getValueLabel(\n                        axisValue, axisModel.axis, ecModel,\n                        item.seriesDataIndices,\n                        item.valueLabelOpt\n                    );\n\n                    zrUtil.each(item.seriesDataIndices, function (idxItem) {\n                        var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n                        var dataIndex = idxItem.dataIndexInside;\n                        var dataParams = series && series.getDataParams(dataIndex);\n                        dataParams.axisDim = item.axisDim;\n                        dataParams.axisIndex = item.axisIndex;\n                        dataParams.axisType = item.axisType;\n                        dataParams.axisId = item.axisId;\n                        dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue);\n                        dataParams.axisValueLabel = valueLabel;\n\n                        if (dataParams) {\n                            singleParamsList.push(dataParams);\n                            seriesDefaultHTML.push(series.formatTooltip(dataIndex, true));\n                        }\n                    });\n\n                    // Default tooltip content\n                    // FIXME\n                    // (1) shold be the first data which has name?\n                    // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n                    var firstLine = valueLabel;\n                    singleDefaultHTML.push(\n                        (firstLine ? formatUtil.encodeHTML(firstLine) + '<br />' : '')\n                        + seriesDefaultHTML.join('<br />')\n                    );\n                });\n            }, this);\n\n            // In most case, the second axis is shown upper than the first one.\n            singleDefaultHTML.reverse();\n            singleDefaultHTML = singleDefaultHTML.join('<br /><br />');\n\n            var positionExpr = e.position;\n            this._showOrMove(singleTooltipModel, function () {\n                if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {\n                    this._updatePosition(\n                        singleTooltipModel,\n                        positionExpr,\n                        point[0], point[1],\n                        this._tooltipContent,\n                        singleParamsList\n                    );\n                }\n                else {\n                    this._showTooltipContent(\n                        singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(),\n                        point[0], point[1], positionExpr\n                    );\n                }\n            });\n\n            // Do not trigger events here, because this branch only be entered\n            // from dispatchAction.\n        },\n\n        _showSeriesItemTooltip: function (e, el, dispatchAction) {\n            var ecModel = this._ecModel;\n            // Use dataModel in element if possible\n            // Used when mouseover on a element like markPoint or edge\n            // In which case, the data is not main data in series.\n            var seriesIndex = el.seriesIndex;\n            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n\n            // For example, graph link.\n            var dataModel = el.dataModel || seriesModel;\n            var dataIndex = el.dataIndex;\n            var dataType = el.dataType;\n            var data = dataModel.getData();\n\n            var tooltipModel = buildTooltipModel([\n                data.getItemModel(dataIndex),\n                dataModel,\n                seriesModel && (seriesModel.coordinateSystem || {}).model,\n                this._tooltipModel\n            ]);\n\n            var tooltipTrigger = tooltipModel.get('trigger');\n            if (tooltipTrigger != null && tooltipTrigger !== 'item') {\n                return;\n            }\n\n            var params = dataModel.getDataParams(dataIndex, dataType);\n            var defaultHtml = dataModel.formatTooltip(dataIndex, false, dataType);\n            var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;\n\n            this._showOrMove(tooltipModel, function () {\n                this._showTooltipContent(\n                    tooltipModel, defaultHtml, params, asyncTicket,\n                    e.offsetX, e.offsetY, e.position, e.target\n                );\n            });\n\n            // FIXME\n            // duplicated showtip if manuallyShowTip is called from dispatchAction.\n            dispatchAction({\n                type: 'showTip',\n                dataIndexInside: dataIndex,\n                dataIndex: data.getRawIndex(dataIndex),\n                seriesIndex: seriesIndex,\n                from: this.uid\n            });\n        },\n\n        _showComponentItemTooltip: function (e, el, dispatchAction) {\n            var tooltipOpt = el.tooltip;\n            if (typeof tooltipOpt === 'string') {\n                var content = tooltipOpt;\n                tooltipOpt = {\n                    content: content,\n                    // Fixed formatter\n                    formatter: content\n                };\n            }\n            var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel);\n            var defaultHtml = subTooltipModel.get('content');\n            var asyncTicket = Math.random();\n\n            // Do not check whether `trigger` is 'none' here, because `trigger`\n            // only works on cooridinate system. In fact, we have not found case\n            // that requires setting `trigger` nothing on component yet.\n\n            this._showOrMove(subTooltipModel, function () {\n                this._showTooltipContent(\n                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},\n                    asyncTicket, e.offsetX, e.offsetY, e.position, el\n                );\n            });\n\n            // If not dispatch showTip, tip may be hide triggered by axis.\n            dispatchAction({\n                type: 'showTip',\n                from: this.uid\n            });\n        },\n\n        _showTooltipContent: function (\n            tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el\n        ) {\n            // Reset ticket\n            this._ticket = '';\n\n            if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {\n                return;\n            }\n\n            var tooltipContent = this._tooltipContent;\n\n            var formatter = tooltipModel.get('formatter');\n            positionExpr = positionExpr || tooltipModel.get('position');\n            var html = defaultHtml;\n\n            if (formatter && typeof formatter === 'string') {\n                html = formatUtil.formatTpl(formatter, params, true);\n            }\n            else if (typeof formatter === 'function') {\n                var callback = bind(function (cbTicket, html) {\n                    if (cbTicket === this._ticket) {\n                        tooltipContent.setContent(html);\n                        this._updatePosition(\n                            tooltipModel, positionExpr, x, y, tooltipContent, params, el\n                        );\n                    }\n                }, this);\n                this._ticket = asyncTicket;\n                html = formatter(params, asyncTicket, callback);\n            }\n\n            tooltipContent.setContent(html);\n            tooltipContent.show(tooltipModel);\n\n            this._updatePosition(\n                tooltipModel, positionExpr, x, y, tooltipContent, params, el\n            );\n        },\n\n        /**\n         * @param  {string|Function|Array.<number>|Object} positionExpr\n         * @param  {number} x Mouse x\n         * @param  {number} y Mouse y\n         * @param  {boolean} confine Whether confine tooltip content in view rect.\n         * @param  {Object|<Array.<Object>} params\n         * @param  {module:zrender/Element} el target element\n         * @param  {module:echarts/ExtensionAPI} api\n         * @return {Array.<number>}\n         */\n        _updatePosition: function (tooltipModel, positionExpr, x, y, content, params, el) {\n            var viewWidth = this._api.getWidth();\n            var viewHeight = this._api.getHeight();\n            positionExpr = positionExpr || tooltipModel.get('position');\n\n            var contentSize = content.getSize();\n            var align = tooltipModel.get('align');\n            var vAlign = tooltipModel.get('verticalAlign');\n            var rect = el && el.getBoundingRect().clone();\n            el && rect.applyTransform(el.transform);\n\n            if (typeof positionExpr === 'function') {\n                // Callback of position can be an array or a string specify the position\n                positionExpr = positionExpr([x, y], params, content.el, rect, {\n                    viewSize: [viewWidth, viewHeight],\n                    contentSize: contentSize.slice()\n                });\n            }\n\n            if (zrUtil.isArray(positionExpr)) {\n                x = parsePercent(positionExpr[0], viewWidth);\n                y = parsePercent(positionExpr[1], viewHeight);\n            }\n            else if (zrUtil.isObject(positionExpr)) {\n                positionExpr.width = contentSize[0];\n                positionExpr.height = contentSize[1];\n                var layoutRect = layoutUtil.getLayoutRect(\n                    positionExpr, {width: viewWidth, height: viewHeight}\n                );\n                x = layoutRect.x;\n                y = layoutRect.y;\n                align = null;\n                // When positionExpr is left/top/right/bottom,\n                // align and verticalAlign will not work.\n                vAlign = null;\n            }\n            // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n            else if (typeof positionExpr === 'string' && el) {\n                var pos = calcTooltipPosition(\n                    positionExpr, rect, contentSize\n                );\n                x = pos[0];\n                y = pos[1];\n            }\n            else {\n                var pos = refixTooltipPosition(\n                    x, y, content.el, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20\n                );\n                x = pos[0];\n                y = pos[1];\n            }\n\n            align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);\n            vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);\n\n            if (tooltipModel.get('confine')) {\n                var pos = confineTooltipPosition(\n                    x, y, content.el, viewWidth, viewHeight\n                );\n                x = pos[0];\n                y = pos[1];\n            }\n\n            content.moveTo(x, y);\n        },\n\n        // FIXME\n        // Should we remove this but leave this to user?\n        _updateContentNotChangedOnAxis: function (dataByCoordSys) {\n            var lastCoordSys = this._lastDataByCoordSys;\n            var contentNotChanged = !!lastCoordSys\n                && lastCoordSys.length === dataByCoordSys.length;\n\n            contentNotChanged && each(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {\n                var lastDataByAxis = lastItemCoordSys.dataByAxis || {};\n                var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};\n                var thisDataByAxis = thisItemCoordSys.dataByAxis || [];\n                contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;\n\n                contentNotChanged && each(lastDataByAxis, function (lastItem, indexAxis) {\n                    var thisItem = thisDataByAxis[indexAxis] || {};\n                    var lastIndices = lastItem.seriesDataIndices || [];\n                    var newIndices = thisItem.seriesDataIndices || [];\n\n                    contentNotChanged &=\n                        lastItem.value === thisItem.value\n                        && lastItem.axisType === thisItem.axisType\n                        && lastItem.axisId === thisItem.axisId\n                        && lastIndices.length === newIndices.length;\n\n                    contentNotChanged && each(lastIndices, function (lastIdxItem, j) {\n                        var newIdxItem = newIndices[j];\n                        contentNotChanged &=\n                            lastIdxItem.seriesIndex === newIdxItem.seriesIndex\n                            && lastIdxItem.dataIndex === newIdxItem.dataIndex;\n                    });\n                });\n            });\n\n            this._lastDataByCoordSys = dataByCoordSys;\n\n            return !!contentNotChanged;\n        },\n\n        _hide: function (dispatchAction) {\n            // Do not directly hideLater here, because this behavior may be prevented\n            // in dispatchAction when showTip is dispatched.\n\n            // FIXME\n            // duplicated hideTip if manuallyHideTip is called from dispatchAction.\n            this._lastDataByCoordSys = null;\n            dispatchAction({\n                type: 'hideTip',\n                from: this.uid\n            });\n        },\n\n        dispose: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            this._tooltipContent.hide();\n            globalListener.unregister('itemTooltip', api);\n        }\n    });\n\n\n    /**\n     * @param {Array.<Object|module:echarts/model/Model>} modelCascade\n     * From top to bottom. (the last one should be globalTooltipModel);\n     */\n    function buildTooltipModel(modelCascade) {\n        var resultModel = modelCascade.pop();\n        while (modelCascade.length) {\n            var tooltipOpt = modelCascade.pop();\n            if (tooltipOpt) {\n                if (tooltipOpt instanceof Model) {\n                    tooltipOpt = tooltipOpt.get('tooltip', true);\n                }\n                // In each data item tooltip can be simply write:\n                // {\n                //  value: 10,\n                //  tooltip: 'Something you need to know'\n                // }\n                if (typeof tooltipOpt === 'string') {\n                    tooltipOpt = {formatter: tooltipOpt};\n                }\n                resultModel = new Model(tooltipOpt, resultModel, resultModel.ecModel);\n            }\n        }\n        return resultModel;\n    }\n\n    function makeDispatchAction(payload, api) {\n        return payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n    }\n\n    function refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {\n        var size = getOuterSize(el);\n        var width = size.width;\n        var height = size.height;\n\n        if (gapH != null) {\n            if (x + width + gapH > viewWidth) {\n                x -= width + gapH;\n            }\n            else {\n                x += gapH;\n            }\n        }\n        if (gapV != null) {\n            if (y + height + gapV > viewHeight) {\n                y -= height + gapV;\n            }\n            else {\n                y += gapV;\n            }\n        }\n        return [x, y];\n    }\n\n    function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\n        var size = getOuterSize(el);\n        var width = size.width;\n        var height = size.height;\n\n        x = Math.min(x + width, viewWidth) - width;\n        y = Math.min(y + height, viewHeight) - height;\n        x = Math.max(x, 0);\n        y = Math.max(y, 0);\n\n        return [x, y];\n    }\n\n    function getOuterSize(el) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n\n        // Consider browser compatibility.\n        // IE8 does not support getComputedStyle.\n        if (document.defaultView && document.defaultView.getComputedStyle) {\n            var stl = document.defaultView.getComputedStyle(el);\n            if (stl) {\n                width += parseInt(stl.paddingLeft, 10) + parseInt(stl.paddingRight, 10)\n                    + parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10);\n                height += parseInt(stl.paddingTop, 10) + parseInt(stl.paddingBottom, 10)\n                    + parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10);\n            }\n        }\n\n        return {width: width, height: height};\n    }\n\n    function calcTooltipPosition(position, rect, contentSize) {\n        var domWidth = contentSize[0];\n        var domHeight = contentSize[1];\n        var gap = 5;\n        var x = 0;\n        var y = 0;\n        var rectWidth = rect.width;\n        var rectHeight = rect.height;\n        switch (position) {\n            case 'inside':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'top':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y - domHeight - gap;\n                break;\n            case 'bottom':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight + gap;\n                break;\n            case 'left':\n                x = rect.x - domWidth - gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'right':\n                x = rect.x + rectWidth + gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n        }\n        return [x, y];\n    }\n\n    function isCenterAlign(align) {\n        return align === 'center' || align === 'middle';\n    }\n\n\n\n\n/***/ }),\n\n/***/ 1130:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module echarts/component/tooltip/TooltipContent\n */\n\n\n    var zrUtil = __webpack_require__(971);\n    var zrColor = __webpack_require__(993);\n    var eventUtil = __webpack_require__(990);\n    var formatUtil = __webpack_require__(977);\n    var each = zrUtil.each;\n    var toCamelCase = formatUtil.toCamelCase;\n    var env = __webpack_require__(978);\n\n    var vendors = ['', '-webkit-', '-moz-', '-o-'];\n\n    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n\n    /**\n     * @param {number} duration\n     * @return {string}\n     * @inner\n     */\n    function assembleTransition(duration) {\n        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','\n                            + 'top ' + duration + 's ' + transitionCurve;\n        return zrUtil.map(vendors, function (vendorPrefix) {\n            return vendorPrefix + 'transition:' + transitionText;\n        }).join(';');\n    }\n\n    /**\n     * @param {Object} textStyle\n     * @return {string}\n     * @inner\n     */\n    function assembleFont(textStyleModel) {\n        var cssText = [];\n\n        var fontSize = textStyleModel.get('fontSize');\n        var color = textStyleModel.getTextColor();\n\n        color && cssText.push('color:' + color);\n\n        cssText.push('font:' + textStyleModel.getFont());\n\n        fontSize &&\n            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n\n        each(['decoration', 'align'], function (name) {\n            var val = textStyleModel.get(name);\n            val && cssText.push('text-' + name + ':' + val);\n        });\n\n        return cssText.join(';');\n    }\n\n    /**\n     * @param {Object} tooltipModel\n     * @return {string}\n     * @inner\n     */\n    function assembleCssText(tooltipModel) {\n\n        var cssText = [];\n\n        var transitionDuration = tooltipModel.get('transitionDuration');\n        var backgroundColor = tooltipModel.get('backgroundColor');\n        var textStyleModel = tooltipModel.getModel('textStyle');\n        var padding = tooltipModel.get('padding');\n\n        // Animation transition. Do not animate when transitionDuration is 0.\n        transitionDuration &&\n            cssText.push(assembleTransition(transitionDuration));\n\n        if (backgroundColor) {\n            if (env.canvasSupported) {\n                cssText.push('background-Color:' + backgroundColor);\n            }\n            else {\n                // for ie\n                cssText.push(\n                    'background-Color:#' + zrColor.toHex(backgroundColor)\n                );\n                cssText.push('filter:alpha(opacity=70)');\n            }\n        }\n\n        // Border style\n        each(['width', 'color', 'radius'], function (name) {\n            var borderName = 'border-' + name;\n            var camelCase = toCamelCase(borderName);\n            var val = tooltipModel.get(camelCase);\n            val != null &&\n                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n        });\n\n        // Text style\n        cssText.push(assembleFont(textStyleModel));\n\n        // Padding\n        if (padding != null) {\n            cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n        }\n\n        return cssText.join(';') + ';';\n    }\n\n    /**\n     * @alias module:echarts/component/tooltip/TooltipContent\n     * @constructor\n     */\n    function TooltipContent(container, api) {\n        var el = document.createElement('div');\n        var zr = this._zr = api.getZr();\n\n        this.el = el;\n\n        this._x = api.getWidth() / 2;\n        this._y = api.getHeight() / 2;\n\n        container.appendChild(el);\n\n        this._container = container;\n\n        this._show = false;\n\n        /**\n         * @private\n         */\n        this._hideTimeout;\n\n        var self = this;\n        el.onmouseenter = function () {\n            // clear the timeout in hideLater and keep showing tooltip\n            if (self._enterable) {\n                clearTimeout(self._hideTimeout);\n                self._show = true;\n            }\n            self._inContent = true;\n        };\n        el.onmousemove = function (e) {\n            e = e || window.event;\n            if (!self._enterable) {\n                // Try trigger zrender event to avoid mouse\n                // in and out shape too frequently\n                var handler = zr.handler;\n                eventUtil.normalizeEvent(container, e, true);\n                handler.dispatch('mousemove', e);\n            }\n        };\n        el.onmouseleave = function () {\n            if (self._enterable) {\n                if (self._show) {\n                    self.hideLater(self._hideDelay);\n                }\n            }\n            self._inContent = false;\n        };\n    }\n\n    TooltipContent.prototype = {\n\n        constructor: TooltipContent,\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _enterable: true,\n\n        /**\n         * Update when tooltip is rendered\n         */\n        update: function () {\n            // FIXME\n            // Move this logic to ec main?\n            var container = this._container;\n            var stl = container.currentStyle\n                || document.defaultView.getComputedStyle(container);\n            var domStyle = container.style;\n            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n                domStyle.position = 'relative';\n            }\n            // Hide the tooltip\n            // PENDING\n            // this.hide();\n        },\n\n        show: function (tooltipModel) {\n            clearTimeout(this._hideTimeout);\n            var el = this.el;\n\n            el.style.cssText = gCssText + assembleCssText(tooltipModel)\n                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n                + ';left:' + this._x + 'px;top:' + this._y + 'px;'\n                + (tooltipModel.get('extraCssText') || '');\n\n            el.style.display = el.innerHTML ?  'block' : 'none';\n\n            this._show = true;\n        },\n\n        setContent: function (content) {\n            this.el.innerHTML = content == null ? '' : content;\n        },\n\n        setEnterable: function (enterable) {\n            this._enterable = enterable;\n        },\n\n        getSize: function () {\n            var el = this.el;\n            return [el.clientWidth, el.clientHeight];\n        },\n\n        moveTo: function (x, y) {\n            // xy should be based on canvas root. But tooltipContent is\n            // the sibling of canvas root. So padding of ec container\n            // should be considered here.\n            var zr = this._zr;\n            var viewportRootOffset;\n            if (zr && zr.painter && (viewportRootOffset = zr.painter.getViewportRootOffset())) {\n                x += viewportRootOffset.offsetLeft;\n                y += viewportRootOffset.offsetTop;\n            }\n\n            var style = this.el.style;\n            style.left = x + 'px';\n            style.top = y + 'px';\n\n            this._x = x;\n            this._y = y;\n        },\n\n        hide: function () {\n            this.el.style.display = 'none';\n            this._show = false;\n        },\n\n        hideLater: function (time) {\n            if (this._show && !(this._inContent && this._enterable)) {\n                if (time) {\n                    this._hideDelay = time;\n                    // Set show false to avoid invoke hideLater mutiple times\n                    this._show = false;\n                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n                }\n                else {\n                    this.hide();\n                }\n            }\n        },\n\n        isShow: function () {\n            return this._show;\n        }\n    };\n\n    module.exports = TooltipContent;\n\n\n/***/ }),\n\n/***/ 1131:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @file Legend action\n */\n\n\n    var echarts = __webpack_require__(972);\n    var zrUtil = __webpack_require__(971);\n\n    function legendSelectActionHandler(methodName, payload, ecModel) {\n        var selectedMap = {};\n        var isToggleSelect = methodName === 'toggleSelected';\n        var isSelected;\n        // Update all legend components\n        ecModel.eachComponent('legend', function (legendModel) {\n            if (isToggleSelect && isSelected != null) {\n                // Force other legend has same selected status\n                // Or the first is toggled to true and other are toggled to false\n                // In the case one legend has some item unSelected in option. And if other legend\n                // doesn't has the item, they will assume it is selected.\n                legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n            }\n            else {\n                legendModel[methodName](payload.name);\n                isSelected = legendModel.isSelected(payload.name);\n            }\n            var legendData = legendModel.getData();\n            zrUtil.each(legendData, function (model) {\n                var name = model.get('name');\n                // Wrap element\n                if (name === '\\n' || name === '') {\n                    return;\n                }\n                var isItemSelected = legendModel.isSelected(name);\n                if (selectedMap.hasOwnProperty(name)) {\n                    // Unselected if any legend is unselected\n                    selectedMap[name] = selectedMap[name] && isItemSelected;\n                }\n                else {\n                    selectedMap[name] = isItemSelected;\n                }\n            });\n        });\n        // Return the event explicitly\n        return {\n            name: payload.name,\n            selected: selectedMap\n        };\n    }\n    /**\n     * @event legendToggleSelect\n     * @type {Object}\n     * @property {string} type 'legendToggleSelect'\n     * @property {string} [from]\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendToggleSelect', 'legendselectchanged',\n        zrUtil.curry(legendSelectActionHandler, 'toggleSelected')\n    );\n\n    /**\n     * @event legendSelect\n     * @type {Object}\n     * @property {string} type 'legendSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendSelect', 'legendselected',\n        zrUtil.curry(legendSelectActionHandler, 'select')\n    );\n\n    /**\n     * @event legendUnSelect\n     * @type {Object}\n     * @property {string} type 'legendUnSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendUnSelect', 'legendunselected',\n        zrUtil.curry(legendSelectActionHandler, 'unSelect')\n    );\n\n\n\n/***/ }),\n\n/***/ 1132:\n/***/ (function(module, exports) {\n\n\n   module.exports = function (ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (legendModels && legendModels.length) {\n            ecModel.filterSeries(function (series) {\n                // If in any legend component the status is not selected.\n                // Because in legend series is assumed selected when it is not in the legend data.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(series.name)) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n    };\n\n\n/***/ }),\n\n/***/ 1133:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n *\n * @module echarts/chart/helper/DataSelectable\n */\n\n\n    var zrUtil = __webpack_require__(971);\n\n    module.exports = {\n\n        updateSelectedMap: function (targetList) {\n            this._targetList = targetList.slice();\n            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n                targetMap.set(target.name, target);\n                return targetMap;\n            }, zrUtil.createHashMap());\n        },\n\n        /**\n         * Either name or id should be passed as input here.\n         * If both of them are defined, id is used.\n         *\n         * @param {string|undefined} name name of data\n         * @param {number|undefined} id dataIndex of data\n         */\n        // PENGING If selectedMode is null ?\n        select: function (name, id) {\n            var target = id != null\n                ? this._targetList[id]\n                : this._selectTargetMap.get(name);\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                this._selectTargetMap.each(function (target) {\n                    target.selected = false;\n                });\n            }\n            target && (target.selected = true);\n        },\n\n        /**\n         * Either name or id should be passed as input here.\n         * If both of them are defined, id is used.\n         *\n         * @param {string|undefined} name name of data\n         * @param {number|undefined} id dataIndex of data\n         */\n        unSelect: function (name, id) {\n            var target = id != null\n                ? this._targetList[id]\n                : this._selectTargetMap.get(name);\n            // var selectedMode = this.get('selectedMode');\n            // selectedMode !== 'single' && target && (target.selected = false);\n            target && (target.selected = false);\n        },\n\n        /**\n         * Either name or id should be passed as input here.\n         * If both of them are defined, id is used.\n         *\n         * @param {string|undefined} name name of data\n         * @param {number|undefined} id dataIndex of data\n         */\n        toggleSelected: function (name, id) {\n            var target = id != null\n                ? this._targetList[id]\n                : this._selectTargetMap.get(name);\n            if (target != null) {\n                this[target.selected ? 'unSelect' : 'select'](name, id);\n                return target.selected;\n            }\n        },\n\n        /**\n         * Either name or id should be passed as input here.\n         * If both of them are defined, id is used.\n         *\n         * @param {string|undefined} name name of data\n         * @param {number|undefined} id dataIndex of data\n         */\n        isSelected: function (name, id) {\n            var target = id != null\n                ? this._targetList[id]\n                : this._selectTargetMap.get(name);\n            return target && target.selected;\n        }\n    };\n\n\n/***/ }),\n\n/***/ 1134:\n/***/ (function(module, exports) {\n\n// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\n\n\n    module.exports = function (seriesType, ecModel) {\n        // Pie and funnel may use diferrent scope\n        var paletteScope = {};\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var dataAll = seriesModel.getRawData();\n            var idxMap = {};\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                var data = seriesModel.getData();\n                data.each(function (idx) {\n                    var rawIdx = data.getRawIndex(idx);\n                    idxMap[rawIdx] = idx;\n                });\n                dataAll.each(function (rawIdx) {\n                    var filteredIdx = idxMap[rawIdx];\n\n                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n                    var singleDataColor = filteredIdx != null\n                        && data.getItemVisual(filteredIdx, 'color', true);\n\n                    if (!singleDataColor) {\n                        // FIXME Performance\n                        var itemModel = dataAll.getItemModel(rawIdx);\n                        var color = itemModel.get('itemStyle.normal.color')\n                            || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n                        // Legend may use the visual info in data before processed\n                        dataAll.setItemVisual(rawIdx, 'color', color);\n\n                        // Data is not filtered\n                        if (filteredIdx != null) {\n                            data.setItemVisual(filteredIdx, 'color', color);\n                        }\n                    }\n                    else {\n                        // Set data all color for legend\n                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n                    }\n                });\n            }\n        });\n    };\n\n\n/***/ }),\n\n/***/ 1135:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var featureManager = __webpack_require__(989);\n    var zrUtil = __webpack_require__(971);\n\n    var ToolboxModel = __webpack_require__(972).extendComponentModel({\n\n        type: 'toolbox',\n\n        layoutMode: {\n            type: 'box',\n            ignoreSize: true\n        },\n\n        mergeDefaultAndTheme: function (option) {\n            ToolboxModel.superApply(this, 'mergeDefaultAndTheme', arguments);\n\n            zrUtil.each(this.option.feature, function (featureOpt, featureName) {\n                var Feature = featureManager.get(featureName);\n                Feature && zrUtil.merge(featureOpt, Feature.defaultOption);\n            });\n        },\n\n        defaultOption: {\n\n            show: true,\n\n            z: 6,\n\n            zlevel: 0,\n\n            orient: 'horizontal',\n\n            left: 'right',\n\n            top: 'top',\n\n            // right\n            // bottom\n\n            backgroundColor: 'transparent',\n\n            borderColor: '#ccc',\n\n            borderRadius: 0,\n\n            borderWidth: 0,\n\n            padding: 5,\n\n            itemSize: 15,\n\n            itemGap: 8,\n\n            showTitle: true,\n\n            iconStyle: {\n                normal: {\n                    borderColor: '#666',\n                    color: 'none'\n                },\n                emphasis: {\n                    borderColor: '#3E98C5'\n                }\n            }\n            // textStyle: {},\n\n            // feature\n        }\n    });\n\n    module.exports = ToolboxModel;\n\n\n/***/ }),\n\n/***/ 1136:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var featureManager = __webpack_require__(989);\n    var zrUtil = __webpack_require__(971);\n    var graphic = __webpack_require__(973);\n    var Model = __webpack_require__(979);\n    var DataDiffer = __webpack_require__(1003);\n    var listComponentHelper = __webpack_require__(1044);\n    var textContain = __webpack_require__(985);\n\n    module.exports = __webpack_require__(972).extendComponentView({\n\n        type: 'toolbox',\n\n        render: function (toolboxModel, ecModel, api, payload) {\n            var group = this.group;\n            group.removeAll();\n\n            if (!toolboxModel.get('show')) {\n                return;\n            }\n\n            var itemSize = +toolboxModel.get('itemSize');\n            var featureOpts = toolboxModel.get('feature') || {};\n            var features = this._features || (this._features = {});\n\n            var featureNames = [];\n            zrUtil.each(featureOpts, function (opt, name) {\n                featureNames.push(name);\n            });\n\n            (new DataDiffer(this._featureNames || [], featureNames))\n                .add(process)\n                .update(process)\n                .remove(zrUtil.curry(process, null))\n                .execute();\n\n            // Keep for diff.\n            this._featureNames = featureNames;\n\n            function process(newIndex, oldIndex) {\n                var featureName = featureNames[newIndex];\n                var oldName = featureNames[oldIndex];\n                var featureOpt = featureOpts[featureName];\n                var featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel);\n                var feature;\n\n                if (featureName && !oldName) { // Create\n                    if (isUserFeatureName(featureName)) {\n                        feature = {\n                            model: featureModel,\n                            onclick: featureModel.option.onclick,\n                            featureName: featureName\n                        };\n                    }\n                    else {\n                        var Feature = featureManager.get(featureName);\n                        if (!Feature) {\n                            return;\n                        }\n                        feature = new Feature(featureModel, ecModel, api);\n                    }\n                    features[featureName] = feature;\n                }\n                else {\n                    feature = features[oldName];\n                    // If feature does not exsit.\n                    if (!feature) {\n                        return;\n                    }\n                    feature.model = featureModel;\n                    feature.ecModel = ecModel;\n                    feature.api = api;\n                }\n\n                if (!featureName && oldName) {\n                    feature.dispose && feature.dispose(ecModel, api);\n                    return;\n                }\n\n                if (!featureModel.get('show') || feature.unusable) {\n                    feature.remove && feature.remove(ecModel, api);\n                    return;\n                }\n\n                createIconPaths(featureModel, feature, featureName);\n\n                featureModel.setIconStatus = function (iconName, status) {\n                    var option = this.option;\n                    var iconPaths = this.iconPaths;\n                    option.iconStatus = option.iconStatus || {};\n                    option.iconStatus[iconName] = status;\n                    // FIXME\n                    iconPaths[iconName] && iconPaths[iconName].trigger(status);\n                };\n\n                if (feature.render) {\n                    feature.render(featureModel, ecModel, api, payload);\n                }\n            }\n\n            function createIconPaths(featureModel, feature, featureName) {\n                var iconStyleModel = featureModel.getModel('iconStyle');\n\n                // If one feature has mutiple icon. they are orginaized as\n                // {\n                //     icon: {\n                //         foo: '',\n                //         bar: ''\n                //     },\n                //     title: {\n                //         foo: '',\n                //         bar: ''\n                //     }\n                // }\n                var icons = feature.getIcons ? feature.getIcons() : featureModel.get('icon');\n                var titles = featureModel.get('title') || {};\n                if (typeof icons === 'string') {\n                    var icon = icons;\n                    var title = titles;\n                    icons = {};\n                    titles = {};\n                    icons[featureName] = icon;\n                    titles[featureName] = title;\n                }\n                var iconPaths = featureModel.iconPaths = {};\n                zrUtil.each(icons, function (iconStr, iconName) {\n                    var path = graphic.createIcon(\n                        iconStr,\n                        {},\n                        {\n                            x: -itemSize / 2,\n                            y: -itemSize / 2,\n                            width: itemSize,\n                            height: itemSize\n                        }\n                    );\n                    path.setStyle(iconStyleModel.getModel('normal').getItemStyle());\n                    path.hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();\n\n                    graphic.setHoverStyle(path);\n\n                    if (toolboxModel.get('showTitle')) {\n                        path.__title = titles[iconName];\n                        path.on('mouseover', function () {\n                                // Should not reuse above hoverStyle, which might be modified.\n                                var hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();\n                                path.setStyle({\n                                    text: titles[iconName],\n                                    textPosition: hoverStyle.textPosition || 'bottom',\n                                    textFill: hoverStyle.fill || hoverStyle.stroke || '#000',\n                                    textAlign: hoverStyle.textAlign || 'center'\n                                });\n                            })\n                            .on('mouseout', function () {\n                                path.setStyle({\n                                    textFill: null\n                                });\n                            });\n                    }\n                    path.trigger(featureModel.get('iconStatus.' + iconName) || 'normal');\n\n                    group.add(path);\n                    path.on('click', zrUtil.bind(\n                        feature.onclick, feature, ecModel, api, iconName\n                    ));\n\n                    iconPaths[iconName] = path;\n                });\n            }\n\n            listComponentHelper.layout(group, toolboxModel, api);\n            // Render background after group is layout\n            // FIXME\n            group.add(listComponentHelper.makeBackground(group.getBoundingRect(), toolboxModel));\n\n            // Adjust icon title positions to avoid them out of screen\n            group.eachChild(function (icon) {\n                var titleText = icon.__title;\n                var hoverStyle = icon.hoverStyle;\n                // May be background element\n                if (hoverStyle && titleText) {\n                    var rect = textContain.getBoundingRect(\n                        titleText, textContain.makeFont(hoverStyle)\n                    );\n                    var offsetX = icon.position[0] + group.position[0];\n                    var offsetY = icon.position[1] + group.position[1] + itemSize;\n\n                    var needPutOnTop = false;\n                    if (offsetY + rect.height > api.getHeight()) {\n                        hoverStyle.textPosition = 'top';\n                        needPutOnTop = true;\n                    }\n                    var topOffset = needPutOnTop ? (-5 - rect.height) : (itemSize + 8);\n                    if (offsetX + rect.width /  2 > api.getWidth()) {\n                        hoverStyle.textPosition = ['100%', topOffset];\n                        hoverStyle.textAlign = 'right';\n                    }\n                    else if (offsetX - rect.width / 2 < 0) {\n                        hoverStyle.textPosition = [0, topOffset];\n                        hoverStyle.textAlign = 'left';\n                    }\n                }\n            });\n        },\n\n        updateView: function (toolboxModel, ecModel, api, payload) {\n            zrUtil.each(this._features, function (feature) {\n                feature.updateView && feature.updateView(feature.model, ecModel, api, payload);\n            });\n        },\n\n        updateLayout: function (toolboxModel, ecModel, api, payload) {\n            zrUtil.each(this._features, function (feature) {\n                feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);\n            });\n        },\n\n        remove: function (ecModel, api) {\n            zrUtil.each(this._features, function (feature) {\n                feature.remove && feature.remove(ecModel, api);\n            });\n            this.group.removeAll();\n        },\n\n        dispose: function (ecModel, api) {\n            zrUtil.each(this._features, function (feature) {\n                feature.dispose && feature.dispose(ecModel, api);\n            });\n        }\n    });\n\n    function isUserFeatureName(featureName) {\n        return featureName.indexOf('my') === 0;\n    }\n\n\n\n/***/ }),\n\n/***/ 1137:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var env = __webpack_require__(978);\n    var lang = __webpack_require__(997).toolbox.saveAsImage;\n\n    function SaveAsImage (model) {\n        this.model = model;\n    }\n\n    SaveAsImage.defaultOption = {\n        show: true,\n        icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',\n        title: lang.title,\n        type: 'png',\n        // Default use option.backgroundColor\n        // backgroundColor: '#fff',\n        name: '',\n        excludeComponents: ['toolbox'],\n        pixelRatio: 1,\n        lang: lang.lang.slice()\n    };\n\n    SaveAsImage.prototype.unusable = !env.canvasSupported;\n\n    var proto = SaveAsImage.prototype;\n\n    proto.onclick = function (ecModel, api) {\n        var model = this.model;\n        var title = model.get('name') || ecModel.get('title.0.text') || 'echarts';\n        var $a = document.createElement('a');\n        var type = model.get('type', true) || 'png';\n        $a.download = title + '.' + type;\n        $a.target = '_blank';\n        var url = api.getConnectedDataURL({\n            type: type,\n            backgroundColor: model.get('backgroundColor', true)\n                || ecModel.get('backgroundColor') || '#fff',\n            excludeComponents: model.get('excludeComponents'),\n            pixelRatio: model.get('pixelRatio')\n        });\n        $a.href = url;\n        // Chrome and Firefox\n        if (typeof MouseEvent === 'function' && !env.browser.ie && !env.browser.edge) {\n            var evt = new MouseEvent('click', {\n                view: window,\n                bubbles: true,\n                cancelable: false\n            });\n            $a.dispatchEvent(evt);\n        }\n        // IE\n        else {\n            if (window.navigator.msSaveOrOpenBlob) {\n                var bstr = atob(url.split(',')[1]);\n                var n = bstr.length;\n                var u8arr = new Uint8Array(n);\n                while(n--) {\n                    u8arr[n] = bstr.charCodeAt(n);\n                }\n                var blob = new Blob([u8arr]);\n                window.navigator.msSaveOrOpenBlob(blob, title + '.' + type);\n            }\n            else {\n                var lang = model.get('lang');\n                var html = '' +\n                    '<body style=\"margin:0;\">' +\n                    '<img src=\"' + url + '\" style=\"max-width:100%;\" title=\"' + ((lang && lang[0]) || '') + '\" />' +\n                    '</body>';\n                var tab = window.open();\n                tab.document.write(html);\n            }\n        }\n    };\n\n    __webpack_require__(989).register(\n        'saveAsImage', SaveAsImage\n    );\n\n    module.exports = SaveAsImage;\n\n\n\n/***/ }),\n\n/***/ 1138:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(971);\n    var lang = __webpack_require__(997).toolbox.magicType;\n\n    function MagicType(model) {\n        this.model = model;\n    }\n\n    MagicType.defaultOption = {\n        show: true,\n        type: [],\n        // Icon group\n        icon: {\n            line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',\n            bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',\n            stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z', // jshint ignore:line\n            tiled: 'M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z'\n        },\n        // `line`, `bar`, `stack`, `tiled`\n        title: zrUtil.clone(lang.title),\n        option: {},\n        seriesIndex: {}\n    };\n\n    var proto = MagicType.prototype;\n\n    proto.getIcons = function () {\n        var model = this.model;\n        var availableIcons = model.get('icon');\n        var icons = {};\n        zrUtil.each(model.get('type'), function (type) {\n            if (availableIcons[type]) {\n                icons[type] = availableIcons[type];\n            }\n        });\n        return icons;\n    };\n\n    var seriesOptGenreator = {\n        'line': function (seriesType, seriesId, seriesModel, model) {\n            if (seriesType === 'bar') {\n                return zrUtil.merge({\n                    id: seriesId,\n                    type: 'line',\n                    // Preserve data related option\n                    data: seriesModel.get('data'),\n                    stack: seriesModel.get('stack'),\n                    markPoint: seriesModel.get('markPoint'),\n                    markLine: seriesModel.get('markLine')\n                }, model.get('option.line') || {}, true);\n            }\n        },\n        'bar': function (seriesType, seriesId, seriesModel, model) {\n            if (seriesType === 'line') {\n                return zrUtil.merge({\n                    id: seriesId,\n                    type: 'bar',\n                    // Preserve data related option\n                    data: seriesModel.get('data'),\n                    stack: seriesModel.get('stack'),\n                    markPoint: seriesModel.get('markPoint'),\n                    markLine: seriesModel.get('markLine')\n                }, model.get('option.bar') || {}, true);\n            }\n        },\n        'stack': function (seriesType, seriesId, seriesModel, model) {\n            if (seriesType === 'line' || seriesType === 'bar') {\n                return zrUtil.merge({\n                    id: seriesId,\n                    stack: '__ec_magicType_stack__'\n                }, model.get('option.stack') || {}, true);\n            }\n        },\n        'tiled': function (seriesType, seriesId, seriesModel, model) {\n            if (seriesType === 'line' || seriesType === 'bar') {\n                return zrUtil.merge({\n                    id: seriesId,\n                    stack: ''\n                }, model.get('option.tiled') || {}, true);\n            }\n        }\n    };\n\n    var radioTypes = [\n        ['line', 'bar'],\n        ['stack', 'tiled']\n    ];\n\n    proto.onclick = function (ecModel, api, type) {\n        var model = this.model;\n        var seriesIndex = model.get('seriesIndex.' + type);\n        // Not supported magicType\n        if (!seriesOptGenreator[type]) {\n            return;\n        }\n        var newOption = {\n            series: []\n        };\n        var generateNewSeriesTypes = function (seriesModel) {\n            var seriesType = seriesModel.subType;\n            var seriesId = seriesModel.id;\n            var newSeriesOpt = seriesOptGenreator[type](\n                seriesType, seriesId, seriesModel, model\n            );\n            if (newSeriesOpt) {\n                // PENDING If merge original option?\n                zrUtil.defaults(newSeriesOpt, seriesModel.option);\n                newOption.series.push(newSeriesOpt);\n            }\n            // Modify boundaryGap\n            var coordSys = seriesModel.coordinateSystem;\n            if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {\n                var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n                if (categoryAxis) {\n                    var axisDim = categoryAxis.dim;\n                    var axisType = axisDim + 'Axis';\n                    var axisModel = ecModel.queryComponents({\n                        mainType: axisType,\n                        index: seriesModel.get(name + 'Index'),\n                        id: seriesModel.get(name + 'Id')\n                    })[0];\n                    var axisIndex = axisModel.componentIndex;\n\n                    newOption[axisType] = newOption[axisType] || [];\n                    for (var i = 0; i <= axisIndex; i++) {\n                        newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};\n                    }\n                    newOption[axisType][axisIndex].boundaryGap = type === 'bar' ? true : false;\n                }\n            }\n        };\n\n        zrUtil.each(radioTypes, function (radio) {\n            if (zrUtil.indexOf(radio, type) >= 0) {\n                zrUtil.each(radio, function (item) {\n                    model.setIconStatus(item, 'normal');\n                });\n            }\n        });\n\n        model.setIconStatus(type, 'emphasis');\n\n        ecModel.eachComponent(\n            {\n                mainType: 'series',\n                query: seriesIndex == null ? null : {\n                    seriesIndex: seriesIndex\n                }\n            }, generateNewSeriesTypes\n        );\n        api.dispatchAction({\n            type: 'changeMagicType',\n            currentType: type,\n            newOption: newOption\n        });\n    };\n\n    var echarts = __webpack_require__(972);\n    echarts.registerAction({\n        type: 'changeMagicType',\n        event: 'magicTypeChanged',\n        update: 'prepareAndUpdate'\n    }, function (payload, ecModel) {\n        ecModel.mergeOption(payload.newOption);\n    });\n\n    __webpack_require__(989).register('magicType', MagicType);\n\n    module.exports = MagicType;\n\n\n/***/ }),\n\n/***/ 1139:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module echarts/component/toolbox/feature/DataView\n */\n\n\n\n    var zrUtil = __webpack_require__(971);\n    var eventTool = __webpack_require__(990);\n    var lang = __webpack_require__(997).toolbox.dataView;\n\n    var BLOCK_SPLITER = new Array(60).join('-');\n    var ITEM_SPLITER = '\\t';\n    /**\n     * Group series into two types\n     *  1. on category axis, like line, bar\n     *  2. others, like scatter, pie\n     * @param {module:echarts/model/Global} ecModel\n     * @return {Object}\n     * @inner\n     */\n    function groupSeries(ecModel) {\n        var seriesGroupByCategoryAxis = {};\n        var otherSeries = [];\n        var meta = [];\n        ecModel.eachRawSeries(function (seriesModel) {\n            var coordSys = seriesModel.coordinateSystem;\n\n            if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {\n                var baseAxis = coordSys.getBaseAxis();\n                if (baseAxis.type === 'category') {\n                    var key = baseAxis.dim + '_' + baseAxis.index;\n                    if (!seriesGroupByCategoryAxis[key]) {\n                        seriesGroupByCategoryAxis[key] = {\n                            categoryAxis: baseAxis,\n                            valueAxis: coordSys.getOtherAxis(baseAxis),\n                            series: []\n                        };\n                        meta.push({\n                            axisDim: baseAxis.dim,\n                            axisIndex: baseAxis.index\n                        });\n                    }\n                    seriesGroupByCategoryAxis[key].series.push(seriesModel);\n                }\n                else {\n                    otherSeries.push(seriesModel);\n                }\n            }\n            else {\n                otherSeries.push(seriesModel);\n            }\n        });\n\n        return {\n            seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,\n            other: otherSeries,\n            meta: meta\n        };\n    }\n\n    /**\n     * Assemble content of series on cateogory axis\n     * @param {Array.<module:echarts/model/Series>} series\n     * @return {string}\n     * @inner\n     */\n    function assembleSeriesWithCategoryAxis(series) {\n        var tables = [];\n        zrUtil.each(series, function (group, key) {\n            var categoryAxis = group.categoryAxis;\n            var valueAxis = group.valueAxis;\n            var valueAxisDim = valueAxis.dim;\n\n            var headers = [' '].concat(zrUtil.map(group.series, function (series) {\n                return series.name;\n            }));\n            var columns = [categoryAxis.model.getCategories()];\n            zrUtil.each(group.series, function (series) {\n                columns.push(series.getRawData().mapArray(valueAxisDim, function (val) {\n                    return val;\n                }));\n            });\n            // Assemble table content\n            var lines = [headers.join(ITEM_SPLITER)];\n            for (var i = 0; i < columns[0].length; i++) {\n                var items = [];\n                for (var j = 0; j < columns.length; j++) {\n                    items.push(columns[j][i]);\n                }\n                lines.push(items.join(ITEM_SPLITER));\n            }\n            tables.push(lines.join('\\n'));\n        });\n        return tables.join('\\n\\n' +  BLOCK_SPLITER + '\\n\\n');\n    }\n\n    /**\n     * Assemble content of other series\n     * @param {Array.<module:echarts/model/Series>} series\n     * @return {string}\n     * @inner\n     */\n    function assembleOtherSeries(series) {\n        return zrUtil.map(series, function (series) {\n            var data = series.getRawData();\n            var lines = [series.name];\n            var vals = [];\n            data.each(data.dimensions, function () {\n                var argLen = arguments.length;\n                var dataIndex = arguments[argLen - 1];\n                var name = data.getName(dataIndex);\n                for (var i = 0; i < argLen - 1; i++) {\n                    vals[i] = arguments[i];\n                }\n                lines.push((name ? (name + ITEM_SPLITER) : '') + vals.join(ITEM_SPLITER));\n            });\n            return lines.join('\\n');\n        }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n');\n    }\n\n    /**\n     * @param {module:echarts/model/Global}\n     * @return {Object}\n     * @inner\n     */\n    function getContentFromModel(ecModel) {\n\n        var result = groupSeries(ecModel);\n\n        return {\n            value: zrUtil.filter([\n                    assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis),\n                    assembleOtherSeries(result.other)\n                ], function (str) {\n                    return str.replace(/[\\n\\t\\s]/g, '');\n                }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n'),\n\n            meta: result.meta\n        };\n    }\n\n\n    function trim(str) {\n        return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n    }\n    /**\n     * If a block is tsv format\n     */\n    function isTSVFormat(block) {\n        // Simple method to find out if a block is tsv format\n        var firstLine = block.slice(0, block.indexOf('\\n'));\n        if (firstLine.indexOf(ITEM_SPLITER) >= 0) {\n            return true;\n        }\n    }\n\n    var itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g');\n    /**\n     * @param {string} tsv\n     * @return {Object}\n     */\n    function parseTSVContents(tsv) {\n        var tsvLines = tsv.split(/\\n+/g);\n        var headers = trim(tsvLines.shift()).split(itemSplitRegex);\n\n        var categories = [];\n        var series = zrUtil.map(headers, function (header) {\n            return {\n                name: header,\n                data: []\n            };\n        });\n        for (var i = 0; i < tsvLines.length; i++) {\n            var items = trim(tsvLines[i]).split(itemSplitRegex);\n            categories.push(items.shift());\n            for (var j = 0; j < items.length; j++) {\n                series[j] && (series[j].data[i] = items[j]);\n            }\n        }\n        return {\n            series: series,\n            categories: categories\n        };\n    }\n\n    /**\n     * @param {string} str\n     * @return {Array.<Object>}\n     * @inner\n     */\n    function parseListContents(str) {\n        var lines = str.split(/\\n+/g);\n        var seriesName = trim(lines.shift());\n\n        var data = [];\n        for (var i = 0; i < lines.length; i++) {\n            var items = trim(lines[i]).split(itemSplitRegex);\n            var name = '';\n            var value;\n            var hasName = false;\n            if (isNaN(items[0])) { // First item is name\n                hasName = true;\n                name = items[0];\n                items = items.slice(1);\n                data[i] = {\n                    name: name,\n                    value: []\n                };\n                value = data[i].value;\n            }\n            else {\n                value = data[i] = [];\n            }\n            for (var j = 0; j < items.length; j++) {\n                value.push(+items[j]);\n            }\n            if (value.length === 1) {\n                hasName ? (data[i].value = value[0]) : (data[i] = value[0]);\n            }\n        }\n\n        return {\n            name: seriesName,\n            data: data\n        };\n    }\n\n    /**\n     * @param {string} str\n     * @param {Array.<Object>} blockMetaList\n     * @return {Object}\n     * @inner\n     */\n    function parseContents(str, blockMetaList) {\n        var blocks = str.split(new RegExp('\\n*' + BLOCK_SPLITER + '\\n*', 'g'));\n        var newOption = {\n            series: []\n        };\n        zrUtil.each(blocks, function (block, idx) {\n            if (isTSVFormat(block)) {\n                var result = parseTSVContents(block);\n                var blockMeta = blockMetaList[idx];\n                var axisKey = blockMeta.axisDim + 'Axis';\n\n                if (blockMeta) {\n                    newOption[axisKey] = newOption[axisKey] || [];\n                    newOption[axisKey][blockMeta.axisIndex] = {\n                        data: result.categories\n                    };\n                    newOption.series = newOption.series.concat(result.series);\n                }\n            }\n            else {\n                var result = parseListContents(block);\n                newOption.series.push(result);\n            }\n        });\n        return newOption;\n    }\n\n    /**\n     * @alias {module:echarts/component/toolbox/feature/DataView}\n     * @constructor\n     * @param {module:echarts/model/Model} model\n     */\n    function DataView(model) {\n\n        this._dom = null;\n\n        this.model = model;\n    }\n\n    DataView.defaultOption = {\n        show: true,\n        readOnly: false,\n        optionToContent: null,\n        contentToOption: null,\n\n        icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',\n        title: zrUtil.clone(lang.title),\n        lang: zrUtil.clone(lang.lang),\n        backgroundColor: '#fff',\n        textColor: '#000',\n        textareaColor: '#fff',\n        textareaBorderColor: '#333',\n        buttonColor: '#c23531',\n        buttonTextColor: '#fff'\n    };\n\n    DataView.prototype.onclick = function (ecModel, api) {\n        var container = api.getDom();\n        var model = this.model;\n        if (this._dom) {\n            container.removeChild(this._dom);\n        }\n        var root = document.createElement('div');\n        root.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;';\n        root.style.backgroundColor = model.get('backgroundColor') || '#fff';\n\n        // Create elements\n        var header = document.createElement('h4');\n        var lang = model.get('lang') || [];\n        header.innerHTML = lang[0] || model.get('title');\n        header.style.cssText = 'margin: 10px 20px;';\n        header.style.color = model.get('textColor');\n\n        var viewMain = document.createElement('div');\n        var textarea = document.createElement('textarea');\n        viewMain.style.cssText = 'display:block;width:100%;overflow:auto;';\n\n        var optionToContent = model.get('optionToContent');\n        var contentToOption = model.get('contentToOption');\n        var result = getContentFromModel(ecModel);\n        if (typeof optionToContent === 'function') {\n            var htmlOrDom = optionToContent(api.getOption());\n            if (typeof htmlOrDom === 'string') {\n                viewMain.innerHTML = htmlOrDom;\n            }\n            else if (zrUtil.isDom(htmlOrDom)) {\n                viewMain.appendChild(htmlOrDom);\n            }\n        }\n        else {\n            // Use default textarea\n            viewMain.appendChild(textarea);\n            textarea.readOnly = model.get('readOnly');\n            textarea.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;';\n            textarea.style.color = model.get('textColor');\n            textarea.style.borderColor = model.get('textareaBorderColor');\n            textarea.style.backgroundColor = model.get('textareaColor');\n            textarea.value = result.value;\n        }\n\n        var blockMetaList = result.meta;\n\n        var buttonContainer = document.createElement('div');\n        buttonContainer.style.cssText = 'position:absolute;bottom:0;left:0;right:0;';\n\n        var buttonStyle = 'float:right;margin-right:20px;border:none;'\n            + 'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';\n        var closeButton = document.createElement('div');\n        var refreshButton = document.createElement('div');\n\n        buttonStyle += ';background-color:' + model.get('buttonColor');\n        buttonStyle += ';color:' + model.get('buttonTextColor');\n\n        var self = this;\n\n        function close() {\n            container.removeChild(root);\n            self._dom = null;\n        }\n        eventTool.addEventListener(closeButton, 'click', close);\n\n        eventTool.addEventListener(refreshButton, 'click', function () {\n            var newOption;\n            try {\n                if (typeof contentToOption === 'function') {\n                    newOption = contentToOption(viewMain, api.getOption());\n                }\n                else {\n                    newOption = parseContents(textarea.value, blockMetaList);\n                }\n            }\n            catch (e) {\n                close();\n                throw new Error('Data view format error ' + e);\n            }\n            if (newOption) {\n                api.dispatchAction({\n                    type: 'changeDataView',\n                    newOption: newOption\n                });\n            }\n\n            close();\n        });\n\n        closeButton.innerHTML = lang[1];\n        refreshButton.innerHTML = lang[2];\n        refreshButton.style.cssText = buttonStyle;\n        closeButton.style.cssText = buttonStyle;\n\n        !model.get('readOnly') && buttonContainer.appendChild(refreshButton);\n        buttonContainer.appendChild(closeButton);\n\n        // http://stackoverflow.com/questions/6637341/use-tab-to-indent-in-textarea\n        eventTool.addEventListener(textarea, 'keydown', function (e) {\n            if ((e.keyCode || e.which) === 9) {\n                // get caret position/selection\n                var val = this.value;\n                var start = this.selectionStart;\n                var end = this.selectionEnd;\n\n                // set textarea value to: text before caret + tab + text after caret\n                this.value = val.substring(0, start) + ITEM_SPLITER + val.substring(end);\n\n                // put caret at right position again\n                this.selectionStart = this.selectionEnd = start + 1;\n\n                // prevent the focus lose\n                eventTool.stop(e);\n            }\n        });\n\n        root.appendChild(header);\n        root.appendChild(viewMain);\n        root.appendChild(buttonContainer);\n\n        viewMain.style.height = (container.clientHeight - 80) + 'px';\n\n        container.appendChild(root);\n        this._dom = root;\n    };\n\n    DataView.prototype.remove = function (ecModel, api) {\n        this._dom && api.getDom().removeChild(this._dom);\n    };\n\n    DataView.prototype.dispose = function (ecModel, api) {\n        this.remove(ecModel, api);\n    };\n\n    /**\n     * @inner\n     */\n    function tryMergeDataOption(newData, originalData) {\n        return zrUtil.map(newData, function (newVal, idx) {\n            var original = originalData && originalData[idx];\n            if (zrUtil.isObject(original) && !zrUtil.isArray(original)) {\n                if (zrUtil.isObject(newVal) && !zrUtil.isArray(newVal)) {\n                    newVal = newVal.value;\n                }\n                // Original data has option\n                return zrUtil.defaults({\n                    value: newVal\n                }, original);\n            }\n            else {\n                return newVal;\n            }\n        });\n    }\n\n    __webpack_require__(989).register('dataView', DataView);\n\n    __webpack_require__(972).registerAction({\n        type: 'changeDataView',\n        event: 'dataViewChanged',\n        update: 'prepareAndUpdate'\n    }, function (payload, ecModel) {\n        var newSeriesOptList = [];\n        zrUtil.each(payload.newOption.series, function (seriesOpt) {\n            var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];\n            if (!seriesModel) {\n                // New created series\n                // Geuss the series type\n                newSeriesOptList.push(zrUtil.extend({\n                    // Default is scatter\n                    type: 'scatter'\n                }, seriesOpt));\n            }\n            else {\n                var originalData = seriesModel.get('data');\n                newSeriesOptList.push({\n                    name: seriesOpt.name,\n                    data: tryMergeDataOption(seriesOpt.data, originalData)\n                });\n            }\n        });\n\n        ecModel.mergeOption(zrUtil.defaults({\n            series: newSeriesOptList\n        }, payload.newOption));\n    });\n\n    module.exports = DataView;\n\n\n/***/ }),\n\n/***/ 1140:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(971);\n    var BrushController = __webpack_require__(1055);\n    var BrushTargetManager = __webpack_require__(1071);\n    var history = __webpack_require__(1045);\n    var sliderMove = __webpack_require__(1029);\n    var lang = __webpack_require__(997).toolbox.dataZoom;\n\n    var each = zrUtil.each;\n\n    // Use dataZoomSelect\n    __webpack_require__(1141);\n\n    // Spectial component id start with \\0ec\\0, see echarts/model/Global.js~hasInnerId\n    var DATA_ZOOM_ID_BASE = '\\0_ec_\\0toolbox-dataZoom_';\n\n    function DataZoom(model, ecModel, api) {\n\n        /**\n         * @private\n         * @type {module:echarts/component/helper/BrushController}\n         */\n        (this._brushController = new BrushController(api.getZr()))\n            .on('brush', zrUtil.bind(this._onBrush, this))\n            .mount();\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._isZoomActive;\n    }\n\n    DataZoom.defaultOption = {\n        show: true,\n        // Icon group\n        icon: {\n            zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',\n            back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'\n        },\n        // `zoom`, `back`\n        title: zrUtil.clone(lang.title)\n    };\n\n    var proto = DataZoom.prototype;\n\n    proto.render = function (featureModel, ecModel, api, payload) {\n        this.model = featureModel;\n        this.ecModel = ecModel;\n        this.api = api;\n\n        updateZoomBtnStatus(featureModel, ecModel, this, payload, api);\n        updateBackBtnStatus(featureModel, ecModel);\n    };\n\n    proto.onclick = function (ecModel, api, type) {\n        handlers[type].call(this);\n    };\n\n    proto.remove = function (ecModel, api) {\n        this._brushController.unmount();\n    };\n\n    proto.dispose = function (ecModel, api) {\n        this._brushController.dispose();\n    };\n\n    /**\n     * @private\n     */\n    var handlers = {\n\n        zoom: function () {\n            var nextActive = !this._isZoomActive;\n\n            this.api.dispatchAction({\n                type: 'takeGlobalCursor',\n                key: 'dataZoomSelect',\n                dataZoomSelectActive: nextActive\n            });\n        },\n\n        back: function () {\n            this._dispatchZoomAction(history.pop(this.ecModel));\n        }\n    };\n\n    /**\n     * @private\n     */\n    proto._onBrush = function (areas, opt) {\n        if (!opt.isEnd || !areas.length) {\n            return;\n        }\n        var snapshot = {};\n        var ecModel = this.ecModel;\n\n        this._brushController.updateCovers([]); // remove cover\n\n        var brushTargetManager = new BrushTargetManager(\n            retrieveAxisSetting(this.model.option), ecModel, {include: ['grid']}\n        );\n        brushTargetManager.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n            if (coordSys.type !== 'cartesian2d') {\n                return;\n            }\n\n            var brushType = area.brushType;\n            if (brushType === 'rect') {\n                setBatch('x', coordSys, coordRange[0]);\n                setBatch('y', coordSys, coordRange[1]);\n            }\n            else {\n                setBatch(({lineX: 'x', lineY: 'y'})[brushType], coordSys, coordRange);\n            }\n        });\n\n        history.push(ecModel, snapshot);\n\n        this._dispatchZoomAction(snapshot);\n\n        function setBatch(dimName, coordSys, minMax) {\n            var axis = coordSys.getAxis(dimName);\n            var axisModel = axis.model;\n            var dataZoomModel = findDataZoom(dimName, axisModel, ecModel);\n\n            // Restrict range.\n            var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();\n            if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {\n                minMax = sliderMove(\n                    0, minMax.slice(), axis.scale.getExtent(), 0,\n                    minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan\n                );\n            }\n\n            dataZoomModel && (snapshot[dataZoomModel.id] = {\n                dataZoomId: dataZoomModel.id,\n                startValue: minMax[0],\n                endValue: minMax[1]\n            });\n        }\n\n        function findDataZoom(dimName, axisModel, ecModel) {\n            var found;\n            ecModel.eachComponent({mainType: 'dataZoom', subType: 'select'}, function (dzModel) {\n                var has = dzModel.getAxisModel(dimName, axisModel.componentIndex);\n                has && (found = dzModel);\n            });\n            return found;\n        }\n    };\n\n    /**\n     * @private\n     */\n    proto._dispatchZoomAction = function (snapshot) {\n        var batch = [];\n\n        // Convert from hash map to array.\n        each(snapshot, function (batchItem, dataZoomId) {\n            batch.push(zrUtil.clone(batchItem));\n        });\n\n        batch.length && this.api.dispatchAction({\n            type: 'dataZoom',\n            from: this.uid,\n            batch: batch\n        });\n    };\n\n    function retrieveAxisSetting(option) {\n        var setting = {};\n        // Compatible with previous setting: null => all axis, false => no axis.\n        zrUtil.each(['xAxisIndex', 'yAxisIndex'], function (name) {\n            setting[name] = option[name];\n            setting[name] == null && (setting[name] = 'all');\n            (setting[name] === false || setting[name] === 'none') && (setting[name] = []);\n        });\n        return setting;\n    }\n\n    function updateBackBtnStatus(featureModel, ecModel) {\n        featureModel.setIconStatus(\n            'back',\n            history.count(ecModel) > 1 ? 'emphasis' : 'normal'\n        );\n    }\n\n    function updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {\n        var zoomActive = view._isZoomActive;\n\n        if (payload && payload.type === 'takeGlobalCursor') {\n            zoomActive = payload.key === 'dataZoomSelect'\n                ? payload.dataZoomSelectActive : false;\n        }\n\n        view._isZoomActive = zoomActive;\n\n        featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal');\n\n        var brushTargetManager = new BrushTargetManager(\n            retrieveAxisSetting(featureModel.option), ecModel, {include: ['grid']}\n        );\n\n        view._brushController\n            .setPanels(brushTargetManager.makePanelOpts(api, function (targetInfo) {\n                return (targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared)\n                    ? 'lineX'\n                    : (!targetInfo.xAxisDeclared && targetInfo.yAxisDeclared)\n                    ? 'lineY'\n                    : 'rect';\n            }))\n            .enableBrush(\n                zoomActive\n                ? {\n                    brushType: 'auto',\n                    brushStyle: {\n                        // FIXME user customized?\n                        lineWidth: 0,\n                        fill: 'rgba(0,0,0,0.2)'\n                    }\n                }\n                : false\n            );\n    }\n\n\n    __webpack_require__(989).register('dataZoom', DataZoom);\n\n\n    // Create special dataZoom option for select\n    __webpack_require__(972).registerPreprocessor(function (option) {\n        if (!option) {\n            return;\n        }\n\n        var dataZoomOpts = option.dataZoom || (option.dataZoom = []);\n        if (!zrUtil.isArray(dataZoomOpts)) {\n            option.dataZoom = dataZoomOpts = [dataZoomOpts];\n        }\n\n        var toolboxOpt = option.toolbox;\n        if (toolboxOpt) {\n            // Assume there is only one toolbox\n            if (zrUtil.isArray(toolboxOpt)) {\n                toolboxOpt = toolboxOpt[0];\n            }\n\n            if (toolboxOpt && toolboxOpt.feature) {\n                var dataZoomOpt = toolboxOpt.feature.dataZoom;\n                addForAxis('xAxis', dataZoomOpt);\n                addForAxis('yAxis', dataZoomOpt);\n            }\n        }\n\n        function addForAxis(axisName, dataZoomOpt) {\n            if (!dataZoomOpt) {\n                return;\n            }\n\n            // Try not to modify model, because it is not merged yet.\n            var axisIndicesName = axisName + 'Index';\n            var givenAxisIndices = dataZoomOpt[axisIndicesName];\n            if (givenAxisIndices != null\n                && givenAxisIndices != 'all'\n                && !zrUtil.isArray(givenAxisIndices)\n            ) {\n                givenAxisIndices = (givenAxisIndices === false || givenAxisIndices === 'none') ? [] : [givenAxisIndices];\n            }\n\n            forEachComponent(axisName, function (axisOpt, axisIndex) {\n                if (givenAxisIndices != null\n                    && givenAxisIndices != 'all'\n                    && zrUtil.indexOf(givenAxisIndices, axisIndex) === -1\n                ) {\n                    return;\n                }\n                var newOpt = {\n                    type: 'select',\n                    $fromToolbox: true,\n                    // Id for merge mapping.\n                    id: DATA_ZOOM_ID_BASE + axisName + axisIndex\n                };\n                // FIXME\n                // Only support one axis now.\n                newOpt[axisIndicesName] = axisIndex;\n                dataZoomOpts.push(newOpt);\n            });\n        }\n\n        function forEachComponent(mainType, cb) {\n            var opts = option[mainType];\n            if (!zrUtil.isArray(opts)) {\n                opts = opts ? [opts] : [];\n            }\n            each(opts, cb);\n        }\n    });\n\n    module.exports = DataZoom;\n\n\n/***/ }),\n\n/***/ 1141:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * DataZoom component entry\n */\n\n\n    __webpack_require__(1073);\n\n    __webpack_require__(1019);\n    __webpack_require__(1021);\n\n    __webpack_require__(1143);\n    __webpack_require__(1144);\n\n    __webpack_require__(1074);\n    __webpack_require__(1075);\n\n\n\n/***/ }),\n\n/***/ 1142:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @file Axis operator\n */\n\n\n    var zrUtil = __webpack_require__(971);\n    var numberUtil = __webpack_require__(974);\n    var helper = __webpack_require__(1020);\n    var each = zrUtil.each;\n    var asc = numberUtil.asc;\n\n    /**\n     * Operate single axis.\n     * One axis can only operated by one axis operator.\n     * Different dataZoomModels may be defined to operate the same axis.\n     * (i.e. 'inside' data zoom and 'slider' data zoom components)\n     * So dataZoomModels share one axisProxy in that case.\n     *\n     * @class\n     */\n    var AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {\n\n        /**\n         * @private\n         * @type {string}\n         */\n        this._dimName = dimName;\n\n        /**\n         * @private\n         */\n        this._axisIndex = axisIndex;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._valueWindow;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._percentWindow;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._dataExtent;\n\n        /**\n         * {minSpan, maxSpan, minValueSpan, maxValueSpan}\n         * @private\n         * @type {Object}\n         */\n        this._minMaxSpan;\n\n        /**\n         * @readOnly\n         * @type {module: echarts/model/Global}\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @private\n         * @type {module: echarts/component/dataZoom/DataZoomModel}\n         */\n        this._dataZoomModel = dataZoomModel;\n    };\n\n    AxisProxy.prototype = {\n\n        constructor: AxisProxy,\n\n        /**\n         * Whether the axisProxy is hosted by dataZoomModel.\n         *\n         * @public\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         * @return {boolean}\n         */\n        hostedBy: function (dataZoomModel) {\n            return this._dataZoomModel === dataZoomModel;\n        },\n\n        /**\n         * @return {Array.<number>} Value can only be NaN or finite value.\n         */\n        getDataValueWindow: function () {\n            return this._valueWindow.slice();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getDataPercentWindow: function () {\n            return this._percentWindow.slice();\n        },\n\n        /**\n         * @public\n         * @param {number} axisIndex\n         * @return {Array} seriesModels\n         */\n        getTargetSeriesModels: function () {\n            var seriesModels = [];\n            var ecModel = this.ecModel;\n\n            ecModel.eachSeries(function (seriesModel) {\n                if (helper.isCoordSupported(seriesModel.get('coordinateSystem'))) {\n                    var dimName = this._dimName;\n                    var axisModel = ecModel.queryComponents({\n                        mainType: dimName + 'Axis',\n                        index: seriesModel.get(dimName + 'AxisIndex'),\n                        id: seriesModel.get(dimName + 'AxisId')\n                    })[0];\n                    if (this._axisIndex === (axisModel && axisModel.componentIndex)) {\n                        seriesModels.push(seriesModel);\n                    }\n                }\n            }, this);\n\n            return seriesModels;\n        },\n\n        getAxisModel: function () {\n            return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n        },\n\n        getOtherAxisModel: function () {\n            var axisDim = this._dimName;\n            var ecModel = this.ecModel;\n            var axisModel = this.getAxisModel();\n            var isCartesian = axisDim === 'x' || axisDim === 'y';\n            var otherAxisDim;\n            var coordSysIndexName;\n            if (isCartesian) {\n                coordSysIndexName = 'gridIndex';\n                otherAxisDim = axisDim === 'x' ? 'y' : 'x';\n            }\n            else {\n                coordSysIndexName = 'polarIndex';\n                otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';\n            }\n            var foundOtherAxisModel;\n            ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {\n                if ((otherAxisModel.get(coordSysIndexName) || 0)\n                    === (axisModel.get(coordSysIndexName) || 0)\n                ) {\n                    foundOtherAxisModel = otherAxisModel;\n                }\n            });\n            return foundOtherAxisModel;\n        },\n\n        getMinMaxSpan: function () {\n            return zrUtil.clone(this._minMaxSpan);\n        },\n\n        /**\n         * Only calculate by given range and this._dataExtent, do not change anything.\n         *\n         * @param {Object} opt\n         * @param {number} [opt.start]\n         * @param {number} [opt.end]\n         * @param {number} [opt.startValue]\n         * @param {number} [opt.endValue]\n         */\n        calculateDataWindow: function (opt) {\n            var dataExtent = this._dataExtent;\n            var axisModel = this.getAxisModel();\n            var scale = axisModel.axis.scale;\n            var rangePropMode = this._dataZoomModel.getRangePropMode();\n            var percentExtent = [0, 100];\n            var percentWindow = [\n                opt.start,\n                opt.end\n            ];\n            var valueWindow = [];\n\n            each(['startValue', 'endValue'], function (prop) {\n                valueWindow.push(opt[prop] != null ? scale.parse(opt[prop]) : null);\n            });\n\n            // Normalize bound.\n            each([0, 1], function (idx) {\n                var boundValue = valueWindow[idx];\n                var boundPercent = percentWindow[idx];\n\n                // Notice: dataZoom is based either on `percentProp` ('start', 'end') or\n                // on `valueProp` ('startValue', 'endValue'). The former one is suitable\n                // for cases that a dataZoom component controls multiple axes with different\n                // unit or extent, and the latter one is suitable for accurate zoom by pixel\n                // (e.g., in dataZoomSelect). `valueProp` can be calculated from `percentProp`,\n                // but it is awkward that `percentProp` can not be obtained from `valueProp`\n                // accurately (because all of values that are overflow the `dataExtent` will\n                // be calculated to percent '100%'). So we have to use\n                // `dataZoom.getRangePropMode()` to mark which prop is used.\n                // `rangePropMode` is updated only when setOption or dispatchAction, otherwise\n                // it remains its original value.\n\n                if (rangePropMode[idx] === 'percent') {\n                    if (boundPercent == null) {\n                        boundPercent = percentExtent[idx];\n                    }\n                    // Use scale.parse to math round for category or time axis.\n                    boundValue = scale.parse(numberUtil.linearMap(\n                        boundPercent, percentExtent, dataExtent, true\n                    ));\n                }\n                else {\n                    // Calculating `percent` from `value` may be not accurate, because\n                    // This calculation can not be inversed, because all of values that\n                    // are overflow the `dataExtent` will be calculated to percent '100%'\n                    boundPercent = numberUtil.linearMap(\n                        boundValue, dataExtent, percentExtent, true\n                    );\n                }\n\n                // valueWindow[idx] = round(boundValue);\n                // percentWindow[idx] = round(boundPercent);\n                valueWindow[idx] = boundValue;\n                percentWindow[idx] = boundPercent;\n            });\n\n            return {\n                valueWindow: asc(valueWindow),\n                percentWindow: asc(percentWindow)\n            };\n        },\n\n        /**\n         * Notice: reset should not be called before series.restoreData() called,\n         * so it is recommanded to be called in \"process stage\" but not \"model init\n         * stage\".\n         *\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         */\n        reset: function (dataZoomModel) {\n            if (dataZoomModel !== this._dataZoomModel) {\n                return;\n            }\n\n            // Culculate data window and data extent, and record them.\n            this._dataExtent = calculateDataExtent(\n                this, this._dimName, this.getTargetSeriesModels()\n            );\n\n            var dataWindow = this.calculateDataWindow(dataZoomModel.option);\n\n            this._valueWindow = dataWindow.valueWindow;\n            this._percentWindow = dataWindow.percentWindow;\n\n            setMinMaxSpan(this);\n\n            // Update axis setting then.\n            setAxisModel(this);\n        },\n\n        /**\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         */\n        restore: function (dataZoomModel) {\n            if (dataZoomModel !== this._dataZoomModel) {\n                return;\n            }\n\n            this._valueWindow = this._percentWindow = null;\n            setAxisModel(this, true);\n        },\n\n        /**\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         */\n        filterData: function (dataZoomModel) {\n            if (dataZoomModel !== this._dataZoomModel) {\n                return;\n            }\n\n            var axisDim = this._dimName;\n            var seriesModels = this.getTargetSeriesModels();\n            var filterMode = dataZoomModel.get('filterMode');\n            var valueWindow = this._valueWindow;\n\n            if (filterMode === 'none') {\n                return;\n            }\n\n            // FIXME\n            // Toolbox may has dataZoom injected. And if there are stacked bar chart\n            // with NaN data, NaN will be filtered and stack will be wrong.\n            // So we need to force the mode to be set empty.\n            // In fect, it is not a big deal that do not support filterMode-'filter'\n            // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n            // selection\" some day, which might need \"adapt to data extent on the\n            // otherAxis\", which is disabled by filterMode-'empty'.\n            var otherAxisModel = this.getOtherAxisModel();\n            if (dataZoomModel.get('$fromToolbox')\n                && otherAxisModel\n                && otherAxisModel.get('type') === 'category'\n            ) {\n                filterMode = 'empty';\n            }\n\n            // Process series data\n            each(seriesModels, function (seriesModel) {\n                var seriesData = seriesModel.getData();\n                var dataDims = seriesModel.coordDimToDataDim(axisDim);\n\n                if (filterMode === 'weakFilter') {\n                    seriesData && seriesData.filterSelf(function (dataIndex) {\n                        var leftOut;\n                        var rightOut;\n                        var hasValue;\n                        for (var i = 0; i < dataDims.length; i++) {\n                            var value = seriesData.get(dataDims[i], dataIndex);\n                            var thisHasValue = !isNaN(value);\n                            var thisLeftOut = value < valueWindow[0];\n                            var thisRightOut = value > valueWindow[1];\n                            if (thisHasValue && !thisLeftOut && !thisRightOut) {\n                                return true;\n                            }\n                            thisHasValue && (hasValue = true);\n                            thisLeftOut && (leftOut = true);\n                            thisRightOut && (rightOut = true);\n                        }\n                        // If both left out and right out, do not filter.\n                        return hasValue && leftOut && rightOut;\n                    });\n                }\n                else {\n                    seriesData && each(dataDims, function (dim) {\n                        if (filterMode === 'empty') {\n                            seriesModel.setData(\n                                seriesData.map(dim, function (value) {\n                                    return !isInWindow(value) ? NaN : value;\n                                })\n                            );\n                        }\n                        else {\n                            seriesData.filterSelf(dim, isInWindow);\n                        }\n                    });\n                }\n            });\n\n            function isInWindow(value) {\n                return value >= valueWindow[0] && value <= valueWindow[1];\n            }\n        }\n    };\n\n    function calculateDataExtent(axisProxy, axisDim, seriesModels) {\n        var dataExtent = [Infinity, -Infinity];\n\n        each(seriesModels, function (seriesModel) {\n            var seriesData = seriesModel.getData();\n            if (seriesData) {\n                each(seriesModel.coordDimToDataDim(axisDim), function (dim) {\n                    var seriesExtent = seriesData.getDataExtent(dim);\n                    seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n                    seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n                });\n            }\n        });\n\n        if (dataExtent[1] < dataExtent[0]) {\n            dataExtent = [NaN, NaN];\n        }\n\n        // It is important to get \"consistent\" extent when more then one axes is\n        // controlled by a `dataZoom`, otherwise those axes will not be synchronized\n        // when zooming. But it is difficult to know what is \"consistent\", considering\n        // axes have different type or even different meanings (For example, two\n        // time axes are used to compare data of the same date in different years).\n        // So basically dataZoom just obtains extent by series.data (in category axis\n        // extent can be obtained from axis.data).\n        // Nevertheless, user can set min/max/scale on axes to make extent of axes\n        // consistent.\n        fixExtentByAxis(axisProxy, dataExtent);\n\n        return dataExtent;\n    }\n\n    function fixExtentByAxis(axisProxy, dataExtent) {\n        var axisModel = axisProxy.getAxisModel();\n        var min = axisModel.getMin(true);\n\n        // For category axis, if min/max/scale are not set, extent is determined\n        // by axis.data by default.\n        var isCategoryAxis = axisModel.get('type') === 'category';\n        var axisDataLen = isCategoryAxis && (axisModel.get('data') || []).length;\n\n        if (min != null && min !== 'dataMin' && typeof min !== 'function') {\n            dataExtent[0] = min;\n        }\n        else if (isCategoryAxis) {\n            dataExtent[0] = axisDataLen > 0 ? 0 : NaN;\n        }\n\n        var max = axisModel.getMax(true);\n        if (max != null && max !== 'dataMax' && typeof max !== 'function') {\n            dataExtent[1] = max;\n        }\n        else if (isCategoryAxis) {\n            dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;\n        }\n\n        if (!axisModel.get('scale', true)) {\n            dataExtent[0] > 0 && (dataExtent[0] = 0);\n            dataExtent[1] < 0 && (dataExtent[1] = 0);\n        }\n\n        // For value axis, if min/max/scale are not set, we just use the extent obtained\n        // by series data, which may be a little different from the extent calculated by\n        // `axisHelper.getScaleExtent`. But the different just affects the experience a\n        // little when zooming. So it will not be fixed until some users require it strongly.\n\n        return dataExtent;\n    }\n\n    function setAxisModel(axisProxy, isRestore) {\n        var axisModel = axisProxy.getAxisModel();\n\n        var percentWindow = axisProxy._percentWindow;\n        var valueWindow = axisProxy._valueWindow;\n\n        if (!percentWindow) {\n            return;\n        }\n\n        // [0, 500]: arbitrary value, guess axis extent.\n        var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);\n        precision = Math.min(precision, 20);\n        // isRestore or isFull\n        var useOrigin = isRestore || (percentWindow[0] === 0 && percentWindow[1] === 100);\n\n        axisModel.setRange(\n            useOrigin ? null : +valueWindow[0].toFixed(precision),\n            useOrigin ? null : +valueWindow[1].toFixed(precision)\n        );\n    }\n\n    function setMinMaxSpan(axisProxy) {\n        var minMaxSpan = axisProxy._minMaxSpan = {};\n        var dataZoomModel = axisProxy._dataZoomModel;\n\n        each(['min', 'max'], function (minMax) {\n            minMaxSpan[minMax + 'Span'] = dataZoomModel.get(minMax + 'Span');\n\n            // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan\n            var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');\n            if (valueSpan != null) {\n                minMaxSpan[minMax + 'ValueSpan'] = valueSpan;\n\n                valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan);\n                if (valueSpan != null) {\n                    minMaxSpan[minMax + 'Span'] = numberUtil.linearMap(\n                        valueSpan, axisProxy._dataExtent, [0, 100], true\n                    );\n                }\n            }\n        });\n    }\n\n    module.exports = AxisProxy;\n\n\n\n/***/ }),\n\n/***/ 1143:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @file Data zoom model\n */\n\n\n    var DataZoomModel = __webpack_require__(1019);\n\n    module.exports = DataZoomModel.extend({\n\n        type: 'dataZoom.select'\n\n    });\n\n\n\n/***/ }),\n\n/***/ 1144:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    module.exports = __webpack_require__(1021).extend({\n\n        type: 'dataZoom.select'\n\n    });\n\n\n\n/***/ }),\n\n/***/ 1145:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var history = __webpack_require__(1045);\n    var lang = __webpack_require__(997).toolbox.restore;\n\n    function Restore(model) {\n        this.model = model;\n    }\n\n    Restore.defaultOption = {\n        show: true,\n        icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',\n        title: lang.title\n    };\n\n    var proto = Restore.prototype;\n\n    proto.onclick = function (ecModel, api, type) {\n        history.clear(ecModel);\n\n        api.dispatchAction({\n            type: 'restore',\n            from: this.uid\n        });\n    };\n\n\n    __webpack_require__(989).register('restore', Restore);\n\n\n    __webpack_require__(972).registerAction(\n        {type: 'restore', event: 'restore', update: 'prepareAndUpdate'},\n        function (payload, ecModel) {\n            ecModel.resetOption('recreate');\n        }\n    );\n\n    module.exports = Restore;\n\n\n/***/ }),\n\n/***/ 1149:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    var echarts = __webpack_require__(972);\n    var zrUtil = __webpack_require__(971);\n    module.exports = function (seriesType, actionInfos) {\n        zrUtil.each(actionInfos, function (actionInfo) {\n            actionInfo.update = 'updateView';\n            /**\n             * @payload\n             * @property {string} seriesName\n             * @property {string} name\n             */\n            echarts.registerAction(actionInfo, function (payload, ecModel) {\n                var selected = {};\n                ecModel.eachComponent(\n                    {mainType: 'series', subType: seriesType, query: payload},\n                    function (seriesModel) {\n                        if (seriesModel[actionInfo.method]) {\n                            seriesModel[actionInfo.method](\n                                payload.name,\n                                payload.dataIndex\n                            );\n                        }\n                        var data = seriesModel.getData();\n                        // Create selected map\n                        data.each(function (idx) {\n                            var name = data.getName(idx);\n                            selected[name] = seriesModel.isSelected(name)\n                                || false;\n                        });\n                    }\n                );\n                return {\n                    name: payload.name,\n                    selected: selected\n                };\n            });\n        });\n    };\n\n\n/***/ }),\n\n/***/ 1157:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(971);\n    var echarts = __webpack_require__(972);\n\n    __webpack_require__(1158);\n    __webpack_require__(1159);\n\n    __webpack_require__(1149)('pie', [{\n        type: 'pieToggleSelect',\n        event: 'pieselectchanged',\n        method: 'toggleSelected'\n    }, {\n        type: 'pieSelect',\n        event: 'pieselected',\n        method: 'select'\n    }, {\n        type: 'pieUnSelect',\n        event: 'pieunselected',\n        method: 'unSelect'\n    }]);\n\n    echarts.registerVisual(zrUtil.curry(__webpack_require__(1134), 'pie'));\n\n    echarts.registerLayout(zrUtil.curry(\n        __webpack_require__(1160), 'pie'\n    ));\n\n    echarts.registerProcessor(zrUtil.curry(__webpack_require__(1068), 'pie'));\n\n\n/***/ }),\n\n/***/ 1158:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var List = __webpack_require__(987);\n    var zrUtil = __webpack_require__(971);\n    var modelUtil = __webpack_require__(975);\n    var numberUtil = __webpack_require__(974);\n    var completeDimensions = __webpack_require__(995);\n\n    var dataSelectableMixin = __webpack_require__(1133);\n\n    var PieSeries = __webpack_require__(972).extendSeriesModel({\n\n        type: 'series.pie',\n\n        // Overwrite\n        init: function (option) {\n            PieSeries.superApply(this, 'init', arguments);\n\n            // Enable legend selection for each data item\n            // Use a function instead of direct access because data reference may changed\n            this.legendDataProvider = function () {\n                return this.getRawData();\n            };\n\n            this.updateSelectedMap(option.data);\n\n            this._defaultLabelLine(option);\n        },\n\n        // Overwrite\n        mergeOption: function (newOption) {\n            PieSeries.superCall(this, 'mergeOption', newOption);\n            this.updateSelectedMap(this.option.data);\n        },\n\n        getInitialData: function (option, ecModel) {\n            var dimensions = completeDimensions(['value'], option.data);\n            var list = new List(dimensions, this);\n            list.initData(option.data);\n            return list;\n        },\n\n        // Overwrite\n        getDataParams: function (dataIndex) {\n            var data = this.getData();\n            var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n            // FIXME toFixed?\n\n            var valueList = [];\n            data.each('value', function (value) {\n                valueList.push(value);\n            });\n\n            params.percent = numberUtil.getPercentWithPrecision(\n                valueList,\n                dataIndex,\n                data.hostModel.get('percentPrecision')\n            );\n\n            params.$vars.push('percent');\n            return params;\n        },\n\n        _defaultLabelLine: function (option) {\n            // Extend labelLine emphasis\n            modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\n            var labelLineNormalOpt = option.labelLine.normal;\n            var labelLineEmphasisOpt = option.labelLine.emphasis;\n            // Not show label line if `label.normal.show = false`\n            labelLineNormalOpt.show = labelLineNormalOpt.show\n                && option.label.normal.show;\n            labelLineEmphasisOpt.show = labelLineEmphasisOpt.show\n                && option.label.emphasis.show;\n        },\n\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // \n            center: ['50%', '50%'],\n            radius: [0, '75%'],\n            // \n            clockwise: true,\n            startAngle: 90,\n            // 0\n            minAngle: 0,\n            // \n            selectedOffset: 10,\n            // \n            hoverOffset: 10,\n\n            // If use strategy to avoid label overlapping\n            avoidLabelOverlap: true,\n            // singlemultiple\n            // selectedMode: false,\n            // 'radius' | 'area'\n            // roseType: null,\n\n            percentPrecision: 2,\n\n            // If still show when all data zero.\n            stillShowZeroSum: true,\n\n            // cursor: null,\n\n            label: {\n                normal: {\n                    // If rotate around circle\n                    rotate: false,\n                    show: true,\n                    // 'outer', 'inside', 'center'\n                    position: 'outer'\n                    // formatter: Tooltip.formatter\n                    // TEXTSTYLE\n                    // distance: positioninnerlabel()\n                },\n                emphasis: {}\n            },\n            // Enabled when label.normal.position is 'outer'\n            labelLine: {\n                normal: {\n                    show: true,\n                    // \n                    length: 15,\n                    // \n                    length2: 15,\n                    smooth: false,\n                    lineStyle: {\n                        // color: ,\n                        width: 1,\n                        type: 'solid'\n                    }\n                }\n            },\n            itemStyle: {\n                normal: {\n                    borderWidth: 1\n                },\n                emphasis: {}\n            },\n\n            // Animation type canbe expansion, scale\n            animationType: 'expansion',\n\n            animationEasing: 'cubicOut',\n\n            data: []\n        }\n    });\n\n    zrUtil.mixin(PieSeries, dataSelectableMixin);\n\n    module.exports = PieSeries;\n\n\n/***/ }),\n\n/***/ 1159:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var graphic = __webpack_require__(973);\n    var zrUtil = __webpack_require__(971);\n\n    /**\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n        var data = seriesModel.getData();\n        var dataIndex = this.dataIndex;\n        var name = data.getName(dataIndex);\n        var selectedOffset = seriesModel.get('selectedOffset');\n\n        api.dispatchAction({\n            type: 'pieToggleSelect',\n            from: uid,\n            name: name,\n            seriesId: seriesModel.id\n        });\n\n        data.each(function (idx) {\n            toggleItemSelected(\n                data.getItemGraphicEl(idx),\n                data.getItemLayout(idx),\n                seriesModel.isSelected(data.getName(idx)),\n                selectedOffset,\n                hasAnimation\n            );\n        });\n    }\n\n    /**\n     * @param {module:zrender/graphic/Sector} el\n     * @param {Object} layout\n     * @param {boolean} isSelected\n     * @param {number} selectedOffset\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\n        var dx = Math.cos(midAngle);\n        var dy = Math.sin(midAngle);\n\n        var offset = isSelected ? selectedOffset : 0;\n        var position = [dx * offset, dy * offset];\n\n        hasAnimation\n            // animateTo will stop revious animation like update transition\n            ? el.animate()\n                .when(200, {\n                    position: position\n                })\n                .start('bounceOut')\n            : el.attr('position', position);\n    }\n\n    /**\n     * Piece of pie including Sector, Label, LabelLine\n     * @constructor\n     * @extends {module:zrender/graphic/Group}\n     */\n    function PiePiece(data, idx) {\n\n        graphic.Group.call(this);\n\n        var sector = new graphic.Sector({\n            z2: 2\n        });\n        var polyline = new graphic.Polyline();\n        var text = new graphic.Text();\n        this.add(sector);\n        this.add(polyline);\n        this.add(text);\n\n        this.updateData(data, idx, true);\n\n        // Hover to change label and labelLine\n        function onEmphasis() {\n            polyline.ignore = polyline.hoverIgnore;\n            text.ignore = text.hoverIgnore;\n        }\n        function onNormal() {\n            polyline.ignore = polyline.normalIgnore;\n            text.ignore = text.normalIgnore;\n        }\n        this.on('emphasis', onEmphasis)\n            .on('normal', onNormal)\n            .on('mouseover', onEmphasis)\n            .on('mouseout', onNormal);\n    }\n\n    var piePieceProto = PiePiece.prototype;\n\n    piePieceProto.updateData = function (data, idx, firstCreate) {\n\n        var sector = this.childAt(0);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var sectorShape = zrUtil.extend({}, layout);\n        sectorShape.label = null;\n\n        if (firstCreate) {\n            sector.setShape(sectorShape);\n\n            var animationType = seriesModel.getShallow('animationType');\n            if (animationType === 'scale') {\n                sector.shape.r = layout.r0;\n                graphic.initProps(sector, {\n                    shape: {\n                        r: layout.r\n                    }\n                }, seriesModel, idx);\n            }\n            // Expansion\n            else {\n                sector.shape.endAngle = layout.startAngle;\n                graphic.updateProps(sector, {\n                    shape: {\n                        endAngle: layout.endAngle\n                    }\n                }, seriesModel, idx);\n            }\n\n        }\n        else {\n            graphic.updateProps(sector, {\n                shape: sectorShape\n            }, seriesModel, idx);\n        }\n\n        // Update common style\n        var itemStyleModel = itemModel.getModel('itemStyle');\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        sector.useStyle(\n            zrUtil.defaults(\n                {\n                    lineJoin: 'bevel',\n                    fill: visualColor\n                },\n                itemStyleModel.getModel('normal').getItemStyle()\n            )\n        );\n        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\n        var cursorStyle = itemModel.getShallow('cursor');\n        cursorStyle && sector.attr('cursor', cursorStyle);\n\n        // Toggle selected\n        toggleItemSelected(\n            this,\n            data.getItemLayout(idx),\n            itemModel.get('selected'),\n            seriesModel.get('selectedOffset'),\n            seriesModel.get('animation')\n        );\n\n        function onEmphasis() {\n            // Sector may has animation of updating data. Force to move to the last frame\n            // Or it may stopped on the wrong shape\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r + seriesModel.get('hoverOffset')\n                }\n            }, 300, 'elasticOut');\n        }\n        function onNormal() {\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r\n                }\n            }, 300, 'elasticOut');\n        }\n        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n        if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n            sector\n                .on('mouseover', onEmphasis)\n                .on('mouseout', onNormal)\n                .on('emphasis', onEmphasis)\n                .on('normal', onNormal);\n        }\n\n        this._updateLabel(data, idx);\n\n        graphic.setHoverStyle(this);\n    };\n\n    piePieceProto._updateLabel = function (data, idx) {\n\n        var labelLine = this.childAt(1);\n        var labelText = this.childAt(2);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var labelLayout = layout.label;\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        graphic.updateProps(labelLine, {\n            shape: {\n                points: labelLayout.linePoints || [\n                    [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]\n                ]\n            }\n        }, seriesModel, idx);\n\n        graphic.updateProps(labelText, {\n            style: {\n                x: labelLayout.x,\n                y: labelLayout.y\n            }\n        }, seriesModel, idx);\n        labelText.attr({\n            rotation: labelLayout.rotation,\n            origin: [labelLayout.x, labelLayout.y],\n            z2: 10\n        });\n\n        var labelModel = itemModel.getModel('label.normal');\n        var labelHoverModel = itemModel.getModel('label.emphasis');\n        var labelLineModel = itemModel.getModel('labelLine.normal');\n        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        graphic.setLabelStyle(\n            labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel,\n            {\n                labelFetcher: data.hostModel,\n                labelDataIndex: idx,\n                defaultText: data.getName(idx),\n                autoColor: visualColor,\n                useInsideStyle: !!labelLayout.inside\n            },\n            {\n                textAlign: labelLayout.textAlign,\n                textVerticalAlign: labelLayout.verticalAlign,\n                opacity: data.getItemVisual(idx, 'opacity')\n            }\n        );\n\n        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n        labelText.hoverIgnore = !labelHoverModel.get('show');\n\n        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\n        // Default use item visual color\n        labelLine.setStyle({\n            stroke: visualColor,\n            opacity: data.getItemVisual(idx, 'opacity')\n        });\n        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\n        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n\n        var smooth = labelLineModel.get('smooth');\n        if (smooth && smooth === true) {\n            smooth = 0.4;\n        }\n        labelLine.setShape({\n            smooth: smooth\n        });\n    };\n\n    zrUtil.inherits(PiePiece, graphic.Group);\n\n\n    // Pie view\n    var Pie = __webpack_require__(1002).extend({\n\n        type: 'pie',\n\n        init: function () {\n            var sectorGroup = new graphic.Group();\n            this._sectorGroup = sectorGroup;\n        },\n\n        render: function (seriesModel, ecModel, api, payload) {\n            if (payload && (payload.from === this.uid)) {\n                return;\n            }\n\n            var data = seriesModel.getData();\n            var oldData = this._data;\n            var group = this.group;\n\n            var hasAnimation = ecModel.get('animation');\n            var isFirstRender = !oldData;\n            var animationType = seriesModel.get('animationType');\n\n            var onSectorClick = zrUtil.curry(\n                updateDataSelected, this.uid, seriesModel, hasAnimation, api\n            );\n\n            var selectedMode = seriesModel.get('selectedMode');\n\n            data.diff(oldData)\n                .add(function (idx) {\n                    var piePiece = new PiePiece(data, idx);\n                    // Default expansion animation\n                    if (isFirstRender && animationType !== 'scale') {\n                        piePiece.eachChild(function (child) {\n                            child.stopAnimation(true);\n                        });\n                    }\n\n                    selectedMode && piePiece.on('click', onSectorClick);\n\n                    data.setItemGraphicEl(idx, piePiece);\n\n                    group.add(piePiece);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\n                    piePiece.updateData(data, newIdx);\n\n                    piePiece.off('click');\n                    selectedMode && piePiece.on('click', onSectorClick);\n                    group.add(piePiece);\n                    data.setItemGraphicEl(newIdx, piePiece);\n                })\n                .remove(function (idx) {\n                    var piePiece = oldData.getItemGraphicEl(idx);\n                    group.remove(piePiece);\n                })\n                .execute();\n\n            if (\n                hasAnimation && isFirstRender && data.count() > 0\n                // Default expansion animation\n                && animationType !== 'scale'\n            ) {\n                var shape = data.getItemLayout(0);\n                var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n\n                var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n                group.setClipPath(this._createClipPath(\n                    shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel\n                ));\n            }\n\n            this._data = data;\n        },\n\n        dispose: function () {},\n\n        _createClipPath: function (\n            cx, cy, r, startAngle, clockwise, cb, seriesModel\n        ) {\n            var clipPath = new graphic.Sector({\n                shape: {\n                    cx: cx,\n                    cy: cy,\n                    r0: 0,\n                    r: r,\n                    startAngle: startAngle,\n                    endAngle: startAngle,\n                    clockwise: clockwise\n                }\n            });\n\n            graphic.initProps(clipPath, {\n                shape: {\n                    endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n                }\n            }, seriesModel, cb);\n\n            return clipPath;\n        },\n\n        /**\n         * @implement\n         */\n        containPoint: function (point, seriesModel) {\n            var data = seriesModel.getData();\n            var itemLayout = data.getItemLayout(0);\n            if (itemLayout) {\n                var dx = point[0] - itemLayout.cx;\n                var dy = point[1] - itemLayout.cy;\n                var radius = Math.sqrt(dx * dx + dy * dy);\n                return radius <= itemLayout.r && radius >= itemLayout.r0;\n            }\n        }\n\n    });\n\n    module.exports = Pie;\n\n\n/***/ }),\n\n/***/ 1160:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var numberUtil = __webpack_require__(974);\n    var parsePercent = numberUtil.parsePercent;\n    var labelLayout = __webpack_require__(1161);\n    var zrUtil = __webpack_require__(971);\n\n    var PI2 = Math.PI * 2;\n    var RADIAN = Math.PI / 180;\n\n    module.exports = function (seriesType, ecModel, api, payload) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var center = seriesModel.get('center');\n            var radius = seriesModel.get('radius');\n\n            if (!zrUtil.isArray(radius)) {\n                radius = [0, radius];\n            }\n            if (!zrUtil.isArray(center)) {\n                center = [center, center];\n            }\n\n            var width = api.getWidth();\n            var height = api.getHeight();\n            var size = Math.min(width, height);\n            var cx = parsePercent(center[0], width);\n            var cy = parsePercent(center[1], height);\n            var r0 = parsePercent(radius[0], size / 2);\n            var r = parsePercent(radius[1], size / 2);\n\n            var data = seriesModel.getData();\n\n            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n\n            var minAngle = seriesModel.get('minAngle') * RADIAN;\n\n            var validDataCount = 0;\n            data.each('value', function (value) {\n                !isNaN(value) && validDataCount++;\n            });\n\n            var sum = data.getSum('value');\n            // Sum may be 0\n            var unitRadian = Math.PI / (sum || validDataCount) * 2;\n\n            var clockwise = seriesModel.get('clockwise');\n\n            var roseType = seriesModel.get('roseType');\n            var stillShowZeroSum = seriesModel.get('stillShowZeroSum');\n\n            // [0...max]\n            var extent = data.getDataExtent('value');\n            extent[0] = 0;\n\n            // In the case some sector angle is smaller than minAngle\n            var restAngle = PI2;\n            var valueSumLargerThanMinAngle = 0;\n\n            var currentAngle = startAngle;\n            var dir = clockwise ? 1 : -1;\n\n            data.each('value', function (value, idx) {\n                var angle;\n                if (isNaN(value)) {\n                    data.setItemLayout(idx, {\n                        angle: NaN,\n                        startAngle: NaN,\n                        endAngle: NaN,\n                        clockwise: clockwise,\n                        cx: cx,\n                        cy: cy,\n                        r0: r0,\n                        r: roseType\n                            ? NaN\n                            : r\n                    });\n                    return;\n                }\n\n                // FIXME  2.0  roseType  area \n                if (roseType !== 'area') {\n                    angle = (sum === 0 && stillShowZeroSum)\n                        ? unitRadian : (value * unitRadian);\n                }\n                else {\n                    angle = PI2 / validDataCount;\n                }\n\n                if (angle < minAngle) {\n                    angle = minAngle;\n                    restAngle -= minAngle;\n                }\n                else {\n                    valueSumLargerThanMinAngle += value;\n                }\n\n                var endAngle = currentAngle + dir * angle;\n                data.setItemLayout(idx, {\n                    angle: angle,\n                    startAngle: currentAngle,\n                    endAngle: endAngle,\n                    clockwise: clockwise,\n                    cx: cx,\n                    cy: cy,\n                    r0: r0,\n                    r: roseType\n                        ? numberUtil.linearMap(value, extent, [r0, r])\n                        : r\n                });\n\n                currentAngle = endAngle;\n            }, true);\n\n            // Some sector is constrained by minAngle\n            // Rest sectors needs recalculate angle\n            if (restAngle < PI2 && validDataCount) {\n                // Average the angle if rest angle is not enough after all angles is\n                // Constrained by minAngle\n                if (restAngle <= 1e-3) {\n                    var angle = PI2 / validDataCount;\n                    data.each('value', function (value, idx) {\n                        if (!isNaN(value)) {\n                            var layout = data.getItemLayout(idx);\n                            layout.angle = angle;\n                            layout.startAngle = startAngle + dir * idx * angle;\n                            layout.endAngle = startAngle + dir * (idx + 1) * angle;\n                        }\n                    });\n                }\n                else {\n                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n                    currentAngle = startAngle;\n                    data.each('value', function (value, idx) {\n                        if (!isNaN(value)) {\n                            var layout = data.getItemLayout(idx);\n                            var angle = layout.angle === minAngle\n                                ? minAngle : value * unitRadian;\n                            layout.startAngle = currentAngle;\n                            layout.endAngle = currentAngle + dir * angle;\n                            currentAngle += dir * angle;\n                        }\n                    });\n                }\n            }\n\n            labelLayout(seriesModel, r, width, height);\n        });\n    };\n\n\n/***/ }),\n\n/***/ 1161:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// FIXME emphasis label position is not same with normal label position\n\n\n    var textContain = __webpack_require__(985);\n\n    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n        list.sort(function (a, b) {\n            return a.y - b.y;\n        });\n\n        // \n        function shiftDown(start, end, delta, dir) {\n            for (var j = start; j < end; j++) {\n                list[j].y += delta;\n                if (j > start\n                    && j + 1 < end\n                    && list[j + 1].y > list[j].y + list[j].height\n                ) {\n                    shiftUp(j, delta / 2);\n                    return;\n                }\n            }\n\n            shiftUp(end - 1, delta / 2);\n        }\n\n        // \n        function shiftUp(end, delta) {\n            for (var j = end; j >= 0; j--) {\n                list[j].y -= delta;\n                if (j > 0\n                    && list[j].y > list[j - 1].y + list[j - 1].height\n                ) {\n                    break;\n                }\n            }\n        }\n\n        function changeX(list, isDownList, cx, cy, r, dir) {\n            var lastDeltaX = dir > 0\n                ? isDownList                // \n                    ? Number.MAX_VALUE      // \n                    : 0                     // \n                : isDownList                // \n                    ? Number.MAX_VALUE      // \n                    : 0;                    // \n\n            for (var i = 0, l = list.length; i < l; i++) {\n                // Not change x for center label\n                if (list[i].position === 'center') {\n                    continue;\n                }\n                var deltaY = Math.abs(list[i].y - cy);\n                var length = list[i].len;\n                var length2 = list[i].len2;\n                var deltaX = (deltaY < r + length)\n                    ? Math.sqrt(\n                          (r + length + length2) * (r + length + length2)\n                          - deltaY * deltaY\n                      )\n                    : Math.abs(list[i].x - cx);\n                if (isDownList && deltaX >= lastDeltaX) {\n                    // \n                    deltaX = lastDeltaX - 10;\n                }\n                if (!isDownList && deltaX <= lastDeltaX) {\n                    // \n                    deltaX = lastDeltaX + 10;\n                }\n\n                list[i].x = cx + deltaX * dir;\n                lastDeltaX = deltaX;\n            }\n        }\n\n        var lastY = 0;\n        var delta;\n        var len = list.length;\n        var upList = [];\n        var downList = [];\n        for (var i = 0; i < len; i++) {\n            delta = list[i].y - lastY;\n            if (delta < 0) {\n                shiftDown(i, len, -delta, dir);\n            }\n            lastY = list[i].y + list[i].height;\n        }\n        if (viewHeight - lastY < 0) {\n            shiftUp(len - 1, lastY - viewHeight);\n        }\n        for (var i = 0; i < len; i++) {\n            if (list[i].y >= cy) {\n                downList.push(list[i]);\n            }\n            else {\n                upList.push(list[i]);\n            }\n        }\n        changeX(upList, false, cx, cy, r, dir);\n        changeX(downList, true, cx, cy, r, dir);\n    }\n\n    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n        var leftList = [];\n        var rightList = [];\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            if (labelLayoutList[i].x < cx) {\n                leftList.push(labelLayoutList[i]);\n            }\n            else {\n                rightList.push(labelLayoutList[i]);\n            }\n        }\n\n        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            var linePoints = labelLayoutList[i].linePoints;\n            if (linePoints) {\n                var dist = linePoints[1][0] - linePoints[2][0];\n                if (labelLayoutList[i].x < cx) {\n                    linePoints[2][0] = labelLayoutList[i].x + 3;\n                }\n                else {\n                    linePoints[2][0] = labelLayoutList[i].x - 3;\n                }\n                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n                linePoints[1][0] = linePoints[2][0] + dist;\n            }\n        }\n    }\n\n    module.exports = function (seriesModel, r, viewWidth, viewHeight) {\n        var data = seriesModel.getData();\n        var labelLayoutList = [];\n        var cx;\n        var cy;\n        var hasLabelRotate = false;\n\n        data.each(function (idx) {\n            var layout = data.getItemLayout(idx);\n\n            var itemModel = data.getItemModel(idx);\n            var labelModel = itemModel.getModel('label.normal');\n            // Use position in normal or emphasis\n            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n\n            var labelLineModel = itemModel.getModel('labelLine.normal');\n            var labelLineLen = labelLineModel.get('length');\n            var labelLineLen2 = labelLineModel.get('length2');\n\n            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n            var dx = Math.cos(midAngle);\n            var dy = Math.sin(midAngle);\n\n            var textX;\n            var textY;\n            var linePoints;\n            var textAlign;\n\n            cx = layout.cx;\n            cy = layout.cy;\n\n            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n            if (labelPosition === 'center') {\n                textX = layout.cx;\n                textY = layout.cy;\n                textAlign = 'center';\n            }\n            else {\n                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n\n                textX = x1 + dx * 3;\n                textY = y1 + dy * 3;\n\n                if (!isLabelInside) {\n                    // For roseType\n                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n                    var x3 = x2 + ((dx < 0 ? -1 : 1) * labelLineLen2);\n                    var y3 = y2;\n\n                    textX = x3 + (dx < 0 ? -5 : 5);\n                    textY = y3;\n                    linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n                }\n\n                textAlign = isLabelInside ? 'center' : (dx > 0 ? 'left' : 'right');\n            }\n            var font = labelModel.getFont();\n\n            var labelRotate = labelModel.get('rotate')\n                ? (dx < 0 ? -midAngle + Math.PI : -midAngle) : 0;\n            var text = seriesModel.getFormattedLabel(idx, 'normal')\n                        || data.getName(idx);\n            var textRect = textContain.getBoundingRect(\n                text, font, textAlign, 'top'\n            );\n            hasLabelRotate = !!labelRotate;\n            layout.label = {\n                x: textX,\n                y: textY,\n                position: labelPosition,\n                height: textRect.height,\n                len: labelLineLen,\n                len2: labelLineLen2,\n                linePoints: linePoints,\n                textAlign: textAlign,\n                verticalAlign: 'middle',\n                rotation: labelRotate,\n                inside: isLabelInside\n            };\n\n            // Not layout the inside label\n            if (!isLabelInside) {\n                labelLayoutList.push(layout.label);\n            }\n        });\n        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n        }\n    };\n\n\n/***/ }),\n\n/***/ 968:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts__ = __webpack_require__(972);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_echarts_lib_component_tooltip__ = __webpack_require__(1066);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_echarts_lib_component_tooltip___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_echarts_lib_component_tooltip__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_echarts_lib_component_legend__ = __webpack_require__(1067);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_echarts_lib_component_legend___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_echarts_lib_component_legend__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_echarts_lib_chart_pie__ = __webpack_require__(1157);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_echarts_lib_chart_pie___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_echarts_lib_chart_pie__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_echarts_lib_component_toolbox__ = __webpack_require__(1069);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_echarts_lib_component_toolbox___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_echarts_lib_component_toolbox__);\nvar _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}//\nvar PieReact=function(_React$Component){_inherits(PieReact,_React$Component);function PieReact(props){_classCallCheck(this,PieReact);var _this=_possibleConstructorReturn(this,(PieReact.__proto__||Object.getPrototypeOf(PieReact)).call(this,props));_this.initPie=_this.initPie.bind(_this);return _this;}_createClass(PieReact,[{key:'initPie',value:function initPie(){var _props$option=this.props.option,option=_props$option===undefined?{}:_props$option;//data\nvar myChart=__WEBPACK_IMPORTED_MODULE_1_echarts_lib_echarts___default.a.init(this.ID);//echarts\n//options\nmyChart.setOption(option);window.onresize=function(){myChart.resize();};}},{key:'componentDidMount',value:function componentDidMount(){this.initPie();}},{key:'componentDidUpdate',value:function componentDidUpdate(){this.initPie();}},{key:'render',value:function render(){var _this2=this;var _props=this.props,_props$width=_props.width,width=_props$width===undefined?\"100%\":_props$width,_props$height=_props.height,height=_props$height===undefined?'300px':_props$height;return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('div',{ref:function ref(ID){return _this2.ID=ID;},style:{width:width,height:height}});}}]);return PieReact;}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);/* harmony default export */ __webpack_exports__[\"default\"] = (PieReact);\n\n/***/ }),\n\n/***/ 971:\n/***/ (function(module, exports) {\n\n/**\n * @module zrender/core/util\n */\n\n\n    // mergeDate\n    var BUILTIN_OBJECT = {\n        '[object Function]': 1,\n        '[object RegExp]': 1,\n        '[object Date]': 1,\n        '[object Error]': 1,\n        '[object CanvasGradient]': 1,\n        '[object CanvasPattern]': 1,\n        // For node-canvas\n        '[object Image]': 1,\n        '[object Canvas]': 1\n    };\n\n    var TYPED_ARRAY = {\n        '[object Int8Array]': 1,\n        '[object Uint8Array]': 1,\n        '[object Uint8ClampedArray]': 1,\n        '[object Int16Array]': 1,\n        '[object Uint16Array]': 1,\n        '[object Int32Array]': 1,\n        '[object Uint32Array]': 1,\n        '[object Float32Array]': 1,\n        '[object Float64Array]': 1\n    };\n\n    var objToString = Object.prototype.toString;\n\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n\n    /**\n     * Those data types can be cloned:\n     *     Plain object, Array, TypedArray, number, string, null, undefined.\n     * Those data types will be assgined using the orginal data:\n     *     BUILTIN_OBJECT\n     * Instance of user defined class will be cloned to a plain object, without\n     * properties in prototype.\n     * Other data types is not supported (not sure what will happen).\n     *\n     * Caution: do not support clone Date, for performance consideration.\n     * (There might be a large number of date in `series.data`).\n     * So date should not be modified in and out of echarts.\n     *\n     * @param {*} source\n     * @return {*} new\n     */\n    function clone(source) {\n        if (source == null || typeof source != 'object') {\n            return source;\n        }\n\n        var result = source;\n        var typeStr = objToString.call(source);\n\n        if (typeStr === '[object Array]') {\n            result = [];\n            for (var i = 0, len = source.length; i < len; i++) {\n                result[i] = clone(source[i]);\n            }\n        }\n        else if (TYPED_ARRAY[typeStr]) {\n            var Ctor = source.constructor;\n            if (source.constructor.from) {\n                result = Ctor.from(source);\n            }\n            else {\n                result = new Ctor(source.length);\n                for (var i = 0, len = source.length; i < len; i++) {\n                    result[i] = clone(source[i]);\n                }\n            }\n        }\n        else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n            result = {};\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    result[key] = clone(source[key]);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuiltInObject(sourceProp)\n                    && !isBuiltInObject(targetProp)\n                    && !isPrimitive(sourceProp)\n                    && !isPrimitive(targetProp)\n                ) {\n                    // merge\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    // overwritetrue\n                    // NOTE target[key] \n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)\n                && (overlay ? source[key] != null : target[key] == null)\n            ) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n\n    /**\n     * index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * \n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz \n     * @param {Function} baseClazz \n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {}\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n\n        defaults(target, source, overlay);\n    }\n\n    /**\n     * Consider typed array.\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (! data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        }\n        else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        }\n        else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuiltInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return typeof value === 'object'\n            && typeof value.nodeType === 'number'\n            && typeof value.ownerDocument === 'object';\n    }\n\n    /**\n     * Whether is exactly NaN. Notice isNaN('a') returns true.\n     * @param {*} value\n     * @return {boolean}\n     */\n    function eqNaN(value) {\n        return value !== value;\n    }\n\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * Low performance.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n\n    function retrieve2(value0, value1) {\n        return value0 != null\n            ? value0\n            : value1;\n    }\n\n    function retrieve3(value0, value1, value2) {\n        return value0 != null\n            ? value0\n            : value1 != null\n            ? value1\n            : value2;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n\n    /**\n     * Normalize css liked array configuration\n     * e.g.\n     *  3 => [3, 3, 3, 3]\n     *  [4, 2] => [4, 2, 4, 2]\n     *  [4, 3, 2] => [4, 3, 2, 3]\n     * @param {number|Array.<number>} val\n     * @return {Array.<number>}\n     */\n    function normalizeCssArray(val) {\n        if (typeof (val) === 'number') {\n            return [val, val, val, val];\n        }\n        var len = val.length;\n        if (len === 2) {\n            // vertical | horizontal\n            return [val[0], val[1], val[0], val[1]];\n        }\n        else if (len === 3) {\n            // top | horizontal | bottom\n            return [val[0], val[1], val[2], val[1]];\n        }\n        return val;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n\n    var primitiveKey = '__ec_primitive__';\n    /**\n     * Set an object as primitive to be ignored traversing children in clone or merge\n     */\n    function setAsPrimitive(obj) {\n        obj[primitiveKey] = true;\n    }\n\n    function isPrimitive(obj) {\n        return obj[primitiveKey];\n    }\n\n    /**\n     * @constructor\n     * @param {Object} obj Only apply `ownProperty`.\n     */\n    function HashMap(obj) {\n        obj && each(obj, function (value, key) {\n            this.set(key, value);\n        }, this);\n    }\n\n    // Add prefix to avoid conflict with Object.prototype.\n    var HASH_MAP_PREFIX = '_ec_';\n    var HASH_MAP_PREFIX_LENGTH = 4;\n\n    HashMap.prototype = {\n        constructor: HashMap,\n        // Do not provide `has` method to avoid defining what is `has`.\n        // (We usually treat `null` and `undefined` as the same, different\n        // from ES6 Map).\n        get: function (key) {\n            return this[HASH_MAP_PREFIX + key];\n        },\n        set: function (key, value) {\n            this[HASH_MAP_PREFIX + key] = value;\n            // Comparing with invocation chaining, `return value` is more commonly\n            // used in this case: `var someVal = map.set('a', genVal());`\n            return value;\n        },\n        // Although util.each can be performed on this hashMap directly, user\n        // should not use the exposed keys, who are prefixed.\n        each: function (cb, context) {\n            context !== void 0 && (cb = bind(cb, context));\n            for (var prefixedKey in this) {\n                this.hasOwnProperty(prefixedKey)\n                    && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n            }\n        },\n        // Do not use this method if performance sensitive.\n        removeKey: function (key) {\n            delete this[HASH_MAP_PREFIX + key];\n        }\n    };\n\n    function createHashMap(obj) {\n        return new HashMap(obj);\n    }\n\n    var util = {\n        inherits: inherits,\n        mixin: mixin,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n        getContext: getContext,\n        createCanvas: createCanvas,\n        indexOf: indexOf,\n        slice: slice,\n        find: find,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        isBuiltInObject: isBuiltInObject,\n        isDom: isDom,\n        eqNaN: eqNaN,\n        retrieve: retrieve,\n        retrieve2: retrieve2,\n        retrieve3: retrieve3,\n        assert: assert,\n        setAsPrimitive: setAsPrimitive,\n        createHashMap: createHashMap,\n        normalizeCssArray: normalizeCssArray,\n        noop: function () {}\n    };\n    module.exports = util;\n\n\n\n/***/ }),\n\n/***/ 972:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {// Enable DEV mode when using source code without build. which has no __DEV__ variable\n// In build process 'typeof __DEV__' will be replace with 'boolean'\n// So this code will be removed or disabled anyway after built.\nif (typeof __DEV__ === 'undefined') {\n    // In browser\n    if (typeof window !== 'undefined') {\n        window.__DEV__ = true;\n    }\n    // In node\n    else if (typeof global !== 'undefined') {\n        global.__DEV__ = true;\n    }\n}\n\n/*!\n * ECharts, a javascript interactive chart library.\n *\n * Copyright (c) 2015, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n */\n\n/**\n * @module echarts\n */\n\n\n    var env = __webpack_require__(978);\n\n    var GlobalModel = __webpack_require__(1079);\n    var ExtensionAPI = __webpack_require__(1107);\n    var CoordinateSystemManager = __webpack_require__(998);\n    var OptionManager = __webpack_require__(1108);\n    var backwardCompat = __webpack_require__(1109);\n\n    var ComponentModel = __webpack_require__(983);\n    var SeriesModel = __webpack_require__(994);\n\n    var ComponentView = __webpack_require__(1028);\n    var ChartView = __webpack_require__(1002);\n    var graphic = __webpack_require__(973);\n    var modelUtil = __webpack_require__(975);\n    var throttle = __webpack_require__(1011);\n\n    var zrender = __webpack_require__(1065);\n    var zrUtil = __webpack_require__(971);\n    var colorTool = __webpack_require__(993);\n    var Eventful = __webpack_require__(992);\n    var timsort = __webpack_require__(1017);\n\n\n    var each = zrUtil.each;\n    var parseClassType = ComponentModel.parseClassType;\n\n    var PRIORITY_PROCESSOR_FILTER = 1000;\n    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\n\n    var PRIORITY_VISUAL_LAYOUT = 1000;\n    var PRIORITY_VISUAL_GLOBAL = 2000;\n    var PRIORITY_VISUAL_CHART = 3000;\n    var PRIORITY_VISUAL_COMPONENT = 4000;\n    // FIXME\n    // necessary?\n    var PRIORITY_VISUAL_BRUSH = 5000;\n\n    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n    // where they must not be invoked nestedly, except the only case: invoke\n    // dispatchAction with updateMethod \"none\" in main process.\n    // This flag is used to carry out this rule.\n    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n    var IN_MAIN_PROCESS = '__flagInMainProcess';\n    var HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';\n    var OPTION_UPDATED = '__optionUpdated';\n    var ACTION_REG = /^[a-zA-Z0-9_]+$/;\n\n\n    function createRegisterEventWithLowercaseName(method) {\n        return function (eventName, handler, context) {\n            // Event name is all lowercase\n            eventName = eventName && eventName.toLowerCase();\n            Eventful.prototype[method].call(this, eventName, handler, context);\n        };\n    }\n\n    /**\n     * @module echarts~MessageCenter\n     */\n    function MessageCenter() {\n        Eventful.call(this);\n    }\n    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n    zrUtil.mixin(MessageCenter, Eventful);\n\n    /**\n     * @module echarts~ECharts\n     */\n    function ECharts(dom, theme, opts) {\n        opts = opts || {};\n\n        // Get theme by name\n        if (typeof theme === 'string') {\n            theme = themeStorage[theme];\n        }\n\n        /**\n         * @type {string}\n         */\n        this.id;\n        /**\n         * Group id\n         * @type {string}\n         */\n        this.group;\n        /**\n         * @type {HTMLElement}\n         * @private\n         */\n        this._dom = dom;\n        /**\n         * @type {module:zrender/ZRender}\n         * @private\n         */\n        var zr = this._zr = zrender.init(dom, {\n            renderer: opts.renderer || 'canvas',\n            devicePixelRatio: opts.devicePixelRatio,\n            width: opts.width,\n            height: opts.height\n        });\n\n        /**\n         * Expect 60 pfs.\n         * @type {Function}\n         * @private\n         */\n        this._throttledZrFlush = throttle.throttle(zrUtil.bind(zr.flush, zr), 17);\n\n        var theme = zrUtil.clone(theme);\n        theme && backwardCompat(theme, true);\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._theme = theme;\n\n        /**\n         * @type {Array.<module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsMap = {};\n\n        /**\n         * @type {module:echarts/CoordinateSystem}\n         * @private\n         */\n        this._coordSysMgr = new CoordinateSystemManager();\n\n        /**\n         * @type {module:echarts/ExtensionAPI}\n         * @private\n         */\n        this._api = createExtensionAPI(this);\n\n        Eventful.call(this);\n\n        /**\n         * @type {module:echarts~MessageCenter}\n         * @private\n         */\n        this._messageCenter = new MessageCenter();\n\n        // Init mouse events\n        this._initEvents();\n\n        // In case some people write `window.onresize = chart.resize`\n        this.resize = zrUtil.bind(this.resize, this);\n\n        // Can't dispatch action during rendering procedure\n        this._pendingActions = [];\n        // Sort on demand\n        function prioritySortFunc(a, b) {\n            return a.prio - b.prio;\n        }\n        timsort(visualFuncs, prioritySortFunc);\n        timsort(dataProcessorFuncs, prioritySortFunc);\n\n        zr.animation.on('frame', this._onframe, this);\n\n        // ECharts instance can be used as value.\n        zrUtil.setAsPrimitive(this);\n    }\n\n    var echartsProto = ECharts.prototype;\n\n    echartsProto._onframe = function () {\n        // Lazy update\n        if (this[OPTION_UPDATED]) {\n            var silent = this[OPTION_UPDATED].silent;\n\n            this[IN_MAIN_PROCESS] = true;\n\n            updateMethods.prepareAndUpdate.call(this);\n\n            this[IN_MAIN_PROCESS] = false;\n\n            this[OPTION_UPDATED] = false;\n\n            flushPendingActions.call(this, silent);\n\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n    /**\n     * @return {HTMLElement}\n     */\n    echartsProto.getDom = function () {\n        return this._dom;\n    };\n\n    /**\n     * @return {module:zrender~ZRender}\n     */\n    echartsProto.getZr = function () {\n        return this._zr;\n    };\n\n    /**\n     * Usage:\n     * chart.setOption(option, notMerge, lazyUpdate);\n     * chart.setOption(option, {\n     *     notMerge: ...,\n     *     lazyUpdate: ...,\n     *     silent: ...\n     * });\n     *\n     * @param {Object} option\n     * @param {Object|boolean} [opts] opts or notMerge.\n     * @param {boolean} [opts.notMerge=false]\n     * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.\n     */\n    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n        }\n\n        var silent;\n        if (zrUtil.isObject(notMerge)) {\n            lazyUpdate = notMerge.lazyUpdate;\n            silent = notMerge.silent;\n            notMerge = notMerge.notMerge;\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        if (!this._model || notMerge) {\n            var optionManager = new OptionManager(this._api);\n            var theme = this._theme;\n            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n            ecModel.init(null, null, theme, optionManager);\n        }\n\n        this._model.setOption(option, optionPreprocessorFuncs);\n\n        if (lazyUpdate) {\n            this[OPTION_UPDATED] = {silent: silent};\n            this[IN_MAIN_PROCESS] = false;\n        }\n        else {\n            updateMethods.prepareAndUpdate.call(this);\n            // Ensure zr refresh sychronously, and then pixel in canvas can be\n            // fetched after `setOption`.\n            this._zr.flush();\n\n            this[OPTION_UPDATED] = false;\n            this[IN_MAIN_PROCESS] = false;\n\n            flushPendingActions.call(this, silent);\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n\n    /**\n     * @DEPRECATED\n     */\n    echartsProto.setTheme = function () {\n        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n    };\n\n    /**\n     * @return {module:echarts/model/Global}\n     */\n    echartsProto.getModel = function () {\n        return this._model;\n    };\n\n    /**\n     * @return {Object}\n     */\n    echartsProto.getOption = function () {\n        return this._model && this._model.getOption();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getWidth = function () {\n        return this._zr.getWidth();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getHeight = function () {\n        return this._zr.getHeight();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getDevicePixelRatio = function () {\n        return this._zr.painter.dpr || window.devicePixelRatio || 1;\n    };\n\n    /**\n     * Get canvas which has all thing rendered\n     * @param {Object} opts\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getRenderedCanvas = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        opts = opts || {};\n        opts.pixelRatio = opts.pixelRatio || 1;\n        opts.backgroundColor = opts.backgroundColor\n            || this._model.get('backgroundColor');\n        var zr = this._zr;\n        var list = zr.storage.getDisplayList();\n        // Stop animations\n        zrUtil.each(list, function (el) {\n            el.stopAnimation(true);\n        });\n        return zr.painter.getRenderedCanvas(opts);\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     * @param {string} [opts.excludeComponents]\n     */\n    echartsProto.getDataURL = function (opts) {\n        opts = opts || {};\n        var excludeComponents = opts.excludeComponents;\n        var ecModel = this._model;\n        var excludesComponentViews = [];\n        var self = this;\n\n        each(excludeComponents, function (componentType) {\n            ecModel.eachComponent({\n                mainType: componentType\n            }, function (component) {\n                var view = self._componentsMap[component.__viewId];\n                if (!view.group.ignore) {\n                    excludesComponentViews.push(view);\n                    view.group.ignore = true;\n                }\n            });\n        });\n\n        var url = this.getRenderedCanvas(opts).toDataURL(\n            'image/' + (opts && opts.type || 'png')\n        );\n\n        each(excludesComponentViews, function (view) {\n            view.group.ignore = false;\n        });\n        return url;\n    };\n\n\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getConnectedDataURL = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        var groupId = this.group;\n        var mathMin = Math.min;\n        var mathMax = Math.max;\n        var MAX_NUMBER = Infinity;\n        if (connectedGroups[groupId]) {\n            var left = MAX_NUMBER;\n            var top = MAX_NUMBER;\n            var right = -MAX_NUMBER;\n            var bottom = -MAX_NUMBER;\n            var canvasList = [];\n            var dpr = (opts && opts.pixelRatio) || 1;\n\n            zrUtil.each(instances, function (chart, id) {\n                if (chart.group === groupId) {\n                    var canvas = chart.getRenderedCanvas(\n                        zrUtil.clone(opts)\n                    );\n                    var boundingRect = chart.getDom().getBoundingClientRect();\n                    left = mathMin(boundingRect.left, left);\n                    top = mathMin(boundingRect.top, top);\n                    right = mathMax(boundingRect.right, right);\n                    bottom = mathMax(boundingRect.bottom, bottom);\n                    canvasList.push({\n                        dom: canvas,\n                        left: boundingRect.left,\n                        top: boundingRect.top\n                    });\n                }\n            });\n\n            left *= dpr;\n            top *= dpr;\n            right *= dpr;\n            bottom *= dpr;\n            var width = right - left;\n            var height = bottom - top;\n            var targetCanvas = zrUtil.createCanvas();\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            var zr = zrender.init(targetCanvas);\n\n            each(canvasList, function (item) {\n                var img = new graphic.Image({\n                    style: {\n                        x: item.left * dpr - left,\n                        y: item.top * dpr - top,\n                        image: item.dom\n                    }\n                });\n                zr.add(img);\n            });\n            zr.refreshImmediately();\n\n            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n        }\n        else {\n            return this.getDataURL(opts);\n        }\n    };\n\n    /**\n     * Convert from logical coordinate system to pixel coordinate system.\n     * See CoordinateSystem#convertToPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId, geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');\n\n    /**\n     * Convert from pixel coordinate system to logical coordinate system.\n     * See CoordinateSystem#convertFromPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');\n\n    function doConvertPixel(methodName, finder, value) {\n        var ecModel = this._model;\n        var coordSysList = this._coordSysMgr.getCoordinateSystems();\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        for (var i = 0; i < coordSysList.length; i++) {\n            var coordSys = coordSysList[i];\n            if (coordSys[methodName]\n                && (result = coordSys[methodName](ecModel, finder, value)) != null\n            ) {\n                return result;\n            }\n        }\n\n        if (__DEV__) {\n            console.warn(\n                'No coordinate system that supports ' + methodName + ' found by the given finder.'\n            );\n        }\n    }\n\n    /**\n     * Is the specified coordinate systems or components contain the given pixel point.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {boolean} result\n     */\n    echartsProto.containPixel = function (finder, value) {\n        var ecModel = this._model;\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        zrUtil.each(finder, function (models, key) {\n            key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {\n                var coordSys = model.coordinateSystem;\n                if (coordSys && coordSys.containPoint) {\n                    result |= !!coordSys.containPoint(value);\n                }\n                else if (key === 'seriesModels') {\n                    var view = this._chartsMap[model.__viewId];\n                    if (view && view.containPoint) {\n                        result |= view.containPoint(value, model);\n                    }\n                    else {\n                        if (__DEV__) {\n                            console.warn(key + ': ' + (view\n                                ? 'The found component do not support containPoint.'\n                                : 'No view mapping to the found component.'\n                            ));\n                        }\n                    }\n                }\n                else {\n                    if (__DEV__) {\n                        console.warn(key + ': containPoint is not supported');\n                    }\n                }\n            }, this);\n        }, this);\n\n        return !!result;\n    };\n\n    /**\n     * Get visual from series or data.\n     * @param {string|Object} finder\n     *        If string, e.g., 'series', means {seriesIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            dataIndex / dataIndexInside\n     *        }\n     *        If dataIndex is not specified, series visual will be fetched,\n     *        but not data item visual.\n     *        If all of seriesIndex, seriesId, seriesName are not specified,\n     *        visual will be fetched from first series.\n     * @param {string} visualType 'color', 'symbol', 'symbolSize'\n     */\n    echartsProto.getVisual = function (finder, visualType) {\n        var ecModel = this._model;\n\n        finder = modelUtil.parseFinder(ecModel, finder, {defaultMainType: 'series'});\n\n        var seriesModel = finder.seriesModel;\n\n        if (__DEV__) {\n            if (!seriesModel) {\n                console.warn('There is no specified seires model');\n            }\n        }\n\n        var data = seriesModel.getData();\n\n        var dataIndexInside = finder.hasOwnProperty('dataIndexInside')\n            ? finder.dataIndexInside\n            : finder.hasOwnProperty('dataIndex')\n            ? data.indexOfRawIndex(finder.dataIndex)\n            : null;\n\n        return dataIndexInside != null\n            ? data.getItemVisual(dataIndexInside, visualType)\n            : data.getVisual(visualType);\n    };\n\n    /**\n     * Get view of corresponding component model\n     * @param  {module:echarts/model/Component} componentModel\n     * @return {module:echarts/view/Component}\n     */\n    echartsProto.getViewOfComponentModel = function (componentModel) {\n        return this._componentsMap[componentModel.__viewId];\n    };\n\n    /**\n     * Get view of corresponding series model\n     * @param  {module:echarts/model/Series} seriesModel\n     * @return {module:echarts/view/Chart}\n     */\n    echartsProto.getViewOfSeriesModel = function (seriesModel) {\n        return this._chartsMap[seriesModel.__viewId];\n    };\n\n\n    var updateMethods = {\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        update: function (payload) {\n            // console.profile && console.profile('update');\n\n            var ecModel = this._model;\n            var api = this._api;\n            var coordSysMgr = this._coordSysMgr;\n            var zr = this._zr;\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            // Fixme First time update ?\n            ecModel.restoreData();\n\n            // TODO\n            // Save total ecModel here for undo/redo (after restoring data and before processing data).\n            // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\n            // Create new coordinate system each update\n            // In LineView may save the old coordinate system and use it to get the orignal point\n            coordSysMgr.create(this._model, this._api);\n\n            processData.call(this, ecModel, api);\n\n            stackSeriesData.call(this, ecModel);\n\n            coordSysMgr.update(ecModel, api);\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            doRender.call(this, ecModel, payload);\n\n            // Set background\n            var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\n            var painter = zr.painter;\n            // TODO all use clearColor ?\n            if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n                zr.configLayer(0, {\n                    clearColor: backgroundColor\n                });\n            }\n            else {\n                // In IE8\n                if (!env.canvasSupported) {\n                    var colorArr = colorTool.parse(backgroundColor);\n                    backgroundColor = colorTool.stringify(colorArr, 'rgb');\n                    if (colorArr[3] === 0) {\n                        backgroundColor = 'transparent';\n                    }\n                }\n                if (backgroundColor.colorStops || backgroundColor.image) {\n                    // Gradient background\n                    // FIXME Fixed layer\n                    zr.configLayer(0, {\n                        clearColor: backgroundColor\n                    });\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\n                    this._dom.style.background = 'transparent';\n                }\n                else {\n                    if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n                        zr.configLayer(0, {\n                            clearColor: null\n                        });\n                    }\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\n                    this._dom.style.background = backgroundColor;\n                }\n            }\n\n            each(postUpdateFuncs, function (func) {\n                func(ecModel, api);\n            });\n\n            // console.profile && console.profileEnd('update');\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateView: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateVisual: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload, true);\n\n            invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateLayout: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            doLayout.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        prepareAndUpdate: function (payload) {\n            var ecModel = this._model;\n\n            prepareView.call(this, 'component', ecModel);\n\n            prepareView.call(this, 'chart', ecModel);\n\n            updateMethods.update.call(this, payload);\n        }\n    };\n\n    /**\n     * @private\n     */\n    function updateDirectly(ecIns, method, payload, mainType, subType) {\n        var ecModel = ecIns._model;\n\n        // broadcast\n        if (!mainType) {\n            each(ecIns._componentsViews.concat(ecIns._chartsViews), callView);\n            return;\n        }\n\n        var query = {};\n        query[mainType + 'Id'] = payload[mainType + 'Id'];\n        query[mainType + 'Index'] = payload[mainType + 'Index'];\n        query[mainType + 'Name'] = payload[mainType + 'Name'];\n\n        var condition = {mainType: mainType, query: query};\n        subType && (condition.subType = subType); // subType may be '' by parseClassType;\n\n        // If dispatchAction before setOption, do nothing.\n        ecModel && ecModel.eachComponent(condition, function (model, index) {\n            callView(ecIns[\n                mainType === 'series' ? '_chartsMap' : '_componentsMap'\n            ][model.__viewId]);\n        }, ecIns);\n\n        function callView(view) {\n            view && view.__alive && view[method] && view[method](\n                view.__model, ecModel, ecIns._api, payload\n            );\n        }\n    }\n\n    /**\n     * Resize the chart\n     * @param {Object} opts\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @param {boolean} [opts.silent=false]\n     */\n    echartsProto.resize = function (opts) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        this._zr.resize(opts);\n\n        var optionChanged = this._model && this._model.resetOption('media');\n        var updateMethod = optionChanged ? 'prepareAndUpdate' : 'update';\n\n        updateMethods[updateMethod].call(this);\n\n        // Resize loading effect\n        this._loadingFX && this._loadingFX.resize();\n\n        this[IN_MAIN_PROCESS] = false;\n\n        var silent = opts && opts.silent;\n\n        flushPendingActions.call(this, silent);\n\n        triggerUpdatedEvent.call(this, silent);\n    };\n\n    /**\n     * Show loading effect\n     * @param  {string} [name='default']\n     * @param  {Object} [cfg]\n     */\n    echartsProto.showLoading = function (name, cfg) {\n        if (zrUtil.isObject(name)) {\n            cfg = name;\n            name = '';\n        }\n        name = name || 'default';\n\n        this.hideLoading();\n        if (!loadingEffects[name]) {\n            if (__DEV__) {\n                console.warn('Loading effects ' + name + ' not exists.');\n            }\n            return;\n        }\n        var el = loadingEffects[name](this._api, cfg);\n        var zr = this._zr;\n        this._loadingFX = el;\n\n        zr.add(el);\n    };\n\n    /**\n     * Hide loading effect\n     */\n    echartsProto.hideLoading = function () {\n        this._loadingFX && this._zr.remove(this._loadingFX);\n        this._loadingFX = null;\n    };\n\n    /**\n     * @param {Object} eventObj\n     * @return {Object}\n     */\n    echartsProto.makeActionFromEvent = function (eventObj) {\n        var payload = zrUtil.extend({}, eventObj);\n        payload.type = eventActionMap[eventObj.type];\n        return payload;\n    };\n\n    /**\n     * @pubilc\n     * @param {Object} payload\n     * @param {string} [payload.type] Action type\n     * @param {Object|boolean} [opt] If pass boolean, means opt.silent\n     * @param {boolean} [opt.silent=false] Whether trigger events.\n     * @param {boolean} [opt.flush=undefined]\n     *                  true: Flush immediately, and then pixel in canvas can be fetched\n     *                      immediately. Caution: it might affect performance.\n     *                  false: Not not flush.\n     *                  undefined: Auto decide whether perform flush.\n     */\n    echartsProto.dispatchAction = function (payload, opt) {\n        if (!zrUtil.isObject(opt)) {\n            opt = {silent: !!opt};\n        }\n\n        if (!actions[payload.type]) {\n            return;\n        }\n\n        // Avoid dispatch action before setOption. Especially in `connect`.\n        if (!this._model) {\n            return;\n        }\n\n        // May dispatchAction in rendering procedure\n        if (this[IN_MAIN_PROCESS]) {\n            this._pendingActions.push(payload);\n            return;\n        }\n\n        doDispatchAction.call(this, payload, opt.silent);\n\n        if (opt.flush) {\n            this._zr.flush(true);\n        }\n        else if (opt.flush !== false && env.browser.weChat) {\n            // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`\n            // hang when sliding page (on touch event), which cause that zr does not\n            // refresh util user interaction finished, which is not expected.\n            // But `dispatchAction` may be called too frequently when pan on touch\n            // screen, which impacts performance if do not throttle them.\n            this._throttledZrFlush();\n        }\n\n        flushPendingActions.call(this, opt.silent);\n\n        triggerUpdatedEvent.call(this, opt.silent);\n    };\n\n    function doDispatchAction(payload, silent) {\n        var payloadType = payload.type;\n        var escapeConnect = payload.escapeConnect;\n        var actionWrap = actions[payloadType];\n        var actionInfo = actionWrap.actionInfo;\n\n        var cptType = (actionInfo.update || 'update').split(':');\n        var updateMethod = cptType.pop();\n        cptType = cptType[0] != null && parseClassType(cptType[0]);\n\n        this[IN_MAIN_PROCESS] = true;\n\n        var payloads = [payload];\n        var batched = false;\n        // Batch action\n        if (payload.batch) {\n            batched = true;\n            payloads = zrUtil.map(payload.batch, function (item) {\n                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n                item.batch = null;\n                return item;\n            });\n        }\n\n        var eventObjBatch = [];\n        var eventObj;\n        var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';\n\n        each(payloads, function (batchItem) {\n            // Action can specify the event by return it.\n            eventObj = actionWrap.action(batchItem, this._model, this._api);\n            // Emit event outside\n            eventObj = eventObj || zrUtil.extend({}, batchItem);\n            // Convert type to eventType\n            eventObj.type = actionInfo.event || eventObj.type;\n            eventObjBatch.push(eventObj);\n\n            // light update does not perform data process, layout and visual.\n            if (isHighDown) {\n                // method, payload, mainType, subType\n                updateDirectly(this, updateMethod, batchItem, 'series');\n            }\n            else if (cptType) {\n                updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);\n            }\n        }, this);\n\n        if (updateMethod !== 'none' && !isHighDown && !cptType) {\n            // Still dirty\n            if (this[OPTION_UPDATED]) {\n                // FIXME Pass payload ?\n                updateMethods.prepareAndUpdate.call(this, payload);\n                this[OPTION_UPDATED] = false;\n            }\n            else {\n                updateMethods[updateMethod].call(this, payload);\n            }\n        }\n\n        // Follow the rule of action batch\n        if (batched) {\n            eventObj = {\n                type: actionInfo.event || payloadType,\n                escapeConnect: escapeConnect,\n                batch: eventObjBatch\n            };\n        }\n        else {\n            eventObj = eventObjBatch[0];\n        }\n\n        this[IN_MAIN_PROCESS] = false;\n\n        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n    }\n\n    function flushPendingActions(silent) {\n        var pendingActions = this._pendingActions;\n        while (pendingActions.length) {\n            var payload = pendingActions.shift();\n            doDispatchAction.call(this, payload, silent);\n        }\n    }\n\n    function triggerUpdatedEvent(silent) {\n        !silent && this.trigger('updated');\n    }\n\n    /**\n     * Register event\n     * @method\n     */\n    echartsProto.on = createRegisterEventWithLowercaseName('on');\n    echartsProto.off = createRegisterEventWithLowercaseName('off');\n    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\n    /**\n     * @param {string} methodName\n     * @private\n     */\n    function invokeUpdateMethod(methodName, ecModel, payload) {\n        var api = this._api;\n\n        // Update all components\n        each(this._componentsViews, function (component) {\n            var componentModel = component.__model;\n            component[methodName](componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, component);\n        }, this);\n\n        // Upate all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chart = this._chartsMap[seriesModel.__viewId];\n            chart[methodName](seriesModel, ecModel, api, payload);\n\n            updateZ(seriesModel, chart);\n\n            updateProgressiveAndBlend(seriesModel, chart);\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Post render\n        each(postUpdateFuncs, function (func) {\n            func(ecModel, api);\n        });\n    }\n\n    /**\n     * Prepare view instances of charts and components\n     * @param  {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function prepareView(type, ecModel) {\n        var isComponent = type === 'component';\n        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n        var zr = this._zr;\n\n        for (var i = 0; i < viewList.length; i++) {\n            viewList[i].__alive = false;\n        }\n\n        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n            if (isComponent) {\n                if (componentType === 'series') {\n                    return;\n                }\n            }\n            else {\n                model = componentType;\n            }\n\n            // Consider: id same and type changed.\n            var viewId = '_ec_' + model.id + '_' + model.type;\n            var view = viewMap[viewId];\n            if (!view) {\n                var classType = parseClassType(model.type);\n                var Clazz = isComponent\n                    ? ComponentView.getClass(classType.main, classType.sub)\n                    : ChartView.getClass(classType.sub);\n                if (Clazz) {\n                    view = new Clazz();\n                    view.init(ecModel, this._api);\n                    viewMap[viewId] = view;\n                    viewList.push(view);\n                    zr.add(view.group);\n                }\n                else {\n                    // Error\n                    return;\n                }\n            }\n\n            model.__viewId = view.__id = viewId;\n            view.__alive = true;\n            view.__model = model;\n            view.group.__ecComponentInfo = {\n                mainType: model.mainType,\n                index: model.componentIndex\n            };\n        }, this);\n\n        for (var i = 0; i < viewList.length;) {\n            var view = viewList[i];\n            if (!view.__alive) {\n                zr.remove(view.group);\n                view.dispose(ecModel, this._api);\n                viewList.splice(i, 1);\n                delete viewMap[view.__id];\n                view.__id = view.group.__ecComponentInfo = null;\n            }\n            else {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * Processor data in each series\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function processData(ecModel, api) {\n        each(dataProcessorFuncs, function (process) {\n            process.func(ecModel, api);\n        });\n    }\n\n    /**\n     * @private\n     */\n    function stackSeriesData(ecModel) {\n        var stackedDataMap = {};\n        ecModel.eachSeries(function (series) {\n            var stack = series.get('stack');\n            var data = series.getData();\n            if (stack && data.type === 'list') {\n                var previousStack = stackedDataMap[stack];\n                // Avoid conflict with Object.prototype\n                if (stackedDataMap.hasOwnProperty(stack) && previousStack) {\n                    data.stackedOn = previousStack;\n                }\n                stackedDataMap[stack] = data;\n            }\n        });\n    }\n\n    /**\n     * Layout before each chart render there series, special visual encoding stage\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doLayout(ecModel, payload) {\n        var api = this._api;\n        each(visualFuncs, function (visual) {\n            if (visual.isLayout) {\n                visual.func(ecModel, api, payload);\n            }\n        });\n    }\n\n    /**\n     * Encode visual infomation from data after data processing\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @param {object} layout\n     * @param {boolean} [excludesLayout]\n     * @private\n     */\n    function doVisualEncoding(ecModel, payload, excludesLayout) {\n        var api = this._api;\n        ecModel.clearColorPalette();\n        ecModel.eachSeries(function (seriesModel) {\n            seriesModel.clearColorPalette();\n        });\n        each(visualFuncs, function (visual) {\n            (!excludesLayout || !visual.isLayout)\n                && visual.func(ecModel, api, payload);\n        });\n    }\n\n    /**\n     * Render each chart and component\n     * @private\n     */\n    function doRender(ecModel, payload) {\n        var api = this._api;\n        // Render all components\n        each(this._componentsViews, function (componentView) {\n            var componentModel = componentView.__model;\n            componentView.render(componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, componentView);\n        }, this);\n\n        each(this._chartsViews, function (chart) {\n            chart.__alive = false;\n        }, this);\n\n        // Render all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            chartView.__alive = true;\n            chartView.render(seriesModel, ecModel, api, payload);\n\n            chartView.group.silent = !!seriesModel.get('silent');\n\n            updateZ(seriesModel, chartView);\n\n            updateProgressiveAndBlend(seriesModel, chartView);\n\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Remove groups of unrendered charts\n        each(this._chartsViews, function (chart) {\n            if (!chart.__alive) {\n                chart.remove(ecModel, api);\n            }\n        }, this);\n    }\n\n    var MOUSE_EVENT_NAMES = [\n        'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove',\n        'mousedown', 'mouseup', 'globalout', 'contextmenu'\n    ];\n    /**\n     * @private\n     */\n    echartsProto._initEvents = function () {\n        each(MOUSE_EVENT_NAMES, function (eveName) {\n            this._zr.on(eveName, function (e) {\n                var ecModel = this.getModel();\n                var el = e.target;\n                var params;\n\n                // no e.target when 'globalout'.\n                if (eveName === 'globalout') {\n                    params = {};\n                }\n                else if (el && el.dataIndex != null) {\n                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                    params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n                }\n                // If element has custom eventData of components\n                else if (el && el.eventData) {\n                    params = zrUtil.extend({}, el.eventData);\n                }\n\n                if (params) {\n                    params.event = e;\n                    params.type = eveName;\n                    this.trigger(eveName, params);\n                }\n\n            }, this);\n        }, this);\n\n        each(eventActionMap, function (actionType, eventType) {\n            this._messageCenter.on(eventType, function (event) {\n                this.trigger(eventType, event);\n            }, this);\n        }, this);\n    };\n\n    /**\n     * @return {boolean}\n     */\n    echartsProto.isDisposed = function () {\n        return this._disposed;\n    };\n\n    /**\n     * Clear\n     */\n    echartsProto.clear = function () {\n        this.setOption({ series: [] }, true);\n    };\n\n    /**\n     * Dispose instance\n     */\n    echartsProto.dispose = function () {\n        if (this._disposed) {\n            if (__DEV__) {\n                console.warn('Instance ' + this.id + ' has been disposed');\n            }\n            return;\n        }\n        this._disposed = true;\n\n        var api = this._api;\n        var ecModel = this._model;\n\n        each(this._componentsViews, function (component) {\n            component.dispose(ecModel, api);\n        });\n        each(this._chartsViews, function (chart) {\n            chart.dispose(ecModel, api);\n        });\n\n        // Dispose after all views disposed\n        this._zr.dispose();\n\n        delete instances[this.id];\n    };\n\n    zrUtil.mixin(ECharts, Eventful);\n\n    function updateHoverLayerStatus(zr, ecModel) {\n        var storage = zr.storage;\n        var elCount = 0;\n        storage.traverse(function (el) {\n            if (!el.isGroup) {\n                elCount++;\n            }\n        });\n        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n            storage.traverse(function (el) {\n                if (!el.isGroup) {\n                    el.useHoverLayer = true;\n                }\n            });\n        }\n    }\n\n    /**\n     * Update chart progressive and blend.\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateProgressiveAndBlend(seriesModel, chartView) {\n        // Progressive configuration\n        var elCount = 0;\n        chartView.group.traverse(function (el) {\n            if (el.type !== 'group' && !el.ignore) {\n                elCount++;\n            }\n        });\n        var frameDrawNum = +seriesModel.get('progressive');\n        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n        if (needProgressive) {\n            chartView.group.traverse(function (el) {\n                // FIXME marker and other components\n                if (!el.isGroup) {\n                    el.progressive = needProgressive ?\n                        Math.floor(elCount++ / frameDrawNum) : -1;\n                    if (needProgressive) {\n                        el.stopAnimation(true);\n                    }\n                }\n            });\n        }\n\n        // Blend configration\n        var blendMode = seriesModel.get('blendMode') || null;\n        if (__DEV__) {\n            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n                console.warn('Only canvas support blendMode');\n            }\n        }\n        chartView.group.traverse(function (el) {\n            // FIXME marker and other components\n            if (!el.isGroup) {\n                el.setStyle('blend', blendMode);\n            }\n        });\n    }\n\n    /**\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateZ(model, view) {\n        var z = model.get('z');\n        var zlevel = model.get('zlevel');\n        // Set z and zlevel\n        view.group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n            }\n        });\n    }\n\n    function createExtensionAPI(ecInstance) {\n        var coordSysMgr = ecInstance._coordSysMgr;\n        return zrUtil.extend(new ExtensionAPI(ecInstance), {\n            // Inject methods\n            getCoordinateSystems: zrUtil.bind(\n                coordSysMgr.getCoordinateSystems, coordSysMgr\n            ),\n            getComponentByElement: function (el) {\n                while (el) {\n                    var modelInfo = el.__ecComponentInfo;\n                    if (modelInfo != null) {\n                        return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index);\n                    }\n                    el = el.parent;\n                }\n            }\n        });\n    }\n\n    /**\n     * @type {Object} key: actionType.\n     * @inner\n     */\n    var actions = {};\n\n    /**\n     * Map eventType to actionType\n     * @type {Object}\n     */\n    var eventActionMap = {};\n\n    /**\n     * Data processor functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var dataProcessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var optionPreprocessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var postUpdateFuncs = [];\n\n    /**\n     * Visual encoding functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var visualFuncs = [];\n    /**\n     * Theme storage\n     * @type {Object.<key, Object>}\n     */\n    var themeStorage = {};\n    /**\n     * Loading effects\n     */\n    var loadingEffects = {};\n\n\n    var instances = {};\n    var connectedGroups = {};\n\n    var idBase = new Date() - 0;\n    var groupIdBase = new Date() - 0;\n    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n\n    /**\n     * @alias module:echarts\n     */\n    var echarts = {\n        /**\n         * @type {number}\n         */\n        version: '3.7.2',\n        dependencies: {\n            zrender: '3.6.2'\n        }\n    };\n\n    function enableConnect(chart) {\n        var STATUS_PENDING = 0;\n        var STATUS_UPDATING = 1;\n        var STATUS_UPDATED = 2;\n        var STATUS_KEY = '__connectUpdateStatus';\n\n        function updateConnectedChartsStatus(charts, status) {\n            for (var i = 0; i < charts.length; i++) {\n                var otherChart = charts[i];\n                otherChart[STATUS_KEY] = status;\n            }\n        }\n\n        zrUtil.each(eventActionMap, function (actionType, eventType) {\n            chart._messageCenter.on(eventType, function (event) {\n                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n                    if (event && event.escapeConnect) {\n                        return;\n                    }\n\n                    var action = chart.makeActionFromEvent(event);\n                    var otherCharts = [];\n\n                    zrUtil.each(instances, function (otherChart) {\n                        if (otherChart !== chart && otherChart.group === chart.group) {\n                            otherCharts.push(otherChart);\n                        }\n                    });\n\n                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n                    each(otherCharts, function (otherChart) {\n                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n                            otherChart.dispatchAction(action);\n                        }\n                    });\n                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n                }\n            });\n        });\n    }\n\n    /**\n     * @param {HTMLElement} dom\n     * @param {Object} [theme]\n     * @param {Object} opts\n     * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n     * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n     * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n     *                              Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n     *                               Can be 'auto' (the same as null/undefined)\n     */\n    echarts.init = function (dom, theme, opts) {\n        if (__DEV__) {\n            // Check version\n            if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) {\n                throw new Error(\n                    'ZRender ' + zrender.version\n                    + ' is too old for ECharts ' + echarts.version\n                    + '. Current version need ZRender '\n                    + echarts.dependencies.zrender + '+'\n                );\n            }\n\n            if (!dom) {\n                throw new Error('Initialize failed: invalid dom.');\n            }\n        }\n\n        var existInstance = echarts.getInstanceByDom(dom);\n        if (existInstance) {\n            if (__DEV__) {\n                console.warn('There is a chart instance already initialized on the dom.');\n            }\n            return existInstance;\n        }\n\n        if (__DEV__) {\n            if (zrUtil.isDom(dom)\n                && dom.nodeName.toUpperCase() !== 'CANVAS'\n                && (\n                    (!dom.clientWidth && (!opts || opts.width == null))\n                    || (!dom.clientHeight && (!opts || opts.height == null))\n                )\n            ) {\n                console.warn('Can\\'t get dom width or height');\n            }\n        }\n\n        var chart = new ECharts(dom, theme, opts);\n        chart.id = 'ec_' + idBase++;\n        instances[chart.id] = chart;\n\n        if (dom.setAttribute) {\n            dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n        }\n        else {\n            dom[DOM_ATTRIBUTE_KEY] = chart.id;\n        }\n\n        enableConnect(chart);\n\n        return chart;\n    };\n\n    /**\n     * @return {string|Array.<module:echarts~ECharts>} groupId\n     */\n    echarts.connect = function (groupId) {\n        // Is array of charts\n        if (zrUtil.isArray(groupId)) {\n            var charts = groupId;\n            groupId = null;\n            // If any chart has group\n            zrUtil.each(charts, function (chart) {\n                if (chart.group != null) {\n                    groupId = chart.group;\n                }\n            });\n            groupId = groupId || ('g_' + groupIdBase++);\n            zrUtil.each(charts, function (chart) {\n                chart.group = groupId;\n            });\n        }\n        connectedGroups[groupId] = true;\n        return groupId;\n    };\n\n    /**\n     * @DEPRECATED\n     * @return {string} groupId\n     */\n    echarts.disConnect = function (groupId) {\n        connectedGroups[groupId] = false;\n    };\n\n    /**\n     * @return {string} groupId\n     */\n    echarts.disconnect = echarts.disConnect;\n\n    /**\n     * Dispose a chart instance\n     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n     */\n    echarts.dispose = function (chart) {\n        if (typeof chart === 'string') {\n            chart = instances[chart];\n        }\n        else if (!(chart instanceof ECharts)){\n            // Try to treat as dom\n            chart = echarts.getInstanceByDom(chart);\n        }\n        if ((chart instanceof ECharts) && !chart.isDisposed()) {\n            chart.dispose();\n        }\n    };\n\n    /**\n     * @param  {HTMLElement} dom\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceByDom = function (dom) {\n        var key;\n        if (dom.getAttribute) {\n            key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n        }\n        else {\n            key = dom[DOM_ATTRIBUTE_KEY];\n        }\n        return instances[key];\n    };\n\n    /**\n     * @param {string} key\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceById = function (key) {\n        return instances[key];\n    };\n\n    /**\n     * Register theme\n     */\n    echarts.registerTheme = function (name, theme) {\n        themeStorage[name] = theme;\n    };\n\n    /**\n     * Register option preprocessor\n     * @param {Function} preprocessorFunc\n     */\n    echarts.registerPreprocessor = function (preprocessorFunc) {\n        optionPreprocessorFuncs.push(preprocessorFunc);\n    };\n\n    /**\n     * @param {number} [priority=1000]\n     * @param {Function} processorFunc\n     */\n    echarts.registerProcessor = function (priority, processorFunc) {\n        if (typeof priority === 'function') {\n            processorFunc = priority;\n            priority = PRIORITY_PROCESSOR_FILTER;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown processor priority');\n            }\n        }\n        dataProcessorFuncs.push({\n            prio: priority,\n            func: processorFunc\n        });\n    };\n\n    /**\n     * Register postUpdater\n     * @param {Function} postUpdateFunc\n     */\n    echarts.registerPostUpdate = function (postUpdateFunc) {\n        postUpdateFuncs.push(postUpdateFunc);\n    };\n\n    /**\n     * Usage:\n     * registerAction('someAction', 'someEvent', function () { ... });\n     * registerAction('someAction', function () { ... });\n     * registerAction(\n     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n     *     function () { ... }\n     * );\n     *\n     * @param {(string|Object)} actionInfo\n     * @param {string} actionInfo.type\n     * @param {string} [actionInfo.event]\n     * @param {string} [actionInfo.update]\n     * @param {string} [eventName]\n     * @param {Function} action\n     */\n    echarts.registerAction = function (actionInfo, eventName, action) {\n        if (typeof eventName === 'function') {\n            action = eventName;\n            eventName = '';\n        }\n        var actionType = zrUtil.isObject(actionInfo)\n            ? actionInfo.type\n            : ([actionInfo, actionInfo = {\n                event: eventName\n            }][0]);\n\n        // Event name is all lowercase\n        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n        eventName = actionInfo.event;\n\n        // Validate action type and event name.\n        zrUtil.assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));\n\n        if (!actions[actionType]) {\n            actions[actionType] = {action: action, actionInfo: actionInfo};\n        }\n        eventActionMap[eventName] = actionType;\n    };\n\n    /**\n     * @param {string} type\n     * @param {*} CoordinateSystem\n     */\n    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n        CoordinateSystemManager.register(type, CoordinateSystem);\n    };\n\n    /**\n     * Get dimensions of specified coordinate system.\n     * @param {string} type\n     * @return {Array.<string|Object>}\n     */\n    echarts.getCoordinateSystemDimensions = function (type) {\n        var coordSysCreator = CoordinateSystemManager.get(type);\n        if (coordSysCreator) {\n            return coordSysCreator.getDimensionsInfo\n                    ? coordSysCreator.getDimensionsInfo()\n                    : coordSysCreator.dimensions.slice();\n        }\n    };\n\n    /**\n     * Layout is a special stage of visual encoding\n     * Most visual encoding like color are common for different chart\n     * But each chart has it's own layout algorithm\n     *\n     * @param {number} [priority=1000]\n     * @param {Function} layoutFunc\n     */\n    echarts.registerLayout = function (priority, layoutFunc) {\n        if (typeof priority === 'function') {\n            layoutFunc = priority;\n            priority = PRIORITY_VISUAL_LAYOUT;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown layout priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: layoutFunc,\n            isLayout: true\n        });\n    };\n\n    /**\n     * @param {number} [priority=3000]\n     * @param {Function} visualFunc\n     */\n    echarts.registerVisual = function (priority, visualFunc) {\n        if (typeof priority === 'function') {\n            visualFunc = priority;\n            priority = PRIORITY_VISUAL_CHART;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown visual priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: visualFunc\n        });\n    };\n\n    /**\n     * @param {string} name\n     */\n    echarts.registerLoading = function (name, loadingFx) {\n        loadingEffects[name] = loadingFx;\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentModel = function (opts/*, superClass*/) {\n        // var Clazz = ComponentModel;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentView = function (opts/*, superClass*/) {\n        // var Clazz = ComponentView;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentView.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendSeriesModel = function (opts/*, superClass*/) {\n        // var Clazz = SeriesModel;\n        // if (superClass) {\n        //     superClass = 'series.' + superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return SeriesModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendChartView = function (opts/*, superClass*/) {\n        // var Clazz = ChartView;\n        // if (superClass) {\n        //     superClass = superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ChartView.getClass(classType.main, true);\n        // }\n        return ChartView.extend(opts);\n    };\n\n    /**\n     * ZRender need a canvas context to do measureText.\n     * But in node environment canvas may be created by node-canvas.\n     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n     *\n     * Be careful of using it in the browser.\n     *\n     * @param {Function} creator\n     * @example\n     *     var Canvas = require('canvas');\n     *     var echarts = require('echarts');\n     *     echarts.setCanvasCreator(function () {\n     *         // Small size is enough.\n     *         return new Canvas(32, 32);\n     *     });\n     */\n    echarts.setCanvasCreator = function (creator) {\n        zrUtil.createCanvas = creator;\n    };\n\n    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, __webpack_require__(1119));\n    echarts.registerPreprocessor(backwardCompat);\n    echarts.registerLoading('default', __webpack_require__(1120));\n\n    // Default action\n    echarts.registerAction({\n        type: 'highlight',\n        event: 'highlight',\n        update: 'highlight'\n    }, zrUtil.noop);\n    echarts.registerAction({\n        type: 'downplay',\n        event: 'downplay',\n        update: 'downplay'\n    }, zrUtil.noop);\n\n    // --------\n    // Exports\n    // --------\n    echarts.zrender = zrender;\n\n    echarts.List = __webpack_require__(987);\n    echarts.Model = __webpack_require__(979);\n\n    echarts.Axis = __webpack_require__(1007);\n\n    echarts.graphic = __webpack_require__(973);\n    echarts.number = __webpack_require__(974);\n    echarts.format = __webpack_require__(977);\n    echarts.throttle = throttle.throttle;\n    echarts.matrix = __webpack_require__(986);\n    echarts.vector = __webpack_require__(976);\n    echarts.color = __webpack_require__(993);\n\n    echarts.util = {};\n    each([\n            'map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter',\n            'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction',\n            'extend', 'defaults', 'clone', 'merge'\n        ],\n        function (name) {\n            echarts.util[name] = zrUtil[name];\n        }\n    );\n\n    echarts.helper = __webpack_require__(1124);\n\n\n    // PRIORITY\n    echarts.PRIORITY = {\n        PROCESSOR: {\n            FILTER: PRIORITY_PROCESSOR_FILTER,\n            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n        },\n        VISUAL: {\n            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n            CHART: PRIORITY_VISUAL_CHART,\n            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n            BRUSH: PRIORITY_VISUAL_BRUSH\n        }\n    };\n\n    module.exports = echarts;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24)))\n\n/***/ }),\n\n/***/ 973:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(971);\n\n    var pathTool = __webpack_require__(1083);\n    var Path = __webpack_require__(980);\n    var colorTool = __webpack_require__(993);\n    var matrix = __webpack_require__(986);\n    var vector = __webpack_require__(976);\n    var Transformable = __webpack_require__(1024);\n    var BoundingRect = __webpack_require__(982);\n\n    var round = Math.round;\n    var mathMax = Math.max;\n    var mathMin = Math.min;\n\n    var EMPTY_OBJ = {};\n\n    var graphic = {};\n\n    graphic.Group = __webpack_require__(1001);\n\n    graphic.Image = __webpack_require__(1027);\n\n    graphic.Text = __webpack_require__(1063);\n\n    graphic.Circle = __webpack_require__(1091);\n\n    graphic.Sector = __webpack_require__(1092);\n\n    graphic.Ring = __webpack_require__(1093);\n\n    graphic.Polygon = __webpack_require__(1094);\n\n    graphic.Polyline = __webpack_require__(1097);\n\n    graphic.Rect = __webpack_require__(1098);\n\n    graphic.Line = __webpack_require__(1099);\n\n    graphic.BezierCurve = __webpack_require__(1100);\n\n    graphic.Arc = __webpack_require__(1101);\n\n    graphic.CompoundPath = __webpack_require__(1102);\n\n    graphic.LinearGradient = __webpack_require__(1064);\n\n    graphic.RadialGradient = __webpack_require__(1103);\n\n    graphic.BoundingRect = BoundingRect;\n\n    /**\n     * Extend shape with parameters\n     */\n    graphic.extendShape = function (opts) {\n        return Path.extend(opts);\n    };\n\n    /**\n     * Extend path\n     */\n    graphic.extendPath = function (pathData, opts) {\n        return pathTool.extendFromString(pathData, opts);\n    };\n\n    /**\n     * Create a path element from path data string\n     * @param {string} pathData\n     * @param {Object} opts\n     * @param {module:zrender/core/BoundingRect} rect\n     * @param {string} [layout=cover] 'center' or 'cover'\n     */\n    graphic.makePath = function (pathData, opts, rect, layout) {\n        var path = pathTool.createFromString(pathData, opts);\n        var boundingRect = path.getBoundingRect();\n        if (rect) {\n            var aspect = boundingRect.width / boundingRect.height;\n\n            if (layout === 'center') {\n                // Set rect to center, keep width / height ratio.\n                var width = rect.height * aspect;\n                var height;\n                if (width <= rect.width) {\n                    height = rect.height;\n                }\n                else {\n                    width = rect.width;\n                    height = width / aspect;\n                }\n                var cx = rect.x + rect.width / 2;\n                var cy = rect.y + rect.height / 2;\n\n                rect.x = cx - width / 2;\n                rect.y = cy - height / 2;\n                rect.width = width;\n                rect.height = height;\n            }\n\n            graphic.resizePath(path, rect);\n        }\n        return path;\n    };\n\n    graphic.mergePath = pathTool.mergePath,\n\n    /**\n     * Resize a path to fit the rect\n     * @param {module:zrender/graphic/Path} path\n     * @param {Object} rect\n     */\n    graphic.resizePath = function (path, rect) {\n        if (!path.applyTransform) {\n            return;\n        }\n\n        var pathRect = path.getBoundingRect();\n\n        var m = pathRect.calculateTransform(rect);\n\n        path.applyTransform(m);\n    };\n\n    /**\n     * Sub pixel optimize line for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x1]\n     * @param {number} [param.shape.y1]\n     * @param {number} [param.shape.x2]\n     * @param {number} [param.shape.y2]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeLine = function (param) {\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n        }\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n        }\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize rect for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x]\n     * @param {number} [param.shape.y]\n     * @param {number} [param.shape.width]\n     * @param {number} [param.shape.height]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeRect = function (param) {\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        var originX = shape.x;\n        var originY = shape.y;\n        var originWidth = shape.width;\n        var originHeight = shape.height;\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n        shape.width = Math.max(\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\n            originWidth === 0 ? 0 : 1\n        );\n        shape.height = Math.max(\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\n            originHeight === 0 ? 0 : 1\n        );\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize for canvas\n     *\n     * @param {number} position Coordinate, such as x, y\n     * @param {number} lineWidth Should be nonnegative integer.\n     * @param {boolean=} positiveOrNegative Default false (negative).\n     * @return {number} Optimized position.\n     */\n    var subPixelOptimize = graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n        // Assure that (position + lineWidth / 2) is near integer edge,\n        // otherwise line will be fuzzy in canvas.\n        var doubledPosition = round(position * 2);\n        return (doubledPosition + round(lineWidth)) % 2 === 0\n            ? doubledPosition / 2\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n    };\n\n    function hasFillOrStroke(fillOrStroke) {\n        return fillOrStroke != null && fillOrStroke != 'none';\n    }\n\n    function liftColor(color) {\n        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n    }\n\n    /**\n     * @private\n     */\n    function cacheElementStl(el) {\n        if (el.__hoverStlDirty) {\n            var stroke = el.style.stroke;\n            var fill = el.style.fill;\n\n            // Create hoverStyle on mouseover\n            var hoverStyle = el.__hoverStl;\n            hoverStyle.fill = hoverStyle.fill\n                || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n            hoverStyle.stroke = hoverStyle.stroke\n                || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\n            var normalStyle = {};\n            for (var name in hoverStyle) {\n                // See comment in `doSingleEnterHover`.\n                if (hoverStyle[name] != null) {\n                    normalStyle[name] = el.style[name];\n                }\n            }\n\n            el.__normalStl = normalStyle;\n\n            el.__hoverStlDirty = false;\n        }\n    }\n\n    /**\n     * @private\n     */\n    function doSingleEnterHover(el) {\n        if (el.__isHover) {\n            return;\n        }\n\n        cacheElementStl(el);\n\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n        }\n        else {\n            var style = el.style;\n            var insideRollbackOpt = style.insideRollbackOpt;\n\n            // Consider case: only `position: 'top'` is set on emphasis, then text\n            // color should be returned to `autoColor`, rather than remain '#fff'.\n            // So we should rollback then apply again after style merging.\n            insideRollbackOpt && rollbackInsideStyle(style);\n\n            // styles can be:\n            // {\n            //     label: {\n            //         normal: {\n            //             show: false,\n            //             position: 'outside',\n            //             fontSize: 18\n            //         },\n            //         emphasis: {\n            //             show: true\n            //         }\n            //     }\n            // },\n            // where properties of `emphasis` may not appear in `normal`. We previously use\n            // module:echarts/util/model#defaultEmphasis to merge `normal` to `emphasis`.\n            // But consider rich text and setOption in merge mode, it is impossible to cover\n            // all properties in merge. So we use merge mode when setting style here, where\n            // only properties that is not `null/undefined` can be set. The disadventage:\n            // null/undefined can not be used to remove style any more in `emphasis`.\n            style.extendFrom(el.__hoverStl);\n\n            // Do not save `insideRollback`.\n            if (insideRollbackOpt) {\n                applyInsideStyle(style, style.insideOriginalTextPosition, insideRollbackOpt);\n\n                // textFill may be rollbacked to null.\n                if (style.textFill == null) {\n                    style.textFill = insideRollbackOpt.autoColor;\n                }\n            }\n\n            el.dirty(false);\n            el.z2 += 1;\n        }\n\n        el.__isHover = true;\n    }\n\n    /**\n     * @inner\n     */\n    function doSingleLeaveHover(el) {\n        if (!el.__isHover) {\n            return;\n        }\n\n        var normalStl = el.__normalStl;\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.removeHover(el);\n        }\n        else {\n            // Consider null/undefined value, should use\n            // `setStyle` but not `extendFrom(stl, true)`.\n            normalStl && el.setStyle(normalStl);\n            el.z2 -= 1;\n        }\n\n        el.__isHover = false;\n    }\n\n    /**\n     * @inner\n     */\n    function doEnterHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleEnterHover(child);\n                }\n            })\n            : doSingleEnterHover(el);\n    }\n\n    function doLeaveHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleLeaveHover(child);\n                }\n            })\n            : doSingleLeaveHover(el);\n    }\n\n    /**\n     * @inner\n     */\n    function setElementHoverStl(el, hoverStl) {\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n        // Often used when item group has a label element and it's hoverStyle is different\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\n        el.__hoverStlDirty = true;\n\n        if (el.__isHover) {\n            cacheElementStl(el);\n        }\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOver(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOut(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doLeaveHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function enterEmphasis() {\n        this.__isEmphasis = true;\n        doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function leaveEmphasis() {\n        this.__isEmphasis = false;\n        doLeaveHover(this);\n    }\n\n    /**\n     * Set hover style of element.\n     * This method can be called repeatly without side-effects.\n     * @param {module:zrender/Element} el\n     * @param {Object} [hoverStyle]\n     * @param {Object} [opt]\n     * @param {boolean} [opt.hoverSilentOnTouch=false]\n     *        In touch device, mouseover event will be trigger on touchstart event\n     *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can\n     *        conviniently use hoverStyle when tap on touch screen without additional\n     *        code for compatibility.\n     *        But if the chart/component has select feature, which usually also use\n     *        hoverStyle, there might be conflict between 'select-highlight' and\n     *        'hover-highlight' especially when roam is enabled (see geo for example).\n     *        In this case, hoverSilentOnTouch should be used to disable hover-highlight\n     *        on touch device.\n     */\n    graphic.setHoverStyle = function (el, hoverStyle, opt) {\n        el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;\n\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    setElementHoverStl(child, hoverStyle);\n                }\n            })\n            : setElementHoverStl(el, hoverStyle);\n\n        // Duplicated function will be auto-ignored, see Eventful.js.\n        el.on('mouseover', onElementMouseOver)\n          .on('mouseout', onElementMouseOut);\n\n        // Emphasis, normal can be triggered manually\n        el.on('emphasis', enterEmphasis)\n          .on('normal', leaveEmphasis);\n    };\n\n    /**\n     * @param {Object|module:zrender/graphic/Style} normalStyle\n     * @param {Object} emphasisStyle\n     * @param {module:echarts/model/Model} normalModel\n     * @param {module:echarts/model/Model} emphasisModel\n     * @param {Object} opt Check `opt` of `setTextStyleCommon` to find other props.\n     * @param {Object} [opt.defaultText]\n     * @param {module:echarts/model/Model} [opt.labelFetcher] Fetch text by\n     *      `opt.labelFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`\n     * @param {module:echarts/model/Model} [opt.labelDataIndex] Fetch text by\n     *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`\n     * @param {module:echarts/model/Model} [opt.labelDimIndex] Fetch text by\n     *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`\n     * @param {Object} [normalSpecified]\n     * @param {Object} [emphasisSpecified]\n     */\n    graphic.setLabelStyle = function (\n        normalStyle, emphasisStyle,\n        normalModel, emphasisModel,\n        opt,\n        normalSpecified, emphasisSpecified\n    ) {\n        opt = opt || EMPTY_OBJ;\n        var labelFetcher = opt.labelFetcher;\n        var labelDataIndex = opt.labelDataIndex;\n        var labelDimIndex = opt.labelDimIndex;\n\n        // This scenario, `label.normal.show = true; label.emphasis.show = false`,\n        // is not supported util someone requests.\n\n        var showNormal = normalModel.getShallow('show');\n        var showEmphasis = emphasisModel.getShallow('show');\n\n        // Consider performance, only fetch label when necessary.\n        // If `normal.show` is `false` and `emphasis.show` is `true` and `emphasis.formatter` is not set,\n        // label should be displayed, where text is fetched by `normal.formatter` or `opt.defaultText`.\n        var baseText = (showNormal || showEmphasis)\n            ? zrUtil.retrieve2(\n                labelFetcher\n                    ? labelFetcher.getFormattedLabel(labelDataIndex, 'normal', null, labelDimIndex)\n                    : null,\n                opt.defaultText\n            )\n            : null;\n        var normalStyleText = showNormal ? baseText : null;\n        var emphasisStyleText = showEmphasis\n            ? zrUtil.retrieve2(\n                labelFetcher\n                    ? labelFetcher.getFormattedLabel(labelDataIndex, 'emphasis', null, labelDimIndex)\n                    : null,\n                baseText\n            )\n            : null;\n\n        // Optimize: If style.text is null, text will not be drawn.\n        if (normalStyleText != null || emphasisStyleText != null) {\n            // Always set `textStyle` even if `normalStyle.text` is null, because default\n            // values have to be set on `normalStyle`.\n            // If we set default values on `emphasisStyle`, consider case:\n            // Firstly, `setOption(... label: {normal: {text: null}, emphasis: {show: true}} ...);`\n            // Secondly, `setOption(... label: {noraml: {show: true, text: 'abc', color: 'red'} ...);`\n            // Then the 'red' will not work on emphasis.\n            setTextStyle(normalStyle, normalModel, normalSpecified, opt);\n            setTextStyle(emphasisStyle, emphasisModel, emphasisSpecified, opt, true);\n        }\n\n        normalStyle.text = normalStyleText;\n        emphasisStyle.text = emphasisStyleText;\n    };\n\n    /**\n     * Set basic textStyle properties.\n     * @param {Object|module:zrender/graphic/Style} textStyle\n     * @param {module:echarts/model/Model} model\n     * @param {Object} [specifiedTextStyle] Can be overrided by settings in model.\n     * @param {Object} [opt] See `opt` of `setTextStyleCommon`.\n     * @param {boolean} [isEmphasis]\n     */\n    var setTextStyle = graphic.setTextStyle = function (\n        textStyle, textStyleModel, specifiedTextStyle, opt, isEmphasis\n    ) {\n        setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis);\n        specifiedTextStyle && zrUtil.extend(textStyle, specifiedTextStyle);\n        textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);\n\n        return textStyle;\n    };\n\n    /**\n     * Set text option in the style.\n     * @deprecated\n     * @param {Object} textStyle\n     * @param {module:echarts/model/Model} labelModel\n     * @param {string|boolean} defaultColor Default text color.\n     *        If set as false, it will be processed as a emphasis style.\n     */\n    graphic.setText = function (textStyle, labelModel, defaultColor) {\n        var opt = {isRectText: true};\n        var isEmphasis;\n\n        if (defaultColor === false) {\n            isEmphasis = true;\n        }\n        else {\n            // Support setting color as 'auto' to get visual color.\n            opt.autoColor = defaultColor;\n        }\n        setTextStyleCommon(textStyle, labelModel, opt, isEmphasis);\n        textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);\n    };\n\n    /**\n     * {\n     *      disableBox: boolean, Whether diable drawing box of block (outer most).\n     *      isRectText: boolean,\n     *      autoColor: string, specify a color when color is 'auto',\n     *              for textFill, textStroke, textBackgroundColor, and textBorderColor.\n     *              If autoColor specified, it is used as default textFill.\n     *      useInsideStyle:\n     *              `true`: Use inside style (textFill, textStroke, textStrokeWidth)\n     *                  if `textFill` is not specified.\n     *              `false`: Do not use inside style.\n     *              `null/undefined`: use inside style if `isRectText` is true and\n     *                  `textFill` is not specified and textPosition contains `'inside'`.\n     *      forceRich: boolean\n     * }\n     */\n    function setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis) {\n        // Consider there will be abnormal when merge hover style to normal style if given default value.\n        opt = opt || EMPTY_OBJ;\n\n        if (opt.isRectText) {\n            var textPosition = textStyleModel.getShallow('position')\n                || (isEmphasis ? null : 'inside');\n            // 'outside' is not a valid zr textPostion value, but used\n            // in bar series, and magric type should be considered.\n            textPosition === 'outside' && (textPosition = 'top');\n            textStyle.textPosition = textPosition;\n            textStyle.textOffset = textStyleModel.getShallow('offset');\n            var labelRotate = textStyleModel.getShallow('rotate');\n            labelRotate != null && (labelRotate *= Math.PI / 180);\n            textStyle.textRotation = labelRotate;\n            textStyle.textDistance = zrUtil.retrieve2(\n                textStyleModel.getShallow('distance'), isEmphasis ? null : 5\n            );\n        }\n\n        var ecModel = textStyleModel.ecModel;\n        var globalTextStyle = ecModel && ecModel.option.textStyle;\n\n        // Consider case:\n        // {\n        //     data: [{\n        //         value: 12,\n        //         label: {\n        //             normal: {\n        //                 rich: {\n        //                     // no 'a' here but using parent 'a'.\n        //                 }\n        //             }\n        //         }\n        //     }],\n        //     rich: {\n        //         a: { ... }\n        //     }\n        // }\n        var richItemNames = getRichItemNames(textStyleModel);\n        var richResult;\n        if (richItemNames) {\n            richResult = {};\n            for (var name in richItemNames) {\n                if (richItemNames.hasOwnProperty(name)) {\n                    // Cascade is supported in rich.\n                    var richTextStyle = textStyleModel.getModel(['rich', name]);\n                    // In rich, never `disableBox`.\n                    setTokenTextStyle(richResult[name] = {}, richTextStyle, globalTextStyle, opt, isEmphasis);\n                }\n            }\n        }\n        textStyle.rich = richResult;\n\n        setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, true);\n\n        if (opt.forceRich && !opt.textStyle) {\n            opt.textStyle = {};\n        }\n\n        return textStyle;\n    }\n\n    // Consider case:\n    // {\n    //     data: [{\n    //         value: 12,\n    //         label: {\n    //             normal: {\n    //                 rich: {\n    //                     // no 'a' here but using parent 'a'.\n    //                 }\n    //             }\n    //         }\n    //     }],\n    //     rich: {\n    //         a: { ... }\n    //     }\n    // }\n    function getRichItemNames(textStyleModel) {\n        // Use object to remove duplicated names.\n        var richItemNameMap;\n        while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {\n            var rich = (textStyleModel.option || EMPTY_OBJ).rich;\n            if (rich) {\n                richItemNameMap = richItemNameMap || {};\n                for (var name in rich) {\n                    if (rich.hasOwnProperty(name)) {\n                        richItemNameMap[name] = 1;\n                    }\n                }\n            }\n            textStyleModel = textStyleModel.parentModel;\n        }\n        return richItemNameMap;\n    }\n\n    function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, isBlock) {\n        // In merge mode, default value should not be given.\n        globalTextStyle = !isEmphasis && globalTextStyle || EMPTY_OBJ;\n\n        textStyle.textFill = getAutoColor(textStyleModel.getShallow('color'), opt)\n            || globalTextStyle.color;\n        textStyle.textStroke = getAutoColor(textStyleModel.getShallow('textBorderColor'), opt)\n            || globalTextStyle.textBorderColor;\n        textStyle.textStrokeWidth = zrUtil.retrieve2(\n            textStyleModel.getShallow('textBorderWidth'),\n            globalTextStyle.textBorderWidth\n        );\n\n        if (!isEmphasis) {\n            if (isBlock) {\n                // Always set `insideRollback`, for clearing previous.\n                var originalTextPosition = textStyle.textPosition;\n                textStyle.insideRollback = applyInsideStyle(textStyle, originalTextPosition, opt);\n                // Save original textPosition, because style.textPosition will be repalced by\n                // real location (like [10, 30]) in zrender.\n                textStyle.insideOriginalTextPosition = originalTextPosition;\n                textStyle.insideRollbackOpt = opt;\n            }\n\n            // Set default finally.\n            if (textStyle.textFill == null) {\n                textStyle.textFill = opt.autoColor;\n            }\n        }\n\n        // Do not use `getFont` here, because merge should be supported, where\n        // part of these properties may be changed in emphasis style, and the\n        // others should remain their original value got from normal style.\n        textStyle.fontStyle = textStyleModel.getShallow('fontStyle') || globalTextStyle.fontStyle;\n        textStyle.fontWeight = textStyleModel.getShallow('fontWeight') || globalTextStyle.fontWeight;\n        textStyle.fontSize = textStyleModel.getShallow('fontSize') || globalTextStyle.fontSize;\n        textStyle.fontFamily = textStyleModel.getShallow('fontFamily') || globalTextStyle.fontFamily;\n\n        textStyle.textAlign = textStyleModel.getShallow('align');\n        textStyle.textVerticalAlign = textStyleModel.getShallow('verticalAlign')\n            || textStyleModel.getShallow('baseline');\n\n        textStyle.textLineHeight = textStyleModel.getShallow('lineHeight');\n        textStyle.textWidth = textStyleModel.getShallow('width');\n        textStyle.textHeight = textStyleModel.getShallow('height');\n        textStyle.textTag = textStyleModel.getShallow('tag');\n\n        if (!isBlock || !opt.disableBox) {\n            textStyle.textBackgroundColor = getAutoColor(textStyleModel.getShallow('backgroundColor'), opt);\n            textStyle.textPadding = textStyleModel.getShallow('padding');\n            textStyle.textBorderColor = getAutoColor(textStyleModel.getShallow('borderColor'), opt);\n            textStyle.textBorderWidth = textStyleModel.getShallow('borderWidth');\n            textStyle.textBorderRadius = textStyleModel.getShallow('borderRadius');\n\n            textStyle.textBoxShadowColor = textStyleModel.getShallow('shadowColor');\n            textStyle.textBoxShadowBlur = textStyleModel.getShallow('shadowBlur');\n            textStyle.textBoxShadowOffsetX = textStyleModel.getShallow('shadowOffsetX');\n            textStyle.textBoxShadowOffsetY = textStyleModel.getShallow('shadowOffsetY');\n        }\n\n        textStyle.textShadowColor = textStyleModel.getShallow('textShadowColor')\n            || globalTextStyle.textShadowColor;\n        textStyle.textShadowBlur = textStyleModel.getShallow('textShadowBlur')\n            || globalTextStyle.textShadowBlur;\n        textStyle.textShadowOffsetX = textStyleModel.getShallow('textShadowOffsetX')\n            || globalTextStyle.textShadowOffsetX;\n        textStyle.textShadowOffsetY = textStyleModel.getShallow('textShadowOffsetY')\n            || globalTextStyle.textShadowOffsetY;\n    }\n\n    function getAutoColor(color, opt) {\n        return color !== 'auto' ? color : (opt && opt.autoColor) ? opt.autoColor : null;\n    }\n\n    function applyInsideStyle(textStyle, textPosition, opt) {\n        var useInsideStyle = opt.useInsideStyle;\n        var insideRollback;\n\n        if (textStyle.textFill == null\n            && useInsideStyle !== false\n            && (useInsideStyle === true\n                || (opt.isRectText\n                    && textPosition\n                    // textPosition can be [10, 30]\n                    && typeof textPosition === 'string'\n                    && textPosition.indexOf('inside') >= 0\n                )\n            )\n        ) {\n            insideRollback = {\n                textFill: null,\n                textStroke: textStyle.textStroke,\n                textStrokeWidth: textStyle.textStrokeWidth\n            };\n            textStyle.textFill = '#fff';\n            // Consider text with #fff overflow its container.\n            if (textStyle.textStroke == null) {\n                textStyle.textStroke = opt.autoColor;\n                textStyle.textStrokeWidth == null && (textStyle.textStrokeWidth = 2);\n            }\n        }\n\n        return insideRollback;\n    }\n\n    function rollbackInsideStyle(style) {\n        var insideRollback = style.insideRollback;\n        if (insideRollback) {\n            style.textFill = insideRollback.textFill;\n            style.textStroke = insideRollback.textStroke;\n            style.textStrokeWidth = insideRollback.textStrokeWidth;\n        }\n    }\n\n    graphic.getFont = function (opt, ecModel) {\n        // ecModel or default text style model.\n        var gTextStyleModel = ecModel || ecModel.getModel('textStyle');\n        return [\n            // FIXME in node-canvas fontWeight is before fontStyle\n            opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow('fontStyle') || '',\n            opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow('fontWeight') || '',\n            (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow('fontSize') || 12) + 'px',\n            opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow('fontFamily') || 'sans-serif'\n        ].join(' ');\n    };\n\n    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n        if (typeof dataIndex === 'function') {\n            cb = dataIndex;\n            dataIndex = null;\n        }\n        // Do not check 'animation' property directly here. Consider this case:\n        // animation model is an `itemModel`, whose does not have `isAnimationEnabled`\n        // but its parent model (`seriesModel`) does.\n        var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();\n\n        if (animationEnabled) {\n            var postfix = isUpdate ? 'Update' : '';\n            var duration = animatableModel.getShallow('animationDuration' + postfix);\n            var animationEasing = animatableModel.getShallow('animationEasing' + postfix);\n            var animationDelay = animatableModel.getShallow('animationDelay' + postfix);\n            if (typeof animationDelay === 'function') {\n                animationDelay = animationDelay(\n                    dataIndex,\n                    animatableModel.getAnimationDelayParams\n                        ? animatableModel.getAnimationDelayParams(el, dataIndex)\n                        : null\n                );\n            }\n            if (typeof duration === 'function') {\n                duration = duration(dataIndex);\n            }\n\n            duration > 0\n                ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb, !!cb)\n                : (el.stopAnimation(), el.attr(props), cb && cb());\n        }\n        else {\n            el.stopAnimation();\n            el.attr(props);\n            cb && cb();\n        }\n    }\n\n    /**\n     * Update graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} [cb]\n     * @example\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n     *     // Or\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, function () { console.log('Animation done!'); });\n     */\n    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Init graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} cb\n     */\n    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Get transform matrix of target (param target),\n     * in coordinate of its ancestor (param ancestor)\n     *\n     * @param {module:zrender/mixin/Transformable} target\n     * @param {module:zrender/mixin/Transformable} [ancestor]\n     */\n    graphic.getTransform = function (target, ancestor) {\n        var mat = matrix.identity([]);\n\n        while (target && target !== ancestor) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n\n        return mat;\n    };\n\n    /**\n     * Apply transform to an vertex.\n     * @param {Array.<number>} target [x, y]\n     * @param {Array.<number>|TypedArray.<number>|Object} transform Can be:\n     *      + Transform matrix: like [1, 0, 0, 1, 0, 0]\n     *      + {position, rotation, scale}, the same as `zrender/Transformable`.\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {Array.<number>} [x, y]\n     */\n    graphic.applyTransform = function (target, transform, invert) {\n        if (transform && !zrUtil.isArrayLike(transform)) {\n            transform = Transformable.getLocalTransform(transform);\n        }\n\n        if (invert) {\n            transform = matrix.invert([], transform);\n        }\n        return vector.applyTransform([], target, transform);\n    };\n\n    /**\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n     */\n    graphic.transformDirection = function (direction, transform, invert) {\n\n        // Pick a base, ensure that transform result will not be (0, 0).\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\n        var vertex = [\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n        ];\n\n        vertex = graphic.applyTransform(vertex, transform, invert);\n\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\n            ? (vertex[0] > 0 ? 'right' : 'left')\n            : (vertex[1] > 0 ? 'bottom' : 'top');\n    };\n\n    /**\n     * Apply group transition animation from g1 to g2.\n     * If no animatableModel, no animation.\n     */\n    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n        if (!g1 || !g2) {\n            return;\n        }\n\n        function getElMap(g) {\n            var elMap = {};\n            g.traverse(function (el) {\n                if (!el.isGroup && el.anid) {\n                    elMap[el.anid] = el;\n                }\n            });\n            return elMap;\n        }\n        function getAnimatableProps(el) {\n            var obj = {\n                position: vector.clone(el.position),\n                rotation: el.rotation\n            };\n            if (el.shape) {\n                obj.shape = zrUtil.extend({}, el.shape);\n            }\n            return obj;\n        }\n        var elMap1 = getElMap(g1);\n\n        g2.traverse(function (el) {\n            if (!el.isGroup && el.anid) {\n                var oldEl = elMap1[el.anid];\n                if (oldEl) {\n                    var newProp = getAnimatableProps(el);\n                    el.attr(getAnimatableProps(oldEl));\n                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n                }\n                // else {\n                //     if (el.previousProps) {\n                //         graphic.updateProps\n                //     }\n                // }\n            }\n        });\n    };\n\n    /**\n     * @param {Array.<Array.<number>>} points Like: [[23, 44], [53, 66], ...]\n     * @param {Object} rect {x, y, width, height}\n     * @return {Array.<Array.<number>>} A new clipped points.\n     */\n    graphic.clipPointsByRect = function (points, rect) {\n        return zrUtil.map(points, function (point) {\n            var x = point[0];\n            x = mathMax(x, rect.x);\n            x = mathMin(x, rect.x + rect.width);\n            var y = point[1];\n            y = mathMax(y, rect.y);\n            y = mathMin(y, rect.y + rect.height);\n            return [x, y];\n        });\n    };\n\n    /**\n     * @param {Object} targetRect {x, y, width, height}\n     * @param {Object} rect {x, y, width, height}\n     * @return {Object} A new clipped rect. If rect size are negative, return undefined.\n     */\n    graphic.clipRectByRect = function (targetRect, rect) {\n        var x = mathMax(targetRect.x, rect.x);\n        var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);\n        var y = mathMax(targetRect.y, rect.y);\n        var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);\n\n        if (x2 >= x && y2 >= y) {\n            return {\n                x: x,\n                y: y,\n                width: x2 - x,\n                height: y2 - y\n            };\n        }\n    };\n\n    /**\n     * @param {string} iconStr Support 'image://' or 'path://' or direct svg path.\n     * @param {Object} [opt] Properties of `module:zrender/Element`, except `style`.\n     * @param {Object} [rect] {x, y, width, height}\n     * @return {module:zrender/Element} Icon path or image element.\n     */\n    graphic.createIcon = function (iconStr, opt, rect) {\n        opt = zrUtil.extend({rectHover: true}, opt);\n        var style = opt.style = {strokeNoScale: true};\n        rect = rect || {x: -1, y: -1, width: 2, height: 2};\n\n        if (iconStr) {\n            return iconStr.indexOf('image://') === 0\n                ? (\n                    style.image = iconStr.slice(8),\n                    zrUtil.defaults(style, rect),\n                    new graphic.Image(opt)\n                )\n                : (\n                    graphic.makePath(\n                        iconStr.replace('path://', ''),\n                        opt,\n                        rect,\n                        'center'\n                    )\n                );\n        }\n\n    };\n\n    module.exports = graphic;\n\n\n\n/***/ }),\n\n/***/ 974:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * \n * @module echarts/util/number\n */\n\n\n\n    var zrUtil = __webpack_require__(971);\n\n    var number = {};\n\n    var RADIAN_EPSILON = 1e-4;\n\n    function _trim(str) {\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    }\n\n    /**\n     * Linear mapping a value from domain to range\n     * @memberOf module:echarts/util/number\n     * @param  {(number|Array.<number>)} val\n     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n     * @param  {boolean} clamp\n     * @return {(number|Array.<number>}\n     */\n    number.linearMap = function (val, domain, range, clamp) {\n        var subDomain = domain[1] - domain[0];\n        var subRange = range[1] - range[0];\n\n        if (subDomain === 0) {\n            return subRange === 0\n                ? range[0]\n                : (range[0] + range[1]) / 2;\n        }\n\n        // Avoid accuracy problem in edge, such as\n        // 146.39 - 62.83 === 83.55999999999999.\n        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n        // It is a little verbose for efficiency considering this method\n        // is a hotspot.\n        if (clamp) {\n            if (subDomain > 0) {\n                if (val <= domain[0]) {\n                    return range[0];\n                }\n                else if (val >= domain[1]) {\n                    return range[1];\n                }\n            }\n            else {\n                if (val >= domain[0]) {\n                    return range[0];\n                }\n                else if (val <= domain[1]) {\n                    return range[1];\n                }\n            }\n        }\n        else {\n            if (val === domain[0]) {\n                return range[0];\n            }\n            if (val === domain[1]) {\n                return range[1];\n            }\n        }\n\n        return (val - domain[0]) / subDomain * subRange + range[0];\n    };\n\n    /**\n     * Convert a percent string to absolute number.\n     * Returns NaN if percent is not a valid string or number\n     * @memberOf module:echarts/util/number\n     * @param {string|number} percent\n     * @param {number} all\n     * @return {number}\n     */\n    number.parsePercent = function(percent, all) {\n        switch (percent) {\n            case 'center':\n            case 'middle':\n                percent = '50%';\n                break;\n            case 'left':\n            case 'top':\n                percent = '0%';\n                break;\n            case 'right':\n            case 'bottom':\n                percent = '100%';\n                break;\n        }\n        if (typeof percent === 'string') {\n            if (_trim(percent).match(/%$/)) {\n                return parseFloat(percent) / 100 * all;\n            }\n\n            return parseFloat(percent);\n        }\n\n        return percent == null ? NaN : +percent;\n    };\n\n    /**\n     * (1) Fix rounding error of float numbers.\n     * (2) Support return string to avoid scientific notation like '3.5e-7'.\n     *\n     * @param {number} x\n     * @param {number} [precision]\n     * @param {boolean} [returnStr]\n     * @return {number|string}\n     */\n    number.round = function (x, precision, returnStr) {\n        if (precision == null) {\n            precision = 10;\n        }\n        // Avoid range error\n        precision = Math.min(Math.max(0, precision), 20);\n        x = (+x).toFixed(precision);\n        return returnStr ? x : +x;\n    };\n\n    number.asc = function (arr) {\n        arr.sort(function (a, b) {\n            return a - b;\n        });\n        return arr;\n    };\n\n    /**\n     * Get precision\n     * @param {number} val\n     */\n    number.getPrecision = function (val) {\n        val = +val;\n        if (isNaN(val)) {\n            return 0;\n        }\n        // It is much faster than methods converting number to string as follows\n        //      var tmp = val.toString();\n        //      return tmp.length - 1 - tmp.indexOf('.');\n        // especially when precision is low\n        var e = 1;\n        var count = 0;\n        while (Math.round(val * e) / e !== val) {\n            e *= 10;\n            count++;\n        }\n        return count;\n    };\n\n    /**\n     * @param {string|number} val\n     * @return {number}\n     */\n    number.getPrecisionSafe = function (val) {\n        var str = val.toString();\n\n        // Consider scientific notation: '3.4e-12' '3.4e+12'\n        var eIndex = str.indexOf('e');\n        if (eIndex > 0) {\n            var precision = +str.slice(eIndex + 1);\n            return precision < 0 ? -precision : 0;\n        }\n        else {\n            var dotIndex = str.indexOf('.');\n            return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;\n        }\n    };\n\n    /**\n     * Minimal dicernible data precisioin according to a single pixel.\n     *\n     * @param {Array.<number>} dataExtent\n     * @param {Array.<number>} pixelExtent\n     * @return {number} precision\n     */\n    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n        var log = Math.log;\n        var LN10 = Math.LN10;\n        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n        // toFixed() digits argument must be between 0 and 20.\n        var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n        return !isFinite(precision) ? 20 : precision;\n    };\n\n    /**\n     * Get a data of given precision, assuring the sum of percentages\n     * in valueList is 1.\n     * The largest remainer method is used.\n     * https://en.wikipedia.org/wiki/Largest_remainder_method\n     *\n     * @param {Array.<number>} valueList a list of all data\n     * @param {number} idx index of the data to be processed in valueList\n     * @param {number} precision integer number showing digits of precision\n     * @return {number} percent ranging from 0 to 100\n     */\n    number.getPercentWithPrecision = function (valueList, idx, precision) {\n        if (!valueList[idx]) {\n            return 0;\n        }\n\n        var sum = zrUtil.reduce(valueList, function (acc, val) {\n            return acc + (isNaN(val) ? 0 : val);\n        }, 0);\n        if (sum === 0) {\n            return 0;\n        }\n\n        var digits = Math.pow(10, precision);\n        var votesPerQuota = zrUtil.map(valueList, function (val) {\n            return (isNaN(val) ? 0 : val) / sum * digits * 100;\n        });\n        var targetSeats = digits * 100;\n\n        var seats = zrUtil.map(votesPerQuota, function (votes) {\n            // Assign automatic seats.\n            return Math.floor(votes);\n        });\n        var currentSum = zrUtil.reduce(seats, function (acc, val) {\n            return acc + val;\n        }, 0);\n\n        var remainder = zrUtil.map(votesPerQuota, function (votes, idx) {\n            return votes - seats[idx];\n        });\n\n        // Has remainding votes.\n        while (currentSum < targetSeats) {\n            // Find next largest remainder.\n            var max = Number.NEGATIVE_INFINITY;\n            var maxId = null;\n            for (var i = 0, len = remainder.length; i < len; ++i) {\n                if (remainder[i] > max) {\n                    max = remainder[i];\n                    maxId = i;\n                }\n            }\n\n            // Add a vote to max remainder.\n            ++seats[maxId];\n            remainder[maxId] = 0;\n            ++currentSum;\n        }\n\n        return seats[idx] / digits;\n    };\n\n    // Number.MAX_SAFE_INTEGER, ie do not support.\n    number.MAX_SAFE_INTEGER = 9007199254740991;\n\n    /**\n     * To 0 - 2 * PI, considering negative radian.\n     * @param {number} radian\n     * @return {number}\n     */\n    number.remRadian = function (radian) {\n        var pi2 = Math.PI * 2;\n        return (radian % pi2 + pi2) % pi2;\n    };\n\n    /**\n     * @param {type} radian\n     * @return {boolean}\n     */\n    number.isRadianAroundZero = function (val) {\n        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n    };\n\n    var TIME_REG = /^(?:(\\d{4})(?:[-\\/](\\d{1,2})(?:[-\\/](\\d{1,2})(?:[T ](\\d{1,2})(?::(\\d\\d)(?::(\\d\\d)(?:[.,](\\d+))?)?)?(Z|[\\+\\-]\\d\\d:?\\d\\d)?)?)?)?)?$/; // jshint ignore:line\n\n    /**\n     * Consider DST, it is incorrect to provide a method `getTimezoneOffset`\n     * without time specified. So this method is removed.\n     *\n     * @return {number} in minutes\n     */\n    // number.getTimezoneOffset = function () {\n    //     return (new Date()).getTimezoneOffset();\n    // };\n\n    /**\n     * @param {string|Date|number} value These values can be accepted:\n     *   + An instance of Date, represent a time in its own time zone.\n     *   + Or string in a subset of ISO 8601, only including:\n     *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',\n     *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',\n     *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',\n     *     all of which will be treated as local time if time zone is not specified\n     *     (see <https://momentjs.com/>).\n     *   + Or other string format, including (all of which will be treated as loacal time):\n     *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',\n     *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'\n     *   + a timestamp, which represent a time in UTC.\n     * @return {Date} date\n     */\n    number.parseDate = function (value) {\n        if (value instanceof Date) {\n            return value;\n        }\n        else if (typeof value === 'string') {\n            // Different browsers parse date in different way, so we parse it manually.\n            // Some other issues:\n            // new Date('1970-01-01') is UTC,\n            // new Date('1970/01/01') and new Date('1970-1-01') is local.\n            // See issue #3623\n            var match = TIME_REG.exec(value);\n\n            if (!match) {\n                // return Invalid Date.\n                return new Date(NaN);\n            }\n\n            // Use local time when no timezone offset specifed.\n            if (!match[8]) {\n                // match[n] can only be string or undefined.\n                // But take care of '12' + 1 => '121'.\n                return new Date(\n                    +match[1],\n                    +(match[2] || 1) - 1,\n                    +match[3] || 1,\n                    +match[4] || 0,\n                    +(match[5] || 0),\n                    +match[6] || 0,\n                    +match[7] || 0\n                );\n            }\n            // Timezoneoffset of Javascript Date has considered DST (Daylight Saving Time,\n            // https://tc39.github.io/ecma262/#sec-daylight-saving-time-adjustment).\n            // For example, system timezone is set as \"Time Zone: America/Toronto\",\n            // then these code will get different result:\n            // `new Date(1478411999999).getTimezoneOffset();  // get 240`\n            // `new Date(1478412000000).getTimezoneOffset();  // get 300`\n            // So we should not use `new Date`, but use `Date.UTC`.\n            else {\n                var hour = +match[4] || 0;\n                if (match[8].toUpperCase() !== 'Z') {\n                    hour -= match[8].slice(0, 3);\n                }\n                return new Date(Date.UTC(\n                    +match[1],\n                    +(match[2] || 1) - 1,\n                    +match[3] || 1,\n                    hour,\n                    +(match[5] || 0),\n                    +match[6] || 0,\n                    +match[7] || 0\n                ));\n            }\n        }\n        else if (value == null) {\n            return new Date(NaN);\n        }\n\n        return new Date(Math.round(value));\n    };\n\n    /**\n     * Quantity of a number. e.g. 0.1, 1, 10, 100\n     *\n     * @param  {number} val\n     * @return {number}\n     */\n    number.quantity = function (val) {\n        return Math.pow(10, quantityExponent(val));\n    };\n\n    function quantityExponent(val) {\n        return Math.floor(Math.log(val) / Math.LN10);\n    }\n\n    /**\n     * find a nice number approximately equal to x. Round the number if round = true,\n     * take ceiling if round = false. The primary observation is that the nicest\n     * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n     *\n     * See \"Nice Numbers for Graph Labels\" of Graphic Gems.\n     *\n     * @param  {number} val Non-negative value.\n     * @param  {boolean} round\n     * @return {number}\n     */\n    number.nice = function (val, round) {\n        var exponent = quantityExponent(val);\n        var exp10 = Math.pow(10, exponent);\n        var f = val / exp10; // 1 <= f < 10\n        var nf;\n        if (round) {\n            if (f < 1.5) { nf = 1; }\n            else if (f < 2.5) { nf = 2; }\n            else if (f < 4) { nf = 3; }\n            else if (f < 7) { nf = 5; }\n            else { nf = 10; }\n        }\n        else {\n            if (f < 1) { nf = 1; }\n            else if (f < 2) { nf = 2; }\n            else if (f < 3) { nf = 3; }\n            else if (f < 5) { nf = 5; }\n            else { nf = 10; }\n        }\n        val = nf * exp10;\n\n        // Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).\n        // 20 is the uppper bound of toFixed.\n        return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;\n    };\n\n    /**\n     * Order intervals asc, and split them when overlap.\n     * expect(numberUtil.reformIntervals([\n     *     {interval: [18, 62], close: [1, 1]},\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [1, 1]},\n     *     {interval: [62, 150], close: [1, 1]},\n     *     {interval: [106, 150], close: [1, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ])).toEqual([\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [0, 1]},\n     *     {interval: [18, 62], close: [0, 1]},\n     *     {interval: [62, 150], close: [0, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ]);\n     * @param {Array.<Object>} list, where `close` mean open or close\n     *        of the interval, and Infinity can be used.\n     * @return {Array.<Object>} The origin list, which has been reformed.\n     */\n    number.reformIntervals = function (list) {\n        list.sort(function (a, b) {\n            return littleThan(a, b, 0) ? -1 : 1;\n        });\n\n        var curr = -Infinity;\n        var currClose = 1;\n        for (var i = 0; i < list.length;) {\n            var interval = list[i].interval;\n            var close = list[i].close;\n\n            for (var lg = 0; lg < 2; lg++) {\n                if (interval[lg] <= curr) {\n                    interval[lg] = curr;\n                    close[lg] = !lg ? 1 - currClose : 1;\n                }\n                curr = interval[lg];\n                currClose = close[lg];\n            }\n\n            if (interval[0] === interval[1] && close[0] * close[1] !== 1) {\n                list.splice(i, 1);\n            }\n            else {\n                i++;\n            }\n        }\n\n        return list;\n\n        function littleThan(a, b, lg) {\n            return a.interval[lg] < b.interval[lg]\n                || (\n                    a.interval[lg] === b.interval[lg]\n                    && (\n                        (a.close[lg] - b.close[lg] === (!lg ? 1 : -1))\n                        || (!lg && littleThan(a, b, 1))\n                    )\n                );\n        }\n    };\n\n    /**\n     * parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n     * ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n     * subtraction forces infinities to NaN\n     *\n     * @param {*} v\n     * @return {boolean}\n     */\n    number.isNumeric = function (v) {\n        return v - parseFloat(v) >= 0;\n    };\n\n    module.exports = number;\n\n\n/***/ }),\n\n/***/ 975:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var formatUtil = __webpack_require__(977);\n    var nubmerUtil = __webpack_require__(974);\n    var Model = __webpack_require__(979);\n    var zrUtil = __webpack_require__(971);\n    var each = zrUtil.each;\n    var isObject = zrUtil.isObject;\n\n    var modelUtil = {};\n\n    /**\n     * If value is not array, then translate it to array.\n     * @param  {*} value\n     * @return {Array} [value] or value\n     */\n    modelUtil.normalizeToArray = function (value) {\n        return value instanceof Array\n            ? value\n            : value == null\n            ? []\n            : [value];\n    };\n\n    /**\n     * Sync default option between normal and emphasis like `position` and `show`\n     * In case some one will write code like\n     *     label: {\n     *         normal: {\n     *             show: false,\n     *             position: 'outside',\n     *             fontSize: 18\n     *         },\n     *         emphasis: {\n     *             show: true\n     *         }\n     *     }\n     * @param {Object} opt\n     * @param {Array.<string>} subOpts\n     */\n     modelUtil.defaultEmphasis = function (opt, subOpts) {\n        if (opt) {\n            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n            var normalOpt = opt.normal = opt.normal || {};\n\n            // Default emphasis option from normal\n            for (var i = 0, len = subOpts.length; i < len; i++) {\n                var subOptName = subOpts[i];\n                if (!emphasisOpt.hasOwnProperty(subOptName)\n                    && normalOpt.hasOwnProperty(subOptName)\n                ) {\n                    emphasisOpt[subOptName] = normalOpt[subOptName];\n                }\n            }\n        }\n    };\n\n    modelUtil.TEXT_STYLE_OPTIONS = [\n        'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',\n        'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth',\n        'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline',\n        'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY',\n        'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY',\n        'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding'\n    ];\n\n    // modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([\n    //     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',\n    //     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',\n    //     // FIXME: deprecated, check and remove it.\n    //     'textStyle'\n    // ]);\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method retieves value from data.\n     * @param {string|number|Date|Array|Object} dataItem\n     * @return {number|string|Date|Array.<number|string|Date>}\n     */\n    modelUtil.getDataItemValue = function (dataItem) {\n        // Performance sensitive.\n        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n    };\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method determine if dataItem has extra option besides value\n     * @param {string|number|Date|Array|Object} dataItem\n     */\n    modelUtil.isDataItemOption = function (dataItem) {\n        return isObject(dataItem)\n            && !(dataItem instanceof Array);\n            // // markLine data can be array\n            // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n    };\n\n    /**\n     * This helper method convert value in data.\n     * @param {string|number|Date} value\n     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n     */\n    modelUtil.converDataValue = function (value, dimInfo) {\n        // Performance sensitive.\n        var dimType = dimInfo && dimInfo.type;\n        if (dimType === 'ordinal') {\n            return value;\n        }\n\n        if (dimType === 'time'\n            // spead up when using timestamp\n            && typeof value !== 'number'\n            && value != null\n            && value !== '-'\n        ) {\n            value = +nubmerUtil.parseDate(value);\n        }\n\n        // dimType defaults 'number'.\n        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n        // parse to NaN.\n        return (value == null || value === '')\n            ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n    };\n\n    /**\n     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n     * @param {module:echarts/data/List} data\n     * @param {Object} opt\n     * @param {string} [opt.seriesIndex]\n     * @param {Object} [opt.name]\n     * @param {Object} [opt.mainType]\n     * @param {Object} [opt.subType]\n     */\n    modelUtil.createDataFormatModel = function (data, opt) {\n        var model = new Model();\n        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n        model.seriesIndex = opt.seriesIndex;\n        model.name = opt.name || '';\n        model.mainType = opt.mainType;\n        model.subType = opt.subType;\n\n        model.getData = function () {\n            return data;\n        };\n        return model;\n    };\n\n    // PENDING A little ugly\n    modelUtil.dataFormatMixin = {\n        /**\n         * Get params for formatter\n         * @param {number} dataIndex\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getDataParams: function (dataIndex, dataType) {\n            var data = this.getData(dataType);\n            var rawValue = this.getRawValue(dataIndex, dataType);\n            var rawDataIndex = data.getRawIndex(dataIndex);\n            var name = data.getName(dataIndex, true);\n            var itemOpt = data.getRawDataItem(dataIndex);\n            var color = data.getItemVisual(dataIndex, 'color');\n\n            return {\n                componentType: this.mainType,\n                componentSubType: this.subType,\n                seriesType: this.mainType === 'series' ? this.subType : null,\n                seriesIndex: this.seriesIndex,\n                seriesId: this.id,\n                seriesName: this.name,\n                name: name,\n                dataIndex: rawDataIndex,\n                data: itemOpt,\n                dataType: dataType,\n                value: rawValue,\n                color: color,\n                marker: formatUtil.getTooltipMarker(color),\n\n                // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n                $vars: ['seriesName', 'name', 'value']\n            };\n        },\n\n        /**\n         * Format label\n         * @param {number} dataIndex\n         * @param {string} [status='normal'] 'normal' or 'emphasis'\n         * @param {string} [dataType]\n         * @param {number} [dimIndex]\n         * @param {string} [labelProp='label']\n         * @return {string}\n         */\n        getFormattedLabel: function (dataIndex, status, dataType, dimIndex, labelProp) {\n            status = status || 'normal';\n            var data = this.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n\n            var params = this.getDataParams(dataIndex, dataType);\n            if (dimIndex != null && (params.value instanceof Array)) {\n                params.value = params.value[dimIndex];\n            }\n\n            var formatter = itemModel.get([labelProp || 'label', status, 'formatter']);\n\n            if (typeof formatter === 'function') {\n                params.status = status;\n                return formatter(params);\n            }\n            else if (typeof formatter === 'string') {\n                return formatUtil.formatTpl(formatter, params);\n            }\n        },\n\n        /**\n         * Get raw value in option\n         * @param {number} idx\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getRawValue: function (idx, dataType) {\n            var data = this.getData(dataType);\n            var dataItem = data.getRawDataItem(idx);\n            if (dataItem != null) {\n                return (isObject(dataItem) && !(dataItem instanceof Array))\n                    ? dataItem.value : dataItem;\n            }\n        },\n\n        /**\n         * Should be implemented.\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         * @return {string} tooltip string\n         */\n        formatTooltip: zrUtil.noop\n    };\n\n    /**\n     * Mapping to exists for merge.\n     *\n     * @public\n     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n     * @param {Object|Array.<Object>} newCptOptions\n     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          index of which is the same as exists.\n     */\n    modelUtil.mappingToExists = function (exists, newCptOptions) {\n        // Mapping by the order by original option (but not order of\n        // new option) in merge mode. Because we should ensure\n        // some specified index (like xAxisIndex) is consistent with\n        // original option, which is easy to understand, espatially in\n        // media query. And in most case, merge option is used to\n        // update partial option but not be expected to change order.\n        newCptOptions = (newCptOptions || []).slice();\n\n        var result = zrUtil.map(exists || [], function (obj, index) {\n            return {exist: obj};\n        });\n\n        // Mapping by id or name if specified.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            // id has highest priority.\n            for (var i = 0; i < result.length; i++) {\n                if (!result[i].option // Consider name: two map to one.\n                    && cptOption.id != null\n                    && result[i].exist.id === cptOption.id + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n\n            for (var i = 0; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option // Consider name: two map to one.\n                    // Can not match when both ids exist but different.\n                    && (exist.id == null || cptOption.id == null)\n                    && cptOption.name != null\n                    && !modelUtil.isIdInner(cptOption)\n                    && !modelUtil.isIdInner(exist)\n                    && exist.name === cptOption.name + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n        });\n\n        // Otherwise mapping by index.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            var i = 0;\n            for (; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option\n                    // Existing model that already has id should be able to\n                    // mapped to (because after mapping performed model may\n                    // be assigned with a id, whish should not affect next\n                    // mapping), except those has inner id.\n                    && !modelUtil.isIdInner(exist)\n                    // Caution:\n                    // Do not overwrite id. But name can be overwritten,\n                    // because axis use name as 'show label text'.\n                    // 'exist' always has id and name and we dont\n                    // need to check it.\n                    && cptOption.id == null\n                ) {\n                    result[i].option = cptOption;\n                    break;\n                }\n            }\n\n            if (i >= result.length) {\n                result.push({option: cptOption});\n            }\n        });\n\n        return result;\n    };\n\n    /**\n     * Make id and name for mapping result (result of mappingToExists)\n     * into `keyInfo` field.\n     *\n     * @public\n     * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          which order is the same as exists.\n     * @return {Array.<Object>} The input.\n     */\n    modelUtil.makeIdAndName = function (mapResult) {\n        // We use this id to hash component models and view instances\n        // in echarts. id can be specified by user, or auto generated.\n\n        // The id generation rule ensures new view instance are able\n        // to mapped to old instance when setOption are called in\n        // no-merge mode. So we generate model id by name and plus\n        // type in view id.\n\n        // name can be duplicated among components, which is convenient\n        // to specify multi components (like series) by one name.\n\n        // Ensure that each id is distinct.\n        var idMap = zrUtil.createHashMap();\n\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            existCpt && idMap.set(existCpt.id, item);\n        });\n\n        each(mapResult, function (item, index) {\n            var opt = item.option;\n\n            zrUtil.assert(\n                !opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item,\n                'id duplicates: ' + (opt && opt.id)\n            );\n\n            opt && opt.id != null && idMap.set(opt.id, item);\n            !item.keyInfo && (item.keyInfo = {});\n        });\n\n        // Make name and id.\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            var opt = item.option;\n            var keyInfo = item.keyInfo;\n\n            if (!isObject(opt)) {\n                return;\n            }\n\n            // name can be overwitten. Consider case: axis.name = '20km'.\n            // But id generated by name will not be changed, which affect\n            // only in that case: setOption with 'not merge mode' and view\n            // instance will be recreated, which can be accepted.\n            keyInfo.name = opt.name != null\n                ? opt.name + ''\n                : existCpt\n                ? existCpt.name\n                : '\\0-'; // name may be displayed on screen, so use '-'.\n\n            if (existCpt) {\n                keyInfo.id = existCpt.id;\n            }\n            else if (opt.id != null) {\n                keyInfo.id = opt.id + '';\n            }\n            else {\n                // Consider this situatoin:\n                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n                // Series with the same name between optionA and optionB\n                // should be mapped.\n                var idNum = 0;\n                do {\n                    keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n                }\n                while (idMap.get(keyInfo.id));\n            }\n\n            idMap.set(keyInfo.id, item);\n        });\n    };\n\n    /**\n     * @public\n     * @param {Object} cptOption\n     * @return {boolean}\n     */\n    modelUtil.isIdInner = function (cptOption) {\n        return isObject(cptOption)\n            && cptOption.id\n            && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n    };\n\n    /**\n     * A helper for removing duplicate items between batchA and batchB,\n     * and in themselves, and categorize by series.\n     *\n     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n     */\n    modelUtil.compressBatches = function (batchA, batchB) {\n        var mapA = {};\n        var mapB = {};\n\n        makeMap(batchA || [], mapA);\n        makeMap(batchB || [], mapB, mapA);\n\n        return [mapToArray(mapA), mapToArray(mapB)];\n\n        function makeMap(sourceBatch, map, otherMap) {\n            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n                var seriesId = sourceBatch[i].seriesId;\n                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n                var otherDataIndices = otherMap && otherMap[seriesId];\n\n                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n                    var dataIndex = dataIndices[j];\n\n                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n                        otherDataIndices[dataIndex] = null;\n                    }\n                    else {\n                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n                    }\n                }\n            }\n        }\n\n        function mapToArray(map, isData) {\n            var result = [];\n            for (var i in map) {\n                if (map.hasOwnProperty(i) && map[i] != null) {\n                    if (isData) {\n                        result.push(+i);\n                    }\n                    else {\n                        var dataIndices = mapToArray(map[i], true);\n                        dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});\n                    }\n                }\n            }\n            return result;\n        }\n    };\n\n    /**\n     * @param {module:echarts/data/List} data\n     * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n     *                         each of which can be Array or primary type.\n     * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n     */\n    modelUtil.queryDataIndex = function (data, payload) {\n        if (payload.dataIndexInside != null) {\n            return payload.dataIndexInside;\n        }\n        else if (payload.dataIndex != null) {\n            return zrUtil.isArray(payload.dataIndex)\n                ? zrUtil.map(payload.dataIndex, function (value) {\n                    return data.indexOfRawIndex(value);\n                })\n                : data.indexOfRawIndex(payload.dataIndex);\n        }\n        else if (payload.name != null) {\n            return zrUtil.isArray(payload.name)\n                ? zrUtil.map(payload.name, function (value) {\n                    return data.indexOfName(value);\n                })\n                : data.indexOfName(payload.name);\n        }\n    };\n\n    /**\n     * Enable property storage to any host object.\n     * Notice: Serialization is not supported.\n     *\n     * For example:\n     * var get = modelUitl.makeGetter();\n     *\n     * function some(hostObj) {\n     *      get(hostObj)._someProperty = 1212;\n     *      ...\n     * }\n     *\n     * @return {Function}\n     */\n    modelUtil.makeGetter = (function () {\n        var index = 0;\n        return function () {\n            var key = '\\0__ec_prop_getter_' + index++;\n            return function (hostObj) {\n                return hostObj[key] || (hostObj[key] = {});\n            };\n        };\n    })();\n\n    /**\n     * @param {module:echarts/model/Global} ecModel\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex, seriesId, seriesName,\n     *            geoIndex, geoId, geoName,\n     *            bmapIndex, bmapId, bmapName,\n     *            xAxisIndex, xAxisId, xAxisName,\n     *            yAxisIndex, yAxisId, yAxisName,\n     *            gridIndex, gridId, gridName,\n     *            ... (can be extended)\n     *        }\n     *        Each properties can be number|string|Array.<number>|Array.<string>\n     *        For example, a finder could be\n     *        {\n     *            seriesIndex: 3,\n     *            geoId: ['aa', 'cc'],\n     *            gridName: ['xx', 'rr']\n     *        }\n     *        xxxIndex can be set as 'all' (means all xxx) or 'none' (means not specify)\n     *        If nothing or null/undefined specified, return nothing.\n     * @param {Object} [opt]\n     * @param {string} [opt.defaultMainType]\n     * @param {Array.<string>} [opt.includeMainTypes]\n     * @return {Object} result like:\n     *        {\n     *            seriesModels: [seriesModel1, seriesModel2],\n     *            seriesModel: seriesModel1, // The first model\n     *            geoModels: [geoModel1, geoModel2],\n     *            geoModel: geoModel1, // The first model\n     *            ...\n     *        }\n     */\n    modelUtil.parseFinder = function (ecModel, finder, opt) {\n        if (zrUtil.isString(finder)) {\n            var obj = {};\n            obj[finder + 'Index'] = 0;\n            finder = obj;\n        }\n\n        var defaultMainType = opt && opt.defaultMainType;\n        if (defaultMainType\n            && !has(finder, defaultMainType + 'Index')\n            && !has(finder, defaultMainType + 'Id')\n            && !has(finder, defaultMainType + 'Name')\n        ) {\n            finder[defaultMainType + 'Index'] = 0;\n        }\n\n        var result = {};\n\n        each(finder, function (value, key) {\n            var value = finder[key];\n\n            // Exclude 'dataIndex' and other illgal keys.\n            if (key === 'dataIndex' || key === 'dataIndexInside') {\n                result[key] = value;\n                return;\n            }\n\n            var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n            var mainType = parsedKey[1];\n            var queryType = (parsedKey[2] || '').toLowerCase();\n\n            if (!mainType\n                || !queryType\n                || value == null\n                || (queryType === 'index' && value === 'none')\n                || (opt && opt.includeMainTypes && zrUtil.indexOf(opt.includeMainTypes, mainType) < 0)\n            ) {\n                return;\n            }\n\n            var queryParam = {mainType: mainType};\n            if (queryType !== 'index' || value !== 'all') {\n                queryParam[queryType] = value;\n            }\n\n            var models = ecModel.queryComponents(queryParam);\n            result[mainType + 'Models'] = models;\n            result[mainType + 'Model'] = models[0];\n        });\n\n        return result;\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string|number} dataDim\n     * @return {string}\n     */\n    modelUtil.dataDimToCoordDim = function (data, dataDim) {\n        var dimensions = data.dimensions;\n        dataDim = data.getDimension(dataDim);\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimItem = data.getDimensionInfo(dimensions[i]);\n            if (dimItem.name === dataDim) {\n                return dimItem.coordDim;\n            }\n        }\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string} coordDim\n     * @return {Array.<string>} data dimensions on the coordDim.\n     */\n    modelUtil.coordDimToDataDim = function (data, coordDim) {\n        var dataDim = [];\n        each(data.dimensions, function (dimName) {\n            var dimItem = data.getDimensionInfo(dimName);\n            if (dimItem.coordDim === coordDim) {\n                dataDim[dimItem.coordDimIndex] = dimItem.name;\n            }\n        });\n        return dataDim;\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string} otherDim Can be `otherDims`\n     *                        like 'label' or 'tooltip'.\n     * @return {Array.<string>} data dimensions on the otherDim.\n     */\n    modelUtil.otherDimToDataDim = function (data, otherDim) {\n        var dataDim = [];\n        each(data.dimensions, function (dimName) {\n            var dimItem = data.getDimensionInfo(dimName);\n            var otherDims = dimItem.otherDims;\n            var dimIndex = otherDims[otherDim];\n            if (dimIndex != null && dimIndex !== false) {\n                dataDim[dimIndex] = dimItem.name;\n            }\n        });\n        return dataDim;\n    };\n\n    function has(obj, prop) {\n        return obj && obj.hasOwnProperty(prop);\n    }\n\n    module.exports = modelUtil;\n\n\n\n/***/ }),\n\n/***/ 976:\n/***/ (function(module, exports) {\n\n\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * \n     * @exports zrender/tool/vector\n     */\n    var vector = {\n        /**\n         * \n         * @param {number} [x=0]\n         * @param {number} [y=0]\n         * @return {Vector2}\n         */\n        create: function (x, y) {\n            var out = new ArrayCtor(2);\n            if (x == null) {\n                x = 0;\n            }\n            if (y == null) {\n                y = 0;\n            }\n            out[0] = x;\n            out[1] = y;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        copy: function (out, v) {\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        clone: function (v) {\n            var out = new ArrayCtor(2);\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {number} a\n         * @param {number} b\n         * @return {Vector2} \n         */\n        set: function (out, a, b) {\n            out[0] = a;\n            out[1] = b;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        add: function (out, v1, v2) {\n            out[0] = v1[0] + v2[0];\n            out[1] = v1[1] + v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} a\n         */\n        scaleAndAdd: function (out, v1, v2, a) {\n            out[0] = v1[0] + v2[0] * a;\n            out[1] = v1[1] + v2[1] * a;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        sub: function (out, v1, v2) {\n            out[0] = v1[0] - v2[0];\n            out[1] = v1[1] - v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        len: function (v) {\n            return Math.sqrt(this.lenSquare(v));\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        lenSquare: function (v) {\n            return v[0] * v[0] + v[1] * v[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        mul: function (out, v1, v2) {\n            out[0] = v1[0] * v2[0];\n            out[1] = v1[1] * v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        div: function (out, v1, v2) {\n            out[0] = v1[0] / v2[0];\n            out[1] = v1[1] / v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        dot: function (v1, v2) {\n            return v1[0] * v2[0] + v1[1] * v2[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {number} s\n         */\n        scale: function (out, v, s) {\n            out[0] = v[0] * s;\n            out[1] = v[1] * s;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        normalize: function (out, v) {\n            var d = vector.len(v);\n            if (d === 0) {\n                out[0] = 0;\n                out[1] = 0;\n            }\n            else {\n                out[0] = v[0] / d;\n                out[1] = v[1] / d;\n            }\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distance: function (v1, v2) {\n            return Math.sqrt(\n                (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n            );\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distanceSquare: function (v1, v2) {\n            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        negate: function (out, v) {\n            out[0] = -v[0];\n            out[1] = -v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} t\n         */\n        lerp: function (out, v1, v2, t) {\n            out[0] = v1[0] + t * (v2[0] - v1[0]);\n            out[1] = v1[1] + t * (v2[1] - v1[1]);\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {Vector2} m\n         */\n        applyTransform: function (out, v, m) {\n            var x = v[0];\n            var y = v[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        min: function (out, v1, v2) {\n            out[0] = Math.min(v1[0], v2[0]);\n            out[1] = Math.min(v1[1], v2[1]);\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        max: function (out, v1, v2) {\n            out[0] = Math.max(v1[0], v2[0]);\n            out[1] = Math.max(v1[1], v2[1]);\n            return out;\n        }\n    };\n\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n\n    module.exports = vector;\n\n\n\n/***/ }),\n\n/***/ 977:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(971);\n    var numberUtil = __webpack_require__(974);\n    var textContain = __webpack_require__(985);\n\n    var formatUtil = {};\n\n    /**\n     * ,\n     * @param {string|number} x\n     * @return {string}\n     */\n    formatUtil.addCommas = function (x) {\n        if (isNaN(x)) {\n            return '-';\n        }\n        x = (x + '').split('.');\n        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,')\n               + (x.length > 1 ? ('.' + x[1]) : '');\n    };\n\n    /**\n     * @param {string} str\n     * @param {boolean} [upperCaseFirst=false]\n     * @return {string} str\n     */\n    formatUtil.toCamelCase = function (str, upperCaseFirst) {\n        str = (str || '').toLowerCase().replace(/-(.)/g, function(match, group1) {\n            return group1.toUpperCase();\n        });\n\n        if (upperCaseFirst && str) {\n            str = str.charAt(0).toUpperCase() + str.slice(1);\n        }\n\n        return str;\n    };\n\n    formatUtil.normalizeCssArray = zrUtil.normalizeCssArray;\n\n    var encodeHTML = formatUtil.encodeHTML = function (source) {\n        return String(source)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#39;');\n    };\n\n    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\n    var wrapVar = function (varName, seriesIdx) {\n        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n    };\n\n    /**\n     * Template formatter\n     * @param {string} tpl\n     * @param {Array.<Object>|Object} paramsList\n     * @param {boolean} [encode=false]\n     * @return {string}\n     */\n    formatUtil.formatTpl = function (tpl, paramsList, encode) {\n        if (!zrUtil.isArray(paramsList)) {\n            paramsList = [paramsList];\n        }\n        var seriesLen = paramsList.length;\n        if (!seriesLen) {\n            return '';\n        }\n\n        var $vars = paramsList[0].$vars || [];\n        for (var i = 0; i < $vars.length; i++) {\n            var alias = TPL_VAR_ALIAS[i];\n            var val = wrapVar(alias, 0);\n            tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);\n        }\n        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n            for (var k = 0; k < $vars.length; k++) {\n                var val = paramsList[seriesIdx][$vars[k]];\n                tpl = tpl.replace(\n                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\n                    encode ? encodeHTML(val) : val\n                );\n            }\n        }\n\n        return tpl;\n    };\n\n    /**\n     * simple Template formatter\n     *\n     * @param {string} tpl\n     * @param {Object} param\n     * @param {boolean} [encode=false]\n     * @return {string}\n     */\n    formatUtil.formatTplSimple = function (tpl, param, encode) {\n        zrUtil.each(param, function (value, key) {\n            tpl = tpl.replace(\n                '{' + key + '}',\n                encode ? encodeHTML(value) : value\n            );\n        });\n        return tpl;\n    };\n\n    /**\n     * @param {string} color\n     * @param {string} [extraCssText]\n     * @return {string}\n     */\n    formatUtil.getTooltipMarker = function (color, extraCssText) {\n        return color\n            ? '<span style=\"display:inline-block;margin-right:5px;'\n                + 'border-radius:10px;width:9px;height:9px;background-color:'\n                + formatUtil.encodeHTML(color) + ';' + (extraCssText || '') + '\"></span>'\n            : '';\n    };\n\n    /**\n     * @param {string} str\n     * @return {string}\n     * @inner\n     */\n    var s2d = function (str) {\n        return str < 10 ? ('0' + str) : str;\n    };\n\n    /**\n     * ISO Date format\n     * @param {string} tpl\n     * @param {number} value\n     * @param {boolean} [isUTC=false] Default in local time.\n     *           see `module:echarts/scale/Time`\n     *           and `module:echarts/util/number#parseDate`.\n     * @inner\n     */\n    formatUtil.formatTime = function (tpl, value, isUTC) {\n        if (tpl === 'week'\n            || tpl === 'month'\n            || tpl === 'quarter'\n            || tpl === 'half-year'\n            || tpl === 'year'\n        ) {\n            tpl = 'MM-dd\\nyyyy';\n        }\n\n        var date = numberUtil.parseDate(value);\n        var utc = isUTC ? 'UTC' : '';\n        var y = date['get' + utc + 'FullYear']();\n        var M = date['get' + utc + 'Month']() + 1;\n        var d = date['get' + utc + 'Date']();\n        var h = date['get' + utc + 'Hours']();\n        var m = date['get' + utc + 'Minutes']();\n        var s = date['get' + utc + 'Seconds']();\n\n        tpl = tpl.replace('MM', s2d(M))\n            .replace('M', M)\n            .replace('yyyy', y)\n            .replace('yy', y % 100)\n            .replace('dd', s2d(d))\n            .replace('d', d)\n            .replace('hh', s2d(h))\n            .replace('h', h)\n            .replace('mm', s2d(m))\n            .replace('m', m)\n            .replace('ss', s2d(s))\n            .replace('s', s);\n\n        return tpl;\n    };\n\n    /**\n     * Capital first\n     * @param {string} str\n     * @return {string}\n     */\n    formatUtil.capitalFirst = function (str) {\n        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n    };\n\n    formatUtil.truncateText = textContain.truncateText;\n\n    formatUtil.getTextRect = textContain.getBoundingRect;\n\n    module.exports = formatUtil;\n\n\n\n/***/ }),\n\n/***/ 978:\n/***/ (function(module, exports) {\n\n/**\n * echarts\n *\n * @desc echartsCanvasJavascript\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            // Assume canvas is supported\n            canvasSupported: true\n        };\n    }\n    else {\n        env = detect(navigator.userAgent);\n    }\n\n    module.exports = env;\n\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n            // IE 11 Trident/7.0; rv:11.0\n            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n        var weChat = (/micromessenger/i).test(ua);\n\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox) {\n            browser.firefox = true;\n            browser.version = firefox[1];\n        }\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n\n        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n        // not be set on win phone. So we do not consider Win Phone.\n        if (weChat) {\n            browser.weChat = true;\n        }\n\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            // canvas\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n            canvasSupported : document.createElement('canvas').getContext ? true : false,\n            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n            // works on most browsers\n            // IE10/11 does not support touch event, and MS Edge supports them but not by\n            // default, so we dont check navigator.maxTouchPoints for them here.\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            // <http://caniuse.com/#search=pointer%20event>.\n            pointerEventsSupported: 'onpointerdown' in window\n                // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n                // events currently. So we dont use that on other browsers unless tested sufficiently.\n                // Although IE 10 supports pointer event, it use old style and is different from the\n                // standard. So we exclude that. (IE 10 is hardly used on touch device)\n                && (browser.edge || (browser.ie && browser.version >= 11))\n        };\n    }\n\n\n/***/ }),\n\n/***/ 979:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module echarts/model/Model\n */\n\n\n    var zrUtil = __webpack_require__(971);\n    var clazzUtil = __webpack_require__(984);\n    var env = __webpack_require__(978);\n\n    /**\n     * @alias module:echarts/model/Model\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} [parentModel]\n     * @param {module:echarts/model/Global} [ecModel]\n     */\n    function Model(option, parentModel, ecModel) {\n        /**\n         * @type {module:echarts/model/Model}\n         * @readOnly\n         */\n        this.parentModel = parentModel;\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        this.option = option;\n\n        // Simple optimization\n        // if (this.init) {\n        //     if (arguments.length <= 4) {\n        //         this.init(option, parentModel, ecModel, extraOpt);\n        //     }\n        //     else {\n        //         this.init.apply(this, arguments);\n        //     }\n        // }\n    }\n\n    Model.prototype = {\n\n        constructor: Model,\n\n        /**\n         * Model \n         * @param {Object} option\n         */\n        init: null,\n\n        /**\n         *  Option merge\n         */\n        mergeOption: function (option) {\n            zrUtil.merge(this.option, option, true);\n        },\n\n        /**\n         * @param {string|Array.<string>} path\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        get: function (path, ignoreParent) {\n            if (path == null) {\n                return this.option;\n            }\n\n            return doGet(\n                this.option,\n                this.parsePath(path),\n                !ignoreParent && getParent(this, path)\n            );\n        },\n\n        /**\n         * @param {string} key\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        getShallow: function (key, ignoreParent) {\n            var option = this.option;\n\n            var val = option == null ? option : option[key];\n            var parentModel = !ignoreParent && getParent(this, key);\n            if (val == null && parentModel) {\n                val = parentModel.getShallow(key);\n            }\n            return val;\n        },\n\n        /**\n         * @param {string|Array.<string>} [path]\n         * @param {module:echarts/model/Model} [parentModel]\n         * @return {module:echarts/model/Model}\n         */\n        getModel: function (path, parentModel) {\n            var obj = path == null\n                ? this.option\n                : doGet(this.option, path = this.parsePath(path));\n\n            var thisParentModel;\n            parentModel = parentModel || (\n                (thisParentModel = getParent(this, path))\n                    && thisParentModel.getModel(path)\n            );\n\n            return new Model(obj, parentModel, this.ecModel);\n        },\n\n        /**\n         * If model has option\n         */\n        isEmpty: function () {\n            return this.option == null;\n        },\n\n        restoreData: function () {},\n\n        // Pending\n        clone: function () {\n            var Ctor = this.constructor;\n            return new Ctor(zrUtil.clone(this.option));\n        },\n\n        setReadOnly: function (properties) {\n            clazzUtil.setReadOnly(this, properties);\n        },\n\n        // If path is null/undefined, return null/undefined.\n        parsePath: function(path) {\n            if (typeof path === 'string') {\n                path = path.split('.');\n            }\n            return path;\n        },\n\n        /**\n         * @param {Function} getParentMethod\n         *        param {Array.<string>|string} path\n         *        return {module:echarts/model/Model}\n         */\n        customizeGetParent: function (getParentMethod) {\n            clazzUtil.set(this, 'getParent', getParentMethod);\n        },\n\n        isAnimationEnabled: function () {\n            if (!env.node) {\n                if (this.option.animation != null) {\n                    return !!this.option.animation;\n                }\n                else if (this.parentModel) {\n                    return this.parentModel.isAnimationEnabled();\n                }\n            }\n        }\n    };\n\n    function doGet(obj, pathArr, parentModel) {\n        for (var i = 0; i < pathArr.length; i++) {\n            // Ignore empty\n            if (!pathArr[i]) {\n                continue;\n            }\n            // obj could be number/string/... (like 0)\n            obj = (obj && typeof obj === 'object') ? obj[pathArr[i]] : null;\n            if (obj == null) {\n                break;\n            }\n        }\n        if (obj == null && parentModel) {\n            obj = parentModel.get(pathArr);\n        }\n        return obj;\n    }\n\n    // `path` can be null/undefined\n    function getParent(model, path) {\n        var getParentMethod = clazzUtil.get(model, 'getParent');\n        return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;\n    }\n\n    // Enable Model.extend.\n    clazzUtil.enableClassExtend(Model);\n\n    var mixin = zrUtil.mixin;\n    mixin(Model, __webpack_require__(1080));\n    mixin(Model, __webpack_require__(1081));\n    mixin(Model, __webpack_require__(1082));\n    mixin(Model, __webpack_require__(1104));\n\n    module.exports = Model;\n\n\n/***/ }),\n\n/***/ 980:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Path element\n * @module zrender/graphic/Path\n */\n\n\n\n    var Displayable = __webpack_require__(1009);\n    var zrUtil = __webpack_require__(971);\n    var PathProxy = __webpack_require__(999);\n    var pathContain = __webpack_require__(1087);\n\n    var Pattern = __webpack_require__(1037);\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\n    var abs = Math.abs;\n\n    var pathProxyForDraw = new PathProxy(true);\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = null;\n    }\n\n    Path.prototype = {\n\n        constructor: Path,\n\n        type: 'path',\n\n        __dirtyPath: true,\n\n        strokeContainThreshold: 5,\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path || pathProxyForDraw;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!(fill.colorStops);\n            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n            var hasFillPattern = hasFill && !!(fill.image);\n            var hasStrokePattern = hasStroke && !!(stroke.image);\n\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n\n            if (this.__dirty) {\n                var rect;\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    rect = rect || this.getBoundingRect();\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    rect = rect || this.getBoundingRect();\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            }\n            else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            }\n            else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n\n            var ctxLineDash = !!ctx.setLineDash;\n\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath\n                || (lineDash && !ctxLineDash && hasStroke)\n            ) {\n                path.beginPath(ctx);\n\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n\n                this.buildPath(path, this.shape, false);\n\n                // Clear path dirty flag\n                if (this.path) {\n                    this.__dirtyPath = false;\n                }\n            }\n            else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n\n            hasFill && path.fill(ctx);\n\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n\n            hasStroke && path.stroke(ctx);\n\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n        // Like in circle\n        buildPath: function (ctx, shapeCfg, inBundle) {},\n\n        createPathProxy: function () {\n            this.path = new PathProxy();\n        },\n\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (!path) {\n                    // Create path on demand.\n                    path = this.path = new PathProxy();\n                }\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n\n            return rect;\n        },\n\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(\n                            pathData, lineWidth / lineScale, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n\n        /**\n         * @param  {boolean} dirtyPath\n         */\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n\n            this.__dirty = true;\n\n            this.__zr && this.__zr.refresh();\n\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n\n        /**\n         * Alias for animate('shape')\n         * @param {boolean} loop\n         */\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n\n        // Overwrite attrKV\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            }\n            else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        if (key.hasOwnProperty(name)) {\n                            shape[name] = key[name];\n                        }\n                    }\n                }\n                else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        }\n    };\n\n    /**\n     *  Path element, \n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (\n                        ! thisShape.hasOwnProperty(name)\n                        && defaultShape.hasOwnProperty(name)\n                    ) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n\n            defaults.init && defaults.init.call(this, opts);\n        };\n\n        zrUtil.inherits(Sub, Path);\n\n        // FIXME  extend position, rotation \n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n\n        return Sub;\n    };\n\n    zrUtil.inherits(Path, Displayable);\n\n    module.exports = Path;\n\n\n/***/ }),\n\n/***/ 981:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Layout helpers for each component positioning\n\n\n    var zrUtil = __webpack_require__(971);\n    var BoundingRect = __webpack_require__(982);\n    var numberUtil = __webpack_require__(974);\n    var formatUtil = __webpack_require__(977);\n    var parsePercent = numberUtil.parsePercent;\n    var each = zrUtil.each;\n\n    var layout = {};\n\n    /**\n     * @public\n     */\n    var LOCATION_PARAMS = layout.LOCATION_PARAMS = [\n        'left', 'right', 'top', 'bottom', 'width', 'height'\n    ];\n\n    /**\n     * @public\n     */\n    var HV_NAMES = layout.HV_NAMES = [\n        ['width', 'left', 'right'],\n        ['height', 'top', 'bottom']\n    ];\n\n    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n        var x = 0;\n        var y = 0;\n\n        if (maxWidth == null) {\n            maxWidth = Infinity;\n        }\n        if (maxHeight == null) {\n            maxHeight = Infinity;\n        }\n        var currentLineMaxSize = 0;\n\n        group.eachChild(function (child, idx) {\n            var position = child.position;\n            var rect = child.getBoundingRect();\n            var nextChild = group.childAt(idx + 1);\n            var nextChildRect = nextChild && nextChild.getBoundingRect();\n            var nextX;\n            var nextY;\n\n            if (orient === 'horizontal') {\n                var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\n                nextX = x + moveX;\n                // Wrap when width exceeds maxWidth or meet a `newline` group\n                // FIXME compare before adding gap?\n                if (nextX > maxWidth || child.newline) {\n                    x = 0;\n                    nextX = moveX;\n                    y += currentLineMaxSize + gap;\n                    currentLineMaxSize = rect.height;\n                }\n                else {\n                    // FIXME: consider rect.y is not `0`?\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n                }\n            }\n            else {\n                var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\n                nextY = y + moveY;\n                // Wrap when width exceeds maxHeight or meet a `newline` group\n                if (nextY > maxHeight || child.newline) {\n                    x += currentLineMaxSize + gap;\n                    y = 0;\n                    nextY = moveY;\n                    currentLineMaxSize = rect.width;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n                }\n            }\n\n            if (child.newline) {\n                return;\n            }\n\n            position[0] = x;\n            position[1] = y;\n\n            orient === 'horizontal'\n                ? (x = nextX + gap)\n                : (y = nextY + gap);\n        });\n    }\n\n    /**\n     * VBox or HBox layouting\n     * @param {string} orient\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.box = boxLayout;\n\n    /**\n     * VBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\n    /**\n     * HBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\n    /**\n     * If x or x2 is not specified or 'center' 'left' 'right',\n     * the width would be as long as possible.\n     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n     * the height would be as long as possible.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.x]\n     * @param {number|string} [positionInfo.y]\n     * @param {number|string} [positionInfo.x2]\n     * @param {number|string} [positionInfo.y2]\n     * @param {Object} containerRect {width, height}\n     * @param {string|number} margin\n     * @return {Object} {width, height}\n     */\n    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var x = parsePercent(positionInfo.x, containerWidth);\n        var y = parsePercent(positionInfo.y, containerHeight);\n        var x2 = parsePercent(positionInfo.x2, containerWidth);\n        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\n        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        return {\n            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n        };\n    };\n\n    /**\n     * Parse position info.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {number|string} [positionInfo.width]\n     * @param {number|string} [positionInfo.height]\n     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n     * @param {Object} containerRect\n     * @param {string|number} [margin]\n     *\n     * @return {module:zrender/core/BoundingRect}\n     */\n    layout.getLayoutRect = function (\n        positionInfo, containerRect, margin\n    ) {\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var left = parsePercent(positionInfo.left, containerWidth);\n        var top = parsePercent(positionInfo.top, containerHeight);\n        var right = parsePercent(positionInfo.right, containerWidth);\n        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n        var width = parsePercent(positionInfo.width, containerWidth);\n        var height = parsePercent(positionInfo.height, containerHeight);\n\n        var verticalMargin = margin[2] + margin[0];\n        var horizontalMargin = margin[1] + margin[3];\n        var aspect = positionInfo.aspect;\n\n        // If width is not specified, calculate width from left and right\n        if (isNaN(width)) {\n            width = containerWidth - right - horizontalMargin - left;\n        }\n        if (isNaN(height)) {\n            height = containerHeight - bottom - verticalMargin - top;\n        }\n\n        if (aspect != null) {\n            // If width and height are not given\n            // 1. Graph should not exceeds the container\n            // 2. Aspect must be keeped\n            // 3. Graph should take the space as more as possible\n            // FIXME\n            // Margin is not considered, because there is no case that both\n            // using margin and aspect so far.\n            if (isNaN(width) && isNaN(height)) {\n                if (aspect > containerWidth / containerHeight) {\n                    width = containerWidth * 0.8;\n                }\n                else {\n                    height = containerHeight * 0.8;\n                }\n            }\n\n            // Calculate width or height with given aspect\n            if (isNaN(width)) {\n                width = aspect * height;\n            }\n            if (isNaN(height)) {\n                height = width / aspect;\n            }\n        }\n\n        // If left is not specified, calculate left from right and width\n        if (isNaN(left)) {\n            left = containerWidth - right - width - horizontalMargin;\n        }\n        if (isNaN(top)) {\n            top = containerHeight - bottom - height - verticalMargin;\n        }\n\n        // Align left and top\n        switch (positionInfo.left || positionInfo.right) {\n            case 'center':\n                left = containerWidth / 2 - width / 2 - margin[3];\n                break;\n            case 'right':\n                left = containerWidth - width - horizontalMargin;\n                break;\n        }\n        switch (positionInfo.top || positionInfo.bottom) {\n            case 'middle':\n            case 'center':\n                top = containerHeight / 2 - height / 2 - margin[0];\n                break;\n            case 'bottom':\n                top = containerHeight - height - verticalMargin;\n                break;\n        }\n        // If something is wrong and left, top, width, height are calculated as NaN\n        left = left || 0;\n        top = top || 0;\n        if (isNaN(width)) {\n            // Width may be NaN if only one value is given except width\n            width = containerWidth - horizontalMargin - left - (right || 0);\n        }\n        if (isNaN(height)) {\n            // Height may be NaN if only one value is given except height\n            height = containerHeight - verticalMargin - top - (bottom || 0);\n        }\n\n        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n        rect.margin = margin;\n        return rect;\n    };\n\n\n    /**\n     * Position a zr element in viewport\n     *  Group position is specified by either\n     *  {left, top}, {right, bottom}\n     *  If all properties exists, right and bottom will be igonred.\n     *\n     * Logic:\n     *     1. Scale (against origin point in parent coord)\n     *     2. Rotate (against origin point in parent coord)\n     *     3. Traslate (with el.position by this method)\n     * So this method only fixes the last step 'Traslate', which does not affect\n     * scaling and rotating.\n     *\n     * If be called repeatly with the same input el, the same result will be gotten.\n     *\n     * @param {module:zrender/Element} el Should have `getBoundingRect` method.\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {number|string} [positionInfo.width] Only for opt.boundingModel: 'raw'\n     * @param {number|string} [positionInfo.height] Only for opt.boundingModel: 'raw'\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @param {Object} [opt]\n     * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.\n     * @param {Array.<number>} [opt.boundingMode='all']\n     *        Specify how to calculate boundingRect when locating.\n     *        'all': Position the boundingRect that is transformed and uioned\n     *               both itself and its descendants.\n     *               This mode simplies confine the elements in the bounding\n     *               of their container (e.g., using 'right: 0').\n     *        'raw': Position the boundingRect that is not transformed and only itself.\n     *               This mode is useful when you want a element can overflow its\n     *               container. (Consider a rotated circle needs to be located in a corner.)\n     *               In this mode positionInfo.width/height can only be number.\n     */\n    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {\n        var h = !opt || !opt.hv || opt.hv[0];\n        var v = !opt || !opt.hv || opt.hv[1];\n        var boundingMode = opt && opt.boundingMode || 'all';\n\n        if (!h && !v) {\n            return;\n        }\n\n        var rect;\n        if (boundingMode === 'raw') {\n            rect = el.type === 'group'\n                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)\n                : el.getBoundingRect();\n        }\n        else {\n            rect = el.getBoundingRect();\n            if (el.needLocalTransform()) {\n                var transform = el.getLocalTransform();\n                // Notice: raw rect may be inner object of el,\n                // which should not be modified.\n                rect = rect.clone();\n                rect.applyTransform(transform);\n            }\n        }\n\n        // The real width and height can not be specified but calculated by the given el.\n        positionInfo = layout.getLayoutRect(\n            zrUtil.defaults(\n                {width: rect.width, height: rect.height},\n                positionInfo\n            ),\n            containerRect,\n            margin\n        );\n\n        // Because 'tranlate' is the last step in transform\n        // (see zrender/core/Transformable#getLocalTransfrom),\n        // we can just only modify el.position to get final result.\n        var elPos = el.position;\n        var dx = h ? positionInfo.x - rect.x : 0;\n        var dy = v ? positionInfo.y - rect.y : 0;\n\n        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\n    };\n\n    /**\n     * @param {Object} option Contains some of the properties in HV_NAMES.\n     * @param {number} hvIdx 0: horizontal; 1: vertical.\n     */\n    layout.sizeCalculable = function (option, hvIdx) {\n        return option[HV_NAMES[hvIdx][0]] != null\n            || (option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null);\n    };\n\n    /**\n     * Consider Case:\n     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n     * through setOption or media query, using normal zrUtil.merge will cause\n     * {right: 0} does not take effect.\n     *\n     * @example\n     * ComponentModel.extend({\n     *     init: function () {\n     *         ...\n     *         var inputPositionParams = layout.getLayoutParams(option);\n     *         this.mergeOption(inputPositionParams);\n     *     },\n     *     mergeOption: function (newOption) {\n     *         newOption && zrUtil.merge(thisOption, newOption, true);\n     *         layout.mergeLayoutParam(thisOption, newOption);\n     *     }\n     * });\n     *\n     * @param {Object} targetOption\n     * @param {Object} newOption\n     * @param {Object|string} [opt]\n     * @param {boolean|Array.<boolean>} [opt.ignoreSize=false] Used for the components\n     *  that width (or height) should not be calculated by left and right (or top and bottom).\n     */\n    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n        !zrUtil.isObject(opt) && (opt = {});\n\n        var ignoreSize = opt.ignoreSize;\n        !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);\n\n        var hResult = merge(HV_NAMES[0], 0);\n        var vResult = merge(HV_NAMES[1], 1);\n\n        copy(HV_NAMES[0], targetOption, hResult);\n        copy(HV_NAMES[1], targetOption, vResult);\n\n        function merge(names, hvIdx) {\n            var newParams = {};\n            var newValueCount = 0;\n            var merged = {};\n            var mergedValueCount = 0;\n            var enoughParamNumber = 2;\n\n            each(names, function (name) {\n                merged[name] = targetOption[name];\n            });\n            each(names, function (name) {\n                // Consider case: newOption.width is null, which is\n                // set by user for removing width setting.\n                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n                hasValue(newParams, name) && newValueCount++;\n                hasValue(merged, name) && mergedValueCount++;\n            });\n\n            if (ignoreSize[hvIdx]) {\n                // Only one of left/right is premitted to exist.\n                if (hasValue(newOption, names[1])) {\n                    merged[names[2]] = null;\n                }\n                else if (hasValue(newOption, names[2])) {\n                    merged[names[1]] = null;\n                }\n                return merged;\n            }\n\n            // Case: newOption: {width: ..., right: ...},\n            // or targetOption: {right: ...} and newOption: {width: ...},\n            // There is no conflict when merged only has params count\n            // little than enoughParamNumber.\n            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n                return merged;\n            }\n            // Case: newOption: {width: ..., right: ...},\n            // Than we can make sure user only want those two, and ignore\n            // all origin params in targetOption.\n            else if (newValueCount >= enoughParamNumber) {\n                return newParams;\n            }\n            else {\n                // Chose another param from targetOption by priority.\n                for (var i = 0; i < names.length; i++) {\n                    var name = names[i];\n                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n                        newParams[name] = targetOption[name];\n                        break;\n                    }\n                }\n                return newParams;\n            }\n        }\n\n        function hasProp(obj, name) {\n            return obj.hasOwnProperty(name);\n        }\n\n        function hasValue(obj, name) {\n            return obj[name] != null && obj[name] !== 'auto';\n        }\n\n        function copy(names, target, source) {\n            each(names, function (name) {\n                target[name] = source[name];\n            });\n        }\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.getLayoutParams = function (source) {\n        return layout.copyLayoutParams({}, source);\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.copyLayoutParams = function (target, source) {\n        source && target && each(LOCATION_PARAMS, function (name) {\n            source.hasOwnProperty(name) && (target[name] = source[name]);\n        });\n        return target;\n    };\n\n    module.exports = layout;\n\n\n\n/***/ }),\n\n/***/ 982:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @module echarts/core/BoundingRect\n */\n\n\n    var vec2 = __webpack_require__(976);\n    var matrix = __webpack_require__(986);\n\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n\n        if (width < 0) {\n            x = x + width;\n            width = -width;\n        }\n        if (height < 0) {\n            y = y + height;\n            height = -height;\n        }\n\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n\n    BoundingRect.prototype = {\n\n        constructor: BoundingRect,\n\n        /**\n         * @param {module:echarts/core/BoundingRect} other\n         */\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n\n            this.width = mathMax(\n                    other.x + other.width,\n                    this.x + this.width\n                ) - x;\n            this.height = mathMax(\n                    other.y + other.height,\n                    this.y + this.height\n                ) - y;\n            this.x = x;\n            this.y = y;\n        },\n\n        /**\n         * @param {Array.<number>} m\n         * @methods\n         */\n        applyTransform: (function () {\n            var lt = [];\n            var rb = [];\n            var lb = [];\n            var rt = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                lt[0] = lb[0] = this.x;\n                lt[1] = rt[1] = this.y;\n                rb[0] = rt[0] = this.x + this.width;\n                rb[1] = lb[1] = this.y + this.height;\n\n                v2ApplyTransform(lt, lt, m);\n                v2ApplyTransform(rb, rb, m);\n                v2ApplyTransform(lb, lb, m);\n                v2ApplyTransform(rt, rt, m);\n\n                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n                this.width = maxX - this.x;\n                this.height = maxY - this.y;\n            };\n        })(),\n\n        /**\n         * Calculate matrix of transforming from self to target rect\n         * @param  {module:zrender/core/BoundingRect} b\n         * @return {Array.<number>}\n         */\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n\n            var m = matrix.create();\n\n            // \n            matrix.translate(m, m, [-a.x, -a.y]);\n            matrix.scale(m, m, [sx, sy]);\n            matrix.translate(m, m, [b.x, b.y]);\n\n            return m;\n        },\n\n        /**\n         * @param {(module:echarts/core/BoundingRect|Object)} b\n         * @return {boolean}\n         */\n        intersect: function (b) {\n            if (!b) {\n                return false;\n            }\n\n            if (!(b instanceof BoundingRect)) {\n                // Normalize negative width/height.\n                b = BoundingRect.create(b);\n            }\n\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n\n            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        },\n\n        /**\n         * @return {module:echarts/core/BoundingRect}\n         */\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n\n        /**\n         * Copy from another rect\n         */\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        },\n\n        plain: function () {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height\n            };\n        }\n    };\n\n    /**\n     * @param {Object|module:zrender/core/BoundingRect} rect\n     * @param {number} rect.x\n     * @param {number} rect.y\n     * @param {number} rect.width\n     * @param {number} rect.height\n     * @return {module:zrender/core/BoundingRect}\n     */\n    BoundingRect.create = function (rect) {\n        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n    };\n\n    module.exports = BoundingRect;\n\n\n/***/ }),\n\n/***/ 983:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Component model\n *\n * @module echarts/model/Component\n */\n\n\n    var Model = __webpack_require__(979);\n    var zrUtil = __webpack_require__(971);\n    var arrayPush = Array.prototype.push;\n    var componentUtil = __webpack_require__(1016);\n    var clazzUtil = __webpack_require__(984);\n    var layout = __webpack_require__(981);\n\n    /**\n     * @alias module:echarts/model/Component\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {module:echarts/model/Model} ecModel\n     */\n    var ComponentModel = Model.extend({\n\n        type: 'component',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        id: '',\n\n        /**\n         * @readOnly\n         */\n        name: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        mainType: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        subType: '',\n\n        /**\n         * @readOnly\n         * @type {number}\n         */\n        componentIndex: 0,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        ecModel: null,\n\n        /**\n         * key: componentType\n         * value:  Component model list, can not be null.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @readOnly\n         */\n        dependentModels: [],\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        uid: null,\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        $constructor: function (option, parentModel, ecModel, extraOpt) {\n            Model.call(this, option, parentModel, ecModel, extraOpt);\n\n            this.uid = componentUtil.getUID('componentModel');\n        },\n\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n            this.mergeDefaultAndTheme(option, ecModel);\n        },\n\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            var themeModel = ecModel.getTheme();\n            zrUtil.merge(option, themeModel.get(this.mainType));\n            zrUtil.merge(option, this.getDefaultOption());\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (option, extraOpt) {\n            zrUtil.merge(this.option, option, true);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, option, layoutMode);\n            }\n        },\n\n        // Hooker after init or mergeOption\n        optionUpdated: function (newCptOption, isInit) {},\n\n        getDefaultOption: function () {\n            if (!clazzUtil.hasOwn(this, '__defaultOption')) {\n                var optList = [];\n                var Class = this.constructor;\n                while (Class) {\n                    var opt = Class.prototype.defaultOption;\n                    opt && optList.push(opt);\n                    Class = Class.superClass;\n                }\n\n                var defaultOption = {};\n                for (var i = optList.length - 1; i >= 0; i--) {\n                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n                }\n                clazzUtil.set(this, '__defaultOption', defaultOption);\n            }\n            return clazzUtil.get(this, '__defaultOption');\n        },\n\n        getReferringComponents: function (mainType) {\n            return this.ecModel.queryComponents({\n                mainType: mainType,\n                index: this.get(mainType + 'Index', true),\n                id: this.get(mainType + 'Id', true)\n            });\n        }\n\n    });\n\n    // Reset ComponentModel.extend, add preConstruct.\n    // clazzUtil.enableClassExtend(\n    //     ComponentModel,\n    //     function (option, parentModel, ecModel, extraOpt) {\n    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n    //         zrUtil.extend(this, extraOpt);\n\n    //         this.uid = componentUtil.getUID('componentModel');\n\n    //         // this.setReadOnly([\n    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n    //         //     'dependentModels', 'componentIndex'\n    //         // ]);\n    //     }\n    // );\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(\n        ComponentModel, {registerWhenExtend: true}\n    );\n    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\n    // Add capability of ComponentModel.topologicalTravel.\n    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\n    function getDependencies(componentType) {\n        var deps = [];\n        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n        });\n        // Ensure main type\n        return zrUtil.map(deps, function (type) {\n            return clazzUtil.parseClassType(type).main;\n        });\n    }\n\n    zrUtil.mixin(ComponentModel, __webpack_require__(1105));\n\n    module.exports = ComponentModel;\n\n\n/***/ }),\n\n/***/ 984:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var zrUtil = __webpack_require__(971);\n\n    var clazz = {};\n\n    var TYPE_DELIMITER = '.';\n    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n    var MEMBER_PRIFIX = '\\0ec_\\0';\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name] = value;` (can be right-value)\n     * @public\n     */\n    clazz.set = function (host, name, value) {\n        return (host[MEMBER_PRIFIX + name] = value);\n    };\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name];`\n     * @public\n     */\n    clazz.get = function (host, name) {\n        return host[MEMBER_PRIFIX + name];\n    };\n\n    /**\n     * For hidden private class member.\n     * The same behavior as `host.hasOwnProperty(name);`\n     * @public\n     */\n    clazz.hasOwn = function (host, name) {\n        return host.hasOwnProperty(MEMBER_PRIFIX + name);\n    };\n\n    /**\n     * Notice, parseClassType('') should returns {main: '', sub: ''}\n     * @public\n     */\n    var parseClassType = clazz.parseClassType = function (componentType) {\n        var ret = {main: '', sub: ''};\n        if (componentType) {\n            componentType = componentType.split(TYPE_DELIMITER);\n            ret.main = componentType[0] || '';\n            ret.sub = componentType[1] || '';\n        }\n        return ret;\n    };\n\n    /**\n     * @public\n     */\n    function checkClassType(componentType) {\n        zrUtil.assert(\n            /^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType),\n            'componentType \"' + componentType + '\" illegal'\n        );\n    }\n\n    /**\n     * @public\n     */\n    clazz.enableClassExtend = function (RootClass, mandatoryMethods) {\n\n        RootClass.$constructor = RootClass;\n        RootClass.extend = function (proto) {\n\n            if (__DEV__) {\n                zrUtil.each(mandatoryMethods, function (method) {\n                    if (!proto[method]) {\n                        console.warn(\n                            'Method `' + method + '` should be implemented'\n                            + (proto.type ? ' in ' + proto.type : '') + '.'\n                        );\n                    }\n                });\n            }\n\n            var superClass = this;\n            var ExtendedClass = function () {\n                if (!proto.$constructor) {\n                    superClass.apply(this, arguments);\n                }\n                else {\n                    proto.$constructor.apply(this, arguments);\n                }\n            };\n\n            zrUtil.extend(ExtendedClass.prototype, proto);\n\n            ExtendedClass.extend = this.extend;\n            ExtendedClass.superCall = superCall;\n            ExtendedClass.superApply = superApply;\n            zrUtil.inherits(ExtendedClass, this);\n            ExtendedClass.superClass = superClass;\n\n            return ExtendedClass;\n        };\n    };\n\n    // superCall should have class info, which can not be fetch from 'this'.\n    // Consider this case:\n    // class A has method f,\n    // class B inherits class A, overrides method f, f call superApply('f'),\n    // class C inherits class B, do not overrides method f,\n    // then when method of class C is called, dead loop occured.\n    function superCall(context, methodName) {\n        var args = zrUtil.slice(arguments, 2);\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    function superApply(context, methodName, args) {\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    /**\n     * @param {Object} entity\n     * @param {Object} options\n     * @param {boolean} [options.registerWhenExtend]\n     * @public\n     */\n    clazz.enableClassManagement = function (entity, options) {\n        options = options || {};\n\n        /**\n         * Component model classes\n         * key: componentType,\n         * value:\n         *     componentClass, when componentType is 'xxx'\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n         * @type {Object}\n         */\n        var storage = {};\n\n        entity.registerClass = function (Clazz, componentType) {\n            if (componentType) {\n                checkClassType(componentType);\n                componentType = parseClassType(componentType);\n\n                if (!componentType.sub) {\n                    if (__DEV__) {\n                        if (storage[componentType.main]) {\n                            console.warn(componentType.main + ' exists.');\n                        }\n                    }\n                    storage[componentType.main] = Clazz;\n                }\n                else if (componentType.sub !== IS_CONTAINER) {\n                    var container = makeContainer(componentType);\n                    container[componentType.sub] = Clazz;\n                }\n            }\n            return Clazz;\n        };\n\n        entity.getClass = function (componentMainType, subType, throwWhenNotFound) {\n            var Clazz = storage[componentMainType];\n\n            if (Clazz && Clazz[IS_CONTAINER]) {\n                Clazz = subType ? Clazz[subType] : null;\n            }\n\n            if (throwWhenNotFound && !Clazz) {\n                throw new Error(\n                    !subType\n                        ? componentMainType + '.' + 'type should be specified.'\n                        : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.'\n                );\n            }\n\n            return Clazz;\n        };\n\n        entity.getClassesByMainType = function (componentType) {\n            componentType = parseClassType(componentType);\n\n            var result = [];\n            var obj = storage[componentType.main];\n\n            if (obj && obj[IS_CONTAINER]) {\n                zrUtil.each(obj, function (o, type) {\n                    type !== IS_CONTAINER && result.push(o);\n                });\n            }\n            else {\n                result.push(obj);\n            }\n\n            return result;\n        };\n\n        entity.hasClass = function (componentType) {\n            // Just consider componentType.main.\n            componentType = parseClassType(componentType);\n            return !!storage[componentType.main];\n        };\n\n        /**\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n         */\n        entity.getAllClassMainTypes = function () {\n            var types = [];\n            zrUtil.each(storage, function (obj, type) {\n                types.push(type);\n            });\n            return types;\n        };\n\n        /**\n         * If a main type is container and has sub types\n         * @param  {string}  mainType\n         * @return {boolean}\n         */\n        entity.hasSubTypes = function (componentType) {\n            componentType = parseClassType(componentType);\n            var obj = storage[componentType.main];\n            return obj && obj[IS_CONTAINER];\n        };\n\n        entity.parseClassType = parseClassType;\n\n        function makeContainer(componentType) {\n            var container = storage[componentType.main];\n            if (!container || !container[IS_CONTAINER]) {\n                container = storage[componentType.main] = {};\n                container[IS_CONTAINER] = true;\n            }\n            return container;\n        }\n\n        if (options.registerWhenExtend) {\n            var originalExtend = entity.extend;\n            if (originalExtend) {\n                entity.extend = function (proto) {\n                    var ExtendedClass = originalExtend.call(this, proto);\n                    return entity.registerClass(ExtendedClass, proto.type);\n                };\n            }\n        }\n\n        return entity;\n    };\n\n    /**\n     * @param {string|Array.<string>} properties\n     */\n    clazz.setReadOnly = function (obj, properties) {\n        // FIXME It seems broken in IE8 simulation of IE11\n        // if (!zrUtil.isArray(properties)) {\n        //     properties = properties != null ? [properties] : [];\n        // }\n        // zrUtil.each(properties, function (prop) {\n        //     var value = obj[prop];\n\n        //     Object.defineProperty\n        //         && Object.defineProperty(obj, prop, {\n        //             value: value, writable: false\n        //         });\n        //     zrUtil.isArray(obj[prop])\n        //         && Object.freeze\n        //         && Object.freeze(obj[prop]);\n        // });\n    };\n\n    module.exports = clazz;\n\n\n/***/ }),\n\n/***/ 985:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var util = __webpack_require__(971);\n    var BoundingRect = __webpack_require__(982);\n    var imageHelper = __webpack_require__(1015);\n\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n\n    var TEXT_CACHE_MAX = 5000;\n    var STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\n    var DEFAULT_FONT = '12px sans-serif';\n\n    var retrieve2 = util.retrieve2;\n    var retrieve3 = util.retrieve3;\n\n    /**\n     * @public\n     * @param {string} text\n     * @param {string} font\n     * @return {number} width\n     */\n    function getTextWidth(text, font) {\n        font = font || DEFAULT_FONT;\n        var key = text + ':' + font;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // textContain.measureText may be overrided in SVG or VML\n            width = Math.max(textContain.measureText(textLines[i], font).width, width);\n        }\n\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n\n        return width;\n    }\n\n    /**\n     * @public\n     * @param {string} text\n     * @param {string} font\n     * @param {string} [textAlign='left']\n     * @param {string} [textVerticalAlign='top']\n     * @param {Array.<number>} [textPadding]\n     * @param {Object} [rich]\n     * @param {Object} [truncate]\n     * @return {Object} {x, y, width, height, lineHeight}\n     */\n    function getTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n        return rich\n            ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate)\n            : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);\n    }\n\n    function getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {\n        var contentBlock = parsePlainText(text, font, textPadding, truncate);\n        var outerWidth = getTextWidth(text, font);\n        if (textPadding) {\n            outerWidth += textPadding[1] + textPadding[3];\n        }\n        var outerHeight = contentBlock.outerHeight;\n\n        var x = adjustTextX(0, outerWidth, textAlign);\n        var y = adjustTextY(0, outerHeight, textVerticalAlign);\n\n        var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n        rect.lineHeight = contentBlock.lineHeight;\n\n        return rect;\n    }\n\n    function getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n        var contentBlock = parseRichText(text, {\n            rich: rich,\n            truncate: truncate,\n            font: font,\n            textAlign: textAlign,\n            textPadding: textPadding\n        });\n        var outerWidth = contentBlock.outerWidth;\n        var outerHeight = contentBlock.outerHeight;\n\n        var x = adjustTextX(0, outerWidth, textAlign);\n        var y = adjustTextY(0, outerHeight, textVerticalAlign);\n\n        return new BoundingRect(x, y, outerWidth, outerHeight);\n    }\n\n    /**\n     * @public\n     * @param {number} x\n     * @param {number} width\n     * @param {string} [textAlign='left']\n     * @return {number} Adjusted x.\n     */\n    function adjustTextX(x, width, textAlign) {\n        // FIXME Right to left language\n        if (textAlign === 'right') {\n            x -= width;\n        }\n        else if (textAlign === 'center') {\n            x -= width / 2;\n        }\n        return x;\n    }\n\n    /**\n     * @public\n     * @param {number} y\n     * @param {number} height\n     * @param {string} [textVerticalAlign='top']\n     * @return {number} Adjusted y.\n     */\n    function adjustTextY(y, height, textVerticalAlign) {\n        if (textVerticalAlign === 'middle') {\n            y -= height / 2;\n        }\n        else if (textVerticalAlign === 'bottom') {\n            y -= height;\n        }\n        return y;\n    }\n\n    /**\n     * @public\n     * @param {stirng} textPosition\n     * @param {Object} rect {x, y, width, height}\n     * @param {number} distance\n     * @return {Object} {x, y, textAlign, textVerticalAlign}\n     */\n    function adjustTextPositionOnRect(textPosition, rect, distance) {\n\n        var x = rect.x;\n        var y = rect.y;\n\n        var height = rect.height;\n        var width = rect.width;\n        var halfHeight = height / 2;\n\n        var textAlign = 'left';\n        var textVerticalAlign = 'top';\n\n        switch (textPosition) {\n            case 'left':\n                x -= distance;\n                y += halfHeight;\n                textAlign = 'right';\n                textVerticalAlign = 'middle';\n                break;\n            case 'right':\n                x += distance + width;\n                y += halfHeight;\n                textVerticalAlign = 'middle';\n                break;\n            case 'top':\n                x += width / 2;\n                y -= distance;\n                textAlign = 'center';\n                textVerticalAlign = 'bottom';\n                break;\n            case 'bottom':\n                x += width / 2;\n                y += height + distance;\n                textAlign = 'center';\n                break;\n            case 'inside':\n                x += width / 2;\n                y += halfHeight;\n                textAlign = 'center';\n                textVerticalAlign = 'middle';\n                break;\n            case 'insideLeft':\n                x += distance;\n                y += halfHeight;\n                textVerticalAlign = 'middle';\n                break;\n            case 'insideRight':\n                x += width - distance;\n                y += halfHeight;\n                textAlign = 'right';\n                textVerticalAlign = 'middle';\n                break;\n            case 'insideTop':\n                x += width / 2;\n                y += distance;\n                textAlign = 'center';\n                break;\n            case 'insideBottom':\n                x += width / 2;\n                y += height - distance;\n                textAlign = 'center';\n                textVerticalAlign = 'bottom';\n                break;\n            case 'insideTopLeft':\n                x += distance;\n                y += distance;\n                break;\n            case 'insideTopRight':\n                x += width - distance;\n                y += distance;\n                textAlign = 'right';\n                break;\n            case 'insideBottomLeft':\n                x += distance;\n                y += height - distance;\n                textVerticalAlign = 'bottom';\n                break;\n            case 'insideBottomRight':\n                x += width - distance;\n                y += height - distance;\n                textAlign = 'right';\n                textVerticalAlign = 'bottom';\n                break;\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    }\n\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @public\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} font\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, font, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n\n        var textLines = (text + '').split('\\n');\n        options = prepareTruncateOptions(containerWidth, font, ellipsis, options);\n\n        // FIXME\n        // It is not appropriate that every line has '...' when truncate multiple lines.\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            textLines[i] = truncateSingleLine(textLines[i], options);\n        }\n\n        return textLines.join('\\n');\n    }\n\n    function prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n        options = util.extend({}, options);\n\n        options.font = font;\n        var ellipsis = retrieve2(ellipsis, '...');\n        options.maxIterations = retrieve2(options.maxIterations, 2);\n        var minChar = options.minChar = retrieve2(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        options.cnCharWidth = getTextWidth('', font);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = options.ascCharWidth = getTextWidth('a', font);\n        options.placeholder = retrieve2(options.placeholder, '');\n\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n\n        contentWidth = containerWidth - ellipsisWidth;\n\n        options.ellipsis = ellipsis;\n        options.ellipsisWidth = ellipsisWidth;\n        options.contentWidth = contentWidth;\n        options.containerWidth = containerWidth;\n\n        return options;\n    }\n\n    function truncateSingleLine(textLine, options) {\n        var containerWidth = options.containerWidth;\n        var font = options.font;\n        var contentWidth = options.contentWidth;\n\n        if (!containerWidth) {\n            return '';\n        }\n\n        var lineWidth = getTextWidth(textLine, font);\n\n        if (lineWidth <= containerWidth) {\n            return textLine;\n        }\n\n        for (var j = 0;; j++) {\n            if (lineWidth <= contentWidth || j >= options.maxIterations) {\n                textLine += options.ellipsis;\n                break;\n            }\n\n            var subLength = j === 0\n                ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth)\n                : lineWidth > 0\n                ? Math.floor(textLine.length * contentWidth / lineWidth)\n                : 0;\n\n            textLine = textLine.substr(0, subLength);\n            lineWidth = getTextWidth(textLine, font);\n        }\n\n        if (textLine === '') {\n            textLine = options.placeholder;\n        }\n\n        return textLine;\n    }\n\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n\n    /**\n     * @public\n     * @param {string} font\n     * @return {number} line height\n     */\n    function getLineHeight(font) {\n        // FIXME A rough approach.\n        return getTextWidth('', font);\n    }\n\n    /**\n     * @public\n     * @param {string} text\n     * @param {string} font\n     * @return {Object} width\n     */\n    function measureText(text, font) {\n        var ctx = util.getContext();\n        ctx.font = font || DEFAULT_FONT;\n        return ctx.measureText(text);\n    }\n\n    /**\n     * @public\n     * @param {string} text\n     * @param {string} font\n     * @param {Object} [truncate]\n     * @return {Object} block: {lineHeight, lines, height, outerHeight}\n     *  Notice: for performance, do not calculate outerWidth util needed.\n     */\n    function parsePlainText(text, font, padding, truncate) {\n        text != null && (text += '');\n\n        var lineHeight = getLineHeight(font);\n        var lines = text ? text.split('\\n') : [];\n        var height = lines.length * lineHeight;\n        var outerHeight = height;\n\n        if (padding) {\n            outerHeight += padding[0] + padding[2];\n        }\n\n        if (text && truncate) {\n            var truncOuterHeight = truncate.outerHeight;\n            var truncOuterWidth = truncate.outerWidth;\n            if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n                text = '';\n                lines = [];\n            }\n            else if (truncOuterWidth != null) {\n                var options = prepareTruncateOptions(\n                    truncOuterWidth - (padding ? padding[1] + padding[3] : 0),\n                    font,\n                    truncate.ellipsis,\n                    {minChar: truncate.minChar, placeholder: truncate.placeholder}\n                );\n\n                // FIXME\n                // It is not appropriate that every line has '...' when truncate multiple lines.\n                for (var i = 0, len = lines.length; i < len; i++) {\n                    lines[i] = truncateSingleLine(lines[i], options);\n                }\n            }\n        }\n\n        return {\n            lines: lines,\n            height: height,\n            outerHeight: outerHeight,\n            lineHeight: lineHeight\n        };\n    }\n\n    /**\n     * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n     * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n     *\n     * @public\n     * @param {string} text\n     * @param {Object} style\n     * @return {Object} block\n     * {\n     *      width,\n     *      height,\n     *      lines: [{\n     *          lineHeight,\n     *          width,\n     *          tokens: [[{\n     *              styleName,\n     *              text,\n     *              width,      // include textPadding\n     *              height,     // include textPadding\n     *              textWidth, // pure text width\n     *              textHeight, // pure text height\n     *              lineHeihgt,\n     *              font,\n     *              textAlign,\n     *              textVerticalAlign\n     *          }], [...], ...]\n     *      }, ...]\n     * }\n     * If styleName is undefined, it is plain text.\n     */\n    function parseRichText(text, style) {\n        var contentBlock = {lines: [], width: 0, height: 0};\n\n        text != null && (text += '');\n        if (!text) {\n            return contentBlock;\n        }\n\n        var lastIndex = STYLE_REG.lastIndex = 0;\n        var result;\n        while ((result = STYLE_REG.exec(text)) != null) {\n            var matchedIndex = result.index;\n            if (matchedIndex > lastIndex) {\n                pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n            }\n            pushTokens(contentBlock, result[2], result[1]);\n            lastIndex = STYLE_REG.lastIndex;\n        }\n\n        if (lastIndex < text.length) {\n            pushTokens(contentBlock, text.substring(lastIndex, text.length));\n        }\n\n        var lines = contentBlock.lines;\n        var contentHeight = 0;\n        var contentWidth = 0;\n        // For `textWidth: 100%`\n        var pendingList = [];\n\n        var stlPadding = style.textPadding;\n\n        var truncate = style.truncate;\n        var truncateWidth = truncate && truncate.outerWidth;\n        var truncateHeight = truncate && truncate.outerHeight;\n        if (stlPadding) {\n            truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n            truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n        }\n\n        // Calculate layout info of tokens.\n        for (var i = 0; i < lines.length; i++) {\n            var line = lines[i];\n            var lineHeight = 0;\n            var lineWidth = 0;\n\n            for (var j = 0; j < line.tokens.length; j++) {\n                var token = line.tokens[j];\n                var tokenStyle = token.styleName && style.rich[token.styleName] || {};\n                // textPadding should not inherit from style.\n                var textPadding = token.textPadding = tokenStyle.textPadding;\n\n                // textFont has been asigned to font by `normalizeStyle`.\n                var font = token.font = tokenStyle.font || style.font;\n\n                // textHeight can be used when textVerticalAlign is specified in token.\n                var tokenHeight = token.textHeight = retrieve2(\n                    // textHeight should not be inherited, consider it can be specified\n                    // as box height of the block.\n                    tokenStyle.textHeight, textContain.getLineHeight(font)\n                );\n                textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n                token.height = tokenHeight;\n                token.lineHeight = retrieve3(\n                    tokenStyle.textLineHeight, style.textLineHeight, tokenHeight\n                );\n\n                token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n                token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n                if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n                    return {lines: [], width: 0, height: 0};\n                }\n\n                token.textWidth = textContain.getWidth(token.text, font);\n                var tokenWidth = tokenStyle.textWidth;\n                var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto';\n\n                // Percent width, can be `100%`, can be used in drawing separate\n                // line when box width is needed to be auto.\n                if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n                    token.percentWidth = tokenWidth;\n                    pendingList.push(token);\n                    tokenWidth = 0;\n                    // Do not truncate in this case, because there is no user case\n                    // and it is too complicated.\n                }\n                else {\n                    if (tokenWidthNotSpecified) {\n                        tokenWidth = token.textWidth;\n\n                        // FIXME: If image is not loaded and textWidth is not specified, calling\n                        // `getBoundingRect()` will not get correct result.\n                        var textBackgroundColor = tokenStyle.textBackgroundColor;\n                        var bgImg = textBackgroundColor && textBackgroundColor.image;\n\n                        // Use cases:\n                        // (1) If image is not loaded, it will be loaded at render phase and call\n                        // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n                        // image, and then the right size will be calculated here at the next tick.\n                        // See `graphic/helper/text.js`.\n                        // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n                        // use `imageHelper.findExistImage` to find cached image.\n                        // `imageHelper.findExistImage` will always be called here before\n                        // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n                        // which ensures that image will not be rendered before correct size calcualted.\n                        if (bgImg) {\n                            bgImg = imageHelper.findExistImage(bgImg);\n                            if (imageHelper.isImageReady(bgImg)) {\n                                tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n                            }\n                        }\n                    }\n\n                    var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n                    tokenWidth += paddingW;\n\n                    var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n                    if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n                        if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n                            token.text = '';\n                            token.textWidth = tokenWidth = 0;\n                        }\n                        else {\n                            token.text = truncateText(\n                                token.text, remianTruncWidth - paddingW, font, truncate.ellipsis,\n                                {minChar: truncate.minChar}\n                            );\n                            token.textWidth = textContain.getWidth(token.text, font);\n                            tokenWidth = token.textWidth + paddingW;\n                        }\n                    }\n                }\n\n                lineWidth += (token.width = tokenWidth);\n                tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n            }\n\n            line.width = lineWidth;\n            line.lineHeight = lineHeight;\n            contentHeight += lineHeight;\n            contentWidth = Math.max(contentWidth, lineWidth);\n        }\n\n        contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n        contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n        if (stlPadding) {\n            contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n            contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n        }\n\n        for (var i = 0; i < pendingList.length; i++) {\n            var token = pendingList[i];\n            var percentWidth = token.percentWidth;\n            // Should not base on outerWidth, because token can not be placed out of padding.\n            token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n        }\n\n        return contentBlock;\n    }\n\n    function pushTokens(block, str, styleName) {\n        var isEmptyStr = str === '';\n        var strs = str.split('\\n');\n        var lines = block.lines;\n\n        for (var i = 0; i < strs.length; i++) {\n            var text = strs[i];\n            var token = {\n                styleName: styleName,\n                text: text,\n                isLineHolder: !text && !isEmptyStr\n            };\n\n            // The first token should be appended to the last line.\n            if (!i) {\n                var tokens = (lines[lines.length - 1] || (lines[0] = {tokens: []})).tokens;\n\n                // Consider cases:\n                // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n                // (which is a placeholder) should be replaced by new token.\n                // (2) A image backage, where token likes {a|}.\n                // (3) A redundant '' will affect textAlign in line.\n                // (4) tokens with the same tplName should not be merged, because\n                // they should be displayed in different box (with border and padding).\n                var tokensLen = tokens.length;\n                (tokensLen === 1 && tokens[0].isLineHolder)\n                    ? (tokens[0] = token)\n                    // Consider text is '', only insert when it is the \"lineHolder\" or\n                    // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n                    : ((text || !tokensLen || isEmptyStr) && tokens.push(token));\n            }\n            // Other tokens always start a new line.\n            else {\n                // If there is '', insert it as a placeholder.\n                lines.push({tokens: [token]});\n            }\n        }\n    }\n\n    function makeFont(style) {\n        // FIXME in node-canvas fontWeight is before fontStyle\n        // Use `fontSize` `fontFamily` to check whether font properties are defined.\n        return (style.fontSize || style.fontFamily) && [\n            style.fontStyle,\n            style.fontWeight,\n            (style.fontSize || 12) + 'px',\n            // If font properties are defined, `fontFamily` should not be ignored.\n            style.fontFamily || 'sans-serif'\n        ].join(' ') || style.textFont || style.font;\n    }\n\n    var textContain = {\n\n        getWidth: getTextWidth,\n\n        getBoundingRect: getTextRect,\n\n        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\n        truncateText: truncateText,\n\n        measureText: measureText,\n\n        getLineHeight: getLineHeight,\n\n        parsePlainText: parsePlainText,\n\n        parseRichText: parseRichText,\n\n        adjustTextX: adjustTextX,\n\n        adjustTextY: adjustTextY,\n\n        makeFont: makeFont,\n\n        DEFAULT_FONT: DEFAULT_FONT\n    };\n\n    module.exports = textContain;\n\n\n/***/ }),\n\n/***/ 986:\n/***/ (function(module, exports) {\n\n\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n    /**\n     * 3x2\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n        /**\n         * \n         * @return {Float32Array|Array.<number>}\n         */\n        create : function() {\n            var out = new ArrayCtor(6);\n            matrix.identity(out);\n\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         */\n        identity : function(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m\n         */\n        copy: function(out, m) {\n            out[0] = m[0];\n            out[1] = m[1];\n            out[2] = m[2];\n            out[3] = m[3];\n            out[4] = m[4];\n            out[5] = m[5];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m1\n         * @param {Float32Array|Array.<number>} m2\n         */\n        mul : function (out, m1, m2) {\n            // Consider matrix.mul(m, m2, m);\n            // where out is the same as m2.\n            // So use temp variable to escape error.\n            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = out3;\n            out[4] = out4;\n            out[5] = out5;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        translate : function(out, a, v) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4] + v[0];\n            out[5] = a[5] + v[1];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {number} rad\n         */\n        rotate : function(out, a, rad) {\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n            var st = Math.sin(rad);\n            var ct = Math.cos(rad);\n\n            out[0] = aa * ct + ab * st;\n            out[1] = -aa * st + ab * ct;\n            out[2] = ac * ct + ad * st;\n            out[3] = -ac * st + ct * ad;\n            out[4] = ct * atx + st * aty;\n            out[5] = ct * aty - st * atx;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        scale : function(out, a, v) {\n            var vx = v[0];\n            var vy = v[1];\n            out[0] = a[0] * vx;\n            out[1] = a[1] * vy;\n            out[2] = a[2] * vx;\n            out[3] = a[3] * vy;\n            out[4] = a[4] * vx;\n            out[5] = a[5] * vy;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         */\n        invert : function(out, a) {\n\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n\n            var det = aa * ad - ab * ac;\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out;\n        }\n    };\n\n    module.exports = matrix;\n\n\n\n/***/ }),\n\n/***/ 987:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/**\n * List for data storage\n * @module echarts/data/List\n */\n\n\n    var UNDEFINED = 'undefined';\n    var globalObj = typeof window === 'undefined' ? global : window;\n    var Float64Array = typeof globalObj.Float64Array === UNDEFINED\n        ? Array : globalObj.Float64Array;\n    var Int32Array = typeof globalObj.Int32Array === UNDEFINED\n        ? Array : globalObj.Int32Array;\n\n    var dataCtors = {\n        'float': Float64Array,\n        'int': Int32Array,\n        // Ordinal data type can be string or int\n        'ordinal': Array,\n        'number': Array,\n        'time': Array\n    };\n\n    var Model = __webpack_require__(979);\n    var DataDiffer = __webpack_require__(1003);\n\n    var zrUtil = __webpack_require__(971);\n    var modelUtil = __webpack_require__(975);\n    var isObject = zrUtil.isObject;\n\n    var TRANSFERABLE_PROPERTIES = [\n        'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'\n    ];\n\n    function transferProperties(a, b) {\n        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n            if (b.hasOwnProperty(propName)) {\n                a[propName] = b[propName];\n            }\n        });\n\n        a.__wrappedMethods = b.__wrappedMethods;\n    }\n\n    function DefaultDataProvider(dataArray) {\n        this._array = dataArray || [];\n    }\n\n    DefaultDataProvider.prototype.pure = false;\n\n    DefaultDataProvider.prototype.count = function () {\n        return this._array.length;\n    };\n    DefaultDataProvider.prototype.getItem = function (idx) {\n        return this._array[idx];\n    };\n\n    /**\n     * @constructor\n     * @alias module:echarts/data/List\n     *\n     * @param {Array.<string|Object>} dimensions\n     *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n     *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n     * @param {module:echarts/model/Model} hostModel\n     */\n    var List = function (dimensions, hostModel) {\n\n        dimensions = dimensions || ['x', 'y'];\n\n        var dimensionInfos = {};\n        var dimensionNames = [];\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimensionName;\n            var dimensionInfo = {};\n            if (typeof dimensions[i] === 'string') {\n                dimensionName = dimensions[i];\n                dimensionInfo = {\n                    name: dimensionName,\n                    coordDim: dimensionName,\n                    coordDimIndex: 0,\n                    stackable: false,\n                    // Type can be 'float', 'int', 'number'\n                    // Default is number, Precision of float may not enough\n                    type: 'number'\n                };\n            }\n            else {\n                dimensionInfo = dimensions[i];\n                dimensionName = dimensionInfo.name;\n                dimensionInfo.type = dimensionInfo.type || 'number';\n                if (!dimensionInfo.coordDim) {\n                    dimensionInfo.coordDim = dimensionName;\n                    dimensionInfo.coordDimIndex = 0;\n                }\n            }\n            dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n            dimensionNames.push(dimensionName);\n            dimensionInfos[dimensionName] = dimensionInfo;\n        }\n\n        /**\n         * @readOnly\n         * @type {Array.<string>}\n         */\n        this.dimensions = dimensionNames;\n\n        /**\n         * Infomation of each data dimension, like data type.\n         * @type {Object}\n         */\n        this._dimensionInfos = dimensionInfos;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.hostModel = hostModel;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.dataType;\n\n        /**\n         * Indices stores the indices of data subset after filtered.\n         * This data subset will be used in chart.\n         * @type {Array.<number>}\n         * @readOnly\n         */\n        this.indices = [];\n\n        /**\n         * Data storage\n         * @type {Object.<key, TypedArray|Array>}\n         * @private\n         */\n        this._storage = {};\n\n        /**\n         * @type {Array.<string>}\n         */\n        this._nameList = [];\n        /**\n         * @type {Array.<string>}\n         */\n        this._idList = [];\n\n        /**\n         * Models of data option is stored sparse for optimizing memory cost\n         * @type {Array.<module:echarts/model/Model>}\n         * @private\n         */\n        this._optionModels = [];\n\n        /**\n         * @param {module:echarts/data/List}\n         */\n        this.stackedOn = null;\n\n        /**\n         * Global visual properties after visual coding\n         * @type {Object}\n         * @private\n         */\n        this._visual = {};\n\n        /**\n         * Globel layout properties.\n         * @type {Object}\n         * @private\n         */\n        this._layout = {};\n\n        /**\n         * Item visual properties after visual coding\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemVisuals = [];\n\n        /**\n         * Item layout properties after layout\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemLayouts = [];\n\n        /**\n         * Graphic elemnents\n         * @type {Array.<module:zrender/Element>}\n         * @private\n         */\n        this._graphicEls = [];\n\n        /**\n         * @type {Array.<Array|Object>}\n         * @private\n         */\n        this._rawData;\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._extent;\n    };\n\n    var listProto = List.prototype;\n\n    listProto.type = 'list';\n\n    /**\n     * If each data item has it's own option\n     * @type {boolean}\n     */\n    listProto.hasItemOption = true;\n\n    /**\n     * Get dimension name\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     * @return {string} Concrete dim name.\n     */\n    listProto.getDimension = function (dim) {\n        if (!isNaN(dim)) {\n            dim = this.dimensions[dim] || dim;\n        }\n        return dim;\n    };\n\n    /**\n     * Get type and stackable info of particular dimension\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     */\n    listProto.getDimensionInfo = function (dim) {\n        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n    };\n\n    /**\n     * Initialize from data\n     * @param {Array.<Object|number|Array>} data\n     * @param {Array.<string>} [nameList]\n     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n     */\n    listProto.initData = function (data, nameList, dimValueGetter) {\n        data = data || [];\n\n        var isDataArray = zrUtil.isArray(data);\n        if (isDataArray) {\n            data = new DefaultDataProvider(data);\n        }\n        if (__DEV__) {\n            if (!isDataArray && (typeof data.getItem != 'function' || typeof data.count != 'function')) {\n                throw new Error('Inavlid data provider.');\n            }\n        }\n\n        this._rawData = data;\n\n        // Clear\n        var storage = this._storage = {};\n        var indices = this.indices = [];\n\n        var dimensions = this.dimensions;\n        var dimensionInfoMap = this._dimensionInfos;\n\n        var size = data.count();\n\n        var idList = [];\n        var nameRepeatCount = {};\n        var nameDimIdx;\n\n        nameList = nameList || [];\n\n        // Init storage\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimInfo = dimensionInfoMap[dimensions[i]];\n            dimInfo.otherDims.itemName === 0 && (nameDimIdx = i);\n            var DataCtor = dataCtors[dimInfo.type];\n            storage[dimensions[i]] = new DataCtor(size);\n        }\n\n        var self = this;\n        if (!dimValueGetter) {\n            self.hasItemOption = false;\n        }\n        // Default dim value getter\n        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n            var value = modelUtil.getDataItemValue(dataItem);\n            // If any dataItem is like { value: 10 }\n            if (modelUtil.isDataItemOption(dataItem)) {\n                self.hasItemOption = true;\n            }\n            return modelUtil.converDataValue(\n                (value instanceof Array)\n                    ? value[dimIndex]\n                    // If value is a single number or something else not array.\n                    : value,\n                dimensionInfoMap[dimName]\n            );\n        };\n\n        for (var i = 0; i < size; i++) {\n            // NOTICE: Try not to write things into dataItem\n            var dataItem = data.getItem(i);\n            // Each data item is value\n            // [1, 2]\n            // 2\n            // Bar chart, line chart which uses category axis\n            // only gives the 'y' value. 'x' value is the indices of cateogry\n            // Use a tempValue to normalize the value to be a (x, y) value\n\n            // Store the data by dimensions\n            for (var k = 0; k < dimensions.length; k++) {\n                var dim = dimensions[k];\n                var dimStorage = storage[dim];\n                // PENDING NULL is empty or zero\n                dimStorage[i] = dimValueGetter(dataItem, dim, i, k);\n            }\n\n            indices.push(i);\n        }\n\n        // Use the name in option and create id\n        for (var i = 0; i < size; i++) {\n            var dataItem = data.getItem(i);\n            if (!nameList[i] && dataItem) {\n                if (dataItem.name != null) {\n                    nameList[i] = dataItem.name;\n                }\n                else if (nameDimIdx != null) {\n                    nameList[i] = storage[dimensions[nameDimIdx]][i];\n                }\n            }\n            var name = nameList[i] || '';\n            // Try using the id in option\n            var id = dataItem && dataItem.id;\n\n            if (!id && name) {\n                // Use name as id and add counter to avoid same name\n                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n                id = name;\n                if (nameRepeatCount[name] > 0) {\n                    id += '__ec__' + nameRepeatCount[name];\n                }\n                nameRepeatCount[name]++;\n            }\n            id && (idList[i] = id);\n        }\n\n        this._nameList = nameList;\n        this._idList = idList;\n    };\n\n    /**\n     * @return {number}\n     */\n    listProto.count = function () {\n        return this.indices.length;\n    };\n\n    /**\n     * Get value. Return NaN if idx is out of range.\n     * @param {string} dim Dim must be concrete name.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.get = function (dim, idx, stack) {\n        var storage = this._storage;\n        var dataIndex = this.indices[idx];\n\n        // If value not exists\n        if (dataIndex == null || !storage[dim]) {\n            return NaN;\n        }\n\n        var value = storage[dim][dataIndex];\n        // FIXME ordinal data type is not stackable\n        if (stack) {\n            var dimensionInfo = this._dimensionInfos[dim];\n            if (dimensionInfo && dimensionInfo.stackable) {\n                var stackedOn = this.stackedOn;\n                while (stackedOn) {\n                    // Get no stacked data of stacked on\n                    var stackedValue = stackedOn.get(dim, idx);\n                    // Considering positive stack, negative stack and empty data\n                    if ((value >= 0 && stackedValue > 0)  // Positive stack\n                        || (value <= 0 && stackedValue < 0) // Negative stack\n                    ) {\n                        value += stackedValue;\n                    }\n                    stackedOn = stackedOn.stackedOn;\n                }\n            }\n        }\n        return value;\n    };\n\n    /**\n     * Get value for multi dimensions.\n     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.getValues = function (dimensions, idx, stack) {\n        var values = [];\n\n        if (!zrUtil.isArray(dimensions)) {\n            stack = idx;\n            idx = dimensions;\n            dimensions = this.dimensions;\n        }\n\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            values.push(this.get(dimensions[i], idx, stack));\n        }\n\n        return values;\n    };\n\n    /**\n     * If value is NaN. Inlcuding '-'\n     * @param {string} dim\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.hasValue = function (idx) {\n        var dimensions = this.dimensions;\n        var dimensionInfos = this._dimensionInfos;\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            if (\n                // Ordinal type can be string or number\n                dimensionInfos[dimensions[i]].type !== 'ordinal'\n                && isNaN(this.get(dimensions[i], idx))\n            ) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Get extent of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     * @param {Function} filter\n     */\n    listProto.getDataExtent = function (dim, stack, filter) {\n        dim = this.getDimension(dim);\n        var dimData = this._storage[dim];\n        var dimInfo = this.getDimensionInfo(dim);\n        stack = (dimInfo && dimInfo.stackable) && stack;\n        var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];\n        var value;\n        if (dimExtent) {\n            return dimExtent;\n        }\n        // var dimInfo = this._dimensionInfos[dim];\n        if (dimData) {\n            var min = Infinity;\n            var max = -Infinity;\n            // var isOrdinal = dimInfo.type === 'ordinal';\n            for (var i = 0, len = this.count(); i < len; i++) {\n                value = this.get(dim, i, stack);\n                // FIXME\n                // if (isOrdinal && typeof value === 'string') {\n                //     value = zrUtil.indexOf(dimData, value);\n                // }\n                if (!filter || filter(value, dim, i)) {\n                    value < min && (min = value);\n                    value > max && (max = value);\n                }\n            }\n            return (this._extent[dim + !!stack] = [min, max]);\n        }\n        else {\n            return [Infinity, -Infinity];\n        }\n    };\n\n    /**\n     * Get sum of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getSum = function (dim, stack) {\n        var dimData = this._storage[dim];\n        var sum = 0;\n        if (dimData) {\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var value = this.get(dim, i, stack);\n                if (!isNaN(value)) {\n                    sum += value;\n                }\n            }\n        }\n        return sum;\n    };\n\n    /**\n     * Retreive the index with given value\n     * @param {number} idx\n     * @param {number} value\n     * @return {number}\n     */\n    // FIXME Precision of float value\n    listProto.indexOf = function (dim, value) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var indices = this.indices;\n\n        if (dimData) {\n            for (var i = 0, len = indices.length; i < len; i++) {\n                var rawIndex = indices[i];\n                if (dimData[rawIndex] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given name\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfName = function (name) {\n        var indices = this.indices;\n        var nameList = this._nameList;\n\n        for (var i = 0, len = indices.length; i < len; i++) {\n            var rawIndex = indices[i];\n            if (nameList[rawIndex] === name) {\n                return i;\n            }\n        }\n\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given raw data index\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfRawIndex = function (rawIndex) {\n        // Indices are ascending\n        var indices = this.indices;\n\n        // If rawIndex === dataIndex\n        var rawDataIndex = indices[rawIndex];\n        if (rawDataIndex != null && rawDataIndex === rawIndex) {\n            return rawIndex;\n        }\n\n        var left = 0;\n        var right = indices.length - 1;\n        while (left <= right) {\n            var mid = (left + right) / 2 | 0;\n            if (indices[mid] < rawIndex) {\n                left = mid + 1;\n            }\n            else if (indices[mid] > rawIndex) {\n                right = mid - 1;\n            }\n            else {\n                return mid;\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index of nearest value\n     * @param {string} dim\n     * @param {number} value\n     * @param {boolean} stack If given value is after stacked\n     * @param {number} [maxDistance=Infinity]\n     * @return {Array.<number>} Considere multiple points has the same value.\n     */\n    listProto.indicesOfNearest = function (dim, value, stack, maxDistance) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var nearestIndices = [];\n\n        if (!dimData) {\n            return nearestIndices;\n        }\n\n        if (maxDistance == null) {\n            maxDistance = Infinity;\n        }\n\n        var minDist = Number.MAX_VALUE;\n        var minDiff = -1;\n        for (var i = 0, len = this.count(); i < len; i++) {\n            var diff = value - this.get(dim, i, stack);\n            var dist = Math.abs(diff);\n            if (diff <= maxDistance && dist <= minDist) {\n                // For the case of two data are same on xAxis, which has sequence data.\n                // Show the nearest index\n                // https://github.com/ecomfe/echarts/issues/2869\n                if (dist < minDist || (diff >= 0 && minDiff < 0)) {\n                    minDist = dist;\n                    minDiff = diff;\n                    nearestIndices.length = 0;\n                }\n                nearestIndices.push(i);\n            }\n        }\n        return nearestIndices;\n    };\n\n    /**\n     * Get raw data index\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawIndex = function (idx) {\n        var rawIdx = this.indices[idx];\n        return rawIdx == null ? -1 : rawIdx;\n    };\n\n    /**\n     * Get raw data item\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawDataItem = function (idx) {\n        return this._rawData.getItem(this.getRawIndex(idx));\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getName = function (idx) {\n        return this._nameList[this.indices[idx]] || '';\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getId = function (idx) {\n        return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');\n    };\n\n\n    function normalizeDimensions(dimensions) {\n        if (!zrUtil.isArray(dimensions)) {\n            dimensions = [dimensions];\n        }\n        return dimensions;\n    }\n\n    /**\n     * Data iteration\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     *\n     * @example\n     *  list.each('x', function (x, idx) {});\n     *  list.each(['x', 'y'], function (x, y, idx) {});\n     *  list.each(function (idx) {})\n     */\n    listProto.each = function (dims, cb, stack, context) {\n        if (typeof dims === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dims;\n            dims = [];\n        }\n\n        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\n        var value = [];\n        var dimSize = dims.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            // Simple optimization\n            switch (dimSize) {\n                case 0:\n                    cb.call(context, i);\n                    break;\n                case 1:\n                    cb.call(context, this.get(dims[0], i, stack), i);\n                    break;\n                case 2:\n                    cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n                    break;\n                default:\n                    for (var k = 0; k < dimSize; k++) {\n                        value[k] = this.get(dims[k], i, stack);\n                    }\n                    // Index\n                    value[k] = i;\n                    cb.apply(context, value);\n            }\n        }\n    };\n\n    /**\n     * Data filter\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     */\n    listProto.filterSelf = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var newIndices = [];\n        var value = [];\n        var dimSize = dimensions.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            var keep;\n            // Simple optimization\n            if (!dimSize) {\n                keep = cb.call(context, i);\n            }\n            else if (dimSize === 1) {\n                keep = cb.call(\n                    context, this.get(dimensions[0], i, stack), i\n                );\n            }\n            else {\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dimensions[k], i, stack);\n                }\n                value[k] = i;\n                keep = cb.apply(context, value);\n            }\n            if (keep) {\n                newIndices.push(indices[i]);\n            }\n        }\n\n        this.indices = newIndices;\n\n        // Reset data extent\n        this._extent = {};\n\n        return this;\n    };\n\n    /**\n     * Data mapping to a plain array\n     * @param {string|Array.<string>} [dimensions]\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.mapArray = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        var result = [];\n        this.each(dimensions, function () {\n            result.push(cb && cb.apply(this, arguments));\n        }, stack, context);\n        return result;\n    };\n\n    function cloneListForMapAndSample(original, excludeDimensions) {\n        var allDimensions = original.dimensions;\n        var list = new List(\n            zrUtil.map(allDimensions, original.getDimensionInfo, original),\n            original.hostModel\n        );\n        // FIXME If needs stackedOn, value may already been stacked\n        transferProperties(list, original);\n\n        var storage = list._storage = {};\n        var originalStorage = original._storage;\n        // Init storage\n        for (var i = 0; i < allDimensions.length; i++) {\n            var dim = allDimensions[i];\n            var dimStore = originalStorage[dim];\n            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n                storage[dim] = new dimStore.constructor(\n                    originalStorage[dim].length\n                );\n            }\n            else {\n                // Direct reference for other dimensions\n                storage[dim] = originalStorage[dim];\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Data mapping to a new List with given dimensions\n     * @param {string|Array.<string>} dimensions\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.map = function (dimensions, cb, stack, context) {\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var list = cloneListForMapAndSample(this, dimensions);\n        // Following properties are all immutable.\n        // So we can reference to the same value\n        var indices = list.indices = this.indices;\n\n        var storage = list._storage;\n\n        var tmpRetValue = [];\n        this.each(dimensions, function () {\n            var idx = arguments[arguments.length - 1];\n            var retValue = cb && cb.apply(this, arguments);\n            if (retValue != null) {\n                // a number\n                if (typeof retValue === 'number') {\n                    tmpRetValue[0] = retValue;\n                    retValue = tmpRetValue;\n                }\n                for (var i = 0; i < retValue.length; i++) {\n                    var dim = dimensions[i];\n                    var dimStore = storage[dim];\n                    var rawIdx = indices[idx];\n                    if (dimStore) {\n                        dimStore[rawIdx] = retValue[i];\n                    }\n                }\n            }\n        }, stack, context);\n\n        return list;\n    };\n\n    /**\n     * Large data down sampling on given dimension\n     * @param {string} dimension\n     * @param {number} rate\n     * @param {Function} sampleValue\n     * @param {Function} sampleIndex Sample index for name and id\n     */\n    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n        var list = cloneListForMapAndSample(this, [dimension]);\n        var storage = this._storage;\n        var targetStorage = list._storage;\n\n        var originalIndices = this.indices;\n        var indices = list.indices = [];\n\n        var frameValues = [];\n        var frameIndices = [];\n        var frameSize = Math.floor(1 / rate);\n\n        var dimStore = targetStorage[dimension];\n        var len = this.count();\n        // Copy data from original data\n        for (var i = 0; i < storage[dimension].length; i++) {\n            targetStorage[dimension][i] = storage[dimension][i];\n        }\n        for (var i = 0; i < len; i += frameSize) {\n            // Last frame\n            if (frameSize > len - i) {\n                frameSize = len - i;\n                frameValues.length = frameSize;\n            }\n            for (var k = 0; k < frameSize; k++) {\n                var idx = originalIndices[i + k];\n                frameValues[k] = dimStore[idx];\n                frameIndices[k] = idx;\n            }\n            var value = sampleValue(frameValues);\n            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n            // Only write value on the filtered data\n            dimStore[idx] = value;\n            indices.push(idx);\n        }\n\n        return list;\n    };\n\n    /**\n     * Get model of one data item.\n     *\n     * @param {number} idx\n     */\n    // FIXME Model proxy ?\n    listProto.getItemModel = function (idx) {\n        var hostModel = this.hostModel;\n        idx = this.indices[idx];\n        return new Model(this._rawData.getItem(idx), hostModel, hostModel && hostModel.ecModel);\n    };\n\n    /**\n     * Create a data differ\n     * @param {module:echarts/data/List} otherList\n     * @return {module:echarts/data/DataDiffer}\n     */\n    listProto.diff = function (otherList) {\n        var idList = this._idList;\n        var otherIdList = otherList && otherList._idList;\n        var val;\n        // Use prefix to avoid index to be the same as otherIdList[idx],\n        // which will cause weird udpate animation.\n        var prefix = 'e\\0\\0';\n\n        return new DataDiffer(\n            otherList ? otherList.indices : [],\n            this.indices,\n            function (idx) {\n                return (val = otherIdList[idx]) != null ? val : prefix + idx;\n            },\n            function (idx) {\n                return (val = idList[idx]) != null ? val : prefix + idx;\n            }\n        );\n    };\n    /**\n     * Get visual property.\n     * @param {string} key\n     */\n    listProto.getVisual = function (key) {\n        var visual = this._visual;\n        return visual && visual[key];\n    };\n\n    /**\n     * Set visual property\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setVisual('color', color);\n     *  setVisual({\n     *      'color': color\n     *  });\n     */\n    listProto.setVisual = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setVisual(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._visual = this._visual || {};\n        this._visual[key] = val;\n    };\n\n    /**\n     * Set layout property.\n     * @param {string|Object} key\n     * @param {*} [val]\n     */\n    listProto.setLayout = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setLayout(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._layout[key] = val;\n    };\n\n    /**\n     * Get layout property.\n     * @param  {string} key.\n     * @return {*}\n     */\n    listProto.getLayout = function (key) {\n        return this._layout[key];\n    };\n\n    /**\n     * Get layout of single data item\n     * @param {number} idx\n     */\n    listProto.getItemLayout = function (idx) {\n        return this._itemLayouts[idx];\n    };\n\n    /**\n     * Set layout of single data item\n     * @param {number} idx\n     * @param {Object} layout\n     * @param {boolean=} [merge=false]\n     */\n    listProto.setItemLayout = function (idx, layout, merge) {\n        this._itemLayouts[idx] = merge\n            ? zrUtil.extend(this._itemLayouts[idx] || {}, layout)\n            : layout;\n    };\n\n    /**\n     * Clear all layout of single data item\n     */\n    listProto.clearItemLayouts = function () {\n        this._itemLayouts.length = 0;\n    };\n\n    /**\n     * Get visual property of single data item\n     * @param {number} idx\n     * @param {string} key\n     * @param {boolean} [ignoreParent=false]\n     */\n    listProto.getItemVisual = function (idx, key, ignoreParent) {\n        var itemVisual = this._itemVisuals[idx];\n        var val = itemVisual && itemVisual[key];\n        if (val == null && !ignoreParent) {\n            // Use global visual property\n            return this.getVisual(key);\n        }\n        return val;\n    };\n\n    /**\n     * Set visual property of single data item\n     *\n     * @param {number} idx\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setItemVisual(0, 'color', color);\n     *  setItemVisual(0, {\n     *      'color': color\n     *  });\n     */\n    listProto.setItemVisual = function (idx, key, value) {\n        var itemVisual = this._itemVisuals[idx] || {};\n        this._itemVisuals[idx] = itemVisual;\n\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    itemVisual[name] = key[name];\n                }\n            }\n            return;\n        }\n        itemVisual[key] = value;\n    };\n\n    /**\n     * Clear itemVisuals and list visual.\n     */\n    listProto.clearAllVisual = function () {\n        this._visual = {};\n        this._itemVisuals = [];\n    };\n\n    var setItemDataAndSeriesIndex = function (child) {\n        child.seriesIndex = this.seriesIndex;\n        child.dataIndex = this.dataIndex;\n        child.dataType = this.dataType;\n    };\n    /**\n     * Set graphic element relative to data. It can be set as null\n     * @param {number} idx\n     * @param {module:zrender/Element} [el]\n     */\n    listProto.setItemGraphicEl = function (idx, el) {\n        var hostModel = this.hostModel;\n\n        if (el) {\n            // Add data index and series index for indexing the data by element\n            // Useful in tooltip\n            el.dataIndex = idx;\n            el.dataType = this.dataType;\n            el.seriesIndex = hostModel && hostModel.seriesIndex;\n            if (el.type === 'group') {\n                el.traverse(setItemDataAndSeriesIndex, el);\n            }\n        }\n\n        this._graphicEls[idx] = el;\n    };\n\n    /**\n     * @param {number} idx\n     * @return {module:zrender/Element}\n     */\n    listProto.getItemGraphicEl = function (idx) {\n        return this._graphicEls[idx];\n    };\n\n    /**\n     * @param {Function} cb\n     * @param {*} context\n     */\n    listProto.eachItemGraphicEl = function (cb, context) {\n        zrUtil.each(this._graphicEls, function (el, idx) {\n            if (el) {\n                cb && cb.call(context, el, idx);\n            }\n        });\n    };\n\n    /**\n     * Shallow clone a new list except visual and layout properties, and graph elements.\n     * New list only change the indices.\n     */\n    listProto.cloneShallow = function () {\n        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n        var list = new List(dimensionInfoList, this.hostModel);\n\n        // FIXME\n        list._storage = this._storage;\n\n        transferProperties(list, this);\n\n\n        // Clone will not change the data extent and indices\n        list.indices = this.indices.slice();\n\n        if (this._extent) {\n            list._extent = zrUtil.extend({}, this._extent);\n        }\n\n        return list;\n    };\n\n    /**\n     * Wrap some method to add more feature\n     * @param {string} methodName\n     * @param {Function} injectFunction\n     */\n    listProto.wrapMethod = function (methodName, injectFunction) {\n        var originalMethod = this[methodName];\n        if (typeof originalMethod !== 'function') {\n            return;\n        }\n        this.__wrappedMethods = this.__wrappedMethods || [];\n        this.__wrappedMethods.push(methodName);\n        this[methodName] = function () {\n            var res = originalMethod.apply(this, arguments);\n            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n        };\n    };\n\n    // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n    listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];\n    // Methods that change indices of this list should be listed here.\n    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\n    module.exports = List;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24)))\n\n/***/ }),\n\n/***/ 988:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n    var OrdinalScale = __webpack_require__(1121);\n    var IntervalScale = __webpack_require__(1012);\n    __webpack_require__(1122);\n    __webpack_require__(1123);\n    var Scale = __webpack_require__(1004);\n\n    var numberUtil = __webpack_require__(974);\n    var zrUtil = __webpack_require__(971);\n    var textContain = __webpack_require__(985);\n    var axisHelper = {};\n\n    /**\n     * Get axis scale extent before niced.\n     * Item of returned array can only be number (including Infinity and NaN).\n     */\n    axisHelper.getScaleExtent = function (scale, model) {\n        var scaleType = scale.type;\n\n        var min = model.getMin();\n        var max = model.getMax();\n        var fixMin = min != null;\n        var fixMax = max != null;\n        var originalExtent = scale.getExtent();\n\n        var axisDataLen;\n        var boundaryGap;\n        var span;\n        if (scaleType === 'ordinal') {\n            axisDataLen = (model.get('data') || []).length;\n        }\n        else {\n            boundaryGap = model.get('boundaryGap');\n            if (!zrUtil.isArray(boundaryGap)) {\n                boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n            }\n            if (typeof boundaryGap[0] === 'boolean') {\n                if (__DEV__) {\n                    console.warn('Boolean type for boundaryGap is only '\n                        + 'allowed for ordinal axis. Please use string in '\n                        + 'percentage instead, e.g., \"20%\". Currently, '\n                        + 'boundaryGap is set to be 0.');\n                }\n                boundaryGap = [0, 0];\n            }\n            boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n            boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n            span = (originalExtent[1] - originalExtent[0])\n                || Math.abs(originalExtent[0]);\n        }\n\n        // Notice: When min/max is not set (that is, when there are null/undefined,\n        // which is the most common case), these cases should be ensured:\n        // (1) For 'ordinal', show all axis.data.\n        // (2) For others:\n        //      + `boundaryGap` is applied (if min/max set, boundaryGap is\n        //      disabled).\n        //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should\n        //      be the result that originalExtent enlarged by boundaryGap.\n        // (3) If no data, it should be ensured that `scale.setBlank` is set.\n\n        // FIXME\n        // (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?\n        // (2) When `needCrossZero` and all data is positive/negative, should it be ensured\n        // that the results processed by boundaryGap are positive/negative?\n\n        if (min == null) {\n            min = scaleType === 'ordinal'\n                ? (axisDataLen ? 0 : NaN)\n                : originalExtent[0] - boundaryGap[0] * span;\n        }\n        if (max == null) {\n            max = scaleType === 'ordinal'\n                ? (axisDataLen ? axisDataLen - 1 : NaN)\n                : originalExtent[1] + boundaryGap[1] * span;\n        }\n\n        if (min === 'dataMin') {\n            min = originalExtent[0];\n        }\n        else if (typeof min === 'function') {\n            min = min({\n                min: originalExtent[0],\n                max: originalExtent[1]\n            });\n        }\n\n        if (max === 'dataMax') {\n            max = originalExtent[1];\n        }\n        else if (typeof max === 'function') {\n            max = max({\n                min: originalExtent[0],\n                max: originalExtent[1]\n            });\n        }\n\n        (min == null || !isFinite(min)) && (min = NaN);\n        (max == null || !isFinite(max)) && (max = NaN);\n\n        scale.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max));\n\n        // Evaluate if axis needs cross zero\n        if (model.getNeedCrossZero()) {\n            // Axis is over zero and min is not set\n            if (min > 0 && max > 0 && !fixMin) {\n                min = 0;\n            }\n            // Axis is under zero and max is not set\n            if (min < 0 && max < 0 && !fixMax) {\n                max = 0;\n            }\n        }\n\n        return [min, max];\n    };\n\n    axisHelper.niceScaleExtent = function (scale, model) {\n        var extent = axisHelper.getScaleExtent(scale, model);\n        var fixMin = model.getMin() != null;\n        var fixMax = model.getMax() != null;\n        var splitNumber = model.get('splitNumber');\n\n        if (scale.type === 'log') {\n            scale.base = model.get('logBase');\n        }\n\n        var scaleType = scale.type;\n        scale.setExtent(extent[0], extent[1]);\n        scale.niceExtent({\n            splitNumber: splitNumber,\n            fixMin: fixMin,\n            fixMax: fixMax,\n            minInterval: (scaleType === 'interval' || scaleType === 'time')\n                ? model.get('minInterval') : null,\n            maxInterval: (scaleType === 'interval' || scaleType === 'time')\n                ? model.get('maxInterval') : null\n        });\n\n        // If some one specified the min, max. And the default calculated interval\n        // is not good enough. He can specify the interval. It is often appeared\n        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n        // to be 60.\n        // FIXME\n        var interval = model.get('interval');\n        if (interval != null) {\n            scale.setInterval && scale.setInterval(interval);\n        }\n    };\n\n    /**\n     * @param {module:echarts/model/Model} model\n     * @param {string} [axisType] Default retrieve from model.type\n     * @return {module:echarts/scale/*}\n     */\n    axisHelper.createScaleByModel = function(model, axisType) {\n        axisType = axisType || model.get('type');\n        if (axisType) {\n            switch (axisType) {\n                // Buildin scale\n                case 'category':\n                    return new OrdinalScale(\n                        model.getCategories(), [Infinity, -Infinity]\n                    );\n                case 'value':\n                    return new IntervalScale();\n                // Extended scale, like time and log\n                default:\n                    return (Scale.getClass(axisType) || IntervalScale).create(model);\n            }\n        }\n    };\n\n    /**\n     * Check if the axis corss 0\n     */\n    axisHelper.ifAxisCrossZero = function (axis) {\n        var dataExtent = axis.scale.getExtent();\n        var min = dataExtent[0];\n        var max = dataExtent[1];\n        return !((min > 0 && max > 0) || (min < 0 && max < 0));\n    };\n\n    /**\n     * @param {Array.<number>} tickCoords In axis self coordinate.\n     * @param {Array.<string>} labels\n     * @param {string} font\n     * @param {boolean} isAxisHorizontal\n     * @return {number}\n     */\n    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n        // FIXME\n        // axislabelhorizontalvertical.\n\n        var textSpaceTakenRect;\n        var autoLabelInterval = 0;\n        var accumulatedLabelInterval = 0;\n\n        var step = 1;\n        if (labels.length > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.floor(labels.length / 40);\n        }\n\n        for (var i = 0; i < tickCoords.length; i += step) {\n            var tickCoord = tickCoords[i];\n            var rect = textContain.getBoundingRect(\n                labels[i], font, 'center', 'top'\n            );\n            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n            // FIXME Magic number 1.5\n            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n            if (!textSpaceTakenRect) {\n                textSpaceTakenRect = rect.clone();\n            }\n            // There is no space for current label;\n            else if (textSpaceTakenRect.intersect(rect)) {\n                accumulatedLabelInterval++;\n                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n            }\n            else {\n                textSpaceTakenRect.union(rect);\n                // Reset\n                accumulatedLabelInterval = 0;\n            }\n        }\n        if (autoLabelInterval === 0 && step > 1) {\n            return step;\n        }\n        return (autoLabelInterval + 1) * step - 1;\n    };\n\n    /**\n     * @param {Object} axis\n     * @param {Function} labelFormatter\n     * @return {Array.<string>}\n     */\n    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n        var scale = axis.scale;\n        var labels = scale.getTicksLabels();\n        var ticks = scale.getTicks();\n        if (typeof labelFormatter === 'string') {\n            labelFormatter = (function (tpl) {\n                return function (val) {\n                    return tpl.replace('{value}', val != null ? val : '');\n                };\n            })(labelFormatter);\n            // Consider empty array\n            return zrUtil.map(labels, labelFormatter);\n        }\n        else if (typeof labelFormatter === 'function') {\n            return zrUtil.map(ticks, function (tick, idx) {\n                return labelFormatter(\n                    axisHelper.getAxisRawValue(axis, tick),\n                    idx\n                );\n            }, this);\n        }\n        else {\n            return labels;\n        }\n    };\n\n    axisHelper.getAxisRawValue = function (axis, value) {\n        // In category axis with data zoom, tick is not the original\n        // index of axis.data. So tick should not be exposed to user\n        // in category axis.\n        return axis.type === 'category' ? axis.scale.getLabel(value) : value;\n    };\n\n    module.exports = axisHelper;\n\n\n/***/ }),\n\n/***/ 989:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var features = {};\n\n    module.exports = {\n        register: function (name, ctor) {\n            features[name] = ctor;\n        },\n\n        get: function (name) {\n            return features[name];\n        }\n    };\n\n\n/***/ }),\n\n/***/ 990:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * \n * @module zrender/core/event\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n */\n\n\n    var Eventful = __webpack_require__(992);\n    var env = __webpack_require__(978);\n\n    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\n    var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;\n\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n    }\n\n    // `calculate` is optional, default false\n    function clientToLocal(el, e, out, calculate) {\n        out = out || {};\n\n        // According to the W3C Working Draft, offsetX and offsetY should be relative\n        // to the padding edge of the target element. The only browser using this convention\n        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n        // not support the properties.\n        // (see http://www.jacklmoore.com/notes/mouse-position/)\n        // In zr painter.dom, padding edge equals to border edge.\n\n        // FIXME\n        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n        // is too complex. So css-transfrom dont support in this case temporarily.\n        if (calculate || !env.canvasSupported) {\n            defaultGetZrXY(el, e, out);\n        }\n        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n        // zoom-factor, overflow / opacity layers, transforms ...)\n        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n        // <https://bugs.jquery.com/ticket/8523#comment:14>\n        // BTW3, In ff, offsetX/offsetY is always 0.\n        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n            out.zrX = e.layerX;\n            out.zrY = e.layerY;\n        }\n        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n        else if (e.offsetX != null) {\n            out.zrX = e.offsetX;\n            out.zrY = e.offsetY;\n        }\n        // For some other device, e.g., IOS safari.\n        else {\n            defaultGetZrXY(el, e, out);\n        }\n\n        return out;\n    }\n\n    function defaultGetZrXY(el, e, out) {\n        // This well-known method below does not support css transform.\n        var box = getBoundingClientRect(el);\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n    }\n\n    /**\n     * domtouch.\n     * `calculate` is optional, default false.\n     */\n    function normalizeEvent(el, e, calculate) {\n\n        e = e || window.event;\n\n        if (e.zrX != null) {\n            return e;\n        }\n\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n        if (!isTouch) {\n            clientToLocal(el, e, e, calculate);\n            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType != 'touchend'\n                ? e.targetTouches[0]\n                : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e, calculate);\n        }\n\n        // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;\n        // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js\n        // If e.which has been defined, if may be readonly,\n        // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which\n        var button = e.button;\n        if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {\n            e.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));\n        }\n\n        return e;\n    }\n\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        }\n        else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        }\n        else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n\n    /**\n     * preventDefault and stopPropagation.\n     * Notice: do not do that in zrender. Upper application\n     * do that if necessary.\n     *\n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event\n     */\n    var stop = isDomLevel2\n        ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        }\n        : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n\n    function notLeftMouse(e) {\n        // If e.which is undefined, considered as left mouse event.\n        return e.which > 1;\n    }\n\n    module.exports = {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n        notLeftMouse: notLeftMouse,\n\n        stop: stop,\n        // \n        Dispatcher: Eventful\n    };\n\n\n\n/***/ }),\n\n/***/ 991:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * \n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var vec2 = __webpack_require__(976);\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 1e-4;\n\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n\n    // \n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n             + t * t * (t * p3 + 3 * onet * p2);\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t\n        );\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1  - p0);\n        var d = p0 - val;\n\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n\n        var n = 0;\n\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;  // t1, a is not zero\n                var t2 = -K / 2;  // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} \n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <=1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] \n     * @return {number}\n     */\n    function cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n            d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out \n     * @return {number}\n     */\n    function quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n            var d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    module.exports = {\n\n        cubicAt: cubicAt,\n\n        cubicDerivativeAt: cubicDerivativeAt,\n\n        cubicRootAt: cubicRootAt,\n\n        cubicExtrema: cubicExtrema,\n\n        cubicSubdivide: cubicSubdivide,\n\n        cubicProjectPoint: cubicProjectPoint,\n\n        quadraticAt: quadraticAt,\n\n        quadraticDerivativeAt: quadraticDerivativeAt,\n\n        quadraticRootAt: quadraticRootAt,\n\n        quadraticExtremum: quadraticExtremum,\n\n        quadraticSubdivide: quadraticSubdivide,\n\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n\n\n/***/ }),\n\n/***/ 992:\n/***/ (function(module, exports) {\n\n/**\n * \n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n\n    var arrySlice = Array.prototype.slice;\n\n    /**\n     * \n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n\n    Eventful.prototype = {\n\n        constructor: Eventful,\n\n        /**\n         * trigger\n         *\n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} context\n         */\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} [context]\n         */\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {string}  event\n         * @return {boolean}\n         */\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} [handler] \n         */\n        off: function (event, handler) {\n            var _h = this._$handlers;\n\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            }\n            else {\n                delete _h[event];\n            }\n\n            return this;\n        },\n\n        /**\n         * \n         *\n         * @param {string} type \n         */\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(_h[i]['ctx']);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(_h[i]['ctx'], args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * context, context\n         * @param {string} type \n         */\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(ctx);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(ctx, args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(ctx, args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(ctx, args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n\n    //  onxxxx \n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrag\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n\n    module.exports = Eventful;\n\n\n\n/***/ }),\n\n/***/ 993:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @module zrender/tool/color\n */\n\n\n    var LRU = __webpack_require__(1030);\n\n    var kCSSColorTable = {\n        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n        'gray': [128,128,128,1], 'green': [0,128,0,1],\n        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n    };\n\n    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n\n    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n\n    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n\n    function parseCssInt(str) {  // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n\n    function parseCssFloat(str) {  // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2/3 - h) * 6;\n        }\n        return m1;\n    }\n\n    function lerpNumber(a, b, p) {\n        return a + (b - a) * p;\n    }\n\n    function setRgba(out, r, g, b, a) {\n        out[0] = r; out[1] = g; out[2] = b; out[3] = a;\n        return out;\n    }\n    function copyRgba(out, a) {\n        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];\n        return out;\n    }\n    var colorCache = new LRU(20);\n    var lastRemovedArr = null;\n    function putToCache(colorStr, rgbaArr) {\n        // Reuse removed array\n        if (lastRemovedArr) {\n            copyRgba(lastRemovedArr, rgbaArr);\n        }\n        lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()));\n    }\n    /**\n     * @param {string} colorStr\n     * @param {Array.<number>} out\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr, rgbaArr) {\n        if (!colorStr) {\n            return;\n        }\n        rgbaArr = rgbaArr || [];\n\n        var cached = colorCache.get(colorStr);\n        if (cached) {\n            return copyRgba(rgbaArr, cached);\n        }\n\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            copyRgba(rgbaArr, kCSSColorTable[str]);\n            putToCache(colorStr, rgbaArr);\n            return rgbaArr;\n        }\n\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                    (iv & 0xf) | ((iv & 0xf) << 4),\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n            else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    (iv & 0xff0000) >> 16,\n                    (iv & 0xff00) >> 8,\n                    iv & 0xff,\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;  // To allow case fallthrough.\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n                // Fall through.\n                case 'rgb':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    setRgba(rgbaArr,\n                        parseCssInt(params[0]),\n                        parseCssInt(params[1]),\n                        parseCssInt(params[2]),\n                        alpha\n                    );\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsla':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsl':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                default:\n                    return;\n            }\n        }\n\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return;\n    }\n\n    /**\n     * @param {Array.<number>} hsla\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla, rgba) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n\n        rgba = rgba || [];\n        setRgba(rgba,\n            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255),\n            1\n        );\n\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n\n        return rgba;\n    }\n\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n\n        var vMin = Math.min(R, G, B); // Min. value of RGB\n        var vMax = Math.max(R, G, B); // Max. value of RGB\n        var delta = vMax - vMin; // Delta RGB value\n\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n\n            if (H < 0) {\n                H += 1;\n            }\n\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n\n        var hsla = [H * 360, S, L];\n\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n\n        return hsla;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n\n    /**\n     * Map value to color. Faster than lerp methods because color is represented by rgba array.\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>} will be null/undefined if input illegal.\n     */\n    function fastLerp(normalizedValue, colors, out) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        out = out || [];\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));\n\n        return out;\n    }\n\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function lerp(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n\n        var color = stringify(\n            [\n                clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))\n            ],\n            'rgba'\n        );\n\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n\n    /**\n     * @param {Array.<number>} arrColor like [12,33,44,0.4]\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color. (If input illegal, return undefined).\n     */\n    function stringify(arrColor, type) {\n        if (!arrColor || !arrColor.length) {\n            return;\n        }\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n\n    module.exports = {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastLerp: fastLerp,\n        fastMapToColor: fastLerp, // Deprecated\n        lerp: lerp,\n        mapToColor: lerp, // Deprecated\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n\n\n\n\n/***/ }),\n\n/***/ 994:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(971);\n    var formatUtil = __webpack_require__(977);\n    var classUtil = __webpack_require__(984);\n    var modelUtil = __webpack_require__(975);\n    var ComponentModel = __webpack_require__(983);\n    var colorPaletteMixin = __webpack_require__(1039);\n    var env = __webpack_require__(978);\n    var layout = __webpack_require__(981);\n\n    var set = classUtil.set;\n    var get = classUtil.get;\n    var encodeHTML = formatUtil.encodeHTML;\n    var addCommas = formatUtil.addCommas;\n\n    var SeriesModel = ComponentModel.extend({\n\n        type: 'series.__base__',\n\n        /**\n         * @readOnly\n         */\n        seriesIndex: 0,\n\n        // coodinateSystem will be injected in the echarts/CoordinateSystem\n        coordinateSystem: null,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * Data provided for legend\n         * @type {Function}\n         */\n        // PENDING\n        legendDataProvider: null,\n\n        /**\n         * Access path of color for visual\n         */\n        visualColorAccessPath: 'itemStyle.normal.color',\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n\n            /**\n             * @type {number}\n             * @readOnly\n             */\n            this.seriesIndex = this.componentIndex;\n\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            var data = this.getInitialData(option, ecModel);\n            if (__DEV__) {\n                zrUtil.assert(data, 'getInitialData returned invalid data.');\n            }\n            /**\n             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n             * @private\n             */\n            set(this, 'dataBeforeProcessed', data);\n\n            // If we reverse the order (make data firstly, and then make\n            // dataBeforeProcessed by cloneShallow), cloneShallow will\n            // cause data.graph.data !== data when using\n            // module:echarts/data/Graph or module:echarts/data/Tree.\n            // See module:echarts/data/helper/linkList\n            this.restoreData();\n        },\n\n        /**\n         * Util for merge default and theme to option\n         * @param  {Object} option\n         * @param  {module:echarts/model/Global} ecModel\n         */\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            // Backward compat: using subType on theme.\n            // But if name duplicate between series subType\n            // (for example: parallel) add component mainType,\n            // add suffix 'Series'.\n            var themeSubType = this.subType;\n            if (ComponentModel.hasClass(themeSubType)) {\n                themeSubType += 'Series';\n            }\n            zrUtil.merge(\n                option,\n                ecModel.getTheme().get(this.subType)\n            );\n            zrUtil.merge(option, this.getDefaultOption());\n\n            // Default label emphasis `show`\n            modelUtil.defaultEmphasis(option.label, ['show']);\n\n            this.fillDataTextStyle(option.data);\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (newSeriesOption, ecModel) {\n            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n            this.fillDataTextStyle(newSeriesOption.data);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n            }\n\n            var data = this.getInitialData(newSeriesOption, ecModel);\n            // TODO Merge data?\n            if (data) {\n                set(this, 'data', data);\n                set(this, 'dataBeforeProcessed', data.cloneShallow());\n            }\n        },\n\n        fillDataTextStyle: function (data) {\n            // Default data label emphasis `show`\n            // FIXME Tree structure data ?\n            // FIXME Performance ?\n            if (data) {\n                var props = ['show'];\n                for (var i = 0; i < data.length; i++) {\n                    if (data[i] && data[i].label) {\n                        modelUtil.defaultEmphasis(data[i].label, props);\n                    }\n                }\n            }\n        },\n\n        /**\n         * Init a data structure from data related option in series\n         * Must be overwritten\n         */\n        getInitialData: function () {},\n\n        /**\n         * @param {string} [dataType]\n         * @return {module:echarts/data/List}\n         */\n        getData: function (dataType) {\n            var data = get(this, 'data');\n            return dataType == null ? data : data.getLinkedData(dataType);\n        },\n\n        /**\n         * @param {module:echarts/data/List} data\n         */\n        setData: function (data) {\n            set(this, 'data', data);\n        },\n\n        /**\n         * Get data before processed\n         * @return {module:echarts/data/List}\n         */\n        getRawData: function () {\n            return get(this, 'dataBeforeProcessed');\n        },\n\n        /**\n         * Coord dimension to data dimension.\n         *\n         * By default the result is the same as dimensions of series data.\n         * But in some series data dimensions are different from coord dimensions (i.e.\n         * candlestick and boxplot). Override this method to handle those cases.\n         *\n         * Coord dimension to data dimension can be one-to-many\n         *\n         * @param {string} coordDim\n         * @return {Array.<string>} dimensions on the axis.\n         */\n        coordDimToDataDim: function (coordDim) {\n            return modelUtil.coordDimToDataDim(this.getData(), coordDim);\n        },\n\n        /**\n         * Convert data dimension to coord dimension.\n         *\n         * @param {string|number} dataDim\n         * @return {string}\n         */\n        dataDimToCoordDim: function (dataDim) {\n            return modelUtil.dataDimToCoordDim(this.getData(), dataDim);\n        },\n\n        /**\n         * Get base axis if has coordinate system and has axis.\n         * By default use coordSys.getBaseAxis();\n         * Can be overrided for some chart.\n         * @return {type} description\n         */\n        getBaseAxis: function () {\n            var coordSys = this.coordinateSystem;\n            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n        },\n\n        // FIXME\n        /**\n         * Default tooltip formatter\n         *\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         */\n        formatTooltip: function (dataIndex, multipleSeries, dataType) {\n            function formatArrayValue(value) {\n                var vertially = zrUtil.reduce(value, function (vertially, val, idx) {\n                    var dimItem = data.getDimensionInfo(idx);\n                    return vertially |= dimItem && dimItem.tooltip !== false && dimItem.tooltipName != null;\n                }, 0);\n\n                var result = [];\n                var tooltipDims = modelUtil.otherDimToDataDim(data, 'tooltip');\n\n                tooltipDims.length\n                    ? zrUtil.each(tooltipDims, function (dimIdx) {\n                        setEachItem(data.get(dimIdx, dataIndex), dimIdx);\n                    })\n                    // By default, all dims is used on tooltip.\n                    : zrUtil.each(value, setEachItem);\n\n                function setEachItem(val, dimIdx) {\n                    var dimInfo = data.getDimensionInfo(dimIdx);\n                    // If `dimInfo.tooltip` is not set, show tooltip.\n                    if (!dimInfo || dimInfo.otherDims.tooltip === false) {\n                        return;\n                    }\n                    var dimType = dimInfo.type;\n                    var valStr = (vertially ? '- ' + (dimInfo.tooltipName || dimInfo.name) + ': ' : '')\n                        + (dimType === 'ordinal'\n                            ? val + ''\n                            : dimType === 'time'\n                            ? (multipleSeries ? '' : formatUtil.formatTime('yyyy/MM/dd hh:mm:ss', val))\n                            : addCommas(val)\n                        );\n                    valStr && result.push(encodeHTML(valStr));\n                }\n\n                return (vertially ? '<br/>' : '') + result.join(vertially ? '<br/>' : ', ');\n            }\n\n            var data = get(this, 'data');\n\n            var value = this.getRawValue(dataIndex);\n            var formattedValue = zrUtil.isArray(value)\n                ? formatArrayValue(value) : encodeHTML(addCommas(value));\n            var name = data.getName(dataIndex);\n\n            var color = data.getItemVisual(dataIndex, 'color');\n            if (zrUtil.isObject(color) && color.colorStops) {\n                color = (color.colorStops[0] || {}).color;\n            }\n            color = color || 'transparent';\n\n            var colorEl = formatUtil.getTooltipMarker(color);\n\n            var seriesName = this.name;\n            // FIXME\n            if (seriesName === '\\0-') {\n                // Not show '-'\n                seriesName = '';\n            }\n            seriesName = seriesName\n                ? encodeHTML(seriesName) + (!multipleSeries ? '<br/>' : ': ')\n                : '';\n            return !multipleSeries\n                ? seriesName + colorEl\n                    + (name\n                        ? encodeHTML(name) + ': ' + formattedValue\n                        : formattedValue\n                    )\n                : colorEl + seriesName + formattedValue;\n        },\n\n        /**\n         * @return {boolean}\n         */\n        isAnimationEnabled: function () {\n            if (env.node) {\n                return false;\n            }\n\n            var animationEnabled = this.getShallow('animation');\n            if (animationEnabled) {\n                if (this.getData().count() > this.getShallow('animationThreshold')) {\n                    animationEnabled = false;\n                }\n            }\n            return animationEnabled;\n        },\n\n        restoreData: function () {\n            set(this, 'data', get(this, 'dataBeforeProcessed').cloneShallow());\n        },\n\n        getColorFromPalette: function (name, scope) {\n            var ecModel = this.ecModel;\n            // PENDING\n            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n            if (!color) {\n                color = ecModel.getColorFromPalette(name, scope);\n            }\n            return color;\n        },\n\n        /**\n         * Get data indices for show tooltip content. See tooltip.\n         * @abstract\n         * @param {Array.<string>|string} dim\n         * @param {Array.<number>} value\n         * @param {module:echarts/coord/single/SingleAxis} baseAxis\n         * @return {Object} {dataIndices, nestestValue}.\n         */\n        getAxisTooltipData: null,\n\n        /**\n         * See tooltip.\n         * @abstract\n         * @param {number} dataIndex\n         * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n         */\n        getTooltipPosition: null\n    });\n\n    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\n    module.exports = SeriesModel;\n\n\n/***/ }),\n\n/***/ 995:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Complete dimensions by data (guess dimension).\n */\n\n\n    var zrUtil = __webpack_require__(971);\n    var modelUtil = __webpack_require__(975);\n    var each = zrUtil.each;\n    var isString = zrUtil.isString;\n    var defaults = zrUtil.defaults;\n    var normalizeToArray = modelUtil.normalizeToArray;\n\n    var OTHER_DIMS = {tooltip: 1, label: 1, itemName: 1};\n\n    /**\n     * Complete the dimensions array, by user defined `dimension` and `encode`,\n     * and guessing from the data structure.\n     * If no 'value' dimension specified, the first no-named dimension will be\n     * named as 'value'.\n     *\n     * @param {Array.<string>} sysDims Necessary dimensions, like ['x', 'y'], which\n     *      provides not only dim template, but also default order.\n     *      `name` of each item provides default coord name.\n     *      [{dimsDef: []}, ...] can be specified to give names.\n     * @param {Array} data Data list. [[1, 2, 3], [2, 3, 4]].\n     * @param {Object} [opt]\n     * @param {Array.<Object|string>} [opt.dimsDef] option.series.dimensions User defined dimensions\n     *      For example: ['asdf', {name, type}, ...].\n     * @param {Object} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3}\n     * @param {string} [opt.extraPrefix] Prefix of name when filling the left dimensions.\n     * @param {string} [opt.extraFromZero] If specified, extra dim names will be:\n     *                      extraPrefix + 0, extraPrefix + extraBaseIndex + 1 ...\n     *                      If not specified, extra dim names will be:\n     *                      extraPrefix, extraPrefix + 0, extraPrefix + 1 ...\n     * @param {number} [opt.dimCount] If not specified, guess by the first data item.\n     * @return {Array.<Object>} [{\n     *      name: string mandatory,\n     *      coordDim: string mandatory,\n     *      coordDimIndex: number mandatory,\n     *      type: string optional,\n     *      tooltipName: string optional,\n     *      otherDims: {\n     *          tooltip: number optional,\n     *          label: number optional\n     *      },\n     *      isExtraCoord: boolean true or undefined.\n     *      other props ...\n     * }]\n     */\n    function completeDimensions(sysDims, data, opt) {\n        data = data || [];\n        opt = opt || {};\n        sysDims = (sysDims || []).slice();\n        var dimsDef = (opt.dimsDef || []).slice();\n        var encodeDef = zrUtil.createHashMap(opt.encodeDef);\n        var dataDimNameMap = zrUtil.createHashMap();\n        var coordDimNameMap = zrUtil.createHashMap();\n        // var valueCandidate;\n        var result = [];\n\n        var dimCount = opt.dimCount;\n        if (dimCount == null) {\n            var value0 = retrieveValue(data[0]);\n            dimCount = Math.max(\n                zrUtil.isArray(value0) && value0.length || 1,\n                sysDims.length,\n                dimsDef.length\n            );\n            each(sysDims, function (sysDimItem) {\n                var sysDimItemDimsDef = sysDimItem.dimsDef;\n                sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));\n            });\n        }\n\n        // Apply user defined dims (`name` and `type`) and init result.\n        for (var i = 0; i < dimCount; i++) {\n            var dimDefItem = isString(dimsDef[i]) ? {name: dimsDef[i]} : (dimsDef[i] || {});\n            var userDimName = dimDefItem.name;\n            var resultItem = result[i] = {otherDims: {}};\n            // Name will be applied later for avoiding duplication.\n            if (userDimName != null && dataDimNameMap.get(userDimName) == null) {\n                // Only if `series.dimensions` is defined in option, tooltipName\n                // will be set, and dimension will be diplayed vertically in\n                // tooltip by default.\n                resultItem.name = resultItem.tooltipName = userDimName;\n                dataDimNameMap.set(userDimName, i);\n            }\n            dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n        }\n\n        // Set `coordDim` and `coordDimIndex` by `encodeDef` and normalize `encodeDef`.\n        encodeDef.each(function (dataDims, coordDim) {\n            dataDims = encodeDef.set(coordDim, normalizeToArray(dataDims).slice());\n            each(dataDims, function (resultDimIdx, coordDimIndex) {\n                // The input resultDimIdx can be dim name or index.\n                isString(resultDimIdx) && (resultDimIdx = dataDimNameMap.get(resultDimIdx));\n                if (resultDimIdx != null && resultDimIdx < dimCount) {\n                    dataDims[coordDimIndex] = resultDimIdx;\n                    applyDim(result[resultDimIdx], coordDim, coordDimIndex);\n                }\n            });\n        });\n\n        // Apply templetes and default order from `sysDims`.\n        var availDimIdx = 0;\n        each(sysDims, function (sysDimItem, sysDimIndex) {\n            var coordDim;\n            var sysDimItem;\n            var sysDimItemDimsDef;\n            var sysDimItemOtherDims;\n            if (isString(sysDimItem)) {\n                coordDim = sysDimItem;\n                sysDimItem = {};\n            }\n            else {\n                coordDim = sysDimItem.name;\n                sysDimItem = zrUtil.clone(sysDimItem);\n                // `coordDimIndex` should not be set directly.\n                sysDimItemDimsDef = sysDimItem.dimsDef;\n                sysDimItemOtherDims = sysDimItem.otherDims;\n                sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex\n                    = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n            }\n\n            var dataDims = normalizeToArray(encodeDef.get(coordDim));\n            // dimensions provides default dim sequences.\n            if (!dataDims.length) {\n                for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n                    while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {\n                        availDimIdx++;\n                    }\n                    availDimIdx < result.length && dataDims.push(availDimIdx++);\n                }\n            }\n            // Apply templates.\n            each(dataDims, function (resultDimIdx, coordDimIndex) {\n                var resultItem = result[resultDimIdx];\n                applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n                if (resultItem.name == null && sysDimItemDimsDef) {\n                    resultItem.name = resultItem.tooltipName = sysDimItemDimsDef[coordDimIndex];\n                }\n                sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n            });\n        });\n\n        // Make sure the first extra dim is 'value'.\n        var extra = opt.extraPrefix || 'value';\n\n        // Set dim `name` and other `coordDim` and other props.\n        for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n            var resultItem = result[resultDimIdx] = result[resultDimIdx] || {};\n            var coordDim = resultItem.coordDim;\n\n            coordDim == null && (\n                resultItem.coordDim = genName(extra, coordDimNameMap, opt.extraFromZero),\n                resultItem.coordDimIndex = 0,\n                resultItem.isExtraCoord = true\n            );\n\n            resultItem.name == null && (resultItem.name = genName(\n                resultItem.coordDim,\n                dataDimNameMap\n            ));\n\n            resultItem.type == null && guessOrdinal(data, resultDimIdx)\n                && (resultItem.type = 'ordinal');\n        }\n\n        return result;\n\n        function applyDim(resultItem, coordDim, coordDimIndex) {\n            if (OTHER_DIMS[coordDim]) {\n                resultItem.otherDims[coordDim] = coordDimIndex;\n            }\n            else {\n                resultItem.coordDim = coordDim;\n                resultItem.coordDimIndex = coordDimIndex;\n                coordDimNameMap.set(coordDim, true);\n            }\n        }\n\n        function genName(name, map, fromZero) {\n            if (fromZero || map.get(name) != null) {\n                var i = 0;\n                while (map.get(name + i) != null) {\n                    i++;\n                }\n                name += i;\n            }\n            map.set(name, true);\n            return name;\n        }\n    }\n\n    // The rule should not be complex, otherwise user might not\n    // be able to known where the data is wrong.\n    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n        for (var i = 0, len = data.length; i < len; i++) {\n            var value = retrieveValue(data[i]);\n\n            if (!zrUtil.isArray(value)) {\n                return false;\n            }\n\n            var value = value[dimIndex];\n            // Consider usage convenience, '1', '2' will be treated as \"number\".\n            // `isFinit('')` get `true`.\n            if (value != null && isFinite(value) && value !== '') {\n                return false;\n            }\n            else if (isString(value) && value !== '-') {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    function retrieveValue(o) {\n        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;\n    }\n\n    module.exports = completeDimensions;\n\n\n\n/***/ }),\n\n/***/ 996:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Symbol factory\n\n\n    var graphic = __webpack_require__(973);\n    var BoundingRect = __webpack_require__(982);\n\n    /**\n     * Triangle shape\n     * @inner\n     */\n    var Triangle = graphic.extendShape({\n        type: 'triangle',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy + height);\n            path.lineTo(cx - width, cy + height);\n            path.closePath();\n        }\n    });\n    /**\n     * Diamond shape\n     * @inner\n     */\n    var Diamond = graphic.extendShape({\n        type: 'diamond',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy);\n            path.lineTo(cx, cy + height);\n            path.lineTo(cx - width, cy);\n            path.closePath();\n        }\n    });\n\n    /**\n     * Pin shape\n     * @inner\n     */\n    var Pin = graphic.extendShape({\n        type: 'pin',\n        shape: {\n            // x, y on the cusp\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (path, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var w = shape.width / 5 * 3;\n            // Height must be larger than width\n            var h = Math.max(w, shape.height);\n            var r = w / 2;\n\n            // Dist on y with tangent point and circle center\n            var dy = r * r / (h - r);\n            var cy = y - h + r + dy;\n            var angle = Math.asin(dy / r);\n            // Dist on x with tangent point and circle center\n            var dx = Math.cos(angle) * r;\n\n            var tanX = Math.sin(angle);\n            var tanY = Math.cos(angle);\n\n            path.arc(\n                x, cy, r,\n                Math.PI - angle,\n                Math.PI * 2 + angle\n            );\n\n            var cpLen = r * 0.6;\n            var cpLen2 = r * 0.7;\n            path.bezierCurveTo(\n                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\n                x, y - cpLen2,\n                x, y\n            );\n            path.bezierCurveTo(\n                x, y - cpLen2,\n                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\n                x - dx, cy + dy\n            );\n            path.closePath();\n        }\n    });\n\n    /**\n     * Arrow shape\n     * @inner\n     */\n    var Arrow = graphic.extendShape({\n\n        type: 'arrow',\n\n        shape: {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var height = shape.height;\n            var width = shape.width;\n            var x = shape.x;\n            var y = shape.y;\n            var dx = width / 3 * 2;\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + dx, y + height);\n            ctx.lineTo(x, y + height / 4 * 3);\n            ctx.lineTo(x - dx, y + height);\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n    });\n\n    /**\n     * Map of path contructors\n     * @type {Object.<string, module:zrender/graphic/Path>}\n     */\n    var symbolCtors = {\n        line: graphic.Line,\n\n        rect: graphic.Rect,\n\n        roundRect: graphic.Rect,\n\n        square: graphic.Rect,\n\n        circle: graphic.Circle,\n\n        diamond: Diamond,\n\n        pin: Pin,\n\n        arrow: Arrow,\n\n        triangle: Triangle\n    };\n\n    var symbolShapeMakers = {\n\n        line: function (x, y, w, h, shape) {\n            // FIXME\n            shape.x1 = x;\n            shape.y1 = y + h / 2;\n            shape.x2 = x + w;\n            shape.y2 = y + h / 2;\n        },\n\n        rect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        roundRect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n            shape.r = Math.min(w, h) / 4;\n        },\n\n        square: function (x, y, w, h, shape) {\n            var size = Math.min(w, h);\n            shape.x = x;\n            shape.y = y;\n            shape.width = size;\n            shape.height = size;\n        },\n\n        circle: function (x, y, w, h, shape) {\n            // Put circle in the center of square\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.r = Math.min(w, h) / 2;\n        },\n\n        diamond: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        pin: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        arrow: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        triangle: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        }\n    };\n\n    var symbolBuildProxies = {};\n    for (var name in symbolCtors) {\n        if (symbolCtors.hasOwnProperty(name)) {\n            symbolBuildProxies[name] = new symbolCtors[name]();\n        }\n    }\n\n    var Symbol = graphic.extendShape({\n\n        type: 'symbol',\n\n        shape: {\n            symbolType: '',\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        beforeBrush: function () {\n            var style = this.style;\n            var shape = this.shape;\n            // FIXME\n            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n                style.textPosition = ['50%', '40%'];\n                style.textAlign = 'center';\n                style.textVerticalAlign = 'middle';\n            }\n        },\n\n        buildPath: function (ctx, shape, inBundle) {\n            var symbolType = shape.symbolType;\n            var proxySymbol = symbolBuildProxies[symbolType];\n            if (shape.symbolType !== 'none') {\n                if (!proxySymbol) {\n                    // Default rect\n                    symbolType = 'rect';\n                    proxySymbol = symbolBuildProxies[symbolType];\n                }\n                symbolShapeMakers[symbolType](\n                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\n                );\n                proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n            }\n        }\n    });\n\n    // Provide setColor helper method to avoid determine if set the fill or stroke outside\n    var symbolPathSetColor = function (color) {\n        if (this.type !== 'image') {\n            var symbolStyle = this.style;\n            var symbolShape = this.shape;\n            if (symbolShape && symbolShape.symbolType === 'line') {\n                symbolStyle.stroke = color;\n            }\n            else if (this.__isEmptyBrush) {\n                symbolStyle.stroke = color;\n                symbolStyle.fill = '#fff';\n            }\n            else {\n                // FIXME  onlyStroke ?\n                symbolStyle.fill && (symbolStyle.fill = color);\n                symbolStyle.stroke && (symbolStyle.stroke = color);\n            }\n            this.dirty(false);\n        }\n    };\n\n    var symbolUtil = {\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @param {string} symbolType\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: function (symbolType, x, y, w, h, color) {\n            // TODO Support image object, DynamicImage.\n\n            var isEmpty = symbolType.indexOf('empty') === 0;\n            if (isEmpty) {\n                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n            }\n            var symbolPath;\n\n            if (symbolType.indexOf('image://') === 0) {\n                symbolPath = new graphic.Image({\n                    style: {\n                        image: symbolType.slice(8),\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n            else if (symbolType.indexOf('path://') === 0) {\n                symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));\n            }\n            else {\n                symbolPath = new Symbol({\n                    shape: {\n                        symbolType: symbolType,\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n\n            symbolPath.__isEmptyBrush = isEmpty;\n\n            symbolPath.setColor = symbolPathSetColor;\n\n            symbolPath.setColor(color);\n\n            return symbolPath;\n        }\n    };\n\n    module.exports = symbolUtil;\n\n\n/***/ }),\n\n/***/ 997:\n/***/ (function(module, exports) {\n\n\n\n    module.exports = {\n        toolbox: {\n            brush: {\n                title: {\n                    rect: '',\n                    polygon: '',\n                    lineX: '',\n                    lineY: '',\n                    keep: '',\n                    clear: ''\n                }\n            },\n            dataView: {\n                title: '',\n                lang: ['', '', '']\n            },\n            dataZoom: {\n                title: {\n                    zoom: '',\n                    back: ''\n                }\n            },\n            magicType: {\n                title: {\n                    line: '',\n                    bar: '',\n                    stack: '',\n                    tiled: ''\n                }\n            },\n            restore: {\n                title: ''\n            },\n            saveAsImage: {\n                title: '',\n                lang: ['']\n            }\n        }\n    };\n\n\n\n/***/ }),\n\n/***/ 998:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\n    var zrUtil = __webpack_require__(971);\n\n    var coordinateSystemCreators = {};\n\n    function CoordinateSystemManager() {\n\n        this._coordinateSystems = [];\n    }\n\n    CoordinateSystemManager.prototype = {\n\n        constructor: CoordinateSystemManager,\n\n        create: function (ecModel, api) {\n            var coordinateSystems = [];\n            zrUtil.each(coordinateSystemCreators, function (creater, type) {\n                var list = creater.create(ecModel, api);\n                coordinateSystems = coordinateSystems.concat(list || []);\n            });\n\n            this._coordinateSystems = coordinateSystems;\n        },\n\n        update: function (ecModel, api) {\n            zrUtil.each(this._coordinateSystems, function (coordSys) {\n                // FIXME MUST have\n                coordSys.update && coordSys.update(ecModel, api);\n            });\n        },\n\n        getCoordinateSystems: function () {\n            return this._coordinateSystems.slice();\n        }\n    };\n\n    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n        coordinateSystemCreators[type] = coordinateSystemCreator;\n    };\n\n    CoordinateSystemManager.get = function (type) {\n        return coordinateSystemCreators[type];\n    };\n\n    module.exports = CoordinateSystemManager;\n\n\n/***/ }),\n\n/***/ 999:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Path `buildPath``ctx`, pathpathCommands\n *  isInsidePath boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n // TODO getTotalLength, getPointAtLength\n\n\n    var curve = __webpack_require__(991);\n    var vec2 = __webpack_require__(976);\n    var bbox = __webpack_require__(1048);\n    var BoundingRect = __webpack_require__(982);\n    var dpr = __webpack_require__(1000).devicePixelRatio;\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        // Rect\n        R: 7\n    };\n\n    // var CMD_MEM_SIZE = {\n    //     M: 3,\n    //     L: 3,\n    //     C: 7,\n    //     Q: 5,\n    //     A: 9,\n    //     R: 5,\n    //     Z: 1\n    // };\n\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n\n    var hasTypedArray = typeof Float32Array != 'undefined';\n\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function (notSaveData) {\n\n        this._saveData = !(notSaveData || false);\n\n        if (this._saveData) {\n            /**\n             * Path data. Stored as flat array\n             * @type {Array.<Object>}\n             */\n            this.data = [];\n        }\n\n        this._ctx = null;\n    };\n\n    /**\n     * Path\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n\n        constructor: PathProxy,\n\n        _xi: 0,\n        _yi: 0,\n\n        _x0: 0,\n        _y0: 0,\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        _ux: 0,\n        _uy: 0,\n\n        _len: 0,\n\n        _lineDash: null,\n\n        _dashOffset: 0,\n\n        _dashIdx: 0,\n\n        _dashSum: 0,\n\n        /**\n         * @readOnly\n         */\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n\n        getContext: function () {\n            return this._ctx;\n        },\n\n        /**\n         * @param  {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        beginPath: function (ctx) {\n\n            this._ctx = ctx;\n\n            ctx && ctx.beginPath();\n\n            ctx && (this.dpr = ctx.dpr);\n\n            // Reset\n            if (this._saveData) {\n                this._len = 0;\n            }\n\n            if (this._lineDash) {\n                this._lineDash = null;\n\n                this._dashOffset = 0;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n\n            // x0, y0, xi, yi  _dashedXXXXTo \n            // xi, yi , x0, y0  closePath \n            //  beginPath  lineTo x0, y0 \n            //  lineTo dashed line  IE10- \n            this._x0 = x;\n            this._y0 = y;\n\n            this._xi = x;\n            this._yi = y;\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux\n                || mathAbs(y - this._yi) > this._uy\n                // Force draw the first segment\n                || this._len < 5;\n\n            this.addData(CMD.L, x, y);\n\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @param  {number} x3\n         * @param  {number} y3\n         * @return {module:zrender/core/PathProxy}\n         */\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @return {module:zrender/core/PathProxy}\n         */\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n\n        /**\n         * @param  {number} cx\n         * @param  {number} cy\n         * @param  {number} r\n         * @param  {number} startAngle\n         * @param  {number} endAngle\n         * @param  {boolean} anticlockwise\n         * @return {module:zrender/core/PathProxy}\n         */\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(\n                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n            );\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n            this._xi = mathCos(endAngle) * r + cx;\n            this._yi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n\n        // TODO\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n\n        // TODO\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/PathProxy}\n         */\n        closePath: function () {\n            this.addData(CMD.Z);\n\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n\n        /**\n         * Context  rebuildPath  fill\n         * stroke \n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n\n                this._dashIdx = 0;\n\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n\n        /**\n         *\n         * @return {boolean}\n         */\n        len: function () {\n            return this._len;\n        },\n\n        /**\n         *  Path \n         */\n        setData: function (data) {\n\n            var len = data.length;\n\n            if (! (this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n\n            this._len = len;\n        },\n\n        /**\n         * \n         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n         */\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n\n        /**\n         *  Path \n         * \n         */\n        addData: function (cmd) {\n            if (!this._saveData) {\n                return;\n            }\n\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                //  Float32Array\n                // \n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n\n            this._prevCmd = cmd;\n        },\n\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n\n        /**\n         * If needs js implemented dashed line\n         * @return {boolean}\n         * @private\n         */\n        _needsDash: function () {\n            return this._lineDash;\n        },\n\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n\n            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n                );\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        // Not accurate dashed line to\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n\n            var x;\n            var y;\n\n            var tmpLen = 0;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n\n            while (t <= 1) {\n\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n\n                t += lineDash[idx] / bezierLen;\n\n                idx = (idx + 1) % nDash;\n            }\n\n            // Finish the last segment and calculate the new offset\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n\n        /**\n         *  Float32Array \n         * Convert dynamic array to static Float32Array\n         */\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = data[i];\n                    yi = data[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n\n                switch (cmd) {\n                    case CMD.M:\n                        // moveTo  subpath, \n                        //  closePath \n                        x0 = data[i++];\n                        y0 = data[i++];\n                        xi = x0;\n                        yi = y0;\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        bbox.fromCubic(\n                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        bbox.fromQuadratic(\n                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        // TODO Arc \n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        // TODO Arc \n                        var psi = data[i++];\n                        var anticlockwise = 1 - data[i++];\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(startAngle) * rx + cx;\n                            y0 = mathSin(startAngle) * ry + cy;\n                        }\n\n                        bbox.fromArc(\n                            cx, cy, rx, ry, startAngle, endAngle,\n                            anticlockwise, min2, max2\n                        );\n\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        // Use fromLine\n                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n\n            return new BoundingRect(\n                min[0], min[1], max[0] - min[0], max[1] - min[1]\n            );\n        },\n\n        /**\n         * Rebuild path from current data\n         * Rebuild path will not consider javascript implemented line dash.\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = d[i];\n                    yi = d[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        x0 = xi = d[i++];\n                        y0 = yi = d[i++];\n                        ctx.moveTo(xi, yi);\n                        break;\n                    case CMD.L:\n                        x = d[i++];\n                        y = d[i++];\n                        // Not draw too small seg between\n                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                            ctx.lineTo(x, y);\n                            xi = x;\n                            yi = y;\n                        }\n                        break;\n                    case CMD.C:\n                        ctx.bezierCurveTo(\n                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                        );\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.Q:\n                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var theta = d[i++];\n                        var dTheta = d[i++];\n                        var psi = d[i++];\n                        var fs = d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var scaleX = (rx > ry) ? 1 : rx / ry;\n                        var scaleY = (rx > ry) ? ry / rx : 1;\n                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n                        var endAngle = theta + dTheta;\n                        if (isEllipse) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                        }\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(theta) * rx + cx;\n                            y0 = mathSin(theta) * ry + cy;\n                        }\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = d[i];\n                        y0 = yi = d[i + 1];\n                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.Z:\n                        ctx.closePath();\n                        xi = x0;\n                        yi = y0;\n                }\n            }\n        }\n    };\n\n    PathProxy.CMD = CMD;\n\n    module.exports = PathProxy;\n\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/PieReact.b38c3709.chunk.js","\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config\n     * @exports zrender/config\n     * @author Kener (@Kener-, kener.linfeng@gmail.com)\n     */\n    var config = {\n        /**\n         * debugcatchBrushExceptiontrue\n         * 0 : debug\n         * 1 : \n         * 2 : \n         */\n        debugMode: 0,\n\n        // retina \n        devicePixelRatio: dpr\n    };\n    module.exports = config;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/config.js\n// module id = 1000\n// module chunks = 0 1 2","/**\n * GroupGroup\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/lib/container/Group');\n *     var Circle = require('zrender/lib/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n\n    var zrUtil = require('../core/util');\n    var Element = require('../Element');\n    var BoundingRect = require('../core/BoundingRect');\n\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        for (var key in opts) {\n            if (opts.hasOwnProperty(key)) {\n                this[key] = opts[key];\n            }\n        }\n\n        this._children = [];\n\n        this.__storage = null;\n\n        this.__dirty = true;\n    };\n\n    Group.prototype = {\n\n        constructor: Group,\n\n        isGroup: true,\n\n        /**\n         * @type {string}\n         */\n        type: 'group',\n\n        /**\n         * \n         * @name module:/zrender/container/Group#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * @return {Array.<module:zrender/Element>}\n         */\n        children: function () {\n            return this._children.slice();\n        },\n\n        /**\n         *  index \n         * @param  {number} idx\n         * @return {module:zrender/Element}\n         */\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n\n        /**\n         * \n         * @param  {string} name\n         * @return {module:zrender/Element}\n         */\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n             }\n        },\n\n        /**\n         * @return {number}\n         */\n        childCount: function () {\n            return this._children.length;\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n\n                this._children.push(child);\n\n                this._doAdd(child);\n            }\n\n            return this;\n        },\n\n        /**\n         *  nextSibling \n         * @param {module:zrender/Element} child\n         * @param {module:zrender/Element} nextSibling\n         */\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n\n            return this;\n        },\n\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n\n            child.parent = this;\n\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n\n                storage.addToStorage(child);\n\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n        },\n\n        /**\n         * \n         * @param {module:zrender/Element} child\n         */\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n\n            child.parent = null;\n\n            if (storage) {\n\n                storage.delFromStorage(child);\n\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n\n            return this;\n        },\n\n        /**\n         * \n         */\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromStorage(child);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n\n        /**\n         * \n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToStorage(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromStorage(child);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                // TODO\n                // The boundingRect cacluated by transforming original\n                // rect may be bigger than the actual bundingRect when rotation\n                // is used. (Consider a circle rotated aginst its center, where\n                // the actual boundingRect should be the same as that not be\n                // rotated.) But we can not find better approach to calculate\n                // actual boundingRect yet, considering performance.\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n\n    zrUtil.inherits(Group, Element);\n\n    module.exports = Group;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/container/Group.js\n// module id = 1001\n// module chunks = 0 1 2","\n\n    var Group = require('zrender/lib/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var modelUtil = require('../util/model');\n    var zrUtil = require('zrender/lib/core/util');\n\n    function Chart() {\n\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewChart');\n    }\n\n    Chart.prototype = {\n\n        type: 'chart',\n\n        /**\n         * Init the chart\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        init: function (ecModel, api) {},\n\n        /**\n         * Render the chart\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        render: function (seriesModel, ecModel, api, payload) {},\n\n        /**\n         * Highlight series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        highlight: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n        },\n\n        /**\n         * Downplay series or specified data item\n         * @param  {module:echarts/model/Series} seriesModel\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         * @param  {Object} payload\n         */\n        downplay: function (seriesModel, ecModel, api, payload) {\n            toggleHighlight(seriesModel.getData(), payload, 'normal');\n        },\n\n        /**\n         * Remove self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        remove: function (ecModel, api) {\n            this.group.removeAll();\n        },\n\n        /**\n         * Dispose self\n         * @param  {module:echarts/model/Global} ecModel\n         * @param  {module:echarts/ExtensionAPI} api\n         */\n        dispose: function () {}\n\n        /**\n         * The view contains the given point.\n         * @interface\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        // containPoint: function () {}\n\n    };\n\n    var chartProto = Chart.prototype;\n    chartProto.updateView\n        = chartProto.updateLayout\n        = chartProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            this.render(seriesModel, ecModel, api, payload);\n        };\n\n    /**\n     * Set state of single element\n     * @param  {module:zrender/Element} el\n     * @param  {string} state\n     */\n    function elSetState(el, state) {\n        if (el) {\n            el.trigger(state);\n            if (el.type === 'group') {\n                for (var i = 0; i < el.childCount(); i++) {\n                    elSetState(el.childAt(i), state);\n                }\n            }\n        }\n    }\n    /**\n     * @param  {module:echarts/data/List} data\n     * @param  {Object} payload\n     * @param  {string} state 'normal'|'emphasis'\n     * @inner\n     */\n    function toggleHighlight(data, payload, state) {\n        var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n        if (dataIndex != null) {\n            zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {\n                elSetState(data.getItemGraphicEl(dataIdx), state);\n            });\n        }\n        else {\n            data.eachItemGraphicEl(function (el) {\n                elSetState(el, state);\n            });\n        }\n    }\n\n    // Enable Chart.extend.\n    clazzUtil.enableClassExtend(Chart, ['dispose']);\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Chart, {registerWhenExtend: true});\n\n    module.exports = Chart;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/view/Chart.js\n// module id = 1002\n// module chunks = 0 1 2","'use strict';\n\n\n    function defaultKeyGetter(item) {\n        return item;\n    }\n\n    /**\n     * @param {Array} oldArr\n     * @param {Array} newArr\n     * @param {Function} oldKeyGetter\n     * @param {Function} newKeyGetter\n     * @param {Object} [context] Can be visited by this.context in callback.\n     */\n    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context) {\n        this._old = oldArr;\n        this._new = newArr;\n\n        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n\n        this.context = context;\n    }\n\n    DataDiffer.prototype = {\n\n        constructor: DataDiffer,\n\n        /**\n         * Callback function when add a data\n         */\n        add: function (func) {\n            this._add = func;\n            return this;\n        },\n\n        /**\n         * Callback function when update a data\n         */\n        update: function (func) {\n            this._update = func;\n            return this;\n        },\n\n        /**\n         * Callback function when remove a data\n         */\n        remove: function (func) {\n            this._remove = func;\n            return this;\n        },\n\n        execute: function () {\n            var oldArr = this._old;\n            var newArr = this._new;\n\n            var oldDataIndexMap = {};\n            var newDataIndexMap = {};\n            var oldDataKeyArr = [];\n            var newDataKeyArr = [];\n            var i;\n\n            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter', this);\n            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter', this);\n\n            // Travel by inverted order to make sure order consistency\n            // when duplicate keys exists (consider newDataIndex.pop() below).\n            // For performance consideration, these code below do not look neat.\n            for (i = 0; i < oldArr.length; i++) {\n                var key = oldDataKeyArr[i];\n                var idx = newDataIndexMap[key];\n\n                // idx can never be empty array here. see 'set null' logic below.\n                if (idx != null) {\n                    // Consider there is duplicate key (for example, use dataItem.name as key).\n                    // We should make sure every item in newArr and oldArr can be visited.\n                    var len = idx.length;\n                    if (len) {\n                        len === 1 && (newDataIndexMap[key] = null);\n                        idx = idx.unshift();\n                    }\n                    else {\n                        newDataIndexMap[key] = null;\n                    }\n                    this._update && this._update(idx, i);\n                }\n                else {\n                    this._remove && this._remove(i);\n                }\n            }\n\n            for (var i = 0; i < newDataKeyArr.length; i++) {\n                var key = newDataKeyArr[i];\n                if (newDataIndexMap.hasOwnProperty(key)) {\n                    var idx = newDataIndexMap[key];\n                    if (idx == null) {\n                        continue;\n                    }\n                    // idx can never be empty array here. see 'set null' logic above.\n                    if (!idx.length) {\n                        this._add && this._add(idx);\n                    }\n                    else {\n                        for (var j = 0, len = idx.length; j < len; j++) {\n                            this._add && this._add(idx[j]);\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    function initIndexMap(arr, map, keyArr, keyGetterName, dataDiffer) {\n        for (var i = 0; i < arr.length; i++) {\n            // Add prefix to avoid conflict with Object.prototype.\n            var key = '_ec_' + dataDiffer[keyGetterName](arr[i], i);\n            var existence = map[key];\n            if (existence == null) {\n                keyArr.push(key);\n                map[key] = i;\n            }\n            else {\n                if (!existence.length) {\n                    map[key] = existence = [existence];\n                }\n                existence.push(i);\n            }\n        }\n    }\n\n    module.exports = DataDiffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/data/DataDiffer.js\n// module id = 1003\n// module chunks = 0 1 2","/**\n * // Scale class management\n * @module echarts/scale/Scale\n */\n\n\n    var clazzUtil = require('../util/clazz');\n\n    /**\n     * @param {Object} [setting]\n     */\n    function Scale(setting) {\n        this._setting = setting || {};\n\n        /**\n         * Extent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._extent = [Infinity, -Infinity];\n\n        /**\n         * Step is calculated in adjustExtent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._interval = 0;\n\n        this.init && this.init.apply(this, arguments);\n    }\n\n    var scaleProto = Scale.prototype;\n\n    /**\n     * Parse input val to valid inner number.\n     * @param {*} val\n     * @return {number}\n     */\n    scaleProto.parse = function (val) {\n        // Notice: This would be a trap here, If the implementation\n        // of this method depends on extent, and this method is used\n        // before extent set (like in dataZoom), it would be wrong.\n        // Nevertheless, parse does not depend on extent generally.\n        return val;\n    };\n\n    scaleProto.getSetting = function (name) {\n        return this._setting[name];\n    };\n\n    scaleProto.contain = function (val) {\n        var extent = this._extent;\n        return val >= extent[0] && val <= extent[1];\n    };\n\n    /**\n     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.normalize = function (val) {\n        var extent = this._extent;\n        if (extent[1] === extent[0]) {\n            return 0.5;\n        }\n        return (val - extent[0]) / (extent[1] - extent[0]);\n    };\n\n    /**\n     * Scale normalized value\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.scale = function (val) {\n        var extent = this._extent;\n        return val * (extent[1] - extent[0]) + extent[0];\n    };\n\n    /**\n     * Set extent from data\n     * @param {Array.<number>} other\n     */\n    scaleProto.unionExtent = function (other) {\n        var extent = this._extent;\n        other[0] < extent[0] && (extent[0] = other[0]);\n        other[1] > extent[1] && (extent[1] = other[1]);\n        // not setExtent because in log axis it may transformed to power\n        // this.setExtent(extent[0], extent[1]);\n    };\n\n    /**\n     * Set extent from data\n     * @param {module:echarts/data/List} data\n     * @param {string} dim\n     */\n    scaleProto.unionExtentFromData = function (data, dim) {\n        this.unionExtent(data.getDataExtent(dim, true));\n    };\n\n    /**\n     * Get extent\n     * @return {Array.<number>}\n     */\n    scaleProto.getExtent = function () {\n        return this._extent.slice();\n    };\n\n    /**\n     * Set extent\n     * @param {number} start\n     * @param {number} end\n     */\n    scaleProto.setExtent = function (start, end) {\n        var thisExtent = this._extent;\n        if (!isNaN(start)) {\n            thisExtent[0] = start;\n        }\n        if (!isNaN(end)) {\n            thisExtent[1] = end;\n        }\n    };\n\n    /**\n     * @return {Array.<string>}\n     */\n    scaleProto.getTicksLabels = function () {\n        var labels = [];\n        var ticks = this.getTicks();\n        for (var i = 0; i < ticks.length; i++) {\n            labels.push(this.getLabel(ticks[i]));\n        }\n        return labels;\n    };\n\n    /**\n     * When axis extent depends on data and no data exists,\n     * axis ticks should not be drawn, which is named 'blank'.\n     */\n    scaleProto.isBlank = function () {\n        return this._isBlank;\n    },\n\n    /**\n     * When axis extent depends on data and no data exists,\n     * axis ticks should not be drawn, which is named 'blank'.\n     */\n    scaleProto.setBlank = function (isBlank) {\n        this._isBlank = isBlank;\n    };\n\n\n    clazzUtil.enableClassExtend(Scale);\n    clazzUtil.enableClassManagement(Scale, {\n        registerWhenExtend: true\n    });\n\n    module.exports = Scale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/scale/Scale.js\n// module id = 1004\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Model = require('../../model/Model');\n    var each = zrUtil.each;\n    var curry = zrUtil.curry;\n\n    var helper = {};\n\n    // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n    // allAxesInfo should be updated when setOption performed.\n    helper.collect = function (ecModel, api) {\n        var result = {\n            /**\n             * key: makeKey(axis.model)\n             * value: {\n             *      axis,\n             *      coordSys,\n             *      axisPointerModel,\n             *      triggerTooltip,\n             *      involveSeries,\n             *      snap,\n             *      seriesModels,\n             *      seriesDataCount\n             * }\n             */\n            axesInfo: {},\n            seriesInvolved: false,\n            /**\n             * key: makeKey(coordSys.model)\n             * value: Object: key makeKey(axis.model), value: axisInfo\n             */\n            coordSysAxesInfo: {},\n            coordSysMap: {}\n        };\n\n        collectAxesInfo(result, ecModel, api);\n\n        // Check seriesInvolved for performance, in case too many series in some chart.\n        result.seriesInvolved && collectSeriesInfo(result, ecModel);\n\n        return result;\n    };\n\n    function collectAxesInfo(result, ecModel, api) {\n        var globalTooltipModel = ecModel.getComponent('tooltip');\n        var globalAxisPointerModel = ecModel.getComponent('axisPointer');\n        // links can only be set on global.\n        var linksOption = globalAxisPointerModel.get('link', true) || [];\n        var linkGroups = [];\n\n        // Collect axes info.\n        each(api.getCoordinateSystems(), function (coordSys) {\n            // Some coordinate system do not support axes, like geo.\n            if (!coordSys.axisPointerEnabled) {\n                return;\n            }\n\n            var coordSysKey = makeKey(coordSys.model);\n            var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};\n            result.coordSysMap[coordSysKey] = coordSys;\n\n            // Set tooltip (like 'cross') is a convienent way to show axisPointer\n            // for user. So we enable seting tooltip on coordSys model.\n            var coordSysModel = coordSys.model;\n            var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);\n\n            each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null));\n\n            // If axis tooltip used, choose tooltip axis for each coordSys.\n            // Notice this case: coordSys is `grid` but not `cartesian2D` here.\n            if (coordSys.getTooltipAxes\n                && globalTooltipModel\n                // If tooltip.showContent is set as false, tooltip will not\n                // show but axisPointer will show as normal.\n                && baseTooltipModel.get('show')\n            ) {\n                // Compatible with previous logic. But series.tooltip.trigger: 'axis'\n                // or series.data[n].tooltip.trigger: 'axis' are not support any more.\n                var triggerAxis = baseTooltipModel.get('trigger') === 'axis';\n                var cross = baseTooltipModel.get('axisPointer.type') === 'cross';\n                var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis'));\n                if (triggerAxis || cross) {\n                    each(tooltipAxes.baseAxes, curry(\n                        saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis\n                    ));\n                }\n                if (cross) {\n                    each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, 'cross', false));\n                }\n            }\n\n            // fromTooltip: true | false | 'cross'\n            // triggerTooltip: true | false | null\n            function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {\n                var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);\n\n                var axisPointerShow = axisPointerModel.get('show');\n                if (!axisPointerShow || (\n                    axisPointerShow === 'auto'\n                    && !fromTooltip\n                    && !isHandleTrigger(axisPointerModel)\n                )) {\n                    return;\n                }\n\n                if (triggerTooltip == null) {\n                    triggerTooltip = axisPointerModel.get('triggerTooltip');\n                }\n\n                axisPointerModel = fromTooltip\n                    ? makeAxisPointerModel(\n                        axis, baseTooltipModel, globalAxisPointerModel, ecModel,\n                        fromTooltip, triggerTooltip\n                    )\n                    : axisPointerModel;\n\n                var snap = axisPointerModel.get('snap');\n                var key = makeKey(axis.model);\n                var involveSeries = triggerTooltip || snap || axis.type === 'category';\n\n                // If result.axesInfo[key] exist, override it (tooltip has higher priority).\n                var axisInfo = result.axesInfo[key] = {\n                    key: key,\n                    axis: axis,\n                    coordSys: coordSys,\n                    axisPointerModel: axisPointerModel,\n                    triggerTooltip: triggerTooltip,\n                    involveSeries: involveSeries,\n                    snap: snap,\n                    useHandle: isHandleTrigger(axisPointerModel),\n                    seriesModels: []\n                };\n                axesInfoInCoordSys[key] = axisInfo;\n                result.seriesInvolved |= involveSeries;\n\n                var groupIndex = getLinkGroupIndex(linksOption, axis);\n                if (groupIndex != null) {\n                    var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {axesInfo: {}});\n                    linkGroup.axesInfo[key] = axisInfo;\n                    linkGroup.mapper = linksOption[groupIndex].mapper;\n                    axisInfo.linkGroup = linkGroup;\n                }\n            }\n        });\n    }\n\n    function makeAxisPointerModel(\n        axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip\n    ) {\n        var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');\n        var volatileOption = {};\n\n        each(\n            [\n                'type', 'snap', 'lineStyle', 'shadowStyle', 'label',\n                'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'\n            ],\n            function (field) {\n                volatileOption[field] = zrUtil.clone(tooltipAxisPointerModel.get(field));\n            }\n        );\n\n        // category axis do not auto snap, otherwise some tick that do not\n        // has value can not be hovered. value/time/log axis default snap if\n        // triggered from tooltip and trigger tooltip.\n        volatileOption.snap = axis.type !== 'category' && !!triggerTooltip;\n\n        // Compatibel with previous behavior, tooltip axis do not show label by default.\n        // Only these properties can be overrided from tooltip to axisPointer.\n        if (tooltipAxisPointerModel.get('type') === 'cross') {\n            volatileOption.type = 'line';\n        }\n        var labelOption = volatileOption.label || (volatileOption.label = {});\n        // Follow the convention, do not show label when triggered by tooltip by default.\n        labelOption.show == null && (labelOption.show = false);\n\n        if (fromTooltip === 'cross') {\n            // When 'cross', both axes show labels.\n            labelOption.show = true;\n            // If triggerTooltip, this is a base axis, which should better not use cross style\n            // (cross style is dashed by default)\n            if (!triggerTooltip) {\n                var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');\n                crossStyle && zrUtil.defaults(labelOption, crossStyle.textStyle);\n            }\n        }\n\n        return axis.model.getModel(\n            'axisPointer',\n            new Model(volatileOption, globalAxisPointerModel, ecModel)\n        );\n    }\n\n    function collectSeriesInfo(result, ecModel) {\n        // Prepare data for axis trigger\n        ecModel.eachSeries(function (seriesModel) {\n\n            // Notice this case: this coordSys is `cartesian2D` but not `grid`.\n            var coordSys = seriesModel.coordinateSystem;\n            var seriesTooltipTrigger = seriesModel.get('tooltip.trigger', true);\n            var seriesTooltipShow = seriesModel.get('tooltip.show', true);\n            if (!coordSys\n                || seriesTooltipTrigger === 'none'\n                || seriesTooltipTrigger === false\n                || seriesTooltipTrigger === 'item'\n                || seriesTooltipShow === false\n                || seriesModel.get('axisPointer.show', true) === false\n            ) {\n                return;\n            }\n\n            each(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {\n                var axis = axisInfo.axis;\n                if (coordSys.getAxis(axis.dim) === axis) {\n                    axisInfo.seriesModels.push(seriesModel);\n                    axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);\n                    axisInfo.seriesDataCount += seriesModel.getData().count();\n                }\n            });\n\n        }, this);\n    }\n\n    /**\n     * For example:\n     * {\n     *     axisPointer: {\n     *         links: [{\n     *             xAxisIndex: [2, 4],\n     *             yAxisIndex: 'all'\n     *         }, {\n     *             xAxisId: ['a5', 'a7'],\n     *             xAxisName: 'xxx'\n     *         }]\n     *     }\n     * }\n     */\n    function getLinkGroupIndex(linksOption, axis) {\n        var axisModel = axis.model;\n        var dim = axis.dim;\n        for (var i = 0; i < linksOption.length; i++) {\n            var linkOption = linksOption[i] || {};\n            if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id)\n                || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex)\n                || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)\n            ) {\n                return i;\n            }\n        }\n    }\n\n    function checkPropInLink(linkPropValue, axisPropValue) {\n        return linkPropValue === 'all'\n            || (zrUtil.isArray(linkPropValue) && zrUtil.indexOf(linkPropValue, axisPropValue) >= 0)\n            || linkPropValue === axisPropValue;\n    }\n\n    helper.fixValue = function (axisModel) {\n        var axisInfo = helper.getAxisInfo(axisModel);\n        if (!axisInfo) {\n            return;\n        }\n\n        var axisPointerModel = axisInfo.axisPointerModel;\n        var scale = axisInfo.axis.scale;\n        var option = axisPointerModel.option;\n        var status = axisPointerModel.get('status');\n        var value = axisPointerModel.get('value');\n\n        // Parse init value for category and time axis.\n        if (value != null) {\n            value = scale.parse(value);\n        }\n\n        var useHandle = isHandleTrigger(axisPointerModel);\n        // If `handle` used, `axisPointer` will always be displayed, so value\n        // and status should be initialized.\n        if (status == null) {\n            option.status = useHandle ? 'show' : 'hide';\n        }\n\n        var extent = scale.getExtent().slice();\n        extent[0] > extent[1] && extent.reverse();\n\n        if (// Pick a value on axis when initializing.\n            value == null\n            // If both `handle` and `dataZoom` are used, value may be out of axis extent,\n            // where we should re-pick a value to keep `handle` displaying normally.\n            || value > extent[1]\n        ) {\n            // Make handle displayed on the end of the axis when init, which looks better.\n            value = extent[1];\n        }\n        if (value < extent[0]) {\n            value = extent[0];\n        }\n\n        option.value = value;\n\n        if (useHandle) {\n            option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';\n        }\n    };\n\n    helper.getAxisInfo = function (axisModel) {\n        var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;\n        return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];\n    };\n\n    helper.getAxisPointerModel = function (axisModel) {\n        var axisInfo = helper.getAxisInfo(axisModel);\n        return axisInfo && axisInfo.axisPointerModel;\n    };\n\n    function isHandleTrigger(axisPointerModel) {\n        return !!axisPointerModel.get('handle.show');\n    }\n\n    /**\n     * @param {module:echarts/model/Model} model\n     * @return {string} unique key\n     */\n    var makeKey = helper.makeKey = function (model) {\n        return model.type + '||' + model.id;\n    };\n\n    module.exports = helper;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/modelHelper.js\n// module id = 1005\n// module chunks = 0 1 2","// TODO Parse shadow style\n// TODO Only shallow path support\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    module.exports = function (properties) {\n        // Normalize\n        for (var i = 0; i < properties.length; i++) {\n            if (!properties[i][1]) {\n               properties[i][1] = properties[i][0];\n            }\n        }\n        return function (excludes, includes) {\n            var style = {};\n            for (var i = 0; i < properties.length; i++) {\n                var propName = properties[i][1];\n                if ((excludes && zrUtil.indexOf(excludes, propName) >= 0)\n                    || (includes && zrUtil.indexOf(includes, propName) < 0)\n                ) {\n                    continue;\n                }\n                var val = this.getShallow(propName);\n                if (val != null) {\n                    style[properties[i][0]] = val;\n                }\n            }\n            return style;\n        };\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/model/mixin/makeStyleMapper.js\n// module id = 1006\n// module chunks = 0 1 2","\n\n    var numberUtil = require('../util/number');\n    var linearMap = numberUtil.linearMap;\n    var zrUtil = require('zrender/lib/core/util');\n    var axisHelper = require('./axisHelper');\n\n    function fixExtentWithBands(extent, nTick) {\n        var size = extent[1] - extent[0];\n        var len = nTick;\n        var margin = size / len / 2;\n        extent[0] += margin;\n        extent[1] -= margin;\n    }\n\n    var normalizedExtent = [0, 1];\n    /**\n     * @name module:echarts/coord/CartesianAxis\n     * @constructor\n     */\n    var Axis = function (dim, scale, extent) {\n\n        /**\n         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n         * @type {string}\n         */\n        this.dim = dim;\n\n        /**\n         * Axis scale\n         * @type {module:echarts/coord/scale/*}\n         */\n        this.scale = scale;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        this._extent = extent || [0, 0];\n\n        /**\n         * @type {boolean}\n         */\n        this.inverse = false;\n\n        /**\n         * Usually true when axis has a ordinal scale\n         * @type {boolean}\n         */\n        this.onBand = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._labelInterval;\n    };\n\n    Axis.prototype = {\n\n        constructor: Axis,\n\n        /**\n         * If axis extent contain given coord\n         * @param {number} coord\n         * @return {boolean}\n         */\n        contain: function (coord) {\n            var extent = this._extent;\n            var min = Math.min(extent[0], extent[1]);\n            var max = Math.max(extent[0], extent[1]);\n            return coord >= min && coord <= max;\n        },\n\n        /**\n         * If axis extent contain given data\n         * @param {number} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.contain(this.dataToCoord(data));\n        },\n\n        /**\n         * Get coord extent.\n         * @return {Array.<number>}\n         */\n        getExtent: function () {\n            return this._extent.slice();\n        },\n\n        /**\n         * Get precision used for formatting\n         * @param {Array.<number>} [dataExtent]\n         * @return {number}\n         */\n        getPixelPrecision: function (dataExtent) {\n            return numberUtil.getPixelPrecision(\n                dataExtent || this.scale.getExtent(),\n                this._extent\n            );\n        },\n\n        /**\n         * Set coord extent\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var extent = this._extent;\n            extent[0] = start;\n            extent[1] = end;\n        },\n\n        /**\n         * Convert data to coord. Data is the rank if it has a ordinal scale\n         * @param {number} data\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        dataToCoord: function (data, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            data = scale.normalize(data);\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            return linearMap(data, normalizedExtent, extent, clamp);\n        },\n\n        /**\n         * Convert coord to data. Data is the rank if it has a ordinal scale\n         * @param {number} coord\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        coordToData: function (coord, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\n            return this.scale.scale(t);\n        },\n\n        /**\n         * Convert pixel point to data in axis\n         * @param {Array.<number>} point\n         * @param  {boolean} clamp\n         * @return {number} data\n         */\n        pointToData: function (point, clamp) {\n            // Should be implemented in derived class if necessary.\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicksCoords: function (alignWithLabel) {\n            if (this.onBand && !alignWithLabel) {\n                var bands = this.getBands();\n                var coords = [];\n                for (var i = 0; i < bands.length; i++) {\n                    coords.push(bands[i][0]);\n                }\n                if (bands[i - 1]) {\n                    coords.push(bands[i - 1][1]);\n                }\n                return coords;\n            }\n            else {\n                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n            }\n        },\n\n        /**\n         * Coords of labels are on the ticks or on the middle of bands\n         * @return {Array.<number>}\n         */\n        getLabelsCoords: function () {\n            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n        },\n\n        /**\n         * Get bands.\n         *\n         * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n         * |---1---|---2---|---3---|---4---|.\n         *\n         * @return {Array}\n         */\n         // FIXME Situation when labels is on ticks\n        getBands: function () {\n            var extent = this.getExtent();\n            var bands = [];\n            var len = this.scale.count();\n            var start = extent[0];\n            var end = extent[1];\n            var span = end - start;\n\n            for (var i = 0; i < len; i++) {\n                bands.push([\n                    span * i / len + start,\n                    span * (i + 1) / len + start\n                ]);\n            }\n            return bands;\n        },\n\n        /**\n         * Get width of band\n         * @return {number}\n         */\n        getBandWidth: function () {\n            var axisExtent = this._extent;\n            var dataExtent = this.scale.getExtent();\n\n            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n            // Fix #2728, avoid NaN when only one data.\n            len === 0 && (len = 1);\n\n            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\n            return Math.abs(size) / len;\n        },\n\n        /**\n         * Get interval of the axis label.\n         * @return {number}\n         */\n        getLabelInterval: function () {\n            var labelInterval = this._labelInterval;\n            if (!labelInterval) {\n                var axisModel = this.model;\n                var labelModel = axisModel.getModel('axisLabel');\n                var interval = labelModel.get('interval');\n                if (!(this.type === 'category' && interval === 'auto')) {\n                    labelInterval = interval === 'auto' ? 0 : interval;\n                }\n                else if (this.isHorizontal){\n                    labelInterval = axisHelper.getAxisLabelInterval(\n                        zrUtil.map(this.scale.getTicks(), this.dataToCoord, this),\n                        axisModel.getFormattedLabels(),\n                        labelModel.getFont(),\n                        this.isHorizontal()\n                    );\n                }\n                this._labelInterval = labelInterval;\n            }\n            return labelInterval;\n        }\n\n    };\n\n    module.exports = Axis;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/Axis.js\n// module id = 1007\n// module chunks = 0 1 2","'use strict';\n\n\n    var List = require('../../data/List');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n    var CoordinateSystem = require('../../CoordinateSystem');\n    var getDataItemValue = modelUtil.getDataItemValue;\n    var converDataValue = modelUtil.converDataValue;\n\n    function firstDataNotNull(data) {\n        var i = 0;\n        while (i < data.length && data[i] == null) {\n            i++;\n        }\n        return data[i];\n    }\n    function ifNeedCompleteOrdinalData(data) {\n        var sampleItem = firstDataNotNull(data);\n        return sampleItem != null\n            && !zrUtil.isArray(getDataItemValue(sampleItem));\n    }\n\n    /**\n     * Helper function to create a list from option data\n     */\n    function createListFromArray(data, seriesModel, ecModel) {\n        // If data is undefined\n        data = data || [];\n\n        if (__DEV__) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        var coordSysName = seriesModel.get('coordinateSystem');\n        var creator = creators[coordSysName];\n        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n        var completeDimOpt = {\n            encodeDef: seriesModel.get('encode'),\n            dimsDef: seriesModel.get('dimensions')\n        };\n\n        // FIXME\n        var axesInfo = creator && creator(data, seriesModel, ecModel, completeDimOpt);\n        var dimensions = axesInfo && axesInfo.dimensions;\n        if (!dimensions) {\n            // Get dimensions from registered coordinate system\n            dimensions = (registeredCoordSys && (\n                registeredCoordSys.getDimensionsInfo\n                    ? registeredCoordSys.getDimensionsInfo()\n                    : registeredCoordSys.dimensions.slice()\n            )) || ['x', 'y'];\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n        }\n\n        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\n        var list = new List(dimensions, seriesModel);\n\n        var nameList = createNameList(axesInfo, data);\n\n        var categories = {};\n        var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data))\n            ? function (itemOpt, dimName, dataIndex, dimIndex) {\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                // Use dataIndex as ordinal value in categoryAxis\n                return dimIndex === categoryIndex\n                    ? dataIndex\n                    : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n            }\n            : function (itemOpt, dimName, dataIndex, dimIndex) {\n                var value = getDataItemValue(itemOpt);\n                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n                if (categoryAxesModels && categoryAxesModels[dimName]) {\n                    // If given value is a category string\n                    if (typeof val === 'string') {\n                        // Lazy get categories\n                        categories[dimName] = categories[dimName]\n                            || categoryAxesModels[dimName].getCategories();\n                        val = zrUtil.indexOf(categories[dimName], val);\n                        if (val < 0 && !isNaN(val)) {\n                            // In case some one write '1', '2' istead of 1, 2\n                            val = +val;\n                        }\n                    }\n                }\n                return val;\n            };\n\n        list.hasItemOption = false;\n        list.initData(data, nameList, dimValueGetter);\n\n        return list;\n    }\n\n    function isStackable(axisType) {\n        return axisType !== 'category' && axisType !== 'time';\n    }\n\n    function getDimTypeByAxis(axisType) {\n        return axisType === 'category'\n            ? 'ordinal'\n            : axisType === 'time'\n            ? 'time'\n            : 'float';\n    }\n\n    /**\n     * Creaters for each coord system.\n     */\n    var creators = {\n\n        cartesian2d: function (data, seriesModel, ecModel, completeDimOpt) {\n\n            var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n                return ecModel.queryComponents({\n                    mainType: name,\n                    index: seriesModel.get(name + 'Index'),\n                    id: seriesModel.get(name + 'Id')\n                })[0];\n            });\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            if (__DEV__) {\n                if (!xAxisModel) {\n                    throw new Error('xAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('xAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n                if (!yAxisModel) {\n                    throw new Error('yAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('yAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n\n            var xAxisType = xAxisModel.get('type');\n            var yAxisType = yAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'x',\n                    type: getDimTypeByAxis(xAxisType),\n                    stackable: isStackable(xAxisType)\n                },\n                {\n                    name: 'y',\n                    // If two category axes\n                    type: getDimTypeByAxis(yAxisType),\n                    stackable: isStackable(yAxisType)\n                }\n            ];\n\n            var isXAxisCateogry = xAxisType === 'category';\n            var isYAxisCategory = yAxisType === 'category';\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isXAxisCateogry) {\n                categoryAxesModels.x = xAxisModel;\n            }\n            if (isYAxisCategory) {\n                categoryAxesModels.y = yAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        singleAxis: function (data, seriesModel, ecModel, completeDimOpt) {\n\n            var singleAxisModel = ecModel.queryComponents({\n                mainType: 'singleAxis',\n                index: seriesModel.get('singleAxisIndex'),\n                id: seriesModel.get('singleAxisId')\n            })[0];\n\n            if (__DEV__) {\n                if (!singleAxisModel) {\n                    throw new Error('singleAxis should be specified.');\n                }\n            }\n\n            var singleAxisType = singleAxisModel.get('type');\n            var isCategory = singleAxisType === 'category';\n\n            var dimensions = [{\n                name: 'single',\n                type: getDimTypeByAxis(singleAxisType),\n                stackable: isStackable(singleAxisType)\n            }];\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isCategory) {\n                categoryAxesModels.single = singleAxisModel;\n            }\n\n            return {\n                dimensions: dimensions,\n                categoryIndex: isCategory ? 0 : -1,\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        polar: function (data, seriesModel, ecModel, completeDimOpt) {\n            var polarModel = ecModel.queryComponents({\n                mainType: 'polar',\n                index: seriesModel.get('polarIndex'),\n                id: seriesModel.get('polarId')\n            })[0];\n\n            var angleAxisModel = polarModel.findAxisModel('angleAxis');\n            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\n            if (__DEV__) {\n                if (!angleAxisModel) {\n                    throw new Error('angleAxis option not found');\n                }\n                if (!radiusAxisModel) {\n                    throw new Error('radiusAxis option not found');\n                }\n            }\n\n            var radiusAxisType = radiusAxisModel.get('type');\n            var angleAxisType = angleAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'radius',\n                    type: getDimTypeByAxis(radiusAxisType),\n                    stackable: isStackable(radiusAxisType)\n                },\n                {\n                    name: 'angle',\n                    type: getDimTypeByAxis(angleAxisType),\n                    stackable: isStackable(angleAxisType)\n                }\n            ];\n            var isAngleAxisCateogry = angleAxisType === 'category';\n            var isRadiusAxisCateogry = radiusAxisType === 'category';\n\n            dimensions = completeDimensions(dimensions, data, completeDimOpt);\n\n            var categoryAxesModels = {};\n            if (isRadiusAxisCateogry) {\n                categoryAxesModels.radius = radiusAxisModel;\n            }\n            if (isAngleAxisCateogry) {\n                categoryAxesModels.angle = angleAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        geo: function (data, seriesModel, ecModel, completeDimOpt) {\n            // TODO Region\n            // \n            return {\n                dimensions: completeDimensions([\n                    {name: 'lng'},\n                    {name: 'lat'}\n                ], data, completeDimOpt)\n            };\n        }\n    };\n\n    function createNameList(result, data) {\n        var nameList = [];\n\n        var categoryDim = result && result.dimensions[result.categoryIndex];\n        var categoryAxisModel;\n        if (categoryDim) {\n            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n        }\n\n        if (categoryAxisModel) {\n            // FIXME Two category axis\n            var categories = categoryAxisModel.getCategories();\n            if (categories) {\n                var dataLen = data.length;\n                // Ordered data is given explicitly like\n                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n                // or given scatter data,\n                // pick the category\n                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n                    nameList = [];\n                    for (var i = 0; i < dataLen; i++) {\n                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n                    }\n                }\n                else {\n                    nameList = categories.slice(0);\n                }\n            }\n        }\n\n        return nameList;\n    }\n\n    module.exports = createListFromArray;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/helper/createListFromArray.js\n// module id = 1008\n// module chunks = 0 1 2","/**\n * \n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n\n    var zrUtil = require('../core/util');\n\n    var Style = require('./Style');\n\n    var Element = require('../Element');\n    var RectText = require('./mixin/RectText');\n    // var Stateful = require('./mixin/Stateful');\n\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        // Extend properties\n        for (var name in opts) {\n            if (\n                opts.hasOwnProperty(name) &&\n                name !== 'style'\n            ) {\n                this[name] = opts[name];\n            }\n        }\n\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style, this);\n\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];\n\n        // FIXME Stateful must be mixined after style is setted\n        // Stateful.call(this, opts);\n    }\n\n    Displayable.prototype = {\n\n        constructor: Displayable,\n\n        type: 'displayable',\n\n        /**\n         * Displayable Painter \n         * Dirty flag. From which painter will determine if this displayable object needs brush\n         * @name module:zrender/graphic/Displayable#__dirty\n         * @type {boolean}\n         */\n        __dirty: true,\n\n        /**\n         * true\n         * If ignore drawing of the displayable object. Mouse event will still be triggered\n         * @name module:/zrender/graphic/Displayable#invisible\n         * @type {boolean}\n         * @default false\n         */\n        invisible: false,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z: 0,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z2: 0,\n\n        /**\n         * zlevelcanvas\n         * @name module:/zrender/graphic/Displayable#zlevel\n         * @type {number}\n         * @default 0\n         */\n        zlevel: 0,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        draggable: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        dragging: false,\n\n        /**\n         * \n         * @name module:/zrender/graphic/Displayable#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * If enable culling\n         * @type {boolean}\n         * @default false\n         */\n        culling: false,\n\n        /**\n         * Mouse cursor when hovered\n         * @name module:/zrender/graphic/Displayable#cursor\n         * @type {string}\n         */\n        cursor: 'pointer',\n\n        /**\n         * If hover area is bounding rect\n         * @name module:/zrender/graphic/Displayable#rectHover\n         * @type {string}\n         */\n        rectHover: false,\n\n        /**\n         * Render the element progressively when the value >= 0,\n         * usefull for large data.\n         * @type {number}\n         */\n        progressive: -1,\n\n        beforeBrush: function (ctx) {},\n\n        afterBrush: function (ctx) {},\n\n        /**\n         * \n         * @param {CanvasRenderingContext2D} ctx\n         */\n        // Interface\n        brush: function (ctx, prevEl) {},\n\n        /**\n         * \n         * @return {module:zrender/core/BoundingRect}\n         */\n        // Interface\n        getBoundingRect: function () {},\n\n        /**\n         *  x, y \n         * If displayable element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n\n        /**\n         *  x, y \n         * If bounding rect of element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n\n        /**\n         * \n         * Mark displayable element dirty and refresh next frame\n         */\n        dirty: function () {\n            this.__dirty = true;\n\n            this._rect = null;\n\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * \n         * If displayable object binded any event\n         * @return {boolean}\n         */\n        // TODO,  bind \n        // isSilent: function () {\n        //     return !(\n        //         this.hoverable || this.draggable\n        //         || this.onmousemove || this.onmouseover || this.onmouseout\n        //         || this.onmousedown || this.onmouseup || this.onclick\n        //         || this.ondragenter || this.ondragover || this.ondragleave\n        //         || this.ondrop\n        //     );\n        // },\n        /**\n         * Alias for animate('style')\n         * @param {boolean} loop\n         */\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                this.style.set(value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n\n        /**\n         * Use given style object\n         * @param  {Object} obj\n         */\n        useStyle: function (obj) {\n            this.style = new Style(obj, this);\n            this.dirty(false);\n            return this;\n        }\n    };\n\n    zrUtil.inherits(Displayable, Element);\n\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n\n    module.exports = Displayable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/Displayable.js\n// module id = 1009\n// module chunks = 0 1 2","\n\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n\n        this.colorStops = colorStops || [];\n\n    };\n\n    Gradient.prototype = {\n\n        constructor: Gradient,\n\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n\n                offset: offset,\n\n                color: color\n            });\n        }\n\n    };\n\n    module.exports = Gradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/Gradient.js\n// module id = 1010\n// module chunks = 0 1 2","\n\n    var lib = {};\n\n    var ORIGIN_METHOD = '\\0__throttleOriginMethod';\n    var RATE = '\\0__throttleRate';\n    var THROTTLE_TYPE = '\\0__throttleType';\n\n    /**\n     * @public\n     * @param {(Function)} fn\n     * @param {number} [delay=0] Unit: ms.\n     * @param {boolean} [debounce=false]\n     *        true: If call interval less than `delay`, only the last call works.\n     *        false: If call interval less than `delay, call works on fixed rate.\n     * @return {(Function)} throttled fn.\n     */\n    lib.throttle = function (fn, delay, debounce) {\n\n        var currCall;\n        var lastCall = 0;\n        var lastExec = 0;\n        var timer = null;\n        var diff;\n        var scope;\n        var args;\n        var debounceNextCall;\n\n        delay = delay || 0;\n\n        function exec() {\n            lastExec = (new Date()).getTime();\n            timer = null;\n            fn.apply(scope, args || []);\n        }\n\n        var cb = function () {\n            currCall = (new Date()).getTime();\n            scope = this;\n            args = arguments;\n            var thisDelay = debounceNextCall || delay;\n            var thisDebounce = debounceNextCall || debounce;\n            debounceNextCall = null;\n            diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;\n\n            clearTimeout(timer);\n\n            if (thisDebounce) {\n                timer = setTimeout(exec, thisDelay);\n            }\n            else {\n                if (diff >= 0) {\n                    exec();\n                }\n                else {\n                    timer = setTimeout(exec, -diff);\n                }\n            }\n\n            lastCall = currCall;\n        };\n\n        /**\n         * Clear throttle.\n         * @public\n         */\n        cb.clear = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n        };\n\n        /**\n         * Enable debounce once.\n         */\n        cb.debounceNextCall = function (debounceDelay) {\n            debounceNextCall = debounceDelay;\n        };\n\n        return cb;\n    };\n\n    /**\n     * Create throttle method or update throttle rate.\n     *\n     * @example\n     * ComponentView.prototype.render = function () {\n     *     ...\n     *     throttle.createOrUpdate(\n     *         this,\n     *         '_dispatchAction',\n     *         this.model.get('throttle'),\n     *         'fixRate'\n     *     );\n     * };\n     * ComponentView.prototype.remove = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     * ComponentView.prototype.dispose = function () {\n     *     throttle.clear(this, '_dispatchAction');\n     * };\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     * @param {number} [rate]\n     * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'\n     * @return {Function} throttled function.\n     */\n    lib.createOrUpdate = function (obj, fnAttr, rate, throttleType) {\n        var fn = obj[fnAttr];\n\n        if (!fn) {\n            return;\n        }\n\n        var originFn = fn[ORIGIN_METHOD] || fn;\n        var lastThrottleType = fn[THROTTLE_TYPE];\n        var lastRate = fn[RATE];\n\n        if (lastRate !== rate || lastThrottleType !== throttleType) {\n            if (rate == null || !throttleType) {\n                return (obj[fnAttr] = originFn);\n            }\n\n            fn = obj[fnAttr] = lib.throttle(\n                originFn, rate, throttleType === 'debounce'\n            );\n            fn[ORIGIN_METHOD] = originFn;\n            fn[THROTTLE_TYPE] = throttleType;\n            fn[RATE] = rate;\n        }\n\n        return fn;\n    };\n\n    /**\n     * Clear throttle. Example see throttle.createOrUpdate.\n     *\n     * @public\n     * @param {Object} obj\n     * @param {string} fnAttr\n     */\n    lib.clear = function (obj, fnAttr) {\n        var fn = obj[fnAttr];\n        if (fn && fn[ORIGIN_METHOD]) {\n            obj[fnAttr] = fn[ORIGIN_METHOD];\n        }\n    };\n\n    module.exports = lib;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/util/throttle.js\n// module id = 1011\n// module chunks = 0 1 2","/**\n * Interval scale\n * @module echarts/scale/Interval\n */\n\n\n\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n    var Scale = require('./Scale');\n    var helper = require('./helper');\n\n    var roundNumber = numberUtil.round;\n\n    /**\n     * @alias module:echarts/coord/scale/Interval\n     * @constructor\n     */\n    var IntervalScale = Scale.extend({\n\n        type: 'interval',\n\n        _interval: 0,\n\n        _intervalPrecision: 2,\n\n        setExtent: function (start, end) {\n            var thisExtent = this._extent;\n            //start,end may be a Number like '25',so...\n            if (!isNaN(start)) {\n                thisExtent[0] = parseFloat(start);\n            }\n            if (!isNaN(end)) {\n                thisExtent[1] = parseFloat(end);\n            }\n        },\n\n        unionExtent: function (other) {\n            var extent = this._extent;\n            other[0] < extent[0] && (extent[0] = other[0]);\n            other[1] > extent[1] && (extent[1] = other[1]);\n\n            // unionExtent may called by it's sub classes\n            IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n        },\n        /**\n         * Get interval\n         */\n        getInterval: function () {\n            return this._interval;\n        },\n\n        /**\n         * Set interval\n         */\n        setInterval: function (interval) {\n            this._interval = interval;\n            // Dropped auto calculated niceExtent and use user setted extent\n            // We assume user wan't to set both interval, min, max to get a better result\n            this._niceExtent = this._extent.slice();\n\n            this._intervalPrecision = helper.getIntervalPrecision(interval);\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            return helper.intervalScaleGetTicks(\n                this._interval, this._extent, this._niceExtent, this._intervalPrecision\n            );\n        },\n\n        /**\n         * @return {Array.<string>}\n         */\n        getTicksLabels: function () {\n            var labels = [];\n            var ticks = this.getTicks();\n            for (var i = 0; i < ticks.length; i++) {\n                labels.push(this.getLabel(ticks[i]));\n            }\n            return labels;\n        },\n\n        /**\n         * @param {number} data\n         * @param {Object} [opt]\n         * @param {number|string} [opt.precision] If 'auto', use nice presision.\n         * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.\n         * @return {string}\n         */\n        getLabel: function (data, opt) {\n            if (data == null) {\n                return '';\n            }\n\n            var precision = opt && opt.precision;\n\n            if (precision == null) {\n                precision = numberUtil.getPrecisionSafe(data) || 0;\n            }\n            else if (precision === 'auto') {\n                // Should be more precise then tick.\n                precision = this._intervalPrecision;\n            }\n\n            // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n            // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n            data = roundNumber(data, precision, true);\n\n            return formatUtil.addCommas(data);\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         *\n         * @param {number} [splitNumber = 5] Desired number of ticks\n         * @param {number} [minInterval]\n         * @param {number} [maxInterval]\n         */\n        niceTicks: function (splitNumber, minInterval, maxInterval) {\n            splitNumber = splitNumber || 5;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (!isFinite(span)) {\n                return;\n            }\n            // User may set axis min 0 and data are all negative\n            // FIXME If it needs to reverse ?\n            if (span < 0) {\n                span = -span;\n                extent.reverse();\n            }\n\n            var result = helper.intervalScaleNiceTicks(\n                extent, splitNumber, minInterval, maxInterval\n            );\n\n            this._intervalPrecision = result.intervalPrecision;\n            this._interval = result.interval;\n            this._niceExtent = result.niceTickExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {Object} opt\n         * @param {number} [opt.splitNumber = 5] Given approx tick number\n         * @param {boolean} [opt.fixMin=false]\n         * @param {boolean} [opt.fixMax=false]\n         * @param {boolean} [opt.minInterval]\n         * @param {boolean} [opt.maxInterval]\n         */\n        niceExtent: function (opt) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                if (extent[0] !== 0) {\n                    // Expand extent\n                    var expandSize = extent[0];\n                    // In the fowllowing case\n                    //      Axis has been fixed max 100\n                    //      Plus data are all 100 and axis extent are [100, 100].\n                    // Extend to the both side will cause expanded max is larger than fixed max.\n                    // So only expand to the smaller side.\n                    if (!opt.fixMax) {\n                        extent[1] += expandSize / 2;\n                        extent[0] -= expandSize / 2;\n                    }\n                    else {\n                        extent[0] -= expandSize / 2;\n                    }\n                }\n                else {\n                    extent[1] = 1;\n                }\n            }\n            var span = extent[1] - extent[0];\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (!isFinite(span)) {\n                extent[0] = 0;\n                extent[1] = 1;\n            }\n\n            this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!opt.fixMin) {\n                extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n            }\n            if (!opt.fixMax) {\n                extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n            }\n        }\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    IntervalScale.create = function () {\n        return new IntervalScale();\n    };\n\n    module.exports = IntervalScale;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/scale/Interval.js\n// module id = 1012\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../../util/format');\n    var graphic = require('../../util/graphic');\n    var Model = require('../../model/Model');\n    var numberUtil = require('../../util/number');\n    var remRadian = numberUtil.remRadian;\n    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n    var vec2 = require('zrender/lib/core/vector');\n    var matrix = require('zrender/lib/core/matrix');\n    var v2ApplyTransform = vec2.applyTransform;\n    var retrieve = zrUtil.retrieve;\n\n    var PI = Math.PI;\n\n    function makeAxisEventDataBase(axisModel) {\n        var eventData = {\n            componentType: axisModel.mainType\n        };\n        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n        return eventData;\n    }\n\n    /**\n     * A final axis is translated and rotated from a \"standard axis\".\n     * So opt.position and opt.rotation is required.\n     *\n     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n     * for example: (0, 0) ------------> (0, 50)\n     *\n     * nameDirection or tickDirection or labelDirection is 1 means tick\n     * or label is below the standard axis, whereas is -1 means above\n     * the standard axis. labelOffset means offset between label and axis,\n     * which is useful when 'onZero', where axisLabel is in the grid and\n     * label in outside grid.\n     *\n     * Tips: like always,\n     * positive rotation represents anticlockwise, and negative rotation\n     * represents clockwise.\n     * The direction of position coordinate is the same as the direction\n     * of screen coordinate.\n     *\n     * Do not need to consider axis 'inverse', which is auto processed by\n     * axis extent.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} axisModel\n     * @param {Object} opt Standard axis parameters.\n     * @param {Array.<number>} opt.position [x, y]\n     * @param {number} opt.rotation by radian\n     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.\n     * @param {number} [opt.tickDirection=1] 1 or -1\n     * @param {number} [opt.labelDirection=1] 1 or -1\n     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n     * @param {string} [opt.axisLabelShow] default get from axisModel.\n     * @param {string} [opt.axisName] default get from axisModel.\n     * @param {number} [opt.axisNameAvailableWidth]\n     * @param {number} [opt.labelRotate] by degree, default get from axisModel.\n     * @param {number} [opt.labelInterval] Default label interval when label\n     *                                     interval from model is null or 'auto'.\n     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n     * @param {number} [opt.nameTruncateMaxWidth]\n     */\n    var AxisBuilder = function (axisModel, opt) {\n\n        /**\n         * @readOnly\n         */\n        this.opt = opt;\n\n        /**\n         * @readOnly\n         */\n        this.axisModel = axisModel;\n\n        // Default value\n        zrUtil.defaults(\n            opt,\n            {\n                labelOffset: 0,\n                nameDirection: 1,\n                tickDirection: 1,\n                labelDirection: 1,\n                silent: true\n            }\n        );\n\n        /**\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n\n        // FIXME Not use a seperate text group?\n        var dumbGroup = new graphic.Group({\n            position: opt.position.slice(),\n            rotation: opt.rotation\n        });\n\n        // this.group.add(dumbGroup);\n        // this._dumbGroup = dumbGroup;\n\n        dumbGroup.updateTransform();\n        this._transform = dumbGroup.transform;\n\n        this._dumbGroup = dumbGroup;\n    };\n\n    AxisBuilder.prototype = {\n\n        constructor: AxisBuilder,\n\n        hasBuilder: function (name) {\n            return !!builders[name];\n        },\n\n        add: function (name) {\n            builders[name].call(this);\n        },\n\n        getGroup: function () {\n            return this.group;\n        }\n\n    };\n\n    var builders = {\n\n        /**\n         * @private\n         */\n        axisLine: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n\n            if (!axisModel.get('axisLine.show')) {\n                return;\n            }\n\n            var extent = this.axisModel.axis.getExtent();\n\n            var matrix = this._transform;\n            var pt1 = [extent[0], 0];\n            var pt2 = [extent[1], 0];\n            if (matrix) {\n                v2ApplyTransform(pt1, pt1, matrix);\n                v2ApplyTransform(pt2, pt2, matrix);\n            }\n\n            this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                // Id for animation\n                anid: 'line',\n\n                shape: {\n                    x1: pt1[0],\n                    y1: pt1[1],\n                    x2: pt2[0],\n                    y2: pt2[1]\n                },\n                style: zrUtil.extend(\n                    {lineCap: 'round'},\n                    axisModel.getModel('axisLine.lineStyle').getLineStyle()\n                ),\n                strokeContainThreshold: opt.strokeContainThreshold || 5,\n                silent: true,\n                z2: 1\n            })));\n        },\n\n        /**\n         * @private\n         */\n        axisTickLabel: function () {\n            var axisModel = this.axisModel;\n            var opt = this.opt;\n\n            var tickEls = buildAxisTick(this, axisModel, opt);\n            var labelEls = buildAxisLabel(this, axisModel, opt);\n\n            fixMinMaxLabelShow(axisModel, labelEls, tickEls);\n        },\n\n        /**\n         * @private\n         */\n        axisName: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var name = retrieve(opt.axisName, axisModel.get('name'));\n\n            if (!name) {\n                return;\n            }\n\n            var nameLocation = axisModel.get('nameLocation');\n            var nameDirection = opt.nameDirection;\n            var textStyleModel = axisModel.getModel('nameTextStyle');\n            var gap = axisModel.get('nameGap') || 0;\n\n            var extent = this.axisModel.axis.getExtent();\n            var gapSignal = extent[0] > extent[1] ? -1 : 1;\n            var pos = [\n                nameLocation === 'start'\n                    ? extent[0] - gapSignal * gap\n                    : nameLocation === 'end'\n                    ? extent[1] + gapSignal * gap\n                    : (extent[0] + extent[1]) / 2, // 'middle'\n                // Reuse labelOffset.\n                isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0\n            ];\n\n            var labelLayout;\n\n            var nameRotation = axisModel.get('nameRotate');\n            if (nameRotation != null) {\n                nameRotation = nameRotation * PI / 180; // To radian.\n            }\n\n            var axisNameAvailableWidth;\n\n            if (isNameLocationCenter(nameLocation)) {\n                labelLayout = innerTextLayout(\n                    opt.rotation,\n                    nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n                    nameDirection\n                );\n            }\n            else {\n                labelLayout = endTextLayout(\n                    opt, nameLocation, nameRotation || 0, extent\n                );\n\n                axisNameAvailableWidth = opt.axisNameAvailableWidth;\n                if (axisNameAvailableWidth != null) {\n                    axisNameAvailableWidth = Math.abs(\n                        axisNameAvailableWidth / Math.sin(labelLayout.rotation)\n                    );\n                    !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n                }\n            }\n\n            var textFont = textStyleModel.getFont();\n\n            var truncateOpt = axisModel.get('nameTruncate', true) || {};\n            var ellipsis = truncateOpt.ellipsis;\n            var maxWidth = retrieve(\n                opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth\n            );\n            // FIXME\n            // truncate rich text? (consider performance)\n            var truncatedText = (ellipsis != null && maxWidth != null)\n                ? formatUtil.truncateText(\n                    name, maxWidth, textFont, ellipsis,\n                    {minChar: 2, placeholder: truncateOpt.placeholder}\n                )\n                : name;\n\n            var tooltipOpt = axisModel.get('tooltip', true);\n\n            var mainType = axisModel.mainType;\n            var formatterParams = {\n                componentType: mainType,\n                name: name,\n                $vars: ['name']\n            };\n            formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\n            var textEl = new graphic.Text({\n                // Id for animation\n                anid: 'name',\n\n                __fullText: name,\n                __truncatedText: truncatedText,\n\n                position: pos,\n                rotation: labelLayout.rotation,\n                silent: isSilent(axisModel),\n                z2: 1,\n                tooltip: (tooltipOpt && tooltipOpt.show)\n                    ? zrUtil.extend({\n                        content: name,\n                        formatter: function () {\n                            return name;\n                        },\n                        formatterParams: formatterParams\n                    }, tooltipOpt)\n                    : null\n            });\n\n            graphic.setTextStyle(textEl.style, textStyleModel, {\n                text: truncatedText,\n                textFont: textFont,\n                textFill: textStyleModel.getTextColor()\n                    || axisModel.get('axisLine.lineStyle.color'),\n                textAlign: labelLayout.textAlign,\n                textVerticalAlign: labelLayout.textVerticalAlign\n            });\n\n            if (axisModel.get('triggerEvent')) {\n                textEl.eventData = makeAxisEventDataBase(axisModel);\n                textEl.eventData.targetType = 'axisName';\n                textEl.eventData.name = name;\n            }\n\n            // FIXME\n            this._dumbGroup.add(textEl);\n            textEl.updateTransform();\n\n            this.group.add(textEl);\n\n            textEl.decomposeTransform();\n        }\n\n    };\n\n    /**\n     * @public\n     * @static\n     * @param {Object} opt\n     * @param {number} axisRotation in radian\n     * @param {number} textRotation in radian\n     * @param {number} direction\n     * @return {Object} {\n     *  rotation, // according to axis\n     *  textAlign,\n     *  textVerticalAlign\n     * }\n     */\n    var innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n        var rotationDiff = remRadian(textRotation - axisRotation);\n        var textAlign;\n        var textVerticalAlign;\n\n        if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line.\n            textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI)) { // Label is inverse parallel with axis line.\n            textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else {\n            textVerticalAlign = 'middle';\n\n            if (rotationDiff > 0 && rotationDiff < PI) {\n                textAlign = direction > 0 ? 'right' : 'left';\n            }\n            else {\n                textAlign = direction > 0 ? 'left' : 'right';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    };\n\n    function endTextLayout(opt, textPosition, textRotate, extent) {\n        var rotationDiff = remRadian(textRotate - opt.rotation);\n        var textAlign;\n        var textVerticalAlign;\n        var inverse = extent[0] > extent[1];\n        var onLeft = (textPosition === 'start' && !inverse)\n            || (textPosition !== 'start' && inverse);\n\n        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n            textVerticalAlign = onLeft ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n            textVerticalAlign = onLeft ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else {\n            textVerticalAlign = 'middle';\n            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n                textAlign = onLeft ? 'left' : 'right';\n            }\n            else {\n                textAlign = onLeft ? 'right' : 'left';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    }\n\n    function isSilent(axisModel) {\n        var tooltipOpt = axisModel.get('tooltip');\n        return axisModel.get('silent')\n            // Consider mouse cursor, add these restrictions.\n            || !(\n                axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show)\n            );\n    }\n\n    function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n        // If min or max are user set, we need to check\n        // If the tick on min(max) are overlap on their neighbour tick\n        // If they are overlapped, we need to hide the min(max) tick label\n        var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n        var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n\n        // FIXME\n        // Have not consider onBand yet, where tick els is more than label els.\n\n        labelEls = labelEls || [];\n        tickEls = tickEls || [];\n\n        var firstLabel = labelEls[0];\n        var nextLabel = labelEls[1];\n        var lastLabel = labelEls[labelEls.length - 1];\n        var prevLabel = labelEls[labelEls.length - 2];\n\n        var firstTick = tickEls[0];\n        var nextTick = tickEls[1];\n        var lastTick = tickEls[tickEls.length - 1];\n        var prevTick = tickEls[tickEls.length - 2];\n\n        if (showMinLabel === false) {\n            ignoreEl(firstLabel);\n            ignoreEl(firstTick);\n        }\n        else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n            if (showMinLabel) {\n                ignoreEl(nextLabel);\n                ignoreEl(nextTick);\n            }\n            else {\n                ignoreEl(firstLabel);\n                ignoreEl(firstTick);\n            }\n        }\n\n        if (showMaxLabel === false) {\n            ignoreEl(lastLabel);\n            ignoreEl(lastTick);\n        }\n        else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n            if (showMaxLabel) {\n                ignoreEl(prevLabel);\n                ignoreEl(prevTick);\n            }\n            else {\n                ignoreEl(lastLabel);\n                ignoreEl(lastTick);\n            }\n        }\n    }\n\n    function ignoreEl(el) {\n        el && (el.ignore = true);\n    }\n\n    function isTwoLabelOverlapped(current, next, labelLayout) {\n        // current and next has the same rotation.\n        var firstRect = current && current.getBoundingRect().clone();\n        var nextRect = next && next.getBoundingRect().clone();\n\n        if (!firstRect || !nextRect) {\n            return;\n        }\n\n        // When checking intersect of two rotated labels, we use mRotationBack\n        // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n        var mRotationBack = matrix.identity([]);\n        matrix.rotate(mRotationBack, mRotationBack, -current.rotation);\n\n        firstRect.applyTransform(matrix.mul([], mRotationBack, current.getLocalTransform()));\n        nextRect.applyTransform(matrix.mul([], mRotationBack, next.getLocalTransform()));\n\n        return firstRect.intersect(nextRect);\n    }\n\n    function isNameLocationCenter(nameLocation) {\n        return nameLocation === 'middle' || nameLocation === 'center';\n    }\n\n    /**\n     * @static\n     */\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (\n        axis,\n        i,\n        interval,\n        ticksCnt,\n        showMinLabel,\n        showMaxLabel\n    ) {\n        if (i === 0 && showMinLabel || i === ticksCnt - 1 && showMaxLabel) {\n            return false;\n        }\n\n        // FIXME\n        // Have not consider label overlap (if label is too long) yet.\n\n        var rawTick;\n        var scale = axis.scale;\n        return scale.type === 'ordinal'\n            && (\n                typeof interval === 'function'\n                    ? (\n                        rawTick = scale.getTicks()[i],\n                        !interval(rawTick, scale.getLabel(rawTick))\n                    )\n                    : i % (interval + 1)\n            );\n    };\n\n    /**\n     * @static\n     */\n    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n        var interval = model.get('interval');\n        if (interval == null || interval == 'auto') {\n            interval = labelInterval;\n        }\n        return interval;\n    };\n\n    function buildAxisTick(axisBuilder, axisModel, opt) {\n        var axis = axisModel.axis;\n\n        if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {\n            return;\n        }\n\n        var tickModel = axisModel.getModel('axisTick');\n\n        var lineStyleModel = tickModel.getModel('lineStyle');\n        var tickLen = tickModel.get('length');\n\n        var tickInterval = getInterval(tickModel, opt.labelInterval);\n        var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n        // FIXME\n        // Corresponds to ticksCoords ?\n        var ticks = axis.scale.getTicks();\n\n        var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n        var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n\n        var pt1 = [];\n        var pt2 = [];\n        var matrix = axisBuilder._transform;\n\n        var tickEls = [];\n\n        var ticksCnt = ticksCoords.length;\n        for (var i = 0; i < ticksCnt; i++) {\n            // Only ordinal scale support tick interval\n            if (ifIgnoreOnTick(\n                axis, i, tickInterval, ticksCnt,\n                showMinLabel, showMaxLabel\n            )) {\n                continue;\n            }\n\n            var tickCoord = ticksCoords[i];\n\n            pt1[0] = tickCoord;\n            pt1[1] = 0;\n            pt2[0] = tickCoord;\n            pt2[1] = opt.tickDirection * tickLen;\n\n            if (matrix) {\n                v2ApplyTransform(pt1, pt1, matrix);\n                v2ApplyTransform(pt2, pt2, matrix);\n            }\n            // Tick line, Not use group transform to have better line draw\n            var tickEl = new graphic.Line(graphic.subPixelOptimizeLine({\n                // Id for animation\n                anid: 'tick_' + ticks[i],\n\n                shape: {\n                    x1: pt1[0],\n                    y1: pt1[1],\n                    x2: pt2[0],\n                    y2: pt2[1]\n                },\n                style: zrUtil.defaults(\n                    lineStyleModel.getLineStyle(),\n                    {\n                        stroke: axisModel.get('axisLine.lineStyle.color')\n                    }\n                ),\n                z2: 2,\n                silent: true\n            }));\n            axisBuilder.group.add(tickEl);\n            tickEls.push(tickEl);\n        }\n\n        return tickEls;\n    }\n\n    function buildAxisLabel(axisBuilder, axisModel, opt) {\n        var axis = axisModel.axis;\n        var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n        if (!show || axis.scale.isBlank()) {\n            return;\n        }\n\n        var labelModel = axisModel.getModel('axisLabel');\n        var labelMargin = labelModel.get('margin');\n        var ticks = axis.scale.getTicks();\n        var labels = axisModel.getFormattedLabels();\n\n        // Special label rotate.\n        var labelRotation = (\n            retrieve(opt.labelRotate, labelModel.get('rotate')) || 0\n        ) * PI / 180;\n\n        var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n        var categoryData = axisModel.get('data');\n\n        var labelEls = [];\n        var silent = isSilent(axisModel);\n        var triggerEvent = axisModel.get('triggerEvent');\n\n        var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n        var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n\n        zrUtil.each(ticks, function (tickVal, index) {\n            if (ifIgnoreOnTick(\n                axis, index, opt.labelInterval, ticks.length,\n                showMinLabel, showMaxLabel\n            )) {\n                    return;\n            }\n\n            var itemLabelModel = labelModel;\n            if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {\n                itemLabelModel = new Model(\n                    categoryData[tickVal].textStyle, labelModel, axisModel.ecModel\n                );\n            }\n\n            var textColor = itemLabelModel.getTextColor()\n                || axisModel.get('axisLine.lineStyle.color');\n\n            var tickCoord = axis.dataToCoord(tickVal);\n            var pos = [\n                tickCoord,\n                opt.labelOffset + opt.labelDirection * labelMargin\n            ];\n            var labelStr = axis.scale.getLabel(tickVal);\n\n            var textEl = new graphic.Text({\n                // Id for animation\n                anid: 'label_' + tickVal,\n                position: pos,\n                rotation: labelLayout.rotation,\n                silent: silent,\n                z2: 10\n            });\n\n            graphic.setTextStyle(textEl.style, itemLabelModel, {\n                text: labels[index],\n                textAlign: itemLabelModel.getShallow('align', true)\n                    || labelLayout.textAlign,\n                textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true)\n                    || itemLabelModel.getShallow('baseline', true)\n                    || labelLayout.textVerticalAlign,\n                textFill: typeof textColor === 'function'\n                    ? textColor(\n                        // (1) In category axis with data zoom, tick is not the original\n                        // index of axis.data. So tick should not be exposed to user\n                        // in category axis.\n                        // (2) Compatible with previous version, which always returns labelStr.\n                        // But in interval scale labelStr is like '223,445', which maked\n                        // user repalce ','. So we modify it to return original val but remain\n                        // it as 'string' to avoid error in replacing.\n                        axis.type === 'category' ? labelStr : axis.type === 'value' ? tickVal + '' : tickVal,\n                        index\n                    )\n                    : textColor\n            });\n\n            // Pack data for mouse event\n            if (triggerEvent) {\n                textEl.eventData = makeAxisEventDataBase(axisModel);\n                textEl.eventData.targetType = 'axisLabel';\n                textEl.eventData.value = labelStr;\n            }\n\n            // FIXME\n            axisBuilder._dumbGroup.add(textEl);\n            textEl.updateTransform();\n\n            labelEls.push(textEl);\n            axisBuilder.group.add(textEl);\n\n            textEl.decomposeTransform();\n\n        });\n\n        return labelEls;\n    }\n\n\n    module.exports = AxisBuilder;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axis/AxisBuilder.js\n// module id = 1013\n// module chunks = 0 1 2","\n\n    var axisPointerModelHelper = require('../axisPointer/modelHelper');\n\n    /**\n     * Base class of AxisView.\n     */\n    var AxisView = require('../../echarts').extendComponentView({\n\n        type: 'axis',\n\n        /**\n         * @private\n         */\n        _axisPointer: null,\n\n        /**\n         * @protected\n         * @type {string}\n         */\n        axisPointerClass: null,\n\n        /**\n         * @override\n         */\n        render: function (axisModel, ecModel, api, payload) {\n            // FIXME\n            // This process should proformed after coordinate systems updated\n            // (axis scale updated), and should be performed each time update.\n            // So put it here temporarily, although it is not appropriate to\n            // put a model-writing procedure in `view`.\n            this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel);\n\n            AxisView.superApply(this, 'render', arguments);\n\n            updateAxisPointer(this, axisModel, ecModel, api, payload, true);\n        },\n\n        /**\n         * Action handler.\n         * @public\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/model/Global} ecModel\n         * @param {module:echarts/ExtensionAPI} api\n         * @param {Object} payload\n         */\n        updateAxisPointer: function (axisModel, ecModel, api, payload, force) {\n            updateAxisPointer(this, axisModel, ecModel, api, payload, false);\n        },\n\n        /**\n         * @override\n         */\n        remove: function (ecModel, api) {\n            var axisPointer = this._axisPointer;\n            axisPointer && axisPointer.remove(api);\n            AxisView.superApply(this, 'remove', arguments);\n        },\n\n        /**\n         * @override\n         */\n        dispose: function (ecModel, api) {\n            disposeAxisPointer(this, api);\n            AxisView.superApply(this, 'dispose', arguments);\n        }\n\n    });\n\n    function updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {\n        var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);\n        if (!Clazz) {\n            return;\n        }\n        var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);\n        axisPointerModel\n            ? (axisView._axisPointer || (axisView._axisPointer = new Clazz()))\n                .render(axisModel, axisPointerModel, api, forceRender)\n            : disposeAxisPointer(axisView, api);\n    }\n\n    function disposeAxisPointer(axisView, ecModel, api) {\n        var axisPointer = axisView._axisPointer;\n        axisPointer && axisPointer.dispose(ecModel, api);\n        axisView._axisPointer = null;\n    }\n\n    var axisPointerClazz = [];\n\n    AxisView.registerAxisPointerClass = function (type, clazz) {\n        if (__DEV__) {\n            if (axisPointerClazz[type]) {\n                throw new Error('axisPointer ' + type + ' exists');\n            }\n        }\n        axisPointerClazz[type] = clazz;\n    };\n\n    AxisView.getAxisPointerClass = function (type) {\n        return type && axisPointerClazz[type];\n    };\n\n    module.exports = AxisView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axis/AxisView.js\n// module id = 1014\n// module chunks = 0 1 2","\n\n    var LRU = require('../../core/LRU');\n    var globalImageCache = new LRU(50);\n\n    var helper = {};\n\n    /**\n     * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n     * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n     */\n    helper.findExistImage = function (newImageOrSrc) {\n        if (typeof newImageOrSrc === 'string') {\n            var cachedImgObj = globalImageCache.get(newImageOrSrc);\n            return cachedImgObj && cachedImgObj.image;\n        }\n        else {\n            return newImageOrSrc;\n        }\n    };\n\n    /**\n     * Caution: User should cache loaded images, but not just count on LRU.\n     * Consider if required images more than LRU size, will dead loop occur?\n     *\n     * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n     * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.\n     * @param {module:zrender/Element} [hostEl] For calling `dirty`.\n     * @param {Function} [cb] params: (image, cbPayload)\n     * @param {Object} [cbPayload] Payload on cb calling.\n     * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n     */\n    helper.createOrUpdateImage = function (newImageOrSrc, image, hostEl, cb, cbPayload) {\n        if (!newImageOrSrc) {\n            return image;\n        }\n        else if (typeof newImageOrSrc === 'string') {\n\n            // Image should not be loaded repeatly.\n            if ((image && image.__zrImageSrc === newImageOrSrc) || !hostEl) {\n                return image;\n            }\n\n            // Only when there is no existent image or existent image src\n            // is different, this method is responsible for load.\n            var cachedImgObj = globalImageCache.get(newImageOrSrc);\n\n            var pendingWrap = {hostEl: hostEl, cb: cb, cbPayload: cbPayload};\n\n            if (cachedImgObj) {\n                image = cachedImgObj.image;\n                !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);\n            }\n            else {\n                !image && (image = new Image());\n                image.onload = imageOnLoad;\n\n                globalImageCache.put(\n                    newImageOrSrc,\n                    image.__cachedImgObj = {\n                        image: image,\n                        pending: [pendingWrap]\n                    }\n                );\n\n                image.src = image.__zrImageSrc = newImageOrSrc;\n            }\n\n            return image;\n        }\n        // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas\n        else {\n            return newImageOrSrc;\n        }\n    };\n\n    function imageOnLoad() {\n        var cachedImgObj = this.__cachedImgObj;\n        this.onload = this.__cachedImgObj = null;\n\n        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n            var pendingWrap = cachedImgObj.pending[i];\n            var cb = pendingWrap.cb;\n            cb && cb(this, pendingWrap.cbPayload);\n            pendingWrap.hostEl.dirty();\n        }\n        cachedImgObj.pending.length = 0;\n    }\n\n    var isImageReady = helper.isImageReady = function (image) {\n        return image && image.width && image.height;\n    };\n\n    module.exports = helper;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/helper/image.js\n// module id = 1015\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var clazz = require('./clazz');\n\n    var parseClassType = clazz.parseClassType;\n\n    var base = 0;\n\n    var componentUtil = {};\n\n    var DELIMITER = '_';\n\n    /**\n     * @public\n     * @param {string} type\n     * @return {string}\n     */\n    componentUtil.getUID = function (type) {\n        // Considering the case of crossing js context,\n        // use Math.random to make id as unique as possible.\n        return [(type || ''), base++, Math.random()].join(DELIMITER);\n    };\n\n    /**\n     * @inner\n     */\n    componentUtil.enableSubTypeDefaulter = function (entity) {\n\n        var subTypeDefaulters = {};\n\n        entity.registerSubTypeDefaulter = function (componentType, defaulter) {\n            componentType = parseClassType(componentType);\n            subTypeDefaulters[componentType.main] = defaulter;\n        };\n\n        entity.determineSubType = function (componentType, option) {\n            var type = option.type;\n            if (!type) {\n                var componentTypeMain = parseClassType(componentType).main;\n                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n                    type = subTypeDefaulters[componentTypeMain](option);\n                }\n            }\n            return type;\n        };\n\n        return entity;\n    };\n\n    /**\n     * Topological travel on Activity Network (Activity On Vertices).\n     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].\n     *\n     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.\n     *\n     * If there is circle dependencey, Error will be thrown.\n     *\n     */\n    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {\n\n        /**\n         * @public\n         * @param {Array.<string>} targetNameList Target Component type list.\n         *                                           Can be ['aa', 'bb', 'aa.xx']\n         * @param {Array.<string>} fullNameList By which we can build dependency graph.\n         * @param {Function} callback Params: componentType, dependencies.\n         * @param {Object} context Scope of callback.\n         */\n        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n            if (!targetNameList.length) {\n                return;\n            }\n\n            var result = makeDepndencyGraph(fullNameList);\n            var graph = result.graph;\n            var stack = result.noEntryList;\n\n            var targetNameSet = {};\n            zrUtil.each(targetNameList, function (name) {\n                targetNameSet[name] = true;\n            });\n\n            while (stack.length) {\n                var currComponentType = stack.pop();\n                var currVertex = graph[currComponentType];\n                var isInTargetNameSet = !!targetNameSet[currComponentType];\n                if (isInTargetNameSet) {\n                    callback.call(context, currComponentType, currVertex.originalDeps.slice());\n                    delete targetNameSet[currComponentType];\n                }\n                zrUtil.each(\n                    currVertex.successor,\n                    isInTargetNameSet ? removeEdgeAndAdd : removeEdge\n                );\n            }\n\n            zrUtil.each(targetNameSet, function () {\n                throw new Error('Circle dependency may exists');\n            });\n\n            function removeEdge(succComponentType) {\n                graph[succComponentType].entryCount--;\n                if (graph[succComponentType].entryCount === 0) {\n                    stack.push(succComponentType);\n                }\n            }\n\n            // Consider this case: legend depends on series, and we call\n            // chart.setOption({series: [...]}), where only series is in option.\n            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will\n            // not be called, but only sereis.mergeOption is called. Thus legend\n            // have no chance to update its local record about series (like which\n            // name of series is available in legend).\n            function removeEdgeAndAdd(succComponentType) {\n                targetNameSet[succComponentType] = true;\n                removeEdge(succComponentType);\n            }\n        };\n\n        /**\n         * DepndencyGraph: {Object}\n         * key: conponentType,\n         * value: {\n         *     successor: [conponentTypes...],\n         *     originalDeps: [conponentTypes...],\n         *     entryCount: {number}\n         * }\n         */\n        function makeDepndencyGraph(fullNameList) {\n            var graph = {};\n            var noEntryList = [];\n\n            zrUtil.each(fullNameList, function (name) {\n\n                var thisItem = createDependencyGraphItem(graph, name);\n                var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n\n                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n                thisItem.entryCount = availableDeps.length;\n                if (thisItem.entryCount === 0) {\n                    noEntryList.push(name);\n                }\n\n                zrUtil.each(availableDeps, function (dependentName) {\n                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {\n                        thisItem.predecessor.push(dependentName);\n                    }\n                    var thatItem = createDependencyGraphItem(graph, dependentName);\n                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {\n                        thatItem.successor.push(name);\n                    }\n                });\n            });\n\n            return {graph: graph, noEntryList: noEntryList};\n        }\n\n        function createDependencyGraphItem(graph, name) {\n            if (!graph[name]) {\n                graph[name] = {predecessor: [], successor: []};\n            }\n            return graph[name];\n        }\n\n        function getAvailableDependencies(originalDeps, fullNameList) {\n            var availableDeps = [];\n            zrUtil.each(originalDeps, function (dep) {\n                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n            });\n            return availableDeps;\n        }\n    };\n\n    module.exports = componentUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/util/component.js\n// module id = 1016\n// module chunks = 0 1 2","// https://github.com/mziccard/node-timsort\n\n    var DEFAULT_MIN_MERGE = 32;\n\n    var DEFAULT_MIN_GALLOPING = 7;\n\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\n    function minRunLength(n) {\n        var r = 0;\n\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n\n        return n + r;\n    }\n\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n\n        if (runHi === hi) {\n            return 1;\n        }\n\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n\n            reverseRun(array, lo, runHi);\n        }\n        else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n\n        return runHi - lo;\n    }\n\n    function reverseRun(array, lo, hi) {\n        hi--;\n\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n\n        for (; start < hi; start++) {\n            var pivot = array[start];\n\n            var left = lo;\n            var right = start;\n            var mid;\n\n            while (left < right) {\n                mid = left + right >>> 1;\n\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n\n            var n = start - left;\n\n            switch (n) {\n                case 3:\n                    array[left + 3] = array[left + 2];\n\n                case 2:\n                    array[left + 2] = array[left + 1];\n\n                case 1:\n                    array[left + 1] = array[left];\n                    break;\n                default:\n                    while (n > 0) {\n                        array[left + n] = array[left + n - 1];\n                        n--;\n                    }\n            }\n\n            array[left] = pivot;\n        }\n    }\n\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n        else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            }\n            else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        else {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n\n        lastOffset++;\n\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            }\n            else {\n                lastOffset = m + 1;\n            }\n        }\n\n        return offset;\n    }\n\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n\n        length = array.length;\n\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n\n        var tmp = [];\n\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\n        runStart = [];\n        runLength = [];\n\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                }\n                else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n\n                mergeAt(n);\n            }\n        }\n\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n\n            runLength[i] = length1 + length2;\n\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n\n            stackSize--;\n\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n\n            if (length1 === 0) {\n                return;\n            }\n\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n            if (length2 === 0) {\n                return;\n            }\n\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            }\n            else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n\n            array[dest++] = array[cursor2++];\n\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest++] = array[cursor2++];\n\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            minGallop < 1 && (minGallop = 1);\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            }\n            else if (length1 === 0) {\n                throw new Error();\n                // throw new Error('mergeLow preconditions were not respected');\n            }\n            else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n\n        function mergeHigh (start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n\n            array[dest--] = array[cursor1--];\n\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n\n                return;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n                return;\n            }\n\n            var _minGallop = minGallop;\n\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = tmp[cursor2--];\n\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = array[cursor1--];\n\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n            }\n            else if (length2 === 0) {\n                throw new Error();\n                // throw new Error('mergeHigh preconditions were not respected');\n            }\n            else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n\n        var remaining = hi - lo;\n\n        if (remaining < 2) {\n            return;\n        }\n\n        var runLength = 0;\n\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n\n        var ts = new TimSort(array, compare);\n\n        var minRun = minRunLength(remaining);\n\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n\n        ts.forceMergeRuns();\n    }\n\n    module.exports = sort;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/core/timsort.js\n// module id = 1017\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var axisHelper = require('./axisHelper');\n\n    function getName(obj) {\n        if (zrUtil.isObject(obj) && obj.value != null) {\n            return obj.value;\n        }\n        else {\n            return obj + '';\n        }\n    }\n\n    module.exports = {\n\n        /**\n         * Format labels\n         * @return {Array.<string>}\n         */\n        getFormattedLabels: function () {\n            return axisHelper.getFormattedLabels(\n                this.axis,\n                this.get('axisLabel.formatter')\n            );\n        },\n\n        /**\n         * Get categories\n         */\n        getCategories: function () {\n            return this.get('type') === 'category'\n                && zrUtil.map(this.get('data'), getName);\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN\n         */\n        getMin: function (origin) {\n            var option = this.option;\n            var min = (!origin && option.rangeStart != null)\n                ? option.rangeStart : option.min;\n\n            if (this.axis\n                && min != null\n                && min !== 'dataMin'\n                && typeof min !== 'function'\n                && !zrUtil.eqNaN(min)\n            ) {\n                min = this.axis.scale.parse(min);\n            }\n            return min;\n        },\n\n        /**\n         * @param {boolean} origin\n         * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN\n         */\n        getMax: function (origin) {\n            var option = this.option;\n            var max = (!origin && option.rangeEnd != null)\n                ? option.rangeEnd : option.max;\n\n            if (this.axis\n                && max != null\n                && max !== 'dataMax'\n                && typeof max !== 'function'\n                && !zrUtil.eqNaN(max)\n            ) {\n                max = this.axis.scale.parse(max);\n            }\n            return max;\n        },\n\n        /**\n         * @return {boolean}\n         */\n        getNeedCrossZero: function () {\n            var option = this.option;\n            return (option.rangeStart != null || option.rangeEnd != null)\n                ? false : !option.scale;\n        },\n\n        /**\n         * Should be implemented by each axis model if necessary.\n         * @return {module:echarts/model/Component} coordinate system model\n         */\n        getCoordSysModel: zrUtil.noop,\n\n        /**\n         * @param {number} rangeStart Can only be finite number or null/undefined or NaN.\n         * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.\n         */\n        setRange: function (rangeStart, rangeEnd) {\n            this.option.rangeStart = rangeStart;\n            this.option.rangeEnd = rangeEnd;\n        },\n\n        /**\n         * Reset range\n         */\n        resetRange: function () {\n            // rangeStart and rangeEnd is readonly.\n            this.option.rangeStart = this.option.rangeEnd = null;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/axisModelCommonMixin.js\n// module id = 1018\n// module chunks = 0 1 2","/**\n * @file Data zoom model\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var env = require('zrender/lib/core/env');\n    var echarts = require('../../echarts');\n    var modelUtil = require('../../util/model');\n    var helper = require('./helper');\n    var AxisProxy = require('./AxisProxy');\n    var each = zrUtil.each;\n    var eachAxisDim = helper.eachAxisDim;\n\n    var DataZoomModel = echarts.extendComponentModel({\n\n        type: 'dataZoom',\n\n        dependencies: [\n            'xAxis', 'yAxis', 'zAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series'\n        ],\n\n        /**\n         * @protected\n         */\n        defaultOption: {\n            zlevel: 0,\n            z: 4,                   // Higher than normal component (z: 2).\n            orient: null,           // Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.\n            xAxisIndex: null,       // Default the first horizontal category axis.\n            yAxisIndex: null,       // Default the first vertical category axis.\n\n            filterMode: 'filter',   // Possible values: 'filter' or 'empty' or 'weakFilter'.\n                                    // 'filter': data items which are out of window will be removed. This option is\n                                    //          applicable when filtering outliers. For each data item, it will be\n                                    //          filtered if one of the relevant dimensions is out of the window.\n                                    // 'weakFilter': data items which are out of window will be removed. This option\n                                    //          is applicable when filtering outliers. For each data item, it will be\n                                    //          filtered only if all  of the relevant dimensions are out of the same\n                                    //          side of the window.\n                                    // 'empty': data items which are out of window will be set to empty.\n                                    //          This option is applicable when user should not neglect\n                                    //          that there are some data items out of window.\n                                    // 'none': Do not filter.\n                                    // Taking line chart as an example, line will be broken in\n                                    // the filtered points when filterModel is set to 'empty', but\n                                    // be connected when set to 'filter'.\n\n            throttle: null,         // Dispatch action by the fixed rate, avoid frequency.\n                                    // default 100. Do not throttle when use null/undefined.\n                                    // If animation === true and animationDurationUpdate > 0,\n                                    // default value is 100, otherwise 20.\n            start: 0,               // Start percent. 0 ~ 100\n            end: 100,               // End percent. 0 ~ 100\n            startValue: null,       // Start value. If startValue specified, start is ignored.\n            endValue: null,         // End value. If endValue specified, end is ignored.\n            minSpan: null,          // 0 ~ 100\n            maxSpan: null,          // 0 ~ 100\n            minValueSpan: null,     // The range of dataZoom can not be smaller than that.\n            maxValueSpan: null,     // The range of dataZoom can not be larger than that.\n            rangeMode: null         // Array, can be 'value' or 'percent'.\n        },\n\n        /**\n         * @override\n         */\n        init: function (option, parentModel, ecModel) {\n\n            /**\n             * key like x_0, y_1\n             * @private\n             * @type {Object}\n             */\n            this._dataIntervalByAxis = {};\n\n            /**\n             * @private\n             */\n            this._dataInfo = {};\n\n            /**\n             * key like x_0, y_1\n             * @private\n             */\n            this._axisProxies = {};\n\n            /**\n             * @readOnly\n             */\n            this.textStyleModel;\n\n            /**\n             * @private\n             */\n            this._autoThrottle = true;\n\n            /**\n             * 'percent' or 'value'\n             * @private\n             */\n            this._rangePropMode = ['percent', 'percent'];\n\n            var rawOption = retrieveRaw(option);\n\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            this.doInit(rawOption);\n        },\n\n        /**\n         * @override\n         */\n        mergeOption: function (newOption) {\n            var rawOption = retrieveRaw(newOption);\n\n            //FIX #2591\n            zrUtil.merge(this.option, newOption, true);\n\n            this.doInit(rawOption);\n        },\n\n        /**\n         * @protected\n         */\n        doInit: function (rawOption) {\n            var thisOption = this.option;\n\n            // Disable realtime view update if canvas is not supported.\n            if (!env.canvasSupported) {\n                thisOption.realtime = false;\n            }\n\n            this._setDefaultThrottle(rawOption);\n\n            updateRangeUse(this, rawOption);\n\n            each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n                // start/end has higher priority over startValue/endValue if they\n                // both set, but we should make chart.setOption({endValue: 1000})\n                // effective, rather than chart.setOption({endValue: 1000, end: null}).\n                if (this._rangePropMode[index] === 'value') {\n                    thisOption[names[0]] = null;\n                }\n                // Otherwise do nothing and use the merge result.\n            }, this);\n\n            this.textStyleModel = this.getModel('textStyle');\n\n            this._resetTarget();\n\n            this._giveAxisProxies();\n        },\n\n        /**\n         * @private\n         */\n        _giveAxisProxies: function () {\n            var axisProxies = this._axisProxies;\n\n            this.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel, ecModel) {\n                var axisModel = this.dependentModels[dimNames.axis][axisIndex];\n\n                // If exists, share axisProxy with other dataZoomModels.\n                var axisProxy = axisModel.__dzAxisProxy || (\n                    // Use the first dataZoomModel as the main model of axisProxy.\n                    axisModel.__dzAxisProxy = new AxisProxy(\n                        dimNames.name, axisIndex, this, ecModel\n                    )\n                );\n                // FIXME\n                // dispose __dzAxisProxy\n\n                axisProxies[dimNames.name + '_' + axisIndex] = axisProxy;\n            }, this);\n        },\n\n        /**\n         * @private\n         */\n        _resetTarget: function () {\n            var thisOption = this.option;\n\n            var autoMode = this._judgeAutoMode();\n\n            eachAxisDim(function (dimNames) {\n                var axisIndexName = dimNames.axisIndex;\n                thisOption[axisIndexName] = modelUtil.normalizeToArray(\n                    thisOption[axisIndexName]\n                );\n            }, this);\n\n            if (autoMode === 'axisIndex') {\n                this._autoSetAxisIndex();\n            }\n            else if (autoMode === 'orient') {\n                this._autoSetOrient();\n            }\n        },\n\n        /**\n         * @private\n         */\n        _judgeAutoMode: function () {\n            // Auto set only works for setOption at the first time.\n            // The following is user's reponsibility. So using merged\n            // option is OK.\n            var thisOption = this.option;\n\n            var hasIndexSpecified = false;\n            eachAxisDim(function (dimNames) {\n                // When user set axisIndex as a empty array, we think that user specify axisIndex\n                // but do not want use auto mode. Because empty array may be encountered when\n                // some error occured.\n                if (thisOption[dimNames.axisIndex] != null) {\n                    hasIndexSpecified = true;\n                }\n            }, this);\n\n            var orient = thisOption.orient;\n\n            if (orient == null && hasIndexSpecified) {\n                return 'orient';\n            }\n            else if (!hasIndexSpecified) {\n                if (orient == null) {\n                    thisOption.orient = 'horizontal';\n                }\n                return 'axisIndex';\n            }\n        },\n\n        /**\n         * @private\n         */\n        _autoSetAxisIndex: function () {\n            var autoAxisIndex = true;\n            var orient = this.get('orient', true);\n            var thisOption = this.option;\n            var dependentModels = this.dependentModels;\n\n            if (autoAxisIndex) {\n                // Find axis that parallel to dataZoom as default.\n                var dimName = orient === 'vertical' ? 'y' : 'x';\n\n                if (dependentModels[dimName + 'Axis'].length) {\n                    thisOption[dimName + 'AxisIndex'] = [0];\n                    autoAxisIndex = false;\n                }\n                else {\n                    each(dependentModels.singleAxis, function (singleAxisModel) {\n                        if (autoAxisIndex && singleAxisModel.get('orient', true) === orient) {\n                            thisOption.singleAxisIndex = [singleAxisModel.componentIndex];\n                            autoAxisIndex = false;\n                        }\n                    });\n                }\n            }\n\n            if (autoAxisIndex) {\n                // Find the first category axis as default. (consider polar)\n                eachAxisDim(function (dimNames) {\n                    if (!autoAxisIndex) {\n                        return;\n                    }\n                    var axisIndices = [];\n                    var axisModels = this.dependentModels[dimNames.axis];\n                    if (axisModels.length && !axisIndices.length) {\n                        for (var i = 0, len = axisModels.length; i < len; i++) {\n                            if (axisModels[i].get('type') === 'category') {\n                                axisIndices.push(i);\n                            }\n                        }\n                    }\n                    thisOption[dimNames.axisIndex] = axisIndices;\n                    if (axisIndices.length) {\n                        autoAxisIndex = false;\n                    }\n                }, this);\n            }\n\n            if (autoAxisIndex) {\n                // FIXME\n                // ec2xAxisIndexyAxisIndexscatterdataZoom\n                // Grid.js#getScaleByOptiontimelogaxis type\n\n                // If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified,\n                // dataZoom component auto adopts series that reference to\n                // both xAxis and yAxis which type is 'value'.\n                this.ecModel.eachSeries(function (seriesModel) {\n                    if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) {\n                        eachAxisDim(function (dimNames) {\n                            var axisIndices = thisOption[dimNames.axisIndex];\n\n                            var axisIndex = seriesModel.get(dimNames.axisIndex);\n                            var axisId = seriesModel.get(dimNames.axisId);\n\n                            var axisModel = seriesModel.ecModel.queryComponents({\n                                mainType: dimNames.axis,\n                                index: axisIndex,\n                                id: axisId\n                            })[0];\n\n                            if (__DEV__) {\n                                if (!axisModel) {\n                                    throw new Error(\n                                        dimNames.axis + ' \"' + zrUtil.retrieve(\n                                            axisIndex,\n                                            axisId,\n                                            0\n                                        ) + '\" not found'\n                                    );\n                                }\n                            }\n                            axisIndex = axisModel.componentIndex;\n\n                            if (zrUtil.indexOf(axisIndices, axisIndex) < 0) {\n                                axisIndices.push(axisIndex);\n                            }\n                        });\n                    }\n                }, this);\n            }\n        },\n\n        /**\n         * @private\n         */\n        _autoSetOrient: function () {\n            var dim;\n\n            // Find the first axis\n            this.eachTargetAxis(function (dimNames) {\n                !dim && (dim = dimNames.name);\n            }, this);\n\n            this.option.orient = dim === 'y' ? 'vertical' : 'horizontal';\n        },\n\n        /**\n         * @private\n         */\n        _isSeriesHasAllAxesTypeOf: function (seriesModel, axisType) {\n            // FIXME\n            // seriesxAxisIndexyAxisIndex\n            // series.type === scatter\n\n            var is = true;\n            eachAxisDim(function (dimNames) {\n                var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);\n                var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];\n\n                if (!axisModel || axisModel.get('type') !== axisType) {\n                    is = false;\n                }\n            }, this);\n            return is;\n        },\n\n        /**\n         * @private\n         */\n        _setDefaultThrottle: function (rawOption) {\n            // When first time user set throttle, auto throttle ends.\n            if (rawOption.hasOwnProperty('throttle')) {\n                this._autoThrottle = false;\n            }\n            if (this._autoThrottle) {\n                var globalOption = this.ecModel.option;\n                this.option.throttle =\n                    (globalOption.animation && globalOption.animationDurationUpdate > 0)\n                    ? 100 : 20;\n            }\n        },\n\n        /**\n         * @public\n         */\n        getFirstTargetAxisModel: function () {\n            var firstAxisModel;\n            eachAxisDim(function (dimNames) {\n                if (firstAxisModel == null) {\n                    var indices = this.get(dimNames.axisIndex);\n                    if (indices.length) {\n                        firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];\n                    }\n                }\n            }, this);\n\n            return firstAxisModel;\n        },\n\n        /**\n         * @public\n         * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel\n         */\n        eachTargetAxis: function (callback, context) {\n            var ecModel = this.ecModel;\n            eachAxisDim(function (dimNames) {\n                each(\n                    this.get(dimNames.axisIndex),\n                    function (axisIndex) {\n                        callback.call(context, dimNames, axisIndex, this, ecModel);\n                    },\n                    this\n                );\n            }, this);\n        },\n\n        /**\n         * @param {string} dimName\n         * @param {number} axisIndex\n         * @return {module:echarts/component/dataZoom/AxisProxy} If not found, return null/undefined.\n         */\n        getAxisProxy: function (dimName, axisIndex) {\n            return this._axisProxies[dimName + '_' + axisIndex];\n        },\n\n        /**\n         * @param {string} dimName\n         * @param {number} axisIndex\n         * @return {module:echarts/model/Model} If not found, return null/undefined.\n         */\n        getAxisModel: function (dimName, axisIndex) {\n            var axisProxy = this.getAxisProxy(dimName, axisIndex);\n            return axisProxy && axisProxy.getAxisModel();\n        },\n\n        /**\n         * If not specified, set to undefined.\n         *\n         * @public\n         * @param {Object} opt\n         * @param {number} [opt.start]\n         * @param {number} [opt.end]\n         * @param {number} [opt.startValue]\n         * @param {number} [opt.endValue]\n         * @param {boolean} [ignoreUpdateRangeUsg=false]\n         */\n        setRawRange: function (opt, ignoreUpdateRangeUsg) {\n            each(['start', 'end', 'startValue', 'endValue'], function (name) {\n                // If any of those prop is null/undefined, we should alos set\n                // them, because only one pair between start/end and\n                // startValue/endValue can work.\n                this.option[name] = opt[name];\n            }, this);\n\n            !ignoreUpdateRangeUsg && updateRangeUse(this, opt);\n        },\n\n        /**\n         * @public\n         * @return {Array.<number>} [startPercent, endPercent]\n         */\n        getPercentRange: function () {\n            var axisProxy = this.findRepresentativeAxisProxy();\n            if (axisProxy) {\n                return axisProxy.getDataPercentWindow();\n            }\n        },\n\n        /**\n         * @public\n         * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);\n         *\n         * @param {string} [axisDimName]\n         * @param {number} [axisIndex]\n         * @return {Array.<number>} [startValue, endValue] value can only be '-' or finite number.\n         */\n        getValueRange: function (axisDimName, axisIndex) {\n            if (axisDimName == null && axisIndex == null) {\n                var axisProxy = this.findRepresentativeAxisProxy();\n                if (axisProxy) {\n                    return axisProxy.getDataValueWindow();\n                }\n            }\n            else {\n                return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();\n            }\n        },\n\n        /**\n         * @public\n         * @param {module:echarts/model/Model} [axisModel] If axisModel given, find axisProxy\n         *      corresponding to the axisModel\n         * @return {module:echarts/component/dataZoom/AxisProxy}\n         */\n        findRepresentativeAxisProxy: function (axisModel) {\n            if (axisModel) {\n                return axisModel.__dzAxisProxy;\n            }\n\n            // Find the first hosted axisProxy\n            var axisProxies = this._axisProxies;\n            for (var key in axisProxies) {\n                if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {\n                    return axisProxies[key];\n                }\n            }\n\n            // If no hosted axis find not hosted axisProxy.\n            // Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis,\n            // and the option.start or option.end settings are different. The percentRange\n            // should follow axisProxy.\n            // (We encounter this problem in toolbox data zoom.)\n            for (var key in axisProxies) {\n                if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {\n                    return axisProxies[key];\n                }\n            }\n        },\n\n        /**\n         * @return {Array.<string>}\n         */\n        getRangePropMode: function () {\n            return this._rangePropMode.slice();\n        }\n\n    });\n\n    function retrieveRaw(option) {\n        var ret = {};\n        each(\n            ['start', 'end', 'startValue', 'endValue', 'throttle'],\n            function (name) {\n                option.hasOwnProperty(name) && (ret[name] = option[name]);\n            }\n        );\n        return ret;\n    }\n\n    function updateRangeUse(dataZoomModel, rawOption) {\n        var rangePropMode = dataZoomModel._rangePropMode;\n        var rangeModeInOption = dataZoomModel.get('rangeMode');\n\n        each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n            var percentSpecified = rawOption[names[0]] != null;\n            var valueSpecified = rawOption[names[1]] != null;\n            if (percentSpecified && !valueSpecified) {\n                rangePropMode[index] = 'percent';\n            }\n            else if (!percentSpecified && valueSpecified) {\n                rangePropMode[index] = 'value';\n            }\n            else if (rangeModeInOption) {\n                rangePropMode[index] = rangeModeInOption[index];\n            }\n            else if (percentSpecified) { // percentSpecified && valueSpecified\n                rangePropMode[index] = 'percent';\n            }\n            // else remain its original setting.\n        });\n    }\n\n    module.exports = DataZoomModel;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/DataZoomModel.js\n// module id = 1019\n// module chunks = 0 1 2","\n    var formatUtil = require('../../util/format');\n    var zrUtil = require('zrender/lib/core/util');\n\n    var helper = {};\n\n    var AXIS_DIMS = ['x', 'y', 'z', 'radius', 'angle', 'single'];\n    // Supported coords.\n    var COORDS = ['cartesian2d', 'polar', 'singleAxis'];\n\n    /**\n     * @param {string} coordType\n     * @return {boolean}\n     */\n    helper.isCoordSupported = function (coordType) {\n        return zrUtil.indexOf(COORDS, coordType) >= 0;\n    };\n\n    /**\n     * Create \"each\" method to iterate names.\n     *\n     * @pubilc\n     * @param  {Array.<string>} names\n     * @param  {Array.<string>=} attrs\n     * @return {Function}\n     */\n    helper.createNameEach = function (names, attrs) {\n        names = names.slice();\n        var capitalNames = zrUtil.map(names, formatUtil.capitalFirst);\n        attrs = (attrs || []).slice();\n        var capitalAttrs = zrUtil.map(attrs, formatUtil.capitalFirst);\n\n        return function (callback, context) {\n            zrUtil.each(names, function (name, index) {\n                var nameObj = {name: name, capital: capitalNames[index]};\n\n                for (var j = 0; j < attrs.length; j++) {\n                    nameObj[attrs[j]] = name + capitalAttrs[j];\n                }\n\n                callback.call(context, nameObj);\n            });\n        };\n    };\n\n    /**\n     * Iterate each dimension name.\n     *\n     * @public\n     * @param {Function} callback The parameter is like:\n     *                            {\n     *                                name: 'angle',\n     *                                capital: 'Angle',\n     *                                axis: 'angleAxis',\n     *                                axisIndex: 'angleAixs',\n     *                                index: 'angleIndex'\n     *                            }\n     * @param {Object} context\n     */\n    helper.eachAxisDim = helper.createNameEach(AXIS_DIMS, ['axisIndex', 'axis', 'index', 'id']);\n\n    /**\n     * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'.\n     * dataZoomModels and 'links' make up one or more graphics.\n     * This function finds the graphic where the source dataZoomModel is in.\n     *\n     * @public\n     * @param {Function} forEachNode Node iterator.\n     * @param {Function} forEachEdgeType edgeType iterator\n     * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id.\n     * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}}\n     */\n    helper.createLinkedNodesFinder = function (forEachNode, forEachEdgeType, edgeIdGetter) {\n\n        return function (sourceNode) {\n            var result = {\n                nodes: [],\n                records: {} // key: edgeType.name, value: Object (key: edge id, value: boolean).\n            };\n\n            forEachEdgeType(function (edgeType) {\n                result.records[edgeType.name] = {};\n            });\n\n            if (!sourceNode) {\n                return result;\n            }\n\n            absorb(sourceNode, result);\n\n            var existsLink;\n            do {\n                existsLink = false;\n                forEachNode(processSingleNode);\n            }\n            while (existsLink);\n\n            function processSingleNode(node) {\n                if (!isNodeAbsorded(node, result) && isLinked(node, result)) {\n                    absorb(node, result);\n                    existsLink = true;\n                }\n            }\n\n            return result;\n        };\n\n        function isNodeAbsorded(node, result) {\n            return zrUtil.indexOf(result.nodes, node) >= 0;\n        }\n\n        function isLinked(node, result) {\n            var hasLink = false;\n            forEachEdgeType(function (edgeType) {\n                zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n                    result.records[edgeType.name][edgeId] && (hasLink = true);\n                });\n            });\n            return hasLink;\n        }\n\n        function absorb(node, result) {\n            result.nodes.push(node);\n            forEachEdgeType(function (edgeType) {\n                zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {\n                    result.records[edgeType.name][edgeId] = true;\n                });\n            });\n        }\n    };\n\n    module.exports = helper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/helper.js\n// module id = 1020\n// module chunks = 0 1 2","\n\n    var ComponentView = require('../../view/Component');\n\n    module.exports = ComponentView.extend({\n\n        type: 'dataZoom',\n\n        render: function (dataZoomModel, ecModel, api, payload) {\n            this.dataZoomModel = dataZoomModel;\n            this.ecModel = ecModel;\n            this.api = api;\n        },\n\n        /**\n         * Find the first target coordinate system.\n         *\n         * @protected\n         * @return {Object} {\n         *                   grid: [\n         *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},\n         *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},\n         *                       ...\n         *                   ],  // cartesians must not be null/undefined.\n         *                   polar: [\n         *                       {model: coord0, axisModels: [axis4], coordIndex: 0},\n         *                       ...\n         *                   ],  // polars must not be null/undefined.\n         *                   singleAxis: [\n         *                       {model: coord0, axisModels: [], coordIndex: 0}\n         *                   ]\n         */\n        getTargetCoordInfo: function () {\n            var dataZoomModel = this.dataZoomModel;\n            var ecModel = this.ecModel;\n            var coordSysLists = {};\n\n            dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {\n                var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);\n                if (axisModel) {\n                    var coordModel = axisModel.getCoordSysModel();\n                    coordModel && save(\n                        coordModel,\n                        axisModel,\n                        coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []),\n                        coordModel.componentIndex\n                    );\n                }\n            }, this);\n\n            function save(coordModel, axisModel, store, coordIndex) {\n                var item;\n                for (var i = 0; i < store.length; i++) {\n                    if (store[i].model === coordModel) {\n                        item = store[i];\n                        break;\n                    }\n                }\n                if (!item) {\n                    store.push(item = {\n                        model: coordModel, axisModels: [], coordIndex: coordIndex\n                    });\n                }\n                item.axisModels.push(axisModel);\n            }\n\n            return coordSysLists;\n        }\n\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/DataZoomView.js\n// module id = 1021\n// module chunks = 0 1 2","\n\n    var echarts = require('../echarts');\n    var axisPointerModelHelper = require('./axisPointer/modelHelper');\n    var axisTrigger = require('./axisPointer/axisTrigger');\n    var zrUtil = require('zrender/lib/core/util');\n\n    require('./axisPointer/AxisPointerModel');\n    require('./axisPointer/AxisPointerView');\n\n    // CartesianAxisPointer is not supposed to be required here. But consider\n    // echarts.simple.js and online build tooltip, which only require gridSimple,\n    // CartesianAxisPointer should be able to required somewhere.\n    require('./axisPointer/CartesianAxisPointer');\n\n    echarts.registerPreprocessor(function (option) {\n        // Always has a global axisPointerModel for default setting.\n        if (option) {\n            (!option.axisPointer || option.axisPointer.length === 0)\n                && (option.axisPointer = {});\n\n            var link = option.axisPointer.link;\n            // Normalize to array to avoid object mergin. But if link\n            // is not set, remain null/undefined, otherwise it will\n            // override existent link setting.\n            if (link && !zrUtil.isArray(link)) {\n                option.axisPointer.link = [link];\n            }\n        }\n    });\n\n    // This process should proformed after coordinate systems created\n    // and series data processed. So put it on statistic processing stage.\n    echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {\n        // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.\n        // allAxesInfo should be updated when setOption performed.\n        ecModel.getComponent('axisPointer').coordSysAxesInfo\n            = axisPointerModelHelper.collect(ecModel, api);\n    });\n\n    // Broadcast to all views.\n    echarts.registerAction({\n        type: 'updateAxisPointer',\n        event: 'updateAxisPointer',\n        update: ':updateAxisPointer'\n    }, axisTrigger);\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer.js\n// module id = 1022\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n    var textContain = require('zrender/lib/contain/text');\n    var formatUtil = require('../../util/format');\n    var matrix = require('zrender/lib/core/matrix');\n    var axisHelper = require('../../coord/axisHelper');\n    var AxisBuilder = require('../axis/AxisBuilder');\n\n    var helper = {};\n\n    /**\n     * @param {module:echarts/model/Model} axisPointerModel\n     */\n    helper.buildElStyle = function (axisPointerModel) {\n        var axisPointerType = axisPointerModel.get('type');\n        var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');\n        var style;\n        if (axisPointerType === 'line') {\n            style = styleModel.getLineStyle();\n            style.fill = null;\n        }\n        else if (axisPointerType === 'shadow') {\n            style = styleModel.getAreaStyle();\n            style.stroke = null;\n        }\n        return style;\n    };\n\n    /**\n     * @param {Function} labelPos {align, verticalAlign, position}\n     */\n    helper.buildLabelElOption = function (\n        elOption, axisModel, axisPointerModel, api, labelPos\n    ) {\n        var value = axisPointerModel.get('value');\n        var text = helper.getValueLabel(\n            value, axisModel.axis, axisModel.ecModel,\n            axisPointerModel.get('seriesDataIndices'),\n            {\n                precision: axisPointerModel.get('label.precision'),\n                formatter: axisPointerModel.get('label.formatter')\n            }\n        );\n        var labelModel = axisPointerModel.getModel('label');\n        var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0);\n\n        var font = labelModel.getFont();\n        var textRect = textContain.getBoundingRect(text, font);\n\n        var position = labelPos.position;\n        var width = textRect.width + paddings[1] + paddings[3];\n        var height = textRect.height + paddings[0] + paddings[2];\n\n        // Adjust by align.\n        var align = labelPos.align;\n        align === 'right' && (position[0] -= width);\n        align === 'center' && (position[0] -= width / 2);\n        var verticalAlign = labelPos.verticalAlign;\n        verticalAlign === 'bottom' && (position[1] -= height);\n        verticalAlign === 'middle' && (position[1] -= height / 2);\n\n        // Not overflow ec container\n        confineInContainer(position, width, height, api);\n\n        var bgColor = labelModel.get('backgroundColor');\n        if (!bgColor || bgColor === 'auto') {\n            bgColor = axisModel.get('axisLine.lineStyle.color');\n        }\n\n        elOption.label = {\n            shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},\n            position: position.slice(),\n            // TODO: rich\n            style: {\n                text: text,\n                textFont: font,\n                textFill: labelModel.getTextColor(),\n                textPosition: 'inside',\n                fill: bgColor,\n                stroke: labelModel.get('borderColor') || 'transparent',\n                lineWidth: labelModel.get('borderWidth') || 0,\n                shadowBlur: labelModel.get('shadowBlur'),\n                shadowColor: labelModel.get('shadowColor'),\n                shadowOffsetX: labelModel.get('shadowOffsetX'),\n                shadowOffsetY: labelModel.get('shadowOffsetY')\n            },\n            // Lable should be over axisPointer.\n            z2: 10\n        };\n    };\n\n    // Do not overflow ec container\n    function confineInContainer(position, width, height, api) {\n        var viewWidth = api.getWidth();\n        var viewHeight = api.getHeight();\n        position[0] = Math.min(position[0] + width, viewWidth) - width;\n        position[1] = Math.min(position[1] + height, viewHeight) - height;\n        position[0] = Math.max(position[0], 0);\n        position[1] = Math.max(position[1], 0);\n    }\n\n    /**\n     * @param {number} value\n     * @param {module:echarts/coord/Axis} axis\n     * @param {module:echarts/model/Global} ecModel\n     * @param {Object} opt\n     * @param {Array.<Object>} seriesDataIndices\n     * @param {number|string} opt.precision 'auto' or a number\n     * @param {string|Function} opt.formatter label formatter\n     */\n    helper.getValueLabel = function (value, axis, ecModel, seriesDataIndices, opt) {\n        var text = axis.scale.getLabel(\n            // If `precision` is set, width can be fixed (like '12.00500'), which\n            // helps to debounce when when moving label.\n            value, {precision: opt.precision}\n        );\n        var formatter = opt.formatter;\n\n        if (formatter) {\n            var params = {\n                value: axisHelper.getAxisRawValue(axis, value),\n                seriesData: []\n            };\n            zrUtil.each(seriesDataIndices, function (idxItem) {\n                var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n                var dataIndex = idxItem.dataIndexInside;\n                var dataParams = series && series.getDataParams(dataIndex);\n                dataParams && params.seriesData.push(dataParams);\n            });\n\n            if (zrUtil.isString(formatter)) {\n                text = formatter.replace('{value}', text);\n            }\n            else if (zrUtil.isFunction(formatter)) {\n                text = formatter(params);\n            }\n        }\n\n        return text;\n    };\n\n    /**\n     * @param {module:echarts/coord/Axis} axis\n     * @param {number} value\n     * @param {Object} layoutInfo {\n     *  rotation, position, labelOffset, labelDirection, labelMargin\n     * }\n     */\n    helper.getTransformedPosition = function (axis, value, layoutInfo) {\n        var transform = matrix.create();\n        matrix.rotate(transform, transform, layoutInfo.rotation);\n        matrix.translate(transform, transform, layoutInfo.position);\n\n        return graphic.applyTransform([\n            axis.dataToCoord(value),\n            (layoutInfo.labelOffset || 0)\n                + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)\n        ], transform);\n    };\n\n    helper.buildCartesianSingleLabelElOption = function (\n        value, elOption, layoutInfo, axisModel, axisPointerModel, api\n    ) {\n        var textLayout = AxisBuilder.innerTextLayout(\n            layoutInfo.rotation, 0, layoutInfo.labelDirection\n        );\n        layoutInfo.labelMargin = axisPointerModel.get('label.margin');\n        helper.buildLabelElOption(elOption, axisModel, axisPointerModel, api, {\n            position: helper.getTransformedPosition(axisModel.axis, value, layoutInfo),\n            align: textLayout.textAlign,\n            verticalAlign: textLayout.textVerticalAlign\n        });\n    };\n\n    /**\n     * @param {Array.<number>} p1\n     * @param {Array.<number>} p2\n     * @param {number} [xDimIndex=0] or 1\n     */\n    helper.makeLineShape = function (p1, p2, xDimIndex) {\n        xDimIndex = xDimIndex || 0;\n        return {\n            x1: p1[xDimIndex],\n            y1: p1[1 - xDimIndex],\n            x2: p2[xDimIndex],\n            y2: p2[1 - xDimIndex]\n        };\n    };\n\n    /**\n     * @param {Array.<number>} xy\n     * @param {Array.<number>} wh\n     * @param {number} [xDimIndex=0] or 1\n     */\n    helper.makeRectShape = function (xy, wh, xDimIndex) {\n        xDimIndex = xDimIndex || 0;\n        return {\n            x: xy[xDimIndex],\n            y: xy[1 - xDimIndex],\n            width: wh[xDimIndex],\n            height: wh[1 - xDimIndex]\n        };\n    };\n\n    helper.makeSectorShape = function (cx, cy, r0, r, startAngle, endAngle) {\n        return {\n            cx: cx,\n            cy: cy,\n            r0: r0,\n            r: r,\n            startAngle: startAngle,\n            endAngle: endAngle,\n            clockwise: true\n        };\n    };\n\n    module.exports = helper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/viewHelper.js\n// module id = 1023\n// module chunks = 0 1 2","'use strict';\n/**\n * \n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\n    var matrix = require('../core/matrix');\n    var vector = require('../core/vector');\n    var mIdentity = matrix.identity;\n\n    var EPSILON = 5e-5;\n\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [0, 0];\n        }\n        if (opts.rotation == null) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * \n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [1, 1];\n        }\n        /**\n         * \n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n\n    /**\n     * \n     * , position, rotation, scaletransformtransform\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation)\n            || isNotAroundZero(this.position[0])\n            || isNotAroundZero(this.position[1])\n            || isNotAroundZero(this.scale[0] - 1)\n            || isNotAroundZero(this.scale[1] - 1);\n    };\n\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n\n        m = m || matrix.create();\n\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        }\n        else {\n            mIdentity(m);\n        }\n\n        // \n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            }\n            else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // \n        this.transform = m;\n\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n\n    transformableProto.getLocalTransform = function (m) {\n        return Transformable.getLocalTransform(this, m);\n    };\n\n    /**\n     * transformcontext\n     * @param {CanvasRenderingContext2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {        \n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        }\n        else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n\n    transformableProto.restoreTransform = function (ctx) {\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    };\n\n    var tmpTransform = [];\n\n    /**\n     * `transform``position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [1, 1];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [sx, sy];\n    };\n    /**\n     *  shape \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [x, y];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n\n    /**\n     * \n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [x, y];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n\n    /**\n     * @static\n     * @param {Object} target\n     * @param {Array.<number>} target.origin\n     * @param {number} target.rotation\n     * @param {Array.<number>} target.position\n     * @param {Array.<number>} [m]\n     */\n    Transformable.getLocalTransform = function (target, m) {\n        m = m || [];\n        mIdentity(m);\n\n        var origin = target.origin;\n        var scale = target.scale || [1, 1];\n        var rotation = target.rotation || 0;\n        var position = target.position || [0, 0];\n\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n\n        m[4] += position[0];\n        m[5] += position[1];\n\n        return m;\n    };\n\n    module.exports = Transformable;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/mixin/Transformable.js\n// module id = 1024\n// module chunks = 0 1 2","\n        var config = require('../config');\n\n        /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-, kener.linfeng@gmail.com)\n         */\n        module.exports = function() {\n            if (config.debugMode === 0) {\n                return;\n            }\n            else if (config.debugMode == 1) {\n                for (var k in arguments) {\n                    throw new Error(arguments[k]);\n                }\n            }\n            else if (config.debugMode > 1) {\n                for (var k in arguments) {\n                    console.log(arguments[k]);\n                }\n            }\n        };\n\n        /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>'\n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n    \n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/core/log.js\n// module id = 1025\n// module chunks = 0 1 2","\n\n    var textContain = require('../../contain/text');\n    var util = require('../../core/util');\n    var roundRectHelper = require('./roundRect');\n    var imageHelper = require('./image');\n\n    var retrieve3 = util.retrieve3;\n    var retrieve2 = util.retrieve2;\n\n    // TODO: Have not support 'start', 'end' yet.\n    var VALID_TEXT_ALIGN = {left: 1, right: 1, center: 1};\n    var VALID_TEXT_VERTICAL_ALIGN = {top: 1, bottom: 1, middle: 1};\n\n    var helper = {};\n\n    /**\n     * @param {module:zrender/graphic/Style} style\n     * @return {module:zrender/graphic/Style} The input style.\n     */\n    helper.normalizeTextStyle = function (style) {\n        normalizeStyle(style);\n        util.each(style.rich, normalizeStyle);\n        return style;\n    };\n\n    function normalizeStyle(style) {\n        if (style) {\n\n            style.font = textContain.makeFont(style);\n\n            var textAlign = style.textAlign;\n            textAlign === 'middle' && (textAlign = 'center');\n            style.textAlign = (\n                textAlign == null || VALID_TEXT_ALIGN[textAlign]\n            ) ? textAlign : 'left';\n\n            // Compatible with textBaseline.\n            var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n            textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n            style.textVerticalAlign = (\n                textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign]\n            ) ? textVerticalAlign : 'top';\n\n            var textPadding = style.textPadding;\n            if (textPadding) {\n                style.textPadding = util.normalizeCssArray(style.textPadding);\n            }\n        }\n    }\n\n    /**\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {string} text\n     * @param {module:zrender/graphic/Style} style\n     * @param {Object|boolean} [rect] {x, y, width, height}\n     *                  If set false, rect text is not used.\n     */\n    helper.renderText = function (hostEl, ctx, text, style, rect) {\n        style.rich\n            ? renderRichText(hostEl, ctx, text, style, rect)\n            : renderPlainText(hostEl, ctx, text, style, rect);\n    };\n\n    function renderPlainText(hostEl, ctx, text, style, rect) {\n        var font = setCtx(ctx, 'font', style.font || textContain.DEFAULT_FONT);\n\n        var textPadding = style.textPadding;\n\n        var contentBlock = hostEl.__textCotentBlock;\n        if (!contentBlock || hostEl.__dirty) {\n            contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(\n                text, font, textPadding, style.truncate\n            );\n        }\n\n        var outerHeight = contentBlock.outerHeight;\n\n        var textLines = contentBlock.lines;\n        var lineHeight = contentBlock.lineHeight;\n\n        var boxPos = getBoxPosition(outerHeight, style, rect);\n        var baseX = boxPos.baseX;\n        var baseY = boxPos.baseY;\n        var textAlign = boxPos.textAlign;\n        var textVerticalAlign = boxPos.textVerticalAlign;\n\n        // Origin of textRotation should be the base point of text drawing.\n        applyTextRotation(ctx, style, rect, baseX, baseY);\n\n        var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n        var textX = baseX;\n        var textY = boxY;\n\n        var needDrawBg = needDrawBackground(style);\n        if (needDrawBg || textPadding) {\n            // Consider performance, do not call getTextWidth util necessary.\n            var textWidth = textContain.getWidth(text, font);\n            var outerWidth = textWidth;\n            textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n            var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n\n            needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n            if (textPadding) {\n                textX = getTextXForPadding(baseX, textAlign, textPadding);\n                textY += textPadding[0];\n            }\n        }\n\n        setCtx(ctx, 'textAlign', textAlign || 'left');\n        // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n        // text will offset downward a little bit in font \"Microsoft YaHei\".\n        setCtx(ctx, 'textBaseline', 'middle');\n\n        // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n        setCtx(ctx, 'shadowBlur', style.textShadowBlur || 0);\n        setCtx(ctx, 'shadowColor', style.textShadowColor || 'transparent');\n        setCtx(ctx, 'shadowOffsetX', style.textShadowOffsetX || 0);\n        setCtx(ctx, 'shadowOffsetY', style.textShadowOffsetY || 0);\n\n        // `textBaseline` is set as 'middle'.\n        textY += lineHeight / 2;\n\n        var textStrokeWidth = style.textStrokeWidth;\n        var textStroke = getStroke(style.textStroke, textStrokeWidth);\n        var textFill = getFill(style.textFill);\n\n        if (textStroke) {\n            setCtx(ctx, 'lineWidth', textStrokeWidth);\n            setCtx(ctx, 'strokeStyle', textStroke);\n        }\n        if (textFill) {\n            setCtx(ctx, 'fillStyle', textFill);\n        }\n\n        for (var i = 0; i < textLines.length; i++) {\n            // Fill after stroke so the outline will not cover the main part.\n            textStroke && ctx.strokeText(textLines[i], textX, textY);\n            textFill && ctx.fillText(textLines[i], textX, textY);\n            textY += lineHeight;\n        }\n    }\n\n    function renderRichText(hostEl, ctx, text, style, rect) {\n        var contentBlock = hostEl.__textCotentBlock;\n\n        if (!contentBlock || hostEl.__dirty) {\n            contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n        }\n\n        drawRichText(hostEl, ctx, contentBlock, style, rect);\n    }\n\n    function drawRichText(hostEl, ctx, contentBlock, style, rect) {\n        var contentWidth = contentBlock.width;\n        var outerWidth = contentBlock.outerWidth;\n        var outerHeight = contentBlock.outerHeight;\n        var textPadding = style.textPadding;\n\n        var boxPos = getBoxPosition(outerHeight, style, rect);\n        var baseX = boxPos.baseX;\n        var baseY = boxPos.baseY;\n        var textAlign = boxPos.textAlign;\n        var textVerticalAlign = boxPos.textVerticalAlign;\n\n        // Origin of textRotation should be the base point of text drawing.\n        applyTextRotation(ctx, style, rect, baseX, baseY);\n\n        var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n        var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n        var xLeft = boxX;\n        var lineTop = boxY;\n        if (textPadding) {\n            xLeft += textPadding[3];\n            lineTop += textPadding[0];\n        }\n        var xRight = xLeft + contentWidth;\n\n        needDrawBackground(style) && drawBackground(\n            hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight\n        );\n\n        for (var i = 0; i < contentBlock.lines.length; i++) {\n            var line = contentBlock.lines[i];\n            var tokens = line.tokens;\n            var tokenCount = tokens.length;\n            var lineHeight = line.lineHeight;\n            var usedWidth = line.width;\n\n            var leftIndex = 0;\n            var lineXLeft = xLeft;\n            var lineXRight = xRight;\n            var rightIndex = tokenCount - 1;\n            var token;\n\n            while (\n                leftIndex < tokenCount\n                && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')\n            ) {\n                placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n                usedWidth -= token.width;\n                lineXLeft += token.width;\n                leftIndex++;\n            }\n\n            while (\n                rightIndex >= 0\n                && (token = tokens[rightIndex], token.textAlign === 'right')\n            ) {\n                placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n                usedWidth -= token.width;\n                lineXRight -= token.width;\n                rightIndex--;\n            }\n\n            // The other tokens are placed as textAlign 'center' if there is enough space.\n            lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n            while (leftIndex <= rightIndex) {\n                token = tokens[leftIndex];\n                // Consider width specified by user, use 'center' rather than 'left'.\n                placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n                lineXLeft += token.width;\n                leftIndex++;\n            }\n\n            lineTop += lineHeight;\n        }\n    }\n\n    function applyTextRotation(ctx, style, rect, x, y) {\n        // textRotation only apply in RectText.\n        if (rect && style.textRotation) {\n            var origin = style.textOrigin;\n            if (origin === 'center') {\n                x = rect.width / 2 + rect.x;\n                y = rect.height / 2 + rect.y;\n            }\n            else if (origin) {\n                x = origin[0] + rect.x;\n                y = origin[1] + rect.y;\n            }\n\n            ctx.translate(x, y);\n            // Positive: anticlockwise\n            ctx.rotate(-style.textRotation);\n            ctx.translate(-x, -y);\n        }\n    }\n\n    function placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n        var tokenStyle = style.rich[token.styleName] || {};\n\n        // 'ctx.textBaseline' is always set as 'middle', for sake of\n        // the bias of \"Microsoft YaHei\".\n        var textVerticalAlign = token.textVerticalAlign;\n        var y = lineTop + lineHeight / 2;\n        if (textVerticalAlign === 'top') {\n            y = lineTop + token.height / 2;\n        }\n        else if (textVerticalAlign === 'bottom') {\n            y = lineTop + lineHeight - token.height / 2;\n        }\n\n        !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(\n            hostEl,\n            ctx,\n            tokenStyle,\n            textAlign === 'right'\n                ? x - token.width\n                : textAlign === 'center'\n                ? x - token.width / 2\n                : x,\n            y - token.height / 2,\n            token.width,\n            token.height\n        );\n\n        var textPadding = token.textPadding;\n        if (textPadding) {\n            x = getTextXForPadding(x, textAlign, textPadding);\n            y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n        }\n\n        setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n        setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n        setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n        setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n\n        setCtx(ctx, 'textAlign', textAlign);\n        // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n        // text will offset downward a little bit in font \"Microsoft YaHei\".\n        setCtx(ctx, 'textBaseline', 'middle');\n\n        setCtx(ctx, 'font', token.font || textContain.DEFAULT_FONT);\n\n        var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n        var textFill = getFill(tokenStyle.textFill || style.textFill);\n        var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth);\n\n        // Fill after stroke so the outline will not cover the main part.\n        if (textStroke) {\n            setCtx(ctx, 'lineWidth', textStrokeWidth);\n            setCtx(ctx, 'strokeStyle', textStroke);\n            ctx.strokeText(token.text, x, y);\n        }\n        if (textFill) {\n            setCtx(ctx, 'fillStyle', textFill);\n            ctx.fillText(token.text, x, y);\n        }\n    }\n\n    function needDrawBackground(style) {\n        return style.textBackgroundColor\n            || (style.textBorderWidth && style.textBorderColor);\n    }\n\n    // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius}\n    // shape: {x, y, width, height}\n    function drawBackground(hostEl, ctx, style, x, y, width, height) {\n        var textBackgroundColor = style.textBackgroundColor;\n        var textBorderWidth = style.textBorderWidth;\n        var textBorderColor = style.textBorderColor;\n        var isPlainBg = util.isString(textBackgroundColor);\n\n        setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n        setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n        setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n        setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\n        if (isPlainBg || (textBorderWidth && textBorderColor)) {\n            ctx.beginPath();\n            var textBorderRadius = style.textBorderRadius;\n            if (!textBorderRadius) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, {\n                    x: x, y: y, width: width, height: height, r: textBorderRadius\n                });\n            }\n            ctx.closePath();\n        }\n\n        if (isPlainBg) {\n            setCtx(ctx, 'fillStyle', textBackgroundColor);\n            ctx.fill();\n        }\n        else if (util.isObject(textBackgroundColor)) {\n            var image = textBackgroundColor.image;\n\n            image = imageHelper.createOrUpdateImage(\n                image, null, hostEl, onBgImageLoaded, textBackgroundColor\n            );\n            if (image && imageHelper.isImageReady(image)) {\n                ctx.drawImage(image, x, y, width, height);\n            }\n        }\n\n        if (textBorderWidth && textBorderColor) {\n            setCtx(ctx, 'lineWidth', textBorderWidth);\n            setCtx(ctx, 'strokeStyle', textBorderColor);\n            ctx.stroke();\n        }\n    }\n\n    function onBgImageLoaded(image, textBackgroundColor) {\n        // Replace image, so that `contain/text.js#parseRichText`\n        // will get correct result in next tick.\n        textBackgroundColor.image = image;\n    }\n\n    function getBoxPosition(blockHeiht, style, rect) {\n        var baseX = style.x || 0;\n        var baseY = style.y || 0;\n        var textAlign = style.textAlign;\n        var textVerticalAlign = style.textVerticalAlign;\n\n        // Text position represented by coord\n        if (rect) {\n            var textPosition = style.textPosition;\n            if (textPosition instanceof Array) {\n                // Percent\n                baseX = rect.x + parsePercent(textPosition[0], rect.width);\n                baseY = rect.y + parsePercent(textPosition[1], rect.height);\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, style.textDistance\n                );\n                baseX = res.x;\n                baseY = res.y;\n                // Default align and baseline when has textPosition\n                textAlign = textAlign || res.textAlign;\n                textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n            }\n\n            // textOffset is only support in RectText, otherwise\n            // we have to adjust boundingRect for textOffset.\n            var textOffset = style.textOffset;\n            if (textOffset) {\n                baseX += textOffset[0];\n                baseY += textOffset[1];\n            }\n        }\n\n        return {\n            baseX: baseX,\n            baseY: baseY,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    }\n\n    function setCtx(ctx, prop, value) {\n        // FIXME ??? performance try\n        // if (ctx.__currentValues[prop] !== value) {\n            // ctx[prop] = ctx.__currentValues[prop] = value;\n        ctx[prop] = value;\n        // }\n        return ctx[prop];\n    }\n\n    /**\n     * @param {string} [stroke] If specified, do not check style.textStroke.\n     * @param {string} [lineWidth] If specified, do not check style.textStroke.\n     * @param {number} style\n     */\n    var getStroke = helper.getStroke = function (stroke, lineWidth) {\n        return (stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none')\n            ? null\n            // TODO pattern and gradient?\n            : (stroke.image || stroke.colorStops)\n            ? '#000'\n            : stroke;\n    };\n\n    var getFill = helper.getFill = function (fill) {\n        return (fill == null || fill === 'none')\n            ? null\n            // TODO pattern and gradient?\n            : (fill.image || fill.colorStops)\n            ? '#000'\n            : fill;\n    };\n\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    function getTextXForPadding(x, textAlign, textPadding) {\n        return textAlign === 'right'\n            ? (x - textPadding[1])\n            : textAlign === 'center'\n            ? (x + textPadding[3] / 2 - textPadding[1] / 2)\n            : (x + textPadding[3]);\n    }\n\n    /**\n     * @param {string} text\n     * @param {module:zrender/Style} style\n     * @return {boolean}\n     */\n    helper.needDrawText = function (text, style) {\n        return text != null\n            && (text\n                || style.textBackgroundColor\n                || (style.textBorderWidth && style.textBorderColor)\n                || style.textPadding\n            );\n    };\n\n    module.exports = helper;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/helper/text.js\n// module id = 1026\n// module chunks = 0 1 2","/**\n * Image element\n * @module zrender/graphic/Image\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var BoundingRect = require('../core/BoundingRect');\n    var zrUtil = require('../core/util');\n    var imageHelper = require('./helper/image');\n\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n\n    ZImage.prototype = {\n\n        constructor: ZImage,\n\n        type: 'image',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n\n            var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this);\n\n            if (!image || !imageHelper.isImageReady(image)) {\n                return;\n            }\n\n            // \n            // if (image.nodeName.toUpperCase() == 'IMG') {\n            //     if (!image.complete) {\n            //         return;\n            //     }\n            // }\n            // Else is canvas\n\n            var x = style.x || 0;\n            var y = style.y || 0;\n            var width = style.width;\n            var height = style.height;\n            var aspect = image.width / image.height;\n            if (width == null && height != null) {\n                // Keep image/height ratio\n                width = height * aspect;\n            }\n            else if (height == null && width != null) {\n                height = width / aspect;\n            }\n            else if (width == null && height == null) {\n                width = image.width;\n                height = image.height;\n            }\n\n            // transform\n            this.setTransform(ctx);\n\n            if (style.sWidth && style.sHeight) {\n                var sx = style.sx || 0;\n                var sy = style.sy || 0;\n                ctx.drawImage(\n                    image,\n                    sx, sy, style.sWidth, style.sHeight,\n                    x, y, width, height\n                );\n            }\n            else if (style.sx && style.sy) {\n                var sx = style.sx;\n                var sy = style.sy;\n                var sWidth = width - sx;\n                var sHeight = height - sy;\n                ctx.drawImage(\n                    image,\n                    sx, sy, sWidth, sHeight,\n                    x, y, width, height\n                );\n            }\n            else {\n                ctx.drawImage(image, x, y, width, height);\n            }\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (! this._rect) {\n                this._rect = new BoundingRect(\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n                );\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(ZImage, Displayable);\n\n    module.exports = ZImage;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/Image.js\n// module id = 1027\n// module chunks = 0 1 2","\n\n    var Group = require('zrender/lib/container/Group');\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n\n    var Component = function () {\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new Group();\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        this.uid = componentUtil.getUID('viewComponent');\n    };\n\n    Component.prototype = {\n\n        constructor: Component,\n\n        init: function (ecModel, api) {},\n\n        render: function (componentModel, ecModel, api, payload) {},\n\n        dispose: function () {}\n\n    };\n\n    var componentProto = Component.prototype;\n    componentProto.updateView\n        = componentProto.updateLayout\n        = componentProto.updateVisual\n        = function (seriesModel, ecModel, api, payload) {\n            // Do nothing;\n        };\n    // Enable Component.extend.\n    clazzUtil.enableClassExtend(Component);\n\n    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(Component, {registerWhenExtend: true});\n\n    module.exports = Component;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/view/Component.js\n// module id = 1028\n// module chunks = 0 1 2","\n\n    /**\n     * Calculate slider move result.\n     * Usage:\n     * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as\n     * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.\n     * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.\n     *\n     * @param {number} delta Move length.\n     * @param {Array.<number>} handleEnds handleEnds[0] can be bigger then handleEnds[1].\n     *              handleEnds will be modified in this method.\n     * @param {Array.<number>} extent handleEnds is restricted by extent.\n     *              extent[0] should less or equals than extent[1].\n     * @param {number|string} handleIndex Can be 'all', means that both move the two handleEnds,\n     *              where the input minSpan and maxSpan will not work.\n     * @param {number} [minSpan] The range of dataZoom can not be smaller than that.\n     *              If not set, handle0 and cross handle1. If set as a non-negative\n     *              number (including `0`), handles will push each other when reaching\n     *              the minSpan.\n     * @param {number} [maxSpan] The range of dataZoom can not be larger than that.\n     * @return {Array.<number>} The input handleEnds.\n     */\n    module.exports = function (delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {\n        // Normalize firstly.\n        handleEnds[0] = restrict(handleEnds[0], extent);\n        handleEnds[1] = restrict(handleEnds[1], extent);\n\n        delta = delta || 0;\n\n        var extentSpan = extent[1] - extent[0];\n\n        // Notice maxSpan and minSpan can be null/undefined.\n        if (minSpan != null) {\n            minSpan = restrict(minSpan, [0, extentSpan]);\n        }\n        if (maxSpan != null) {\n            maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);\n        }\n        if (handleIndex === 'all') {\n            minSpan = maxSpan = Math.abs(handleEnds[1] - handleEnds[0]);\n            handleIndex = 0;\n        }\n\n        var originalDistSign = getSpanSign(handleEnds, handleIndex);\n\n        handleEnds[handleIndex] += delta;\n\n        // Restrict in extent.\n        var extentMinSpan = minSpan || 0;\n        var realExtent = extent.slice();\n        originalDistSign.sign < 0 ? (realExtent[0] += extentMinSpan) : (realExtent[1] -= extentMinSpan);\n        handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent);\n\n        // Expand span.\n        var currDistSign = getSpanSign(handleEnds, handleIndex);\n        if (minSpan != null && (\n            currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan\n        )) {\n            // If minSpan exists, 'cross' is forbinden.\n            handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;\n        }\n\n        // Shrink span.\n        var currDistSign = getSpanSign(handleEnds, handleIndex);\n        if (maxSpan != null && currDistSign.span > maxSpan) {\n            handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;\n        }\n\n        return handleEnds;\n    };\n\n    function getSpanSign(handleEnds, handleIndex) {\n        var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex];\n        // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]\n        // is at left of handleEnds[1] for non-cross case.\n        return {span: Math.abs(dist), sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1};\n    }\n\n    function restrict(value, extend) {\n        return Math.min(extend[1], Math.max(extend[0], value));\n    }\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/sliderMove.js\n// module id = 1029\n// module chunks = 0 1 2","// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function () {\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n\n        this._len = 0;\n    };\n\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function (val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function (entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        }\n        else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            entry.next = null;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function (entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        }\n        else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        }\n        else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function () {\n        return this._len;\n    };\n\n    /**\n     * Clear list\n     */\n    linkedListProto.clear = function () {\n        this.head = this.tail = null;\n        this._len = 0;\n    };\n\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function (val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function (maxSize) {\n\n        this._list = new LinkedList();\n\n        this._map = {};\n\n        this._maxSize = maxSize || 10;\n\n        this._lastRemovedEntry = null;\n    };\n\n    var LRUProto = LRU.prototype;\n\n    /**\n     * @param  {string} key\n     * @param  {} value\n     * @return {} Removed value\n     */\n    LRUProto.put = function (key, value) {\n        var list = this._list;\n        var map = this._map;\n        var removed = null;\n        if (map[key] == null) {\n            var len = list.len();\n            // Reuse last removed entry\n            var entry = this._lastRemovedEntry;\n\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n\n                removed = leastUsedEntry.value;\n                this._lastRemovedEntry = leastUsedEntry;\n            }\n\n            if (entry) {\n                entry.value = value;\n            }\n            else {\n                entry = new Entry(value);\n            }\n            entry.key = key;\n            list.insertEntry(entry);\n            map[key] = entry;\n        }\n\n        return removed;\n    };\n\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function (key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n\n            return entry.value;\n        }\n    };\n\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function () {\n        this._list.clear();\n        this._map = {};\n    };\n\n    module.exports = LRU;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/core/LRU.js\n// module id = 1030\n// module chunks = 0 1 2","/**\n * @module zrender/graphic/Style\n */\n\n\n    var STYLE_COMMON_PROPS = [\n        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n    ];\n\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\n    var Style = function (opts, host) {\n        this.extendFrom(opts, false);\n        this.host = host;\n    };\n\n    function createLinearGradient(ctx, obj, rect) {\n        var x = obj.x == null ? 0 : obj.x;\n        var x2 = obj.x2 == null ? 1 : obj.x2;\n        var y = obj.y == null ? 0 : obj.y;\n        var y2 = obj.y2 == null ? 0 : obj.y2;\n\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n        return canvasGradient;\n    }\n\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n\n        var x = obj.x == null ? 0.5 : obj.x;\n        var y = obj.y == null ? 0.5 : obj.y;\n        var r = obj.r == null ? 0.5 : obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n        return canvasGradient;\n    }\n\n\n    Style.prototype = {\n\n        constructor: Style,\n\n        /**\n         * @type {module:zrender/graphic/Displayable}\n         */\n        host: null,\n\n        /**\n         * @type {string}\n         */\n        fill: '#000',\n\n        /**\n         * @type {string}\n         */\n        stroke: null,\n\n        /**\n         * @type {number}\n         */\n        opacity: 1,\n\n        /**\n         * @type {Array.<number>}\n         */\n        lineDash: null,\n\n        /**\n         * @type {number}\n         */\n        lineDashOffset: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetY: 0,\n\n        /**\n         * @type {number}\n         */\n        lineWidth: 1,\n\n        /**\n         * If stroke ignore scale\n         * @type {Boolean}\n         */\n        strokeNoScale: false,\n\n        // Bounding rect text configuration\n        // Not affected by element transform\n        /**\n         * @type {string}\n         */\n        text: null,\n\n        /**\n         * If `fontSize` or `fontFamily` exists, `font` will be reset by\n         * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.\n         * So do not visit it directly in upper application (like echarts),\n         * but use `contain/text#makeFont` instead.\n         * @type {string}\n         */\n        font: null,\n\n        /**\n         * The same as font. Use font please.\n         * @deprecated\n         * @type {string}\n         */\n        textFont: null,\n\n        /**\n         * It helps merging respectively, rather than parsing an entire font string.\n         * @type {string}\n         */\n        fontStyle: null,\n\n        /**\n         * It helps merging respectively, rather than parsing an entire font string.\n         * @type {string}\n         */\n        fontWeight: null,\n\n        /**\n         * It helps merging respectively, rather than parsing an entire font string.\n         * Should be 12 but not '12px'.\n         * @type {number}\n         */\n        fontSize: null,\n\n        /**\n         * It helps merging respectively, rather than parsing an entire font string.\n         * @type {string}\n         */\n        fontFamily: null,\n\n        /**\n         * Reserved for special functinality, like 'hr'.\n         * @type {string}\n         */\n        textTag: null,\n\n        /**\n         * @type {string}\n         */\n        textFill: '#000',\n\n        /**\n         * @type {string}\n         */\n        textStroke: null,\n\n        /**\n         * @type {number}\n         */\n        textWidth: null,\n\n        /**\n         * Only for textBackground.\n         * @type {number}\n         */\n        textHeight: null,\n\n        /**\n         * textStroke may be set as some color as a default\n         * value in upper applicaion, where the default value\n         * of textStrokeWidth should be 0 to make sure that\n         * user can choose to do not use text stroke.\n         * @type {number}\n         */\n        textStrokeWidth: 0,\n\n        /**\n         * @type {number}\n         */\n        textLineHeight: null,\n\n        /**\n         * 'inside', 'left', 'right', 'top', 'bottom'\n         * [x, y]\n         * Based on x, y of rect.\n         * @type {string|Array.<number>}\n         * @default 'inside'\n         */\n        textPosition: 'inside',\n\n        /**\n         * If not specified, use the boundingRect of a `displayable`.\n         * @type {Object}\n         */\n        textRect: null,\n\n        /**\n         * [x, y]\n         * @type {Array.<number>}\n         */\n        textOffset: null,\n\n        /**\n         * @type {string}\n         */\n        textAlign: null,\n\n        /**\n         * @type {string}\n         */\n        textVerticalAlign: null,\n\n        /**\n         * @type {number}\n         */\n        textDistance: 5,\n\n        /**\n         * @type {string}\n         */\n        textShadowColor: 'transparent',\n\n        /**\n         * @type {number}\n         */\n        textShadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        textShadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        textShadowOffsetY: 0,\n\n        /**\n         * @type {string}\n         */\n        textBoxShadowColor: 'transparent',\n\n        /**\n         * @type {number}\n         */\n        textBoxShadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        textBoxShadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        textBoxShadowOffsetY: 0,\n\n        /**\n         * Whether transform text.\n         * Only useful in Path and Image element\n         * @type {boolean}\n         */\n        transformText: false,\n\n        /**\n         * Text rotate around position of Path or Image\n         * Only useful in Path and Image element and transformText is false.\n         */\n        textRotation: 0,\n\n        /**\n         * Text origin of text rotation, like [10, 40].\n         * Based on x, y of rect.\n         * Useful in label rotation of circular symbol.\n         * By default, this origin is textPosition.\n         * Can be 'center'.\n         * @type {string|Array.<number>}\n         */\n        textOrigin: null,\n\n        /**\n         * @type {string}\n         */\n        textBackgroundColor: null,\n\n        /**\n         * @type {string}\n         */\n        textBorderColor: null,\n\n        /**\n         * @type {number}\n         */\n        textBorderWidth: 0,\n\n        /**\n         * @type {number}\n         */\n        textBorderRadius: 0,\n\n        /**\n         * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`\n         * @type {number|Array.<number>}\n         */\n        textPadding: null,\n\n        /**\n         * Text styles for rich text.\n         * @type {Object}\n         */\n        rich: null,\n\n        /**\n         * {outerWidth, outerHeight, ellipsis, placeholder}\n         * @type {Object}\n         */\n        truncate: null,\n\n        /**\n         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n         * @type {string}\n         */\n        blend: null,\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n\n            if ((firstDraw || style.fill !== prevStyle.fill)) {\n                ctx.fillStyle = style.fill;\n            }\n            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n\n            if ((firstDraw || style.blend !== prevStyle.blend)) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (\n                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n                );\n            }\n        },\n\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n\n        /**\n         * Extend from other style\n         * @param {zrender/graphic/Style} otherStyle\n         * @param {boolean} overwrite true: overwrirte any way.\n         *                            false: overwrite only when !target.hasOwnProperty\n         *                            others: overwrite when property is not null/undefined.\n         */\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name)\n                        && (overwrite === true\n                            || (\n                                overwrite === false\n                                    ? !this.hasOwnProperty(name)\n                                    : otherStyle[name] != null\n                            )\n                        )\n                    ) {\n                        this[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Batch setting style with a given object\n         * @param {Object|string} obj\n         * @param {*} [obj]\n         */\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            }\n            else {\n                this.extendFrom(obj, true);\n            }\n        },\n\n        /**\n         * Clone\n         * @return {zrender/graphic/Style} [description]\n         */\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\n            return canvasGradient;\n        }\n\n    };\n\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n\n    module.exports = Style;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/Style.js\n// module id = 1031\n// module chunks = 0 1 2","'use strict';\n/**\n * @module zrender/Element\n */\n\n\n    var guid = require('./core/guid');\n    var Eventful = require('./mixin/Eventful');\n    var Transformable = require('./mixin/Transformable');\n    var Animatable = require('./mixin/Animatable');\n    var zrUtil = require('./core/util');\n\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n\n        /**\n         * ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n\n    Element.prototype = {\n\n        /**\n         * \n         * Element type\n         * @type {string}\n         */\n        type: 'element',\n\n        /**\n         * \n         * Element name\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * ZRender  element  zrender \n         * ZRender instance will be assigned when element is associated with zrender\n         * @name module:/zrender/Element#__zr\n         * @type {module:zrender/ZRender}\n         */\n        __zr: null,\n\n        /**\n         * true\n         * If ignore drawing and events of the element object\n         * @name module:/zrender/Element#ignore\n         * @type {boolean}\n         * @default false\n         */\n        ignore: false,\n\n        /**\n         * (shape) Group \n         * \n         * @type {module:zrender/graphic/Path}\n         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n         * @readOnly\n         */\n        clipPath: null,\n\n        /**\n         * Drift element\n         * @param  {number} dx dx on the global space\n         * @param  {number} dy dy on the global space\n         */\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n\n        /**\n         * Hook before update\n         */\n        beforeUpdate: function () {},\n        /**\n         * Hook after update\n         */\n        afterUpdate: function () {},\n        /**\n         * Update each frame\n         */\n        update: function () {\n            this.updateTransform();\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {},\n\n        /**\n         * @protected\n         */\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            }\n            else {\n                this[key] = value;\n            }\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * Show the element\n         */\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * @param {string|Object} key\n         * @param {*} value\n         */\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            }\n            else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n\n            this.dirty(false);\n\n            return this;\n        },\n\n        /**\n         * @param {module:zrender/graphic/Path} clipPath\n         */\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n\n            this.dirty(false);\n        },\n\n        /**\n         */\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n\n                this.dirty(false);\n            }\n        },\n\n        /**\n         * Add self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n\n        /**\n         * Remove self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // \n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n\n    module.exports = Element;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/Element.js\n// module id = 1032\n// module chunks = 0 1 2","/**\n * zrender: id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\n\n    var idStart = 0x0907;\n\n    module.exports = function () {\n        return idStart++;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/core/guid.js\n// module id = 1033\n// module chunks = 0 1 2","/**\n * @module echarts/animation/Animator\n */\n\n\n    var Clip = require('./Clip');\n    var color = require('../tool/color');\n    var util = require('../core/util');\n    var isArrayLike = util.isArrayLike;\n\n    var arraySlice = Array.prototype.slice;\n\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        }\n        else {\n            var len2 = len && p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(\n                        p0[i][j], p1[i][j], percent\n                    );\n                }\n            }\n        }\n    }\n\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            }\n            else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(\n                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                    );\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            }\n            else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        }\n        else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(\n        p0, p1, p2, p3, t, t2, t3, out, arrDim\n    ) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(\n                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n                );\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(\n                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                        t, t2, t3\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n\n            return arraySlice.call(value);\n        }\n\n        return value;\n    }\n\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n\n    function getArrayDim(keyframes) {\n        var lastValue = keyframes[keyframes.length - 1].value;\n        return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n    }\n\n    function createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n\n        // For vertices morphing\n        var arrDim = isValueArray ? getArrayDim(keyframes) : 0;\n\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function(a, b) {\n            return a.time - b.time;\n        });\n\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n\n            // Check if value is equal, deep check if value is array\n            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n                || (!isValueArray && value === prevValue))) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                }\n                else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (!forceAnimate && isAllValueEqual) {\n            return;\n        }\n\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            }\n            else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n\n        if (isValueColor) {\n            var rgba = [0, 0, 0, 0];\n        }\n\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            }\n            else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            }\n            else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n\n            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n            if (range === 0) {\n                return;\n            }\n            else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(\n                            p0, p1, p2, p3, w, w * w, w * w * w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    }\n                    else {\n                        value = catmullRomInterpolate(\n                            p0, p1, p2, p3, w, w * w, w * w * w\n                        );\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n            else {\n                if (isValueArray) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(\n                            kfValues[frame], kfValues[frame + 1], w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n        };\n\n        var clip = new Clip({\n            target: animator._target,\n            life: trackMaxTime,\n            loop: animator._loop,\n            delay: animator._delay,\n            onframe: onframe,\n            ondestroy: oneTrackDone\n        });\n\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n\n        return clip;\n    }\n\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function(target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n\n        this._loop = loop || false;\n\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n\n        this._clipCount = 0;\n\n        this._delay = 0;\n\n        this._doneList = [];\n\n        this._onframeList = [];\n\n        this._clipList = [];\n    };\n\n    Animator.prototype = {\n        /**\n         * \n         * @param  {number} time ms\n         * @param  {Object} props key-value\n         * @return {module:zrender/animation/Animator}\n         */\n        when: function(time /* ms */, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} callback\n         * @return {module:zrender/animation/Animator}\n         */\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n\n        pause: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].pause();\n            }\n            this._paused = true;\n        },\n\n        resume: function () {\n            for (var i = 0; i < this._clipList.length; i++) {\n                this._clipList[i].resume();\n            }\n            this._paused = false;\n        },\n\n        isPaused: function () {\n            return !!this._paused;\n        },\n\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        /**\n         * \n         * @param  {string|Function} [easing]\n         *         {@link module:zrender/animation/easing}\n         * @param  {boolean} forceAnimate\n         * @return {module:zrender/animation/Animator}\n         */\n        start: function (easing, forceAnimate) {\n\n            var self = this;\n            var clipCount = 0;\n\n            var oneTrackDone = function() {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n\n            var lastClip;\n            for (var propName in this._tracks) {\n                if (!this._tracks.hasOwnProperty(propName)) {\n                    continue;\n                }\n                var clip = createTrackClip(\n                    this, easing, oneTrackDone,\n                    this._tracks[propName], propName, forceAnimate\n                );\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n\n                    lastClip = clip;\n                }\n            }\n\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n\n            // This optimization will help the case that in the upper application\n            // the view may be refreshed frequently, where animation will be\n            // called repeatly but nothing changed.\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        /**\n         * \n         * @param  {number} time ms\n         * @return {module:zrender/animation/Animator}\n         */\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        /**\n         * \n         * @param  {Function} cb\n         * @return {module:zrender/animation/Animator}\n         */\n        done: function(cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n\n        /**\n         * @return {Array.<module:zrender/animation/Clip>}\n         */\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n\n    module.exports = Animator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/animation/Animator.js\n// module id = 1034\n// module chunks = 0 1 2","\n\n    module.exports = {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            }\n            else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                }\n                else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                }\n                else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                }\n                else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            }\n            else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(\n                x + width, y, x + width, y + r2\n            );\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(\n                x + width, y + height, x + width - r3, y + height\n            );\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(\n                x, y + height, x, y + height - r4\n            );\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/helper/roundRect.js\n// module id = 1035\n// module chunks = 0 1 2","\n\n    var PI2 = Math.PI * 2;\n    module.exports = {\n        normalizeRadian: function(angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/contain/util.js\n// module id = 1036\n// module chunks = 0 1 2","\n\n    var Pattern = function (image, repeat) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {image: ...}`, where this constructor will not be called.\n\n        this.image = image;\n        this.repeat = repeat;\n\n        // Can be cloned\n        this.type = 'pattern';\n    };\n\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n        return ctx.createPattern(this.image, this.repeat || 'repeat');\n    };\n\n    module.exports = Pattern;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/Pattern.js\n// module id = 1037\n// module chunks = 0 1 2","\n\n    var smoothSpline = require('./smoothSpline');\n    var smoothBezier = require('./smoothBezier');\n\n    module.exports = {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(\n                        points, smooth, closePath, shape.smoothConstraint\n                    );\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                        );\n                    }\n                }\n                else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n\n                closePath && ctx.closePath();\n            }\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/helper/poly.js\n// module id = 1038\n// module chunks = 0 1 2","\n\n    var classUtil = require('../../util/clazz');\n    var set = classUtil.set;\n    var get = classUtil.get;\n\n    module.exports = {\n        clearColorPalette: function () {\n            set(this, 'colorIdx', 0);\n            set(this, 'colorNameMap', {});\n        },\n\n        getColorFromPalette: function (name, scope) {\n            scope = scope || this;\n            var colorIdx = get(scope, 'colorIdx') || 0;\n            var colorNameMap = get(scope, 'colorNameMap') || set(scope, 'colorNameMap', {});\n            // Use `hasOwnProperty` to avoid conflict with Object.prototype.\n            if (colorNameMap.hasOwnProperty(name)) {\n                return colorNameMap[name];\n            }\n            var colorPalette = this.get('color', true) || [];\n            if (!colorPalette.length) {\n                return;\n            }\n\n            var color = colorPalette[colorIdx];\n            if (name) {\n                colorNameMap[name] = color;\n            }\n            set(scope, 'colorIdx', (colorIdx + 1) % colorPalette.length);\n\n            return color;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/model/mixin/colorPalette.js\n// module id = 1039\n// module chunks = 0 1 2","\n\n    module.exports = (typeof window !== 'undefined' &&\n                ((window.requestAnimationFrame && window.requestAnimationFrame.bind(window))\n                // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809\n                || (window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window))\n                || window.mozRequestAnimationFrame\n                || window.webkitRequestAnimationFrame)\n            )\n            || function (func) {\n                setTimeout(func, 16);\n            };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/animation/requestAnimationFrame.js\n// module id = 1040\n// module chunks = 0 1 2","/**\n * For testable.\n */\n\n\n    var numberUtil = require('../util/number');\n\n    var roundNumber = numberUtil.round;\n\n    var helper = {};\n\n    /**\n     * @param {Array.<number>} extent Both extent[0] and extent[1] should be valid number.\n     *                                Should be extent[0] < extent[1].\n     * @param {number} splitNumber splitNumber should be >= 1.\n     * @param {number} [minInterval]\n     * @param {number} [maxInterval]\n     * @return {Object} {interval, intervalPrecision, niceTickExtent}\n     */\n    helper.intervalScaleNiceTicks = function (extent, splitNumber, minInterval, maxInterval) {\n        var result = {};\n        var span = extent[1] - extent[0];\n\n        var interval = result.interval = numberUtil.nice(span / splitNumber, true);\n        if (minInterval != null && interval < minInterval) {\n            interval = result.interval = minInterval;\n        }\n        if (maxInterval != null && interval > maxInterval) {\n            interval = result.interval = maxInterval;\n        }\n        // Tow more digital for tick.\n        var precision = result.intervalPrecision = helper.getIntervalPrecision(interval);\n        // Niced extent inside original extent\n        var niceTickExtent = result.niceTickExtent = [\n            roundNumber(Math.ceil(extent[0] / interval) * interval, precision),\n            roundNumber(Math.floor(extent[1] / interval) * interval, precision)\n        ];\n\n        helper.fixExtent(niceTickExtent, extent);\n\n        return result;\n    };\n\n    /**\n     * @param {number} interval\n     * @return {number} interval precision\n     */\n    helper.getIntervalPrecision = function (interval) {\n        // Tow more digital for tick.\n        return numberUtil.getPrecisionSafe(interval) + 2;\n    };\n\n    function clamp(niceTickExtent, idx, extent) {\n        niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);\n    }\n\n    // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.\n    helper.fixExtent = function (niceTickExtent, extent) {\n        !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);\n        !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);\n        clamp(niceTickExtent, 0, extent);\n        clamp(niceTickExtent, 1, extent);\n        if (niceTickExtent[0] > niceTickExtent[1]) {\n            niceTickExtent[0] = niceTickExtent[1];\n        }\n    };\n\n    helper.intervalScaleGetTicks = function (interval, extent, niceTickExtent, intervalPrecision) {\n        var ticks = [];\n\n        // If interval is 0, return [];\n        if (!interval) {\n            return ticks;\n        }\n\n        // Consider this case: using dataZoom toolbox, zoom and zoom.\n        var safeLimit = 10000;\n\n        if (extent[0] < niceTickExtent[0]) {\n            ticks.push(extent[0]);\n        }\n        var tick = niceTickExtent[0];\n\n        while (tick <= niceTickExtent[1]) {\n            ticks.push(tick);\n            // Avoid rounding error\n            tick = roundNumber(tick + interval, intervalPrecision);\n            if (tick === ticks[ticks.length - 1]) {\n                // Consider out of safe float point, e.g.,\n                // -3711126.9907707 + 2e-10 === -3711126.9907707\n                break;\n            }\n            if (ticks.length > safeLimit) {\n                return [];\n            }\n        }\n        // Consider this case: the last item of ticks is smaller\n        // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n        if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1])) {\n            ticks.push(extent[1]);\n        }\n\n        return ticks;\n    };\n\n    module.exports = helper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/scale/helper.js\n// module id = 1041\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n\n    /**\n     * @param {Object} finder contains {seriesIndex, dataIndex, dataIndexInside}\n     * @param {module:echarts/model/Global} ecModel\n     * @return {Object} {point: [x, y], el: ...} point Will not be null.\n     */\n    module.exports = function (finder, ecModel) {\n        var point = [];\n        var seriesIndex = finder.seriesIndex;\n        var seriesModel;\n        if (seriesIndex == null || !(\n            seriesModel = ecModel.getSeriesByIndex(seriesIndex)\n        )) {\n            return {point: []};\n        }\n\n        var data = seriesModel.getData();\n        var dataIndex = modelUtil.queryDataIndex(data, finder);\n        if (dataIndex == null || zrUtil.isArray(dataIndex)) {\n            return {point: []};\n        }\n\n        var el = data.getItemGraphicEl(dataIndex);\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (seriesModel.getTooltipPosition) {\n            point = seriesModel.getTooltipPosition(dataIndex) || [];\n        }\n        else if (coordSys && coordSys.dataToPoint) {\n            point = coordSys.dataToPoint(\n                data.getValues(\n                    zrUtil.map(coordSys.dimensions, function (dim) {\n                        return seriesModel.coordDimToDataDim(dim)[0];\n                    }), dataIndex, true\n                )\n            ) || [];\n        }\n        else if (el) {\n            // Use graphic bounding rect\n            var rect = el.getBoundingRect().clone();\n            rect.applyTransform(el.transform);\n            point = [\n                rect.x + rect.width / 2,\n                rect.y + rect.height / 2\n            ];\n        }\n\n        return {point: point, el: el};\n    };\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js\n// module id = 1042\n// module chunks = 0 1 2","\n\n    var env = require('zrender/lib/core/env');\n    var zrUtil = require('zrender/lib/core/util');\n    var get = require('../../util/model').makeGetter();\n\n    var each = zrUtil.each;\n\n    var globalListener = {};\n\n    /**\n     * @param {string} key\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Function} handler\n     *      param: {string} currTrigger\n     *      param: {Array.<number>} point\n     */\n    globalListener.register = function (key, api, handler) {\n        if (env.node) {\n            return;\n        }\n\n        var zr = api.getZr();\n        get(zr).records || (get(zr).records = {});\n\n        initGlobalListeners(zr, api);\n\n        var record = get(zr).records[key] || (get(zr).records[key] = {});\n        record.handler = handler;\n    };\n\n    function initGlobalListeners(zr, api) {\n        if (get(zr).initialized) {\n            return;\n        }\n\n        get(zr).initialized = true;\n\n        useHandler('click', zrUtil.curry(doEnter, 'click'));\n        useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove'));\n        // useHandler('mouseout', onLeave);\n        useHandler('globalout', onLeave);\n\n        function useHandler(eventType, cb) {\n            zr.on(eventType, function (e) {\n                var dis = makeDispatchAction(api);\n\n                each(get(zr).records, function (record) {\n                    record && cb(record, e, dis.dispatchAction);\n                });\n\n                dispatchTooltipFinally(dis.pendings, api);\n            });\n        }\n    }\n\n    function dispatchTooltipFinally(pendings, api) {\n        var showLen = pendings.showTip.length;\n        var hideLen = pendings.hideTip.length;\n\n        var actuallyPayload;\n        if (showLen) {\n            actuallyPayload = pendings.showTip[showLen - 1];\n        }\n        else if (hideLen) {\n            actuallyPayload = pendings.hideTip[hideLen - 1];\n        }\n        if (actuallyPayload) {\n            actuallyPayload.dispatchAction = null;\n            api.dispatchAction(actuallyPayload);\n        }\n    }\n\n    function onLeave(record, e, dispatchAction) {\n        record.handler('leave', null, dispatchAction);\n    }\n\n    function doEnter(currTrigger, record, e, dispatchAction) {\n        record.handler(currTrigger, e, dispatchAction);\n    }\n\n    function makeDispatchAction(api) {\n        var pendings = {\n            showTip: [],\n            hideTip: []\n        };\n        // FIXME\n        // better approach?\n        // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,\n        // which may be conflict, (axisPointer call showTip but tooltip call hideTip);\n        // So we have to add \"final stage\" to merge those dispatched actions.\n        var dispatchAction = function (payload) {\n            var pendingList = pendings[payload.type];\n            if (pendingList) {\n                pendingList.push(payload);\n            }\n            else {\n                payload.dispatchAction = dispatchAction;\n                api.dispatchAction(payload);\n            }\n        };\n\n        return {\n            dispatchAction: dispatchAction,\n            pendings: pendings\n        };\n    }\n\n    /**\n     * @param {string} key\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    globalListener.unregister = function (key, api) {\n        if (env.node) {\n            return;\n        }\n        var zr = api.getZr();\n        var record = (get(zr).records || {})[key];\n        if (record) {\n            get(zr).records[key] = null;\n        }\n    };\n\n    module.exports = globalListener;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/globalListener.js\n// module id = 1043\n// module chunks = 0 1 2","\n    // List layout\n    var layout = require('../../util/layout');\n    var formatUtil = require('../../util/format');\n    var graphic = require('../../util/graphic');\n\n    module.exports = {\n        /**\n         * Layout list like component.\n         * It will box layout each items in group of component and then position the whole group in the viewport\n         * @param {module:zrender/group/Group} group\n         * @param {module:echarts/model/Component} componentModel\n         * @param {module:echarts/ExtensionAPI}\n         */\n        layout: function (group, componentModel, api) {\n            var boxLayoutParams = componentModel.getBoxLayoutParams();\n            var padding = componentModel.get('padding');\n            var viewportSize = {width: api.getWidth(), height: api.getHeight()};\n\n            var rect = layout.getLayoutRect(\n                boxLayoutParams,\n                viewportSize,\n                padding\n            );\n\n            layout.box(\n                componentModel.get('orient'),\n                group,\n                componentModel.get('itemGap'),\n                rect.width,\n                rect.height\n            );\n\n            layout.positionElement(\n                group,\n                boxLayoutParams,\n                viewportSize,\n                padding\n            );\n        },\n\n        makeBackground: function (rect, componentModel) {\n            var padding = formatUtil.normalizeCssArray(\n                componentModel.get('padding')\n            );\n            var style = componentModel.getItemStyle(['color', 'opacity']);\n            style.fill = componentModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                shape: {\n                    x: rect.x - padding[3],\n                    y: rect.y - padding[0],\n                    width: rect.width + padding[1] + padding[3],\n                    height: rect.height + padding[0] + padding[2],\n                    r: componentModel.get('borderRadius')\n                },\n                style: style,\n                silent: true,\n                z2: -1\n            });\n            // FIXME\n            // `subPixelOptimizeRect` may bring some gap between edge of viewpart\n            // and background rect when setting like `left: 0`, `top: 0`.\n            // graphic.subPixelOptimizeRect(rect);\n\n            return rect;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/listComponent.js\n// module id = 1044\n// module chunks = 0 1 2","/**\n * @file History manager.\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var each = zrUtil.each;\n\n    var ATTR = '\\0_ec_hist_store';\n\n    var history = {\n\n        /**\n         * @public\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Object} newSnapshot {dataZoomId, batch: [payloadInfo, ...]}\n         */\n        push: function (ecModel, newSnapshot) {\n            var store = giveStore(ecModel);\n\n            // If previous dataZoom can not be found,\n            // complete an range with current range.\n            each(newSnapshot, function (batchItem, dataZoomId) {\n                var i = store.length - 1;\n                for (; i >= 0; i--) {\n                    var snapshot = store[i];\n                    if (snapshot[dataZoomId]) {\n                        break;\n                    }\n                }\n                if (i < 0) {\n                    // No origin range set, create one by current range.\n                    var dataZoomModel = ecModel.queryComponents(\n                        {mainType: 'dataZoom', subType: 'select', id: dataZoomId}\n                    )[0];\n                    if (dataZoomModel) {\n                        var percentRange = dataZoomModel.getPercentRange();\n                        store[0][dataZoomId] = {\n                            dataZoomId: dataZoomId,\n                            start: percentRange[0],\n                            end: percentRange[1]\n                        };\n                    }\n                }\n            });\n\n            store.push(newSnapshot);\n        },\n\n        /**\n         * @public\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Object} snapshot\n         */\n        pop: function (ecModel) {\n            var store = giveStore(ecModel);\n            var head = store[store.length - 1];\n            store.length > 1 && store.pop();\n\n            // Find top for all dataZoom.\n            var snapshot = {};\n            each(head, function (batchItem, dataZoomId) {\n                for (var i = store.length - 1; i >= 0; i--) {\n                    var batchItem = store[i][dataZoomId];\n                    if (batchItem) {\n                        snapshot[dataZoomId] = batchItem;\n                        break;\n                    }\n                }\n            });\n\n            return snapshot;\n        },\n\n        /**\n         * @public\n         */\n        clear: function (ecModel) {\n            ecModel[ATTR] = null;\n        },\n\n        /**\n         * @public\n         * @param {module:echarts/model/Global} ecModel\n         * @return {number} records. always >= 1.\n         */\n        count: function (ecModel) {\n            return giveStore(ecModel).length;\n        }\n\n    };\n\n    /**\n     * [{key: dataZoomId, value: {dataZoomId, range}}, ...]\n     * History length of each dataZoom may be different.\n     * this._history[0] is used to store origin range.\n     * @type {Array.<Object>}\n     */\n    function giveStore(ecModel) {\n        var store = ecModel[ATTR];\n        if (!store) {\n            store = ecModel[ATTR] = [{}];\n        }\n        return store;\n    }\n\n    module.exports = history;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/history.js\n// module id = 1045\n// module chunks = 0 1 2","/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var curve = require('./curve');\n\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n\n    var PI2 = Math.PI * 2;\n    /**\n     * `min``max`\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points \n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n\n    var xDim = [];\n    var yDim = [];\n    /**\n     * (p0, p1, p2, p3)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function(\n        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n    ) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n\n    /**\n     * (p0, p1, p2)`min``max`\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx =\n            mathMax(\n                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n            );\n        var ty =\n            mathMax(\n                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n            );\n\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n\n    /**\n     * `min``max`\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (\n        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n    ) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n\n        var diff = Math.abs(startAngle - endAngle);\n\n\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n\n    module.exports = bbox;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/core/bbox.js\n// module id = 1048\n// module chunks = 0 1 2","\n\n    var env = require('../../core/env');\n\n    // Fix weird bug in some version of IE11 (like 11.0.9600.178**),\n    // where exception \"unexpected call to method or property access\"\n    // might be thrown when calling ctx.fill or ctx.stroke after a path\n    // whose area size is zero is drawn and ctx.clip() is called and\n    // shadowBlur is set. See #4572, #3112, #5777.\n    // (e.g.,\n    //  ctx.moveTo(10, 10);\n    //  ctx.lineTo(20, 10);\n    //  ctx.closePath();\n    //  ctx.clip();\n    //  ctx.shadowBlur = 10;\n    //  ...\n    //  ctx.fill();\n    // )\n\n    var shadowTemp = [\n        ['shadowBlur', 0],\n        ['shadowColor', '#000'],\n        ['shadowOffsetX', 0],\n        ['shadowOffsetY', 0]\n    ];\n\n    module.exports = function (orignalBrush) {\n\n        // version string can be: '11.0'\n        return (env.browser.ie && env.browser.version >= 11)\n\n            ? function () {\n                var clipPaths = this.__clipPaths;\n                var style = this.style;\n                var modified;\n\n                if (clipPaths) {\n                    for (var i = 0; i < clipPaths.length; i++) {\n                        var clipPath = clipPaths[i];\n                        var shape = clipPath && clipPath.shape;\n                        var type = clipPath && clipPath.type;\n\n                        if (shape && (\n                            (type === 'sector' && shape.startAngle === shape.endAngle)\n                            || (type === 'rect' && (!shape.width || !shape.height))\n                        )) {\n                            for (var j = 0; j < shadowTemp.length; j++) {\n                                // It is save to put shadowTemp static, because shadowTemp\n                                // will be all modified each item brush called.\n                                shadowTemp[j][2] = style[shadowTemp[j][0]];\n                                style[shadowTemp[j][0]] = shadowTemp[j][1];\n                            }\n                            modified = true;\n                            break;\n                        }\n                    }\n                }\n\n                orignalBrush.apply(this, arguments);\n\n                if (modified) {\n                    for (var j = 0; j < shadowTemp.length; j++) {\n                        style[shadowTemp[j][0]] = shadowTemp[j][2];\n                    }\n                }\n            }\n\n            : orignalBrush;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/helper/fixClipWithShadow.js\n// module id = 1049\n// module chunks = 0 1 2","'use strict';\n\n\n    var graphic = require('../../util/graphic');\n    var BaseAxisPointer = require('./BaseAxisPointer');\n    var viewHelper = require('./viewHelper');\n    var cartesianAxisHelper = require('../axis/cartesianAxisHelper');\n    var AxisView = require('../axis/AxisView');\n\n    var CartesianAxisPointer = BaseAxisPointer.extend({\n\n        /**\n         * @override\n         */\n        makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n            var axis = axisModel.axis;\n            var grid = axis.grid;\n            var axisPointerType = axisPointerModel.get('type');\n            var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n            var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));\n\n            if (axisPointerType && axisPointerType !== 'none') {\n                var elStyle = viewHelper.buildElStyle(axisPointerModel);\n                var pointerOption = pointerShapeBuilder[axisPointerType](\n                    axis, pixelValue, otherExtent, elStyle\n                );\n                pointerOption.style = elStyle;\n                elOption.graphicKey = pointerOption.type;\n                elOption.pointer = pointerOption;\n            }\n\n            var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);\n            viewHelper.buildCartesianSingleLabelElOption(\n                value, elOption, layoutInfo, axisModel, axisPointerModel, api\n            );\n        },\n\n        /**\n         * @override\n         */\n        getHandleTransform: function (value, axisModel, axisPointerModel) {\n            var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {\n                labelInside: false\n            });\n            layoutInfo.labelMargin = axisPointerModel.get('handle.margin');\n            return {\n                position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),\n                rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)\n            };\n        },\n\n        /**\n         * @override\n         */\n        updateHandleTransform: function (transform, delta, axisModel, axisPointerModel) {\n            var axis = axisModel.axis;\n            var grid = axis.grid;\n            var axisExtent = axis.getGlobalExtent(true);\n            var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n            var dimIndex = axis.dim === 'x' ? 0 : 1;\n\n            var currPosition = transform.position;\n            currPosition[dimIndex] += delta[dimIndex];\n            currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);\n            currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);\n\n            var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;\n            var cursorPoint = [cursorOtherValue, cursorOtherValue];\n            cursorPoint[dimIndex] = currPosition[dimIndex];\n\n            // Make tooltip do not overlap axisPointer and in the middle of the grid.\n            var tooltipOptions = [{verticalAlign: 'middle'}, {align: 'center'}];\n\n            return {\n                position: currPosition,\n                rotation: transform.rotation,\n                cursorPoint: cursorPoint,\n                tooltipOption: tooltipOptions[dimIndex]\n            };\n        }\n\n    });\n\n    function getCartesian(grid, axis) {\n        var opt = {};\n        opt[axis.dim + 'AxisIndex'] = axis.index;\n        return grid.getCartesian(opt);\n    }\n\n    var pointerShapeBuilder = {\n\n        line: function (axis, pixelValue, otherExtent, elStyle) {\n            var targetShape = viewHelper.makeLineShape(\n                [pixelValue, otherExtent[0]],\n                [pixelValue, otherExtent[1]],\n                getAxisDimIndex(axis)\n            );\n            graphic.subPixelOptimizeLine({\n                shape: targetShape,\n                style: elStyle\n            });\n            return {\n                type: 'Line',\n                shape: targetShape\n            };\n        },\n\n        shadow: function (axis, pixelValue, otherExtent, elStyle) {\n            var bandWidth = axis.getBandWidth();\n            var span = otherExtent[1] - otherExtent[0];\n            return {\n                type: 'Rect',\n                shape: viewHelper.makeRectShape(\n                    [pixelValue - bandWidth / 2, otherExtent[0]],\n                    [bandWidth, span],\n                    getAxisDimIndex(axis)\n                )\n            };\n        }\n    };\n\n    function getAxisDimIndex(axis) {\n        return axis.dim === 'x' ? 0 : 1;\n    }\n\n    AxisView.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);\n\n    module.exports = CartesianAxisPointer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js\n// module id = 1050\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var clazzUtil = require('../../util/clazz');\n    var graphic = require('../../util/graphic');\n    var get = require('../../util/model').makeGetter();\n    var axisPointerModelHelper = require('./modelHelper');\n    var eventTool = require('zrender/lib/core/event');\n    var throttle = require('../../util/throttle');\n\n    var clone = zrUtil.clone;\n    var bind = zrUtil.bind;\n\n    /**\n     * Base axis pointer class in 2D.\n     * Implemenents {module:echarts/component/axis/IAxisPointer}.\n     */\n    function BaseAxisPointer () {\n    }\n\n    BaseAxisPointer.prototype = {\n\n        /**\n         * @private\n         */\n        _group: null,\n\n        /**\n         * @private\n         */\n        _lastGraphicKey: null,\n\n        /**\n         * @private\n         */\n        _handle: null,\n\n        /**\n         * @private\n         */\n        _dragging: false,\n\n        /**\n         * @private\n         */\n        _lastValue: null,\n\n        /**\n         * @private\n         */\n        _lastStatus: null,\n\n        /**\n         * @private\n         */\n        _payloadInfo: null,\n\n        /**\n         * In px, arbitrary value. Do not set too small,\n         * no animation is ok for most cases.\n         * @protected\n         */\n        animationThreshold: 15,\n\n        /**\n         * @implement\n         */\n        render: function (axisModel, axisPointerModel, api, forceRender) {\n            var value = axisPointerModel.get('value');\n            var status = axisPointerModel.get('status');\n\n            // Bind them to `this`, not in closure, otherwise they will not\n            // be replaced when user calling setOption in not merge mode.\n            this._axisModel = axisModel;\n            this._axisPointerModel = axisPointerModel;\n            this._api = api;\n\n            // Optimize: `render` will be called repeatly during mouse move.\n            // So it is power consuming if performing `render` each time,\n            // especially on mobile device.\n            if (!forceRender\n                && this._lastValue === value\n                && this._lastStatus === status\n            ) {\n                return;\n            }\n            this._lastValue = value;\n            this._lastStatus = status;\n\n            var group = this._group;\n            var handle = this._handle;\n\n            if (!status || status === 'hide') {\n                // Do not clear here, for animation better.\n                group && group.hide();\n                handle && handle.hide();\n                return;\n            }\n            group && group.show();\n            handle && handle.show();\n\n            // Otherwise status is 'show'\n            var elOption = {};\n            this.makeElOption(elOption, value, axisModel, axisPointerModel, api);\n\n            // Enable change axis pointer type.\n            var graphicKey = elOption.graphicKey;\n            if (graphicKey !== this._lastGraphicKey) {\n                this.clear(api);\n            }\n            this._lastGraphicKey = graphicKey;\n\n            var moveAnimation = this._moveAnimation =\n                this.determineAnimation(axisModel, axisPointerModel);\n\n            if (!group) {\n                group = this._group = new graphic.Group();\n                this.createPointerEl(group, elOption, axisModel, axisPointerModel);\n                this.createLabelEl(group, elOption, axisModel, axisPointerModel);\n                api.getZr().add(group);\n            }\n            else {\n                var doUpdateProps = zrUtil.curry(updateProps, axisPointerModel, moveAnimation);\n                this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);\n                this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);\n            }\n\n            updateMandatoryProps(group, axisPointerModel, true);\n\n            this._renderHandle(value);\n        },\n\n        /**\n         * @implement\n         */\n        remove: function (api) {\n            this.clear(api);\n        },\n\n        /**\n         * @implement\n         */\n        dispose: function (api) {\n            this.clear(api);\n        },\n\n        /**\n         * @protected\n         */\n        determineAnimation: function (axisModel, axisPointerModel) {\n            var animation = axisPointerModel.get('animation');\n            var axis = axisModel.axis;\n            var isCategoryAxis = axis.type === 'category';\n            var useSnap = axisPointerModel.get('snap');\n\n            // Value axis without snap always do not snap.\n            if (!useSnap && !isCategoryAxis) {\n                return false;\n            }\n\n            if (animation === 'auto' || animation == null) {\n                var animationThreshold = this.animationThreshold;\n                if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {\n                    return true;\n                }\n\n                // It is important to auto animation when snap used. Consider if there is\n                // a dataZoom, animation will be disabled when too many points exist, while\n                // it will be enabled for better visual effect when little points exist.\n                if (useSnap) {\n                    var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount;\n                    var axisExtent = axis.getExtent();\n                    // Approximate band width\n                    return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;\n                }\n\n                return false;\n            }\n\n            return animation === true;\n        },\n\n        /**\n         * add {pointer, label, graphicKey} to elOption\n         * @protected\n         */\n        makeElOption: function (elOption, value, axisModel, axisPointerModel, api) {\n            // Shoule be implemenented by sub-class.\n        },\n\n        /**\n         * @protected\n         */\n        createPointerEl: function (group, elOption, axisModel, axisPointerModel) {\n            var pointerOption = elOption.pointer;\n            if (pointerOption) {\n                var pointerEl = get(group).pointerEl = new graphic[pointerOption.type](\n                    clone(elOption.pointer)\n                );\n                group.add(pointerEl);\n            }\n        },\n\n        /**\n         * @protected\n         */\n        createLabelEl: function (group, elOption, axisModel, axisPointerModel) {\n            if (elOption.label) {\n                var labelEl = get(group).labelEl = new graphic.Rect(\n                    clone(elOption.label)\n                );\n\n                group.add(labelEl);\n                updateLabelShowHide(labelEl, axisPointerModel);\n            }\n        },\n\n        /**\n         * @protected\n         */\n        updatePointerEl: function (group, elOption, updateProps) {\n            var pointerEl = get(group).pointerEl;\n            if (pointerEl) {\n                pointerEl.setStyle(elOption.pointer.style);\n                updateProps(pointerEl, {shape: elOption.pointer.shape});\n            }\n        },\n\n        /**\n         * @protected\n         */\n        updateLabelEl: function (group, elOption, updateProps, axisPointerModel) {\n            var labelEl = get(group).labelEl;\n            if (labelEl) {\n                labelEl.setStyle(elOption.label.style);\n                updateProps(labelEl, {\n                    // Consider text length change in vertical axis, animation should\n                    // be used on shape, otherwise the effect will be weird.\n                    shape: elOption.label.shape,\n                    position: elOption.label.position\n                });\n\n                updateLabelShowHide(labelEl, axisPointerModel);\n            }\n        },\n\n        /**\n         * @private\n         */\n        _renderHandle: function (value) {\n            if (this._dragging || !this.updateHandleTransform) {\n                return;\n            }\n\n            var axisPointerModel = this._axisPointerModel;\n            var zr = this._api.getZr();\n            var handle = this._handle;\n            var handleModel = axisPointerModel.getModel('handle');\n\n            var status = axisPointerModel.get('status');\n            if (!handleModel.get('show') || !status || status === 'hide') {\n                handle && zr.remove(handle);\n                this._handle = null;\n                return;\n            }\n\n            var isInit;\n            if (!this._handle) {\n                isInit = true;\n                handle = this._handle = graphic.createIcon(\n                    handleModel.get('icon'), \n                    {\n                        cursor: 'move',\n                        draggable: true,\n                        onmousemove: function (e) {\n                            // Fot mobile devicem, prevent screen slider on the button.\n                            eventTool.stop(e.event);\n                        },\n                        onmousedown: bind(this._onHandleDragMove, this, 0, 0),\n                        drift: bind(this._onHandleDragMove, this),\n                        ondragend: bind(this._onHandleDragEnd, this)\n                    }\n                );\n                zr.add(handle);\n            }\n\n            updateMandatoryProps(handle, axisPointerModel, false);\n\n            // update style\n            var includeStyles = [\n                'color', 'borderColor', 'borderWidth', 'opacity',\n                'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'\n            ];\n            handle.setStyle(handleModel.getItemStyle(null, includeStyles));\n\n            // update position\n            var handleSize = handleModel.get('size');\n            if (!zrUtil.isArray(handleSize)) {\n                handleSize = [handleSize, handleSize];\n            }\n            handle.attr('scale', [handleSize[0] / 2, handleSize[1] / 2]);\n\n            throttle.createOrUpdate(\n                this,\n                '_doDispatchAxisPointer',\n                handleModel.get('throttle') || 0,\n                'fixRate'\n            );\n\n            this._moveHandleToValue(value, isInit);\n        },\n\n        /**\n         * @private\n         */\n        _moveHandleToValue: function (value, isInit) {\n            updateProps(\n                this._axisPointerModel,\n                !isInit && this._moveAnimation,\n                this._handle,\n                getHandleTransProps(this.getHandleTransform(\n                    value, this._axisModel, this._axisPointerModel\n                ))\n            );\n        },\n\n        /**\n         * @private\n         */\n        _onHandleDragMove: function (dx, dy) {\n            var handle = this._handle;\n            if (!handle) {\n                return;\n            }\n\n            this._dragging = true;\n\n            // Persistent for throttle.\n            var trans = this.updateHandleTransform(\n                getHandleTransProps(handle),\n                [dx, dy],\n                this._axisModel,\n                this._axisPointerModel\n            );\n            this._payloadInfo = trans;\n\n            handle.stopAnimation();\n            handle.attr(getHandleTransProps(trans));\n            get(handle).lastProp = null;\n\n            this._doDispatchAxisPointer();\n        },\n\n        /**\n         * Throttled method.\n         * @private\n         */\n        _doDispatchAxisPointer: function () {\n            var handle = this._handle;\n            if (!handle) {\n                return;\n            }\n\n            var payloadInfo = this._payloadInfo;\n            var axisModel = this._axisModel;\n            this._api.dispatchAction({\n                type: 'updateAxisPointer',\n                x: payloadInfo.cursorPoint[0],\n                y: payloadInfo.cursorPoint[1],\n                tooltipOption: payloadInfo.tooltipOption,\n                axesInfo: [{\n                    axisDim: axisModel.axis.dim,\n                    axisIndex: axisModel.componentIndex\n                }]\n            });\n        },\n\n        /**\n         * @private\n         */\n        _onHandleDragEnd: function (moveAnimation) {\n            this._dragging = false;\n            var handle = this._handle;\n            if (!handle) {\n                return;\n            }\n\n            var value = this._axisPointerModel.get('value');\n            // Consider snap or categroy axis, handle may be not consistent with\n            // axisPointer. So move handle to align the exact value position when\n            // drag ended.\n            this._moveHandleToValue(value);\n\n            // For the effect: tooltip will be shown when finger holding on handle\n            // button, and will be hidden after finger left handle button.\n            this._api.dispatchAction({\n                type: 'hideTip'\n            });\n        },\n\n        /**\n         * Should be implemenented by sub-class if support `handle`.\n         * @protected\n         * @param {number} value\n         * @param {module:echarts/model/Model} axisModel\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @return {Object} {position: [x, y], rotation: 0}\n         */\n        getHandleTransform: null,\n\n        /**\n         * * Should be implemenented by sub-class if support `handle`.\n         * @protected\n         * @param {Object} transform {position, rotation}\n         * @param {Array.<number>} delta [dx, dy]\n         * @param {module:echarts/model/Model} axisModel\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}\n         */\n        updateHandleTransform: null,\n\n        /**\n         * @private\n         */\n        clear: function (api) {\n            this._lastValue = null;\n            this._lastStatus = null;\n\n            var zr = api.getZr();\n            var group = this._group;\n            var handle = this._handle;\n            if (zr && group) {\n                this._lastGraphicKey = null;\n                group && zr.remove(group);\n                handle && zr.remove(handle);\n                this._group = null;\n                this._handle = null;\n                this._payloadInfo = null;\n            }\n        },\n\n        /**\n         * @protected\n         */\n        doClear: function () {\n            // Implemented by sub-class if necessary.\n        },\n\n        /**\n         * @protected\n         * @param {Array.<number>} xy\n         * @param {Array.<number>} wh\n         * @param {number} [xDimIndex=0] or 1\n         */\n        buildLabel: function (xy, wh, xDimIndex) {\n            xDimIndex = xDimIndex || 0;\n            return {\n                x: xy[xDimIndex],\n                y: xy[1 - xDimIndex],\n                width: wh[xDimIndex],\n                height: wh[1 - xDimIndex]\n            };\n        }\n    };\n\n    BaseAxisPointer.prototype.constructor = BaseAxisPointer;\n\n\n    function updateProps(animationModel, moveAnimation, el, props) {\n        // Animation optimize.\n        if (!propsEqual(get(el).lastProp, props)) {\n            get(el).lastProp = props;\n            moveAnimation\n                ? graphic.updateProps(el, props, animationModel)\n                : (el.stopAnimation(), el.attr(props));\n        }\n    }\n\n    function propsEqual(lastProps, newProps) {\n        if (zrUtil.isObject(lastProps) && zrUtil.isObject(newProps)) {\n            var equals = true;\n            zrUtil.each(newProps, function (item, key) {\n                equals = equals && propsEqual(lastProps[key], item);\n            });\n            return !!equals;\n        }\n        else {\n            return lastProps === newProps;\n        }\n    }\n\n    function updateLabelShowHide(labelEl, axisPointerModel) {\n        labelEl[axisPointerModel.get('label.show') ? 'show' : 'hide']();\n    }\n\n    function getHandleTransProps(trans) {\n        return {\n            position: trans.position.slice(),\n            rotation: trans.rotation || 0\n        };\n    }\n\n    function updateMandatoryProps(group, axisPointerModel, silent) {\n        var z = axisPointerModel.get('z');\n        var zlevel = axisPointerModel.get('zlevel');\n\n        group && group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n                el.silent = silent;\n            }\n        });\n    }\n\n    clazzUtil.enableClassExtend(BaseAxisPointer);\n\n    module.exports = BaseAxisPointer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js\n// module id = 1051\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var helper = {};\n\n    /**\n     * @param {Object} opt {labelInside}\n     * @return {Object} {\n     *  position, rotation, labelDirection, labelOffset,\n     *  tickDirection, labelRotate, labelInterval, z2\n     * }\n     */\n    helper.layout = function (gridModel, axisModel, opt) {\n        opt = opt || {};\n        var grid = gridModel.coordinateSystem;\n        var axis = axisModel.axis;\n        var layout = {};\n\n        var rawAxisPosition = axis.position;\n        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n        var axisDim = axis.dim;\n\n        var rect = grid.getRect();\n        var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n        var idx = {left: 0, right: 1, top: 0, bottom: 1, onZero: 2};\n        var axisOffset = axisModel.get('offset') || 0;\n\n        var posBound = axisDim === 'x'\n            ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset]\n            : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];\n\n        if (axis.onZero) {\n            var otherAxis = grid.getAxis(axisDim === 'x' ? 'y' : 'x', axis.onZeroAxisIndex);\n            var onZeroCoord = otherAxis.toGlobalCoord(otherAxis.dataToCoord(0));\n            posBound[idx['onZero']] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);\n        }\n\n        // Axis position\n        layout.position = [\n            axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0],\n            axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3]\n        ];\n\n        // Axis rotation\n        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n\n        // Tick and label direction, x y is axisDim\n        var dirMap = {top: -1, bottom: 1, left: -1, right: 1};\n\n        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n        layout.labelOffset = axis.onZero ? posBound[idx[rawAxisPosition]] - posBound[idx['onZero']] : 0;\n\n        if (axisModel.get('axisTick.inside')) {\n            layout.tickDirection = -layout.tickDirection;\n        }\n        if (zrUtil.retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) {\n            layout.labelDirection = -layout.labelDirection;\n        }\n\n        // Special label rotation\n        var labelRotate = axisModel.get('axisLabel.rotate');\n        layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate;\n\n        // label interval when auto mode.\n        layout.labelInterval = axis.getLabelInterval();\n\n        // Over splitLine and splitArea\n        layout.z2 = 1;\n\n        return layout;\n    };\n\n    module.exports = helper;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axis/cartesianAxisHelper.js\n// module id = 1052\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Model = require('../../model/Model');\n\n    var LegendModel = require('../../echarts').extendComponentModel({\n\n        type: 'legend.plain',\n\n        dependencies: ['series'],\n\n        layoutMode: {\n            type: 'box',\n            // legend.width/height are maxWidth/maxHeight actually,\n            // whereas realy width/height is calculated by its content.\n            // (Setting {left: 10, right: 10} does not make sense).\n            // So consider the case:\n            // `setOption({legend: {left: 10});`\n            // then `setOption({legend: {right: 10});`\n            // The previous `left` should be cleared by setting `ignoreSize`.\n            ignoreSize: true\n        },\n\n        init: function (option, parentModel, ecModel) {\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            option.selected = option.selected || {};\n        },\n\n        mergeOption: function (option) {\n            LegendModel.superCall(this, 'mergeOption', option);\n        },\n\n        optionUpdated: function () {\n            this._updateData(this.ecModel);\n\n            var legendData = this._data;\n\n            // If selectedMode is single, try to select one\n            if (legendData[0] && this.get('selectedMode') === 'single') {\n                var hasSelected = false;\n                // If has any selected in option.selected\n                for (var i = 0; i < legendData.length; i++) {\n                    var name = legendData[i].get('name');\n                    if (this.isSelected(name)) {\n                        // Force to unselect others\n                        this.select(name);\n                        hasSelected = true;\n                        break;\n                    }\n                }\n                // Try select the first if selectedMode is single\n                !hasSelected && this.select(legendData[0].get('name'));\n            }\n        },\n\n        _updateData: function (ecModel) {\n            var legendData = zrUtil.map(this.get('data') || [], function (dataItem) {\n                // Can be string or number\n                if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n                    dataItem = {\n                        name: dataItem\n                    };\n                }\n                return new Model(dataItem, this, this.ecModel);\n            }, this);\n            this._data = legendData;\n\n            var availableNames = zrUtil.map(ecModel.getSeries(), function (series) {\n                return series.name;\n            });\n            ecModel.eachSeries(function (seriesModel) {\n                if (seriesModel.legendDataProvider) {\n                    var data = seriesModel.legendDataProvider();\n                    availableNames = availableNames.concat(data.mapArray(data.getName));\n                }\n            });\n            /**\n             * @type {Array.<string>}\n             * @private\n             */\n            this._availableNames = availableNames;\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Model>}\n         */\n        getData: function () {\n            return this._data;\n        },\n\n        /**\n         * @param {string} name\n         */\n        select: function (name) {\n            var selected = this.option.selected;\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                var data = this._data;\n                zrUtil.each(data, function (dataItem) {\n                    selected[dataItem.get('name')] = false;\n                });\n            }\n            selected[name] = true;\n        },\n\n        /**\n         * @param {string} name\n         */\n        unSelect: function (name) {\n            if (this.get('selectedMode') !== 'single') {\n                this.option.selected[name] = false;\n            }\n        },\n\n        /**\n         * @param {string} name\n         */\n        toggleSelected: function (name) {\n            var selected = this.option.selected;\n            // Default is true\n            if (!selected.hasOwnProperty(name)) {\n                selected[name] = true;\n            }\n            this[selected[name] ? 'unSelect' : 'select'](name);\n        },\n\n        /**\n         * @param {string} name\n         */\n        isSelected: function (name) {\n            var selected = this.option.selected;\n            return !(selected.hasOwnProperty(name) && !selected[name])\n                && zrUtil.indexOf(this._availableNames, name) >= 0;\n        },\n\n        defaultOption: {\n            // \n            zlevel: 0,\n            // \n            z: 4,\n            show: true,\n\n            // \n            // 'horizontal' | 'vertical'\n            orient: 'horizontal',\n\n            left: 'center',\n            // right: 'center',\n\n            top: 0,\n            // bottom: null,\n\n            // \n            // 'auto' | 'left' | 'right'\n            //  'auto',  x \n            align: 'auto',\n\n            backgroundColor: 'rgba(0,0,0,0)',\n            // \n            borderColor: '#ccc',\n            borderRadius: 0,\n            // px0\n            borderWidth: 0,\n            // px5\n            // css\n            padding: 5,\n            // itempx10\n            // \n            itemGap: 10,\n            // \n            itemWidth: 25,\n            // \n            itemHeight: 14,\n\n            // \n            inactiveColor: '#ccc',\n\n            textStyle: {\n                // \n                color: '#333'\n            },\n            // formatter: '',\n            // \n            selectedMode: true,\n            // LEGEND.SELECTED\n            // selected: null,\n            // legend.dataitem\n            // data: [],\n\n            // Tooltip \n            tooltip: {\n                show: false\n            }\n        }\n    });\n\n    module.exports = LegendModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/LegendModel.js\n// module id = 1053\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var symbolCreator = require('../../util/symbol');\n    var graphic = require('../../util/graphic');\n    var listComponentHelper = require('../helper/listComponent');\n    var layoutUtil = require('../../util/layout');\n\n    var curry = zrUtil.curry;\n    var each = zrUtil.each;\n    var Group = graphic.Group;\n\n    module.exports = require('../../echarts').extendComponentView({\n\n        type: 'legend.plain',\n\n        newlineDisabled: false,\n\n        /**\n         * @override\n         */\n        init: function () {\n\n            /**\n             * @private\n             * @type {module:zrender/container/Group}\n             */\n            this.group.add(this._contentGroup = new Group());\n\n            /**\n             * @private\n             * @type {module:zrender/Element}\n             */\n            this._backgroundEl;\n        },\n\n        /**\n         * @protected\n         */\n        getContentGroup: function () {\n            return this._contentGroup;\n        },\n\n        /**\n         * @override\n         */\n        render: function (legendModel, ecModel, api) {\n\n            this.resetInner();\n\n            if (!legendModel.get('show', true)) {\n                return;\n            }\n\n            var itemAlign = legendModel.get('align');\n            if (!itemAlign || itemAlign === 'auto') {\n                itemAlign = (\n                    legendModel.get('left') === 'right'\n                    && legendModel.get('orient') === 'vertical'\n                ) ? 'right' : 'left';\n            }\n\n            this.renderInner(itemAlign, legendModel, ecModel, api);\n\n            // Perform layout.\n            var positionInfo = legendModel.getBoxLayoutParams();\n            var viewportSize = {width: api.getWidth(), height: api.getHeight()};\n            var padding = legendModel.get('padding');\n\n            var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding);\n            var mainRect = this.layoutInner(legendModel, itemAlign, maxSize);\n\n            // Place mainGroup, based on the calculated `mainRect`.\n            var layoutRect = layoutUtil.getLayoutRect(\n                zrUtil.defaults({width: mainRect.width, height: mainRect.height}, positionInfo),\n                viewportSize,\n                padding\n            );\n            this.group.attr('position', [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]);\n\n            // Render background after group is layout.\n            this.group.add(\n                this._backgroundEl = listComponentHelper.makeBackground(mainRect, legendModel)\n            );\n        },\n\n        /**\n         * @protected\n         */\n        resetInner: function () {\n            this.getContentGroup().removeAll();\n            this._backgroundEl && this.group.remove(this._backgroundEl);\n        },\n\n        /**\n         * @protected\n         */\n        renderInner: function (itemAlign, legendModel, ecModel, api) {\n            var contentGroup = this.getContentGroup();\n            var legendDrawnMap = zrUtil.createHashMap();\n            var selectMode = legendModel.get('selectedMode');\n\n            each(legendModel.getData(), function (itemModel, dataIndex) {\n                var name = itemModel.get('name');\n\n                // Use empty string or \\n as a newline string\n                if (!this.newlineDisabled && (name === '' || name === '\\n')) {\n                    contentGroup.add(new Group({\n                        newline: true\n                    }));\n                    return;\n                }\n\n                var seriesModel = ecModel.getSeriesByName(name)[0];\n\n                if (legendDrawnMap.get(name)) {\n                    // Have been drawed\n                    return;\n                }\n\n                // Series legend\n                if (seriesModel) {\n                    var data = seriesModel.getData();\n                    var color = data.getVisual('color');\n\n                    // If color is a callback function\n                    if (typeof color === 'function') {\n                        // Use the first data\n                        color = color(seriesModel.getDataParams(0));\n                    }\n\n                    // Using rect symbol defaultly\n                    var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n                    var symbolType = data.getVisual('symbol');\n\n                    var itemGroup = this._createItem(\n                        name, dataIndex, itemModel, legendModel,\n                        legendSymbolType, symbolType,\n                        itemAlign, color,\n                        selectMode\n                    );\n\n                    itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                        .on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api))\n                        .on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n\n                    legendDrawnMap.set(name, true);\n                }\n                else {\n                    // Data legend of pie, funnel\n                    ecModel.eachRawSeries(function (seriesModel) {\n                        // In case multiple series has same data name\n                        if (legendDrawnMap.get(name)) {\n                            return;\n                        }\n                        if (seriesModel.legendDataProvider) {\n                            var data = seriesModel.legendDataProvider();\n                            var idx = data.indexOfName(name);\n                            if (idx < 0) {\n                                return;\n                            }\n\n                            var color = data.getItemVisual(idx, 'color');\n\n                            var legendSymbolType = 'roundRect';\n\n                            var itemGroup = this._createItem(\n                                name, dataIndex, itemModel, legendModel,\n                                legendSymbolType, null,\n                                itemAlign, color,\n                                selectMode\n                            );\n\n                            itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                                // FIXME Should not specify the series name\n                                .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api))\n                                .on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n\n                            legendDrawnMap.set(name, true);\n                        }\n                    }, this);\n                }\n\n                if (__DEV__) {\n                    if (!legendDrawnMap.get(name)) {\n                        console.warn(name + ' series not exists. Legend data should be same with series name or data name.');\n                    }\n                }\n            }, this);\n        },\n\n        _createItem: function (\n            name, dataIndex, itemModel, legendModel,\n            legendSymbolType, symbolType,\n            itemAlign, color, selectMode\n        ) {\n            var itemWidth = legendModel.get('itemWidth');\n            var itemHeight = legendModel.get('itemHeight');\n            var inactiveColor = legendModel.get('inactiveColor');\n\n            var isSelected = legendModel.isSelected(name);\n            var itemGroup = new Group();\n\n            var textStyleModel = itemModel.getModel('textStyle');\n\n            var itemIcon = itemModel.get('icon');\n\n            var tooltipModel = itemModel.getModel('tooltip');\n            var legendGlobalTooltipModel = tooltipModel.parentModel;\n\n            // Use user given icon first\n            legendSymbolType = itemIcon || legendSymbolType;\n            itemGroup.add(symbolCreator.createSymbol(\n                legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor\n            ));\n\n            // Compose symbols\n            // PENDING\n            if (!itemIcon && symbolType\n                // At least show one symbol, can't be all none\n                && ((symbolType !== legendSymbolType) || symbolType == 'none')\n            ) {\n                var size = itemHeight * 0.8;\n                if (symbolType === 'none') {\n                    symbolType = 'circle';\n                }\n                // Put symbol in the center\n                itemGroup.add(symbolCreator.createSymbol(\n                    symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size,\n                    isSelected ? color : inactiveColor\n                ));\n            }\n\n            var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n            var textAlign = itemAlign;\n\n            var formatter = legendModel.get('formatter');\n            var content = name;\n            if (typeof formatter === 'string' && formatter) {\n                content = formatter.replace('{name}', name != null ? name : '');\n            }\n            else if (typeof formatter === 'function') {\n                content = formatter(name);\n            }\n\n            itemGroup.add(new graphic.Text({\n                style: graphic.setTextStyle({}, textStyleModel, {\n                    text: content,\n                    x: textX,\n                    y: itemHeight / 2,\n                    textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n                    textAlign: textAlign,\n                    textVerticalAlign: 'middle'\n                })\n            }));\n\n            // Add a invisible rect to increase the area of mouse hover\n            var hitRect = new graphic.Rect({\n                shape: itemGroup.getBoundingRect(),\n                invisible: true,\n                tooltip: tooltipModel.get('show') ? zrUtil.extend({\n                    content: name,\n                    // Defaul formatter\n                    formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n                        return name;\n                    },\n                    formatterParams: {\n                        componentType: 'legend',\n                        legendIndex: legendModel.componentIndex,\n                        name: name,\n                        $vars: ['name']\n                    }\n                }, tooltipModel.option) : null\n            });\n            itemGroup.add(hitRect);\n\n            itemGroup.eachChild(function (child) {\n                child.silent = true;\n            });\n\n            hitRect.silent = !selectMode;\n\n            this.getContentGroup().add(itemGroup);\n\n            graphic.setHoverStyle(itemGroup);\n\n            itemGroup.__legendDataIndex = dataIndex;\n\n            return itemGroup;\n        },\n\n        /**\n         * @protected\n         */\n        layoutInner: function (legendModel, itemAlign, maxSize) {\n            var contentGroup = this.getContentGroup();\n\n            // Place items in contentGroup.\n            layoutUtil.box(\n                legendModel.get('orient'),\n                contentGroup,\n                legendModel.get('itemGap'),\n                maxSize.width,\n                maxSize.height\n            );\n\n            var contentRect = contentGroup.getBoundingRect();\n            contentGroup.attr('position', [-contentRect.x, -contentRect.y]);\n\n            return this.group.getBoundingRect();\n        }\n\n    });\n\n    function dispatchSelectAction(name, api) {\n        api.dispatchAction({\n            type: 'legendToggleSelect',\n            name: name\n        });\n    }\n\n    function dispatchHighlightAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'highlight',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n    function dispatchDownplayAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'downplay',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/LegendView.js\n// module id = 1054\n// module chunks = 0 1 2","/**\n * Box selection tool.\n *\n * @module echarts/component/helper/BrushController\n */\n\n\n\n    var Eventful = require('zrender/lib/mixin/Eventful');\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n    var interactionMutex = require('./interactionMutex');\n    var DataDiffer = require('../../data/DataDiffer');\n\n    var curry = zrUtil.curry;\n    var each = zrUtil.each;\n    var map = zrUtil.map;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathPow = Math.pow;\n\n    var COVER_Z = 10000;\n    var UNSELECT_THRESHOLD = 6;\n    var MIN_RESIZE_LINE_WIDTH = 6;\n    var MUTEX_RESOURCE_KEY = 'globalPan';\n\n    var DIRECTION_MAP = {\n        w: [0, 0],\n        e: [0, 1],\n        n: [1, 0],\n        s: [1, 1]\n    };\n    var CURSOR_MAP = {\n        w: 'ew',\n        e: 'ew',\n        n: 'ns',\n        s: 'ns',\n        ne: 'nesw',\n        sw: 'nesw',\n        nw: 'nwse',\n        se: 'nwse'\n    };\n    var DEFAULT_BRUSH_OPT = {\n        brushStyle: {\n            lineWidth: 2,\n            stroke: 'rgba(0,0,0,0.3)',\n            fill: 'rgba(0,0,0,0.1)'\n        },\n        transformable: true,\n        brushMode: 'single',\n        removeOnClick: false\n    };\n\n    var baseUID = 0;\n\n    /**\n     * @alias module:echarts/component/helper/BrushController\n     * @constructor\n     * @mixin {module:zrender/mixin/Eventful}\n     * @event module:echarts/component/helper/BrushController#brush\n     *        params:\n     *            areas: Array.<Array>, coord relates to container group,\n     *                                    If no container specified, to global.\n     *            opt {\n     *                isEnd: boolean,\n     *                removeOnClick: boolean\n     *            }\n     *\n     * @param {module:zrender/zrender~ZRender} zr\n     */\n    function BrushController(zr) {\n\n        if (__DEV__) {\n            zrUtil.assert(zr);\n        }\n\n        Eventful.call(this);\n\n        /**\n         * @type {module:zrender/zrender~ZRender}\n         * @private\n         */\n        this._zr = zr;\n\n        /**\n         * @type {module:zrender/container/Group}\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n\n        /**\n         * Only for drawing (after enabledBrush).\n         *     'line', 'rect', 'polygon' or false\n         *     If passing false/null/undefined, disable brush.\n         *     If passing 'auto', determined by panel.defaultBrushType\n         * @private\n         * @type {string}\n         */\n        this._brushType;\n\n        /**\n         * Only for drawing (after enabledBrush).\n         *\n         * @private\n         * @type {Object}\n         */\n        this._brushOption;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._panels;\n\n        /**\n         * @private\n         * @type {Array.<nubmer>}\n         */\n        this._track = [];\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._dragging;\n\n        /**\n         * @private\n         * @type {Array}\n         */\n        this._covers = [];\n\n        /**\n         * @private\n         * @type {moudule:zrender/container/Group}\n         */\n        this._creatingCover;\n\n        /**\n         * `true` means global panel\n         * @private\n         * @type {module:zrender/container/Group|boolean}\n         */\n        this._creatingPanel;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._enableGlobalPan;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        if (__DEV__) {\n            this._mounted;\n        }\n\n        /**\n         * @private\n         * @type {string}\n         */\n        this._uid = 'brushController_' + baseUID++;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._handlers = {};\n        each(mouseHandlers, function (handler, eventName) {\n            this._handlers[eventName] = zrUtil.bind(handler, this);\n        }, this);\n    }\n\n    BrushController.prototype = {\n\n        constructor: BrushController,\n\n        /**\n         * If set to null/undefined/false, select disabled.\n         * @param {Object} brushOption\n         * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false\n         *                          If passing false/null/undefined, disable brush.\n         *                          If passing 'auto', determined by panel.defaultBrushType.\n         *                              ('auto' can not be used in global panel)\n         * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'\n         * @param {boolean} [brushOption.transformable=true]\n         * @param {boolean} [brushOption.removeOnClick=false]\n         * @param {Object} [brushOption.brushStyle]\n         * @param {number} [brushOption.brushStyle.width]\n         * @param {number} [brushOption.brushStyle.lineWidth]\n         * @param {string} [brushOption.brushStyle.stroke]\n         * @param {string} [brushOption.brushStyle.fill]\n         * @param {number} [brushOption.z]\n         */\n        enableBrush: function (brushOption) {\n            if (__DEV__) {\n                zrUtil.assert(this._mounted);\n            }\n\n            this._brushType && doDisableBrush(this);\n            brushOption.brushType && doEnableBrush(this, brushOption);\n\n            return this;\n        },\n\n        /**\n         * @param {Array.<Object>} panelOpts If not pass, it is global brush.\n         *        Each items: {\n         *            panelId, // mandatory.\n         *            clipPath, // mandatory. function.\n         *            isTargetByCursor, // mandatory. function.\n         *            defaultBrushType, // optional, only used when brushType is 'auto'.\n         *            getLinearBrushOtherExtent, // optional. function.\n         *        }\n         */\n        setPanels: function (panelOpts) {\n            if (panelOpts && panelOpts.length) {\n                var panels = this._panels = {};\n                zrUtil.each(panelOpts, function (panelOpts) {\n                    panels[panelOpts.panelId] = zrUtil.clone(panelOpts);\n                });\n            }\n            else {\n                this._panels = null;\n            }\n            return this;\n        },\n\n        /**\n         * @param {Object} [opt]\n         * @return {boolean} [opt.enableGlobalPan=false]\n         */\n        mount: function (opt) {\n            opt = opt || {};\n\n            if (__DEV__) {\n                this._mounted = true; // should be at first.\n            }\n\n            this._enableGlobalPan = opt.enableGlobalPan;\n\n            var thisGroup = this.group;\n            this._zr.add(thisGroup);\n\n            thisGroup.attr({\n                position: opt.position || [0, 0],\n                rotation: opt.rotation || 0,\n                scale: opt.scale || [1, 1]\n            });\n            this._transform = thisGroup.getLocalTransform();\n\n            return this;\n        },\n\n        eachCover: function (cb, context) {\n            each(this._covers, cb, context);\n        },\n\n        /**\n         * Update covers.\n         * @param {Array.<Object>} brushOptionList Like:\n         *        [\n         *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},\n         *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},\n         *            ...\n         *        ]\n         *        `brushType` is required in each cover info. (can not be 'auto')\n         *        `id` is not mandatory.\n         *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.\n         *        If brushOptionList is null/undefined, all covers removed.\n         */\n        updateCovers: function (brushOptionList) {\n            if (__DEV__) {\n                zrUtil.assert(this._mounted);\n            }\n\n            brushOptionList = zrUtil.map(brushOptionList, function (brushOption) {\n                return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n            });\n\n            var tmpIdPrefix = '\\0-brush-index-';\n            var oldCovers = this._covers;\n            var newCovers = this._covers = [];\n            var controller = this;\n            var creatingCover = this._creatingCover;\n\n            (new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey))\n                .add(addOrUpdate)\n                .update(addOrUpdate)\n                .remove(remove)\n                .execute();\n\n            return this;\n\n            function getKey(brushOption, index) {\n                return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index)\n                    + '-' + brushOption.brushType;\n            }\n\n            function oldGetKey(cover, index) {\n                return getKey(cover.__brushOption, index);\n            }\n\n            function addOrUpdate(newIndex, oldIndex) {\n                var newBrushOption = brushOptionList[newIndex];\n                // Consider setOption in event listener of brushSelect,\n                // where updating cover when creating should be forbiden.\n                if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n                    newCovers[newIndex] = oldCovers[oldIndex];\n                }\n                else {\n                    var cover = newCovers[newIndex] = oldIndex != null\n                        ? (\n                            oldCovers[oldIndex].__brushOption = newBrushOption,\n                            oldCovers[oldIndex]\n                        )\n                        : endCreating(controller, createCover(controller, newBrushOption));\n                    updateCoverAfterCreation(controller, cover);\n                }\n            }\n\n            function remove(oldIndex) {\n                if (oldCovers[oldIndex] !== creatingCover) {\n                    controller.group.remove(oldCovers[oldIndex]);\n                }\n            }\n        },\n\n        unmount: function () {\n            if (__DEV__) {\n                if (!this._mounted) {\n                    return;\n                }\n            }\n\n            this.enableBrush(false);\n\n            // container may 'removeAll' outside.\n            clearCovers(this);\n            this._zr.remove(this.group);\n\n            if (__DEV__) {\n                this._mounted = false; // should be at last.\n            }\n\n            return this;\n        },\n\n        dispose: function () {\n            this.unmount();\n            this.off();\n        }\n    };\n\n    zrUtil.mixin(BrushController, Eventful);\n\n    function doEnableBrush(controller, brushOption) {\n        var zr = controller._zr;\n\n        // Consider roam, which takes globalPan too.\n        if (!controller._enableGlobalPan) {\n            interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);\n        }\n\n        each(controller._handlers, function (handler, eventName) {\n            zr.on(eventName, handler);\n        });\n\n        controller._brushType = brushOption.brushType;\n        controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n    }\n\n    function doDisableBrush(controller) {\n        var zr = controller._zr;\n\n        interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);\n\n        each(controller._handlers, function (handler, eventName) {\n            zr.off(eventName, handler);\n        });\n\n        controller._brushType = controller._brushOption = null;\n    }\n\n    function createCover(controller, brushOption) {\n        var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n        cover.__brushOption = brushOption;\n        updateZ(cover, brushOption);\n        controller.group.add(cover);\n        return cover;\n    }\n\n    function endCreating(controller, creatingCover) {\n        var coverRenderer = getCoverRenderer(creatingCover);\n        if (coverRenderer.endCreating) {\n            coverRenderer.endCreating(controller, creatingCover);\n            updateZ(creatingCover, creatingCover.__brushOption);\n        }\n        return creatingCover;\n    }\n\n    function updateCoverShape(controller, cover) {\n        var brushOption = cover.__brushOption;\n        getCoverRenderer(cover).updateCoverShape(\n            controller, cover, brushOption.range, brushOption\n        );\n    }\n\n    function updateZ(cover, brushOption) {\n        var z = brushOption.z;\n        z == null && (z = COVER_Z);\n        cover.traverse(function (el) {\n            el.z = z;\n            el.z2 = z; // Consider in given container.\n        });\n    }\n\n    function updateCoverAfterCreation(controller, cover) {\n        getCoverRenderer(cover).updateCommon(controller, cover);\n        updateCoverShape(controller, cover);\n    }\n\n    function getCoverRenderer(cover) {\n        return coverRenderers[cover.__brushOption.brushType];\n    }\n\n    // return target panel or `true` (means global panel)\n    function getPanelByPoint(controller, e, localCursorPoint) {\n        var panels = controller._panels;\n        if (!panels) {\n            return true; // Global panel\n        }\n        var panel;\n        var transform = controller._transform;\n        each(panels, function (pn) {\n            pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);\n        });\n        return panel;\n    }\n\n    // Return a panel or true\n    function getPanelByCover(controller, cover) {\n        var panels = controller._panels;\n        if (!panels) {\n            return true; // Global panel\n        }\n        var panelId = cover.__brushOption.panelId;\n        // User may give cover without coord sys info,\n        // which is then treated as global panel.\n        return panelId != null ? panels[panelId] : true;\n    }\n\n    function clearCovers(controller) {\n        var covers = controller._covers;\n        var originalLength = covers.length;\n        each(covers, function (cover) {\n            controller.group.remove(cover);\n        }, controller);\n        covers.length = 0;\n\n        return !!originalLength;\n    }\n\n    function trigger(controller, opt) {\n        var areas = map(controller._covers, function (cover) {\n            var brushOption = cover.__brushOption;\n            var range = zrUtil.clone(brushOption.range);\n            return {\n                brushType: brushOption.brushType,\n                panelId: brushOption.panelId,\n                range: range\n            };\n        });\n\n        controller.trigger('brush', areas, {\n            isEnd: !!opt.isEnd,\n            removeOnClick: !!opt.removeOnClick\n        });\n    }\n\n    function shouldShowCover(controller) {\n        var track = controller._track;\n\n        if (!track.length) {\n            return false;\n        }\n\n        var p2 = track[track.length - 1];\n        var p1 = track[0];\n        var dx = p2[0] - p1[0];\n        var dy = p2[1] - p1[1];\n        var dist = mathPow(dx * dx + dy * dy, 0.5);\n\n        return dist > UNSELECT_THRESHOLD;\n    }\n\n    function getTrackEnds(track) {\n        var tail = track.length - 1;\n        tail < 0 && (tail = 0);\n        return [track[0], track[tail]];\n    }\n\n    function createBaseRectCover(doDrift, controller, brushOption, edgeNames) {\n        var cover = new graphic.Group();\n\n        cover.add(new graphic.Rect({\n            name: 'main',\n            style: makeStyle(brushOption),\n            silent: true,\n            draggable: true,\n            cursor: 'move',\n            drift: curry(doDrift, controller, cover, 'nswe'),\n            ondragend: curry(trigger, controller, {isEnd: true})\n        }));\n\n        each(\n            edgeNames,\n            function (name) {\n                cover.add(new graphic.Rect({\n                    name: name,\n                    style: {opacity: 0},\n                    draggable: true,\n                    silent: true,\n                    invisible: true,\n                    drift: curry(doDrift, controller, cover, name),\n                    ondragend: curry(trigger, controller, {isEnd: true})\n                }));\n            }\n        );\n\n        return cover;\n    }\n\n    function updateBaseRect(controller, cover, localRange, brushOption) {\n        var lineWidth = brushOption.brushStyle.lineWidth || 0;\n        var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);\n        var x = localRange[0][0];\n        var y = localRange[1][0];\n        var xa = x - lineWidth / 2;\n        var ya = y - lineWidth / 2;\n        var x2 = localRange[0][1];\n        var y2 = localRange[1][1];\n        var x2a = x2 - handleSize + lineWidth / 2;\n        var y2a = y2 - handleSize + lineWidth / 2;\n        var width = x2 - x;\n        var height = y2 - y;\n        var widtha = width + lineWidth;\n        var heighta = height + lineWidth;\n\n        updateRectShape(controller, cover, 'main', x, y, width, height);\n\n        if (brushOption.transformable) {\n            updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n            updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n            updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n            updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n\n            updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n            updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n            updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n            updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n        }\n    }\n\n    function updateCommon(controller, cover) {\n        var brushOption = cover.__brushOption;\n        var transformable = brushOption.transformable;\n\n        var mainEl = cover.childAt(0);\n        mainEl.useStyle(makeStyle(brushOption));\n        mainEl.attr({\n            silent: !transformable,\n            cursor: transformable ? 'move' : 'default'\n        });\n\n        each(\n            ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'],\n            function (name) {\n                var el = cover.childOfName(name);\n                var globalDir = getGlobalDirection(controller, name);\n\n                el && el.attr({\n                    silent: !transformable,\n                    invisible: !transformable,\n                    cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n                });\n            }\n        );\n    }\n\n    function updateRectShape(controller, cover, name, x, y, w, h) {\n        var el = cover.childOfName(name);\n        el && el.setShape(pointsToRect(\n            clipByPanel(controller, cover, [[x, y], [x + w, y + h]])\n        ));\n    }\n\n    function makeStyle(brushOption) {\n        return zrUtil.defaults({strokeNoScale: true}, brushOption.brushStyle);\n    }\n\n    function formatRectRange(x, y, x2, y2) {\n        var min = [mathMin(x, x2), mathMin(y, y2)];\n        var max = [mathMax(x, x2), mathMax(y, y2)];\n\n        return [\n            [min[0], max[0]], // x range\n            [min[1], max[1]] // y range\n        ];\n    }\n\n    function getTransform(controller) {\n        return graphic.getTransform(controller.group);\n    }\n\n    function getGlobalDirection(controller, localDirection) {\n        if (localDirection.length > 1) {\n            localDirection = localDirection.split('');\n            var globalDir = [\n                getGlobalDirection(controller, localDirection[0]),\n                getGlobalDirection(controller, localDirection[1])\n            ];\n            (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n            return globalDir.join('');\n        }\n        else {\n            var map = {w: 'left', e: 'right', n: 'top', s: 'bottom'};\n            var inverseMap = {left: 'w', right: 'e', top: 'n', bottom: 's'};\n            var globalDir = graphic.transformDirection(\n                map[localDirection], getTransform(controller)\n            );\n            return inverseMap[globalDir];\n        }\n    }\n\n    function driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {\n        var brushOption = cover.__brushOption;\n        var rectRange = toRectRange(brushOption.range);\n        var localDelta = toLocalDelta(controller, dx, dy);\n\n        each(name.split(''), function (namePart) {\n            var ind = DIRECTION_MAP[namePart];\n            rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n        });\n\n        brushOption.range = fromRectRange(formatRectRange(\n            rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]\n        ));\n\n        updateCoverAfterCreation(controller, cover);\n        trigger(controller, {isEnd: false});\n    }\n\n    function driftPolygon(controller, cover, dx, dy, e) {\n        var range = cover.__brushOption.range;\n        var localDelta = toLocalDelta(controller, dx, dy);\n\n        each(range, function (point) {\n            point[0] += localDelta[0];\n            point[1] += localDelta[1];\n        });\n\n        updateCoverAfterCreation(controller, cover);\n        trigger(controller, {isEnd: false});\n    }\n\n    function toLocalDelta(controller, dx, dy) {\n        var thisGroup = controller.group;\n        var localD = thisGroup.transformCoordToLocal(dx, dy);\n        var localZero = thisGroup.transformCoordToLocal(0, 0);\n\n        return [localD[0] - localZero[0], localD[1] - localZero[1]];\n    }\n\n    function clipByPanel(controller, cover, data) {\n        var panel = getPanelByCover(controller, cover);\n\n        return (panel && panel !== true)\n            ? panel.clipPath(data, controller._transform)\n            : zrUtil.clone(data);\n    }\n\n    function pointsToRect(points) {\n        var xmin = mathMin(points[0][0], points[1][0]);\n        var ymin = mathMin(points[0][1], points[1][1]);\n        var xmax = mathMax(points[0][0], points[1][0]);\n        var ymax = mathMax(points[0][1], points[1][1]);\n\n        return {\n            x: xmin,\n            y: ymin,\n            width: xmax - xmin,\n            height: ymax - ymin\n        };\n    }\n\n    function resetCursor(controller, e, localCursorPoint) {\n        // Check active\n        if (!controller._brushType) {\n            return;\n        }\n\n        var zr = controller._zr;\n        var covers = controller._covers;\n        var currPanel = getPanelByPoint(controller, e, localCursorPoint);\n\n        // Check whether in covers.\n        if (!controller._dragging) {\n            for (var i = 0; i < covers.length; i++) {\n                var brushOption = covers[i].__brushOption;\n                if (currPanel\n                    && (currPanel === true || brushOption.panelId === currPanel.panelId)\n                    && coverRenderers[brushOption.brushType].contain(\n                        covers[i], localCursorPoint[0], localCursorPoint[1]\n                    )\n                ) {\n                    // Use cursor style set on cover.\n                    return;\n                }\n            }\n        }\n\n        currPanel && zr.setCursorStyle('crosshair');\n    }\n\n    function preventDefault(e) {\n        var rawE = e.event;\n        rawE.preventDefault && rawE.preventDefault();\n    }\n\n    function mainShapeContain(cover, x, y) {\n        return cover.childOfName('main').contain(x, y);\n    }\n\n    function updateCoverByMouse(controller, e, localCursorPoint, isEnd) {\n        var creatingCover = controller._creatingCover;\n        var panel = controller._creatingPanel;\n        var thisBrushOption = controller._brushOption;\n        var eventParams;\n\n        controller._track.push(localCursorPoint.slice());\n\n        if (shouldShowCover(controller) || creatingCover) {\n\n            if (panel && !creatingCover) {\n                thisBrushOption.brushMode === 'single' && clearCovers(controller);\n                var brushOption = zrUtil.clone(thisBrushOption);\n                brushOption.brushType = determineBrushType(brushOption.brushType, panel);\n                brushOption.panelId = panel === true ? null : panel.panelId;\n                creatingCover = controller._creatingCover = createCover(controller, brushOption);\n                controller._covers.push(creatingCover);\n            }\n\n            if (creatingCover) {\n                var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];\n                var coverBrushOption = creatingCover.__brushOption;\n\n                coverBrushOption.range = coverRenderer.getCreatingRange(\n                    clipByPanel(controller, creatingCover, controller._track)\n                );\n\n                if (isEnd) {\n                    endCreating(controller, creatingCover);\n                    coverRenderer.updateCommon(controller, creatingCover);\n                }\n\n                updateCoverShape(controller, creatingCover);\n\n                eventParams = {isEnd: isEnd};\n            }\n        }\n        else if (\n            isEnd\n            && thisBrushOption.brushMode === 'single'\n            && thisBrushOption.removeOnClick\n        ) {\n            // Help user to remove covers easily, only by a tiny drag, in 'single' mode.\n            // But a single click do not clear covers, because user may have casual\n            // clicks (for example, click on other component and do not expect covers\n            // disappear).\n            // Only some cover removed, trigger action, but not every click trigger action.\n            if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {\n                eventParams = {isEnd: isEnd, removeOnClick: true};\n            }\n        }\n\n        return eventParams;\n    }\n\n    function determineBrushType(brushType, panel) {\n        if (brushType === 'auto') {\n            if (__DEV__) {\n                zrUtil.assert(\n                    panel && panel.defaultBrushType,\n                    'MUST have defaultBrushType when brushType is \"atuo\"'\n                );\n            }\n            return panel.defaultBrushType;\n        }\n        return brushType;\n    }\n\n    var mouseHandlers = {\n\n        mousedown: function (e) {\n            if (this._dragging) {\n                // In case some browser do not support globalOut,\n                // and release mose out side the browser.\n                handleDragEnd.call(this, e);\n            }\n            else if (!e.target || !e.target.draggable) {\n\n                preventDefault(e);\n\n                var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n\n                this._creatingCover = null;\n                var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);\n\n                if (panel) {\n                    this._dragging = true;\n                    this._track = [localCursorPoint.slice()];\n                }\n            }\n        },\n\n        mousemove: function (e) {\n            var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n\n            resetCursor(this, e, localCursorPoint);\n\n            if (this._dragging) {\n\n                preventDefault(e);\n\n                var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);\n\n                eventParams && trigger(this, eventParams);\n            }\n        },\n\n        mouseup: handleDragEnd //,\n\n        // FIXME\n        // in tooltip, globalout should not be triggered.\n        // globalout: handleDragEnd\n    };\n\n    function handleDragEnd(e) {\n        if (this._dragging) {\n\n            preventDefault(e);\n\n            var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n            var eventParams = updateCoverByMouse(this, e, localCursorPoint, true);\n\n            this._dragging = false;\n            this._track = [];\n            this._creatingCover = null;\n\n            // trigger event shoule be at final, after procedure will be nested.\n            eventParams && trigger(this, eventParams);\n        }\n    }\n\n    /**\n     * key: brushType\n     * @type {Object}\n     */\n    var coverRenderers = {\n\n        lineX: getLineRenderer(0),\n\n        lineY: getLineRenderer(1),\n\n        rect: {\n            createCover: function (controller, brushOption) {\n                return createBaseRectCover(\n                    curry(\n                        driftRect,\n                        function (range) {\n                            return range;\n                        },\n                        function (range) {\n                            return range;\n                        }\n                    ),\n                    controller,\n                    brushOption,\n                    ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']\n                );\n            },\n            getCreatingRange: function (localTrack) {\n                var ends = getTrackEnds(localTrack);\n                return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n            },\n            updateCoverShape: function (controller, cover, localRange, brushOption) {\n                updateBaseRect(controller, cover, localRange, brushOption);\n            },\n            updateCommon: updateCommon,\n            contain: mainShapeContain\n        },\n\n        polygon: {\n            createCover: function (controller, brushOption) {\n                var cover = new graphic.Group();\n\n                // Do not use graphic.Polygon because graphic.Polyline do not close the\n                // border of the shape when drawing, which is a better experience for user.\n                cover.add(new graphic.Polyline({\n                    name: 'main',\n                    style: makeStyle(brushOption),\n                    silent: true\n                }));\n\n                return cover;\n            },\n            getCreatingRange: function (localTrack) {\n                return localTrack;\n            },\n            endCreating: function (controller, cover) {\n                cover.remove(cover.childAt(0));\n                // Use graphic.Polygon close the shape.\n                cover.add(new graphic.Polygon({\n                    name: 'main',\n                    draggable: true,\n                    drift: curry(driftPolygon, controller, cover),\n                    ondragend: curry(trigger, controller, {isEnd: true})\n                }));\n            },\n            updateCoverShape: function (controller, cover, localRange, brushOption) {\n                cover.childAt(0).setShape({\n                    points: clipByPanel(controller, cover, localRange)\n                });\n            },\n            updateCommon: updateCommon,\n            contain: mainShapeContain\n        }\n    };\n\n    function getLineRenderer(xyIndex) {\n        return {\n            createCover: function (controller, brushOption) {\n                return createBaseRectCover(\n                    curry(\n                        driftRect,\n                        function (range) {\n                            var rectRange = [range, [0, 100]];\n                            xyIndex && rectRange.reverse();\n                            return rectRange;\n                        },\n                        function (rectRange) {\n                            return rectRange[xyIndex];\n                        }\n                    ),\n                    controller,\n                    brushOption,\n                    [['w', 'e'], ['n', 's']][xyIndex]\n                );\n            },\n            getCreatingRange: function (localTrack) {\n                var ends = getTrackEnds(localTrack);\n                var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);\n                var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);\n\n                return [min, max];\n            },\n            updateCoverShape: function (controller, cover, localRange, brushOption) {\n                var otherExtent;\n                // If brushWidth not specified, fit the panel.\n                var panel = getPanelByCover(controller, cover);\n                if (panel !== true && panel.getLinearBrushOtherExtent) {\n                    otherExtent = panel.getLinearBrushOtherExtent(\n                        xyIndex, controller._transform\n                    );\n                }\n                else {\n                    var zr = controller._zr;\n                    otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];\n                }\n                var rectRange = [localRange, otherExtent];\n                xyIndex && rectRange.reverse();\n\n                updateBaseRect(controller, cover, rectRange, brushOption);\n            },\n            updateCommon: updateCommon,\n            contain: mainShapeContain\n        };\n    }\n\n    module.exports = BrushController;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/BrushController.js\n// module id = 1055\n// module chunks = 0 1 2","\n\n    var helper = {};\n\n    var IRRELEVANT_EXCLUDES = {'axisPointer': 1, 'tooltip': 1, 'brush': 1};\n\n    /**\n     * Avoid that: mouse click on a elements that is over geo or graph,\n     * but roam is triggered.\n     */\n    helper.onIrrelevantElement = function (e, api, targetCoordSysModel) {\n        var model = api.getComponentByElement(e.topTarget);\n        // If model is axisModel, it works only if it is injected with coordinateSystem.\n        var coordSys = model && model.coordinateSystem;\n        return model\n            && model !== targetCoordSysModel\n            && !IRRELEVANT_EXCLUDES[model.mainType]\n            && (coordSys && coordSys.model !== targetCoordSysModel);\n    };\n\n    module.exports = helper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/cursorHelper.js\n// module id = 1056\n// module chunks = 0 1 2","/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\n\n\n    var textHelper = require('../helper/text');\n    var BoundingRect = require('../../core/BoundingRect');\n\n    var tmpRect = new BoundingRect();\n\n    var RectText = function () {};\n\n    RectText.prototype = {\n\n        constructor: RectText,\n\n        /**\n         * Draw text in a rect with specified position.\n         * @param  {CanvasRenderingContext2D} ctx\n         * @param  {Object} rect Displayable rect\n         */\n        drawRectText: function (ctx, rect) {\n            var style = this.style;\n\n            rect = style.textRect || rect;\n\n            // Optimize, avoid normalize every time.\n            this.__dirty && textHelper.normalizeTextStyle(style, true);\n\n            var text = style.text;\n\n            // Convert to string\n            text != null && (text += '');\n\n            if (!textHelper.needDrawText(text, style)) {\n                return;\n            }\n\n            // FIXME\n            ctx.save();\n\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.transformText) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            }\n            else {\n                this.setTransform(ctx);\n            }\n\n            // transformText and textRotation can not be used at the same time.\n            textHelper.renderText(this, ctx, text, style, rect);\n\n            ctx.restore();\n        }\n    };\n\n    module.exports = RectText;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/mixin/RectText.js\n// module id = 1059\n// module chunks = 0 1 2","\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l)\n                || (y < y0 - _l && y < y1 - _l)\n                || (x > x0 + _l && x > x1 + _l)\n                || (x < x0 - _l && x < x1 - _l)\n            ) {\n                return false;\n            }\n\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n            }\n            else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/contain/line.js\n// module id = 1060\n// module chunks = 0 1 2","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(\n                x0, y0, x1, y1, x2, y2,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/contain/quadratic.js\n// module id = 1061\n// module chunks = 0 1 2","\n    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n\n        var x_ = t * (x1 - x0) + x0;\n\n        return x_ > x ? dir : 0;\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/contain/windingLine.js\n// module id = 1062\n// module chunks = 0 1 2","/**\n * Text element\n * @module zrender/graphic/Text\n *\n * TODO Wrapping\n *\n * Text not support gradient\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var textContain = require('../contain/text');\n    var textHelper = require('./helper/text');\n\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n\n    Text.prototype = {\n\n        constructor: Text,\n\n        type: 'text',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n\n            // Optimize, avoid normalize every time.\n            this.__dirty && textHelper.normalizeTextStyle(style, true);\n\n            // Use props with prefix 'text'.\n            style.fill = style.stroke = style.shadowBlur = style.shadowColor =\n                style.shadowOffsetX = style.shadowOffsetY = null;\n\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n\n            if (!textHelper.needDrawText(text, style)) {\n                return;\n            }\n\n            this.setTransform(ctx);\n\n            textHelper.renderText(this, ctx, text, style);\n\n            this.restoreTransform(ctx);\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n\n            // Optimize, avoid normalize every time.\n            this.__dirty && textHelper.normalizeTextStyle(style, true);\n\n            if (!this._rect) {\n                var text = style.text;\n                text != null ? (text += '') : (text = '');\n\n                var rect = textContain.getBoundingRect(\n                    style.text + '',\n                    style.font,\n                    style.textAlign,\n                    style.textVerticalAlign,\n                    style.textPadding,\n                    style.rich\n                );\n\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n\n                if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {\n                    var w = style.textStrokeWidth;\n                    rect.x -= w / 2;\n                    rect.y -= w / 2;\n                    rect.width += w;\n                    rect.height += w;\n                }\n\n                this._rect = rect;\n            }\n\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(Text, Displayable);\n\n    module.exports = Text;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/Text.js\n// module id = 1063\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {type: 'linear', colorStops: ...}`, where\n        // this constructor will not be called.\n\n        this.x = x == null ? 0 : x;\n\n        this.y = y == null ? 0 : y;\n\n        this.x2 = x2 == null ? 1 : x2;\n\n        this.y2 = y2 == null ? 0 : y2;\n\n        // Can be cloned\n        this.type = 'linear';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    LinearGradient.prototype = {\n\n        constructor: LinearGradient\n    };\n\n    zrUtil.inherits(LinearGradient, Gradient);\n\n    module.exports = LinearGradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/LinearGradient.js\n// module id = 1064\n// module chunks = 0 1 2","/*!\n * ZRender, a high performance 2d drawing library.\n *\n * Copyright (c) 2013, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n */\n// Global defines\n\n    var guid = require('./core/guid');\n    var env = require('./core/env');\n    var zrUtil = require('./core/util');\n\n    var Handler = require('./Handler');\n    var Storage = require('./Storage');\n    var Animation = require('./animation/Animation');\n    var HandlerProxy = require('./dom/HandlerProxy');\n\n    var useVML = !env.canvasSupported;\n\n    var painterCtors = {\n        canvas: require('./Painter')\n    };\n\n    var instances = {};    // ZRendermap\n\n    var zrender = {};\n\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.6.3';\n\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function (dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        }\n        else {\n            for (var key in instances) {\n                if (instances.hasOwnProperty(key)) {\n                    instances[key].dispose();\n                }\n            }\n            instances = {};\n        }\n\n        return zrender;\n    };\n\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n\n    function delInstance(id) {\n        delete instances[id];\n    }\n\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     */\n    var ZRender = function (id, dom, opts) {\n\n        opts = opts || {};\n\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n\n        /**\n         * @type {string}\n         */\n        this.id = id;\n\n        var self = this;\n        var storage = new Storage();\n\n        var rendererType = opts.renderer;\n        // TODO WebGL\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        }\n        else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n\n        this.storage = storage;\n        this.painter = painter;\n\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy, painter.root);\n\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: zrUtil.bind(this.flush, this)\n            }\n        });\n        this.animation.start();\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n\n        //  storage.delFromStorage, \n        // FIXME ugly\n        var oldDelFromStorage = storage.delFromStorage;\n        var oldAddToStorage = storage.addToStorage;\n\n        storage.delFromStorage = function (el) {\n            oldDelFromStorage.call(storage, el);\n\n            el && el.removeSelfFromZr(self);\n        };\n\n        storage.addToStorage = function (el) {\n            oldAddToStorage.call(storage, el);\n\n            el.addSelfToZr(self);\n        };\n    };\n\n    ZRender.prototype = {\n\n        constructor: ZRender,\n        /**\n         * \n         * @return {string}\n         */\n        getId: function () {\n            return this.id;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * \n         * @param  {module:zrender/Element} el\n         */\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Change configuration of layer\n         * @param {string} zLevel\n         * @param {Object} config\n         * @param {string} [config.clearColor=0] Clear color\n         * @param {string} [config.motionBlur=false] If enable motion blur\n         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n        */\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Repaint the canvas immediately\n         */\n        refreshImmediately: function () {\n            // var start = new Date();\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n            // var end = new Date();\n\n            // var log = document.getElementById('log');\n            // if (log) {\n            //     log.innerHTML = log.innerHTML + '<br>' + (end - start);\n            // }\n        },\n\n        /**\n         * Mark and repaint the canvas in the next frame of browser\n         */\n        refresh: function() {\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Perform all refresh\n         */\n        flush: function () {\n            if (this._needsRefresh) {\n                this.refreshImmediately();\n            }\n            if (this._needsRefreshHover) {\n                this.refreshHoverImmediately();\n            }\n        },\n\n        /**\n         * Add element to hover layer\n         * @param  {module:zrender/Element} el\n         * @param {Object} style\n         */\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Add element from hover layer\n         * @param  {module:zrender/Element} el\n         */\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Clear all hover elements in hover layer\n         * @param  {module:zrender/Element} el\n         */\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Refresh hover in next frame\n         */\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n\n        /**\n         * Refresh hover immediately\n         */\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n\n        /**\n         * Resize the canvas.\n         * Should be invoked when container size is changed\n         * @param {Object} [opts]\n         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n         */\n        resize: function(opts) {\n            opts = opts || {};\n            this.painter.resize(opts.width, opts.height);\n            this.handler.resize();\n        },\n\n        /**\n         * Stop and clear all animation immediately\n         */\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n\n        /**\n         * Get container width\n         */\n        getWidth: function() {\n            return this.painter.getWidth();\n        },\n\n        /**\n         * Get container height\n         */\n        getHeight: function() {\n            return this.painter.getHeight();\n        },\n\n        /**\n         * Export the canvas as Base64 URL\n         * @param {string} type\n         * @param {string} [backgroundColor='#fff']\n         * @return {string} Base64 URL\n         */\n        // toDataURL: function(type, backgroundColor) {\n        //     return this.painter.getRenderedCanvas({\n        //         backgroundColor: backgroundColor\n        //     }).toDataURL(type);\n        // },\n\n        /**\n         * Converting a path to image.\n         * It has much better performance of drawing image rather than drawing a vector path.\n         * @param {module:zrender/graphic/Path} e\n         * @param {number} width\n         * @param {number} height\n         */\n        pathToImage: function(e, dpr) {\n            return this.painter.pathToImage(e, dpr);\n        },\n\n        /**\n         * Set default cursor\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n\n        /**\n         * Find hovered element\n         * @param {number} x\n         * @param {number} y\n         * @return {Object} {target, topTarget}\n         */\n        findHover: function (x, y) {\n            return this.handler.findHover(x, y);\n        },\n\n        /**\n         * Bind event\n         *\n         * @param {string} eventName Event name\n         * @param {Function} eventHandler Handler function\n         * @param {Object} [context] Context object\n         */\n        on: function(eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n\n        /**\n         * Unbind event\n         * @param {string} eventName Event name\n         * @param {Function} [eventHandler] Handler function\n         */\n        off: function(eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n\n        /**\n         * Trigger event manually\n         *\n         * @param {string} eventName Event name\n         * @param {event=} event Event object\n         */\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n\n\n        /**\n         * Clear all objects and the canvas.\n         */\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n\n        /**\n         * Dispose self.\n         */\n        dispose: function () {\n            this.animation.stop();\n\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n\n            this.animation =\n            this.storage =\n            this.painter =\n            this.handler = null;\n\n            delInstance(this.id);\n        }\n    };\n\n    module.exports = zrender;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/zrender.js\n// module id = 1065\n// module chunks = 0 1 2","// FIXME Better way to pack data in graphic element\n\n\n    require('./axisPointer');\n\n    require('./tooltip/TooltipModel');\n\n    require('./tooltip/TooltipView');\n\n\n    // Show tip action\n    /**\n     * @action\n     * @property {string} type\n     * @property {number} seriesIndex\n     * @property {number} dataIndex\n     * @property {number} [x]\n     * @property {number} [y]\n     */\n    require('../echarts').registerAction(\n        {\n            type: 'showTip',\n            event: 'showTip',\n            update: 'tooltip:manuallyShowTip'\n        },\n        // noop\n        function () {}\n    );\n    // Hide tip action\n    require('../echarts').registerAction(\n        {\n            type: 'hideTip',\n            event: 'hideTip',\n            update: 'tooltip:manuallyHideTip'\n        },\n        // noop\n        function () {}\n    );\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/tooltip.js\n// module id = 1066\n// module chunks = 0 1 2","\n\n    // Do not contain scrollable legend, for sake of file size.\n\n    require('./legend/LegendModel');\n    require('./legend/legendAction');\n    require('./legend/LegendView');\n\n    var echarts = require('../echarts');\n    // Series Filter\n    echarts.registerProcessor(require('./legend/legendFilter'));\n\n    require('../model/Component').registerSubTypeDefaulter('legend', function () {\n        // Default 'plain' when no type specified.\n        return 'plain';\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend.js\n// module id = 1067\n// module chunks = 0 1 2","\n    module.exports = function (seriesType, ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (!legendModels || !legendModels.length) {\n            return;\n        }\n        ecModel.eachSeriesByType(seriesType, function (series) {\n            var data = series.getData();\n            data.filterSelf(function (idx) {\n                var name = data.getName(idx);\n                // If in any legend component the status is not selected.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(name)) {\n                        return false;\n                    }\n                }\n                return true;\n            }, this);\n        }, this);\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/processor/dataFilter.js\n// module id = 1068\n// module chunks = 0 2","\n\n    require('./toolbox/ToolboxModel');\n    require('./toolbox/ToolboxView');\n\n    require('./toolbox/feature/SaveAsImage');\n    require('./toolbox/feature/MagicType');\n    require('./toolbox/feature/DataView');\n    require('./toolbox/feature/DataZoom');\n    require('./toolbox/feature/Restore');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox.js\n// module id = 1069\n// module chunks = 0 1 2","\n\n    var ATTR = '\\0_ec_interaction_mutex';\n\n    var interactionMutex = {\n\n        take: function (zr, resourceKey, userKey) {\n            var store = getStore(zr);\n            store[resourceKey] = userKey;\n        },\n\n        release: function (zr, resourceKey, userKey) {\n            var store = getStore(zr);\n            var uKey = store[resourceKey];\n\n            if (uKey === userKey) {\n                store[resourceKey] = null;\n            }\n        },\n\n        isTaken: function (zr, resourceKey) {\n            return !!getStore(zr)[resourceKey];\n        }\n    };\n\n    function getStore(zr) {\n        return zr[ATTR] || (zr[ATTR] = {});\n    }\n\n    /**\n     * payload: {\n     *     type: 'takeGlobalCursor',\n     *     key: 'dataZoomSelect', or 'brush', or ...,\n     *         If no userKey, release global cursor.\n     * }\n     */\n    require('../../echarts').registerAction(\n        {type: 'takeGlobalCursor', event: 'globalCursorTaken', update: 'update'},\n        function () {}\n    );\n\n    module.exports = interactionMutex;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/interactionMutex.js\n// module id = 1070\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n    var modelUtil = require('../../util/model');\n    var brushHelper = require('./brushHelper');\n\n    var each = zrUtil.each;\n    var indexOf = zrUtil.indexOf;\n    var curry = zrUtil.curry;\n\n    var COORD_CONVERTS = ['dataToPoint', 'pointToData'];\n\n    // FIXME\n    // how to genarialize to more coordinate systems.\n    var INCLUDE_FINDER_MAIN_TYPES = [\n        'grid', 'xAxis', 'yAxis', 'geo', 'graph',\n        'polar', 'radiusAxis', 'angleAxis', 'bmap'\n    ];\n\n    /**\n     * [option in constructor]:\n     * {\n     *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n     * }\n     *\n     *\n     * [targetInfo]:\n     *\n     * There can be multiple axes in a single targetInfo. Consider the case\n     * of `grid` component, a targetInfo represents a grid which contains one or more\n     * cartesian and one or more axes. And consider the case of parallel system,\n     * which has multiple axes in a coordinate system.\n     * Can be {\n     *     panelId: ...,\n     *     coordSys: <a representitive cartesian in grid (first cartesian by default)>,\n     *     coordSyses: all cartesians.\n     *     gridModel: <grid component>\n     *     xAxes: correspond to coordSyses on index\n     *     yAxes: correspond to coordSyses on index\n     * }\n     * or {\n     *     panelId: ...,\n     *     coordSys: <geo coord sys>\n     *     coordSyses: [<geo coord sys>]\n     *     geoModel: <geo component>\n     * }\n     *\n     *\n     * [panelOpt]:\n     *\n     * Make from targetInfo. Input to BrushController.\n     * {\n     *     panelId: ...,\n     *     rect: ...\n     * }\n     *\n     *\n     * [area]:\n     *\n     * Generated by BrushController or user input.\n     * {\n     *     panelId: Used to locate coordInfo directly. If user inpput, no panelId.\n     *     brushType: determine how to convert to/from coord('rect' or 'polygon' or 'lineX/Y').\n     *     Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder.\n     *     range: pixel range.\n     *     coordRange: representitive coord range (the first one of coordRanges).\n     *     coordRanges: <Array> coord ranges, used in multiple cartesian in one grid.\n     * }\n     */\n\n    /**\n     * @param {Object} option contains Index/Id/Name of xAxis/yAxis/geo/grid\n     *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}\n     * @param {module:echarts/model/Global} ecModel\n     * @param {Object} [opt]\n     * @param {Array.<string>} [opt.include] include coordinate system types.\n     */\n    function BrushTargetManager(option, ecModel, opt) {\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        var targetInfoList = this._targetInfoList = [];\n        var info = {};\n        var foundCpts = parseFinder(ecModel, option);\n\n        each(targetInfoBuilders, function (builder, type) {\n            if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {\n                builder(foundCpts, targetInfoList, info);\n            }\n        });\n    }\n\n    var proto = BrushTargetManager.prototype;\n\n    proto.setOutputRanges = function (areas, ecModel) {\n        this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n            (area.coordRanges || (area.coordRanges = [])).push(coordRange);\n            // area.coordRange is the first of area.coordRanges\n            if (!area.coordRange) {\n                area.coordRange = coordRange;\n                // In 'category' axis, coord to pixel is not reversible, so we can not\n                // rebuild range by coordRange accrately, which may bring trouble when\n                // brushing only one item. So we use __rangeOffset to rebuilding range\n                // by coordRange. And this it only used in brush component so it is no\n                // need to be adapted to coordRanges.\n                var result = coordConvert[area.brushType](0, coordSys, coordRange);\n                area.__rangeOffset = {\n                    offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n                    xyMinMax: result.xyMinMax\n                };\n            }\n        });\n    };\n\n    proto.matchOutputRanges = function (areas, ecModel, cb) {\n        each(areas, function (area) {\n            var targetInfo = this.findTargetInfo(area, ecModel);\n\n            if (targetInfo && targetInfo !== true) {\n                zrUtil.each(\n                    targetInfo.coordSyses,\n                    function (coordSys) {\n                        var result = coordConvert[area.brushType](1, coordSys, area.range);\n                        cb(area, result.values, coordSys, ecModel);\n                    }\n                );\n            }\n        }, this);\n    };\n\n    proto.setInputRanges = function (areas, ecModel) {\n        each(areas, function (area) {\n            var targetInfo = this.findTargetInfo(area, ecModel);\n\n            if (__DEV__) {\n                zrUtil.assert(\n                    !targetInfo || targetInfo === true || area.coordRange,\n                    'coordRange must be specified when coord index specified.'\n                );\n                zrUtil.assert(\n                    !targetInfo || targetInfo !== true || area.range,\n                    'range must be specified in global brush.'\n                );\n            }\n\n            area.range = area.range || [];\n\n            // convert coordRange to global range and set panelId.\n            if (targetInfo && targetInfo !== true) {\n                area.panelId = targetInfo.panelId;\n                // (1) area.range shoule always be calculate from coordRange but does\n                // not keep its original value, for the sake of the dataZoom scenario,\n                // where area.coordRange remains unchanged but area.range may be changed.\n                // (2) Only support converting one coordRange to pixel range in brush\n                // component. So do not consider `coordRanges`.\n                // (3) About __rangeOffset, see comment above.\n                var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n                var rangeOffset = area.__rangeOffset;\n                area.range = rangeOffset\n                    ? diffProcessor[area.brushType](\n                        result.values,\n                        rangeOffset.offset,\n                        getScales(result.xyMinMax, rangeOffset.xyMinMax)\n                    )\n                    : result.values;\n            }\n        }, this);\n    };\n\n    proto.makePanelOpts = function (api, getDefaultBrushType) {\n        return zrUtil.map(this._targetInfoList, function (targetInfo) {\n            var rect = targetInfo.getPanelRect();\n            return {\n                panelId: targetInfo.panelId,\n                defaultBrushType: getDefaultBrushType && getDefaultBrushType(targetInfo),\n                clipPath: brushHelper.makeRectPanelClipPath(rect),\n                isTargetByCursor: brushHelper.makeRectIsTargetByCursor(\n                    rect, api, targetInfo.coordSysModel\n                ),\n                getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)\n            };\n        });\n    };\n\n    proto.controlSeries = function (area, seriesModel, ecModel) {\n        // Check whether area is bound in coord, and series do not belong to that coord.\n        // If do not do this check, some brush (like lineX) will controll all axes.\n        var targetInfo = this.findTargetInfo(area, ecModel);\n        return targetInfo === true || (\n            targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0\n        );\n    };\n\n    /**\n     * If return Object, a coord found.\n     * If reutrn true, global found.\n     * Otherwise nothing found.\n     *\n     * @param {Object} area\n     * @param {Array} targetInfoList\n     * @return {Object|boolean}\n     */\n    proto.findTargetInfo = function (area, ecModel) {\n        var targetInfoList = this._targetInfoList;\n        var foundCpts = parseFinder(ecModel, area);\n\n        for (var i = 0; i < targetInfoList.length; i++) {\n            var targetInfo = targetInfoList[i];\n            var areaPanelId = area.panelId;\n            if (areaPanelId) {\n                if (targetInfo.panelId === areaPanelId) {\n                    return targetInfo;\n                }\n            }\n            else {\n                for (var i = 0; i < targetInfoMatchers.length; i++) {\n                    if (targetInfoMatchers[i](foundCpts, targetInfo)) {\n                        return targetInfo;\n                    }\n                }\n            }\n        }\n\n        return true;\n    };\n\n    function formatMinMax(minMax) {\n        minMax[0] > minMax[1] && minMax.reverse();\n        return minMax;\n    }\n\n    function parseFinder(ecModel, option) {\n        return modelUtil.parseFinder(\n            ecModel, option, {includeMainTypes: INCLUDE_FINDER_MAIN_TYPES}\n        );\n    }\n\n    var targetInfoBuilders = {\n\n        grid: function (foundCpts, targetInfoList) {\n            var xAxisModels = foundCpts.xAxisModels;\n            var yAxisModels = foundCpts.yAxisModels;\n            var gridModels = foundCpts.gridModels;\n            // Remove duplicated.\n            var gridModelMap = zrUtil.createHashMap();\n            var xAxesHas = {};\n            var yAxesHas = {};\n\n            if (!xAxisModels && !yAxisModels && !gridModels) {\n                return;\n            }\n\n            each(xAxisModels, function (axisModel) {\n                var gridModel = axisModel.axis.grid.model;\n                gridModelMap.set(gridModel.id, gridModel);\n                xAxesHas[gridModel.id] = true;\n            });\n            each(yAxisModels, function (axisModel) {\n                var gridModel = axisModel.axis.grid.model;\n                gridModelMap.set(gridModel.id, gridModel);\n                yAxesHas[gridModel.id] = true;\n            });\n            each(gridModels, function (gridModel) {\n                gridModelMap.set(gridModel.id, gridModel);\n                xAxesHas[gridModel.id] = true;\n                yAxesHas[gridModel.id] = true;\n            });\n\n            gridModelMap.each(function (gridModel) {\n                var grid = gridModel.coordinateSystem;\n                var cartesians = [];\n\n                each(grid.getCartesians(), function (cartesian, index) {\n                    if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0\n                        || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0\n                    ) {\n                        cartesians.push(cartesian);\n                    }\n                });\n                targetInfoList.push({\n                    panelId: 'grid--' + gridModel.id,\n                    gridModel: gridModel,\n                    coordSysModel: gridModel,\n                    // Use the first one as the representitive coordSys.\n                    coordSys: cartesians[0],\n                    coordSyses: cartesians,\n                    getPanelRect: panelRectBuilder.grid,\n                    xAxisDeclared: xAxesHas[gridModel.id],\n                    yAxisDeclared: yAxesHas[gridModel.id]\n                });\n            });\n        },\n\n        geo: function (foundCpts, targetInfoList) {\n            each(foundCpts.geoModels, function (geoModel) {\n                var coordSys = geoModel.coordinateSystem;\n                targetInfoList.push({\n                    panelId: 'geo--' + geoModel.id,\n                    geoModel: geoModel,\n                    coordSysModel: geoModel,\n                    coordSys: coordSys,\n                    coordSyses: [coordSys],\n                    getPanelRect: panelRectBuilder.geo\n                });\n            });\n        }\n    };\n\n    var targetInfoMatchers = [\n\n        // grid\n        function (foundCpts, targetInfo) {\n            var xAxisModel = foundCpts.xAxisModel;\n            var yAxisModel = foundCpts.yAxisModel;\n            var gridModel = foundCpts.gridModel;\n\n            !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n            !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n\n            return gridModel && gridModel === targetInfo.gridModel;\n        },\n\n        // geo\n        function (foundCpts, targetInfo) {\n            var geoModel = foundCpts.geoModel;\n            return geoModel && geoModel === targetInfo.geoModel;\n        }\n    ];\n\n    var panelRectBuilder = {\n\n        grid: function () {\n            // grid is not Transformable.\n            return this.coordSys.grid.getRect().clone();\n        },\n\n        geo: function () {\n            var coordSys = this.coordSys;\n            var rect = coordSys.getBoundingRect().clone();\n            // geo roam and zoom transform\n            rect.applyTransform(graphic.getTransform(coordSys));\n            return rect;\n        }\n    };\n\n    var coordConvert = {\n\n        lineX: curry(axisConvert, 0),\n\n        lineY: curry(axisConvert, 1),\n\n        rect: function (to, coordSys, rangeOrCoordRange) {\n            var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);\n            var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);\n            var values = [\n                formatMinMax([xminymin[0], xmaxymax[0]]),\n                formatMinMax([xminymin[1], xmaxymax[1]])\n            ];\n            return {values: values, xyMinMax: values};\n        },\n\n        polygon: function (to, coordSys, rangeOrCoordRange) {\n            var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n            var values = zrUtil.map(rangeOrCoordRange, function (item) {\n                var p = coordSys[COORD_CONVERTS[to]](item);\n                xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n                xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n                xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n                xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n                return p;\n            });\n            return {values: values, xyMinMax: xyMinMax};\n        }\n    };\n\n    function axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n        if (__DEV__) {\n            zrUtil.assert(\n                coordSys.type === 'cartesian2d',\n                'lineX/lineY brush is available only in cartesian2d.'\n            );\n        }\n\n        var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n        var values = formatMinMax(zrUtil.map([0, 1], function (i) {\n            return to\n                ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i]))\n                : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n        }));\n        var xyMinMax = [];\n        xyMinMax[axisNameIndex] = values;\n        xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n\n        return {values: values, xyMinMax: xyMinMax};\n    }\n\n    var diffProcessor = {\n        lineX: curry(axisDiffProcessor, 0),\n\n        lineY: curry(axisDiffProcessor, 1),\n\n        rect: function (values, refer, scales) {\n            return [\n                [values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]],\n                [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]\n            ];\n        },\n\n        polygon: function (values, refer, scales) {\n            return zrUtil.map(values, function (item, idx) {\n                return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n            });\n        }\n    };\n\n    function axisDiffProcessor(axisNameIndex, values, refer, scales) {\n        return [\n            values[0] - scales[axisNameIndex] * refer[0],\n            values[1] - scales[axisNameIndex] * refer[1]\n        ];\n    }\n\n    // We have to process scale caused by dataZoom manually,\n    // although it might be not accurate.\n    function getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n        var sizeCurr = getSize(xyMinMaxCurr);\n        var sizeOrigin = getSize(xyMinMaxOrigin);\n        var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n        isNaN(scales[0]) && (scales[0] = 1);\n        isNaN(scales[1]) && (scales[1] = 1);\n        return scales;\n    }\n\n    function getSize(xyMinMax) {\n        return xyMinMax\n            ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]]\n            : [NaN, NaN];\n    }\n\n    module.exports = BrushTargetManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/BrushTargetManager.js\n// module id = 1071\n// module chunks = 0 1 2","\n\n    var cursorHelper = require('./cursorHelper');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n    var graphicUtil = require('../../util/graphic');\n\n    var helper = {};\n\n    helper.makeRectPanelClipPath = function (rect) {\n        rect = normalizeRect(rect);\n        return function (localPoints, transform) {\n            return graphicUtil.clipPointsByRect(localPoints, rect);\n        };\n    };\n\n    helper.makeLinearBrushOtherExtent = function (rect, specifiedXYIndex) {\n        rect = normalizeRect(rect);\n        return function (xyIndex) {\n            var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;\n            var brushWidth = idx ? rect.width : rect.height;\n            var base = idx ? rect.x : rect.y;\n            return [base, base + (brushWidth || 0)];\n        };\n    };\n\n    helper.makeRectIsTargetByCursor = function (rect, api, targetModel) {\n        rect = normalizeRect(rect);\n        return function (e, localCursorPoint, transform) {\n            return rect.contain(localCursorPoint[0], localCursorPoint[1])\n                && !cursorHelper.onIrrelevantElement(e, api, targetModel);\n        };\n    };\n\n    // Consider width/height is negative.\n    function normalizeRect(rect) {\n        return BoundingRect.create(rect);\n    }\n\n    module.exports = helper;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/brushHelper.js\n// module id = 1072\n// module chunks = 0 1 2","\n\n    require('../../model/Component').registerSubTypeDefaulter('dataZoom', function () {\n        // Default 'slider' when no type specified.\n        return 'slider';\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/typeDefaulter.js\n// module id = 1073\n// module chunks = 0 1 2","/**\n * @file Data zoom processor\n */\n\n\n    var echarts = require('../../echarts');\n\n    echarts.registerProcessor(function (ecModel, api) {\n\n        ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n            // We calculate window and reset axis here but not in model\n            // init stage and not after action dispatch handler, because\n            // reset should be called after seriesData.restoreData.\n            dataZoomModel.eachTargetAxis(resetSingleAxis);\n\n            // Caution: data zoom filtering is order sensitive when using\n            // percent range and no min/max/scale set on axis.\n            // For example, we have dataZoom definition:\n            // [\n            //      {xAxisIndex: 0, start: 30, end: 70},\n            //      {yAxisIndex: 0, start: 20, end: 80}\n            // ]\n            // In this case, [20, 80] of y-dataZoom should be based on data\n            // that have filtered by x-dataZoom using range of [30, 70],\n            // but should not be based on full raw data. Thus sliding\n            // x-dataZoom will change both ranges of xAxis and yAxis,\n            // while sliding y-dataZoom will only change the range of yAxis.\n            // So we should filter x-axis after reset x-axis immediately,\n            // and then reset y-axis and filter y-axis.\n            dataZoomModel.eachTargetAxis(filterSingleAxis);\n        });\n\n        ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n            // Fullfill all of the range props so that user\n            // is able to get them from chart.getOption().\n            var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n            var percentRange = axisProxy.getDataPercentWindow();\n            var valueRange = axisProxy.getDataValueWindow();\n\n            dataZoomModel.setRawRange({\n                start: percentRange[0],\n                end: percentRange[1],\n                startValue: valueRange[0],\n                endValue: valueRange[1]\n            }, true);\n        });\n    });\n\n    function resetSingleAxis(dimNames, axisIndex, dataZoomModel) {\n        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel);\n    }\n\n    function filterSingleAxis(dimNames, axisIndex, dataZoomModel) {\n        dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel);\n    }\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js\n// module id = 1074\n// module chunks = 0 1 2","/**\n * @file Data zoom action\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var helper = require('./helper');\n    var echarts = require('../../echarts');\n\n\n    echarts.registerAction('dataZoom', function (payload, ecModel) {\n\n        var linkedNodesFinder = helper.createLinkedNodesFinder(\n            zrUtil.bind(ecModel.eachComponent, ecModel, 'dataZoom'),\n            helper.eachAxisDim,\n            function (model, dimNames) {\n                return model.get(dimNames.axisIndex);\n            }\n        );\n\n        var effectedModels = [];\n\n        ecModel.eachComponent(\n            {mainType: 'dataZoom', query: payload},\n            function (model, index) {\n                effectedModels.push.apply(\n                    effectedModels, linkedNodesFinder(model).nodes\n                );\n            }\n        );\n\n        zrUtil.each(effectedModels, function (dataZoomModel, index) {\n            dataZoomModel.setRawRange({\n                start: payload.start,\n                end: payload.end,\n                startValue: payload.startValue,\n                endValue: payload.endValue\n            });\n        });\n\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/dataZoomAction.js\n// module id = 1075\n// module chunks = 0 1 2","/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n\n\n    /**\n     * Caution: If the mechanism should be changed some day, these cases\n     * should be considered:\n     *\n     * (1) In `merge option` mode, if using the same option to call `setOption`\n     * many times, the result should be the same (try our best to ensure that).\n     * (2) In `merge option` mode, if a component has no id/name specified, it\n     * will be merged by index, and the result sequence of the components is\n     * consistent to the original sequence.\n     * (3) `reset` feature (in toolbox). Find detailed info in comments about\n     * `mergeOption` in module:echarts/model/OptionManager.\n     */\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var Model = require('./Model');\n    var each = zrUtil.each;\n    var filter = zrUtil.filter;\n    var map = zrUtil.map;\n    var isArray = zrUtil.isArray;\n    var indexOf = zrUtil.indexOf;\n    var isObject = zrUtil.isObject;\n\n    var ComponentModel = require('./Component');\n\n    var globalDefault = require('./globalDefault');\n\n    var OPTION_INNER_KEY = '\\0_ec_inner';\n\n    /**\n     * @alias module:echarts/model/Global\n     *\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {Object} theme\n     */\n    var GlobalModel = Model.extend({\n\n        constructor: GlobalModel,\n\n        init: function (option, parentModel, theme, optionManager) {\n            theme = theme || {};\n\n            this.option = null; // Mark as not initialized.\n\n            /**\n             * @type {module:echarts/model/Model}\n             * @private\n             */\n            this._theme = new Model(theme);\n\n            /**\n             * @type {module:echarts/model/OptionManager}\n             */\n            this._optionManager = optionManager;\n        },\n\n        setOption: function (option, optionPreprocessorFuncs) {\n            zrUtil.assert(\n                !(OPTION_INNER_KEY in option),\n                'please use chart.getOption()'\n            );\n\n            this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n            this.resetOption(null);\n        },\n\n        /**\n         * @param {string} type null/undefined: reset all.\n         *                      'recreate': force recreate all.\n         *                      'timeline': only reset timeline option\n         *                      'media': only reset media query option\n         * @return {boolean} Whether option changed.\n         */\n        resetOption: function (type) {\n            var optionChanged = false;\n            var optionManager = this._optionManager;\n\n            if (!type || type === 'recreate') {\n                var baseOption = optionManager.mountOption(type === 'recreate');\n\n                if (!this.option || type === 'recreate') {\n                    initBase.call(this, baseOption);\n                }\n                else {\n                    this.restoreData();\n                    this.mergeOption(baseOption);\n                }\n                optionChanged = true;\n            }\n\n            if (type === 'timeline' || type === 'media') {\n                this.restoreData();\n            }\n\n            if (!type || type === 'recreate' || type === 'timeline') {\n                var timelineOption = optionManager.getTimelineOption(this);\n                timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n            }\n\n            if (!type || type === 'recreate' || type === 'media') {\n                var mediaOptions = optionManager.getMediaOption(this, this._api);\n                if (mediaOptions.length) {\n                    each(mediaOptions, function (mediaOption) {\n                        this.mergeOption(mediaOption, optionChanged = true);\n                    }, this);\n                }\n            }\n\n            return optionChanged;\n        },\n\n        /**\n         * @protected\n         */\n        mergeOption: function (newOption) {\n            var option = this.option;\n            var componentsMap = this._componentsMap;\n            var newCptTypes = [];\n\n            //  component model  merge\n            each(newOption, function (componentOption, mainType) {\n                if (componentOption == null) {\n                    return;\n                }\n\n                if (!ComponentModel.hasClass(mainType)) {\n                    option[mainType] = option[mainType] == null\n                        ? zrUtil.clone(componentOption)\n                        : zrUtil.merge(option[mainType], componentOption, true);\n                }\n                else {\n                    newCptTypes.push(mainType);\n                }\n            });\n\n            // FIXME OPTION \n            ComponentModel.topologicalTravel(\n                newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this\n            );\n\n            this._seriesIndices = this._seriesIndices || [];\n\n            function visitComponent(mainType, dependencies) {\n                var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n\n                var mapResult = modelUtil.mappingToExists(\n                    componentsMap.get(mainType), newCptOptionList\n                );\n\n                modelUtil.makeIdAndName(mapResult);\n\n                // Set mainType and complete subType.\n                each(mapResult, function (item, index) {\n                    var opt = item.option;\n                    if (isObject(opt)) {\n                        item.keyInfo.mainType = mainType;\n                        item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n                    }\n                });\n\n                var dependentModels = getComponentsByTypes(\n                    componentsMap, dependencies\n                );\n\n                option[mainType] = [];\n                componentsMap.set(mainType, []);\n\n                each(mapResult, function (resultItem, index) {\n                    var componentModel = resultItem.exist;\n                    var newCptOption = resultItem.option;\n\n                    zrUtil.assert(\n                        isObject(newCptOption) || componentModel,\n                        'Empty component definition'\n                    );\n\n                    // Consider where is no new option and should be merged using {},\n                    // see removeEdgeAndAdd in topologicalTravel and\n                    // ComponentModel.getAllClassMainTypes.\n                    if (!newCptOption) {\n                        componentModel.mergeOption({}, this);\n                        componentModel.optionUpdated({}, false);\n                    }\n                    else {\n                        var ComponentModelClass = ComponentModel.getClass(\n                            mainType, resultItem.keyInfo.subType, true\n                        );\n\n                        if (componentModel && componentModel instanceof ComponentModelClass) {\n                            componentModel.name = resultItem.keyInfo.name;\n                            componentModel.mergeOption(newCptOption, this);\n                            componentModel.optionUpdated(newCptOption, false);\n                        }\n                        else {\n                            // PENDING Global as parent ?\n                            var extraOpt = zrUtil.extend(\n                                {\n                                    dependentModels: dependentModels,\n                                    componentIndex: index\n                                },\n                                resultItem.keyInfo\n                            );\n                            componentModel = new ComponentModelClass(\n                                newCptOption, this, this, extraOpt\n                            );\n                            zrUtil.extend(componentModel, extraOpt);\n                            componentModel.init(newCptOption, this, this, extraOpt);\n                            // Call optionUpdated after init.\n                            // newCptOption has been used as componentModel.option\n                            // and may be merged with theme and default, so pass null\n                            // to avoid confusion.\n                            componentModel.optionUpdated(null, true);\n                        }\n                    }\n\n                    componentsMap.get(mainType)[index] = componentModel;\n                    option[mainType][index] = componentModel.option;\n                }, this);\n\n                // Backup series for filtering.\n                if (mainType === 'series') {\n                    this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n                }\n            }\n        },\n\n        /**\n         * Get option for output (cloned option and inner info removed)\n         * @public\n         * @return {Object}\n         */\n        getOption: function () {\n            var option = zrUtil.clone(this.option);\n\n            each(option, function (opts, mainType) {\n                if (ComponentModel.hasClass(mainType)) {\n                    var opts = modelUtil.normalizeToArray(opts);\n                    for (var i = opts.length - 1; i >= 0; i--) {\n                        // Remove options with inner id.\n                        if (modelUtil.isIdInner(opts[i])) {\n                            opts.splice(i, 1);\n                        }\n                    }\n                    option[mainType] = opts;\n                }\n            });\n\n            delete option[OPTION_INNER_KEY];\n\n            return option;\n        },\n\n        /**\n         * @return {module:echarts/model/Model}\n         */\n        getTheme: function () {\n            return this._theme;\n        },\n\n        /**\n         * @param {string} mainType\n         * @param {number} [idx=0]\n         * @return {module:echarts/model/Component}\n         */\n        getComponent: function (mainType, idx) {\n            var list = this._componentsMap.get(mainType);\n            if (list) {\n                return list[idx || 0];\n            }\n        },\n\n        /**\n         * If none of index and id and name used, return all components with mainType.\n         * @param {Object} condition\n         * @param {string} condition.mainType\n         * @param {string} [condition.subType] If ignore, only query by mainType\n         * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n         * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        queryComponents: function (condition) {\n            var mainType = condition.mainType;\n            if (!mainType) {\n                return [];\n            }\n\n            var index = condition.index;\n            var id = condition.id;\n            var name = condition.name;\n\n            var cpts = this._componentsMap.get(mainType);\n\n            if (!cpts || !cpts.length) {\n                return [];\n            }\n\n            var result;\n\n            if (index != null) {\n                if (!isArray(index)) {\n                    index = [index];\n                }\n                result = filter(map(index, function (idx) {\n                    return cpts[idx];\n                }), function (val) {\n                    return !!val;\n                });\n            }\n            else if (id != null) {\n                var isIdArray = isArray(id);\n                result = filter(cpts, function (cpt) {\n                    return (isIdArray && indexOf(id, cpt.id) >= 0)\n                        || (!isIdArray && cpt.id === id);\n                });\n            }\n            else if (name != null) {\n                var isNameArray = isArray(name);\n                result = filter(cpts, function (cpt) {\n                    return (isNameArray && indexOf(name, cpt.name) >= 0)\n                        || (!isNameArray && cpt.name === name);\n                });\n            }\n            else {\n                // Return all components with mainType\n                result = cpts.slice();\n            }\n\n            return filterBySubType(result, condition);\n        },\n\n        /**\n         * The interface is different from queryComponents,\n         * which is convenient for inner usage.\n         *\n         * @usage\n         * var result = findComponents(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n         * );\n         * var result = findComponents(\n         *     {mainType: 'series'},\n         *     function (model, index) {...}\n         * );\n         * // result like [component0, componnet1, ...]\n         *\n         * @param {Object} condition\n         * @param {string} condition.mainType Mandatory.\n         * @param {string} [condition.subType] Optional.\n         * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n         *        where xxx is mainType.\n         *        If query attribute is null/undefined or has no index/id/name,\n         *        do not filtering by query conditions, which is convenient for\n         *        no-payload situations or when target of action is global.\n         * @param {Function} [condition.filter] parameter: component, return boolean.\n         * @return {Array.<module:echarts/model/Component>}\n         */\n        findComponents: function (condition) {\n            var query = condition.query;\n            var mainType = condition.mainType;\n\n            var queryCond = getQueryCond(query);\n            var result = queryCond\n                ? this.queryComponents(queryCond)\n                : this._componentsMap.get(mainType);\n\n            return doFilter(filterBySubType(result, condition));\n\n            function getQueryCond(q) {\n                var indexAttr = mainType + 'Index';\n                var idAttr = mainType + 'Id';\n                var nameAttr = mainType + 'Name';\n                return q && (\n                        q[indexAttr] != null\n                        || q[idAttr] != null\n                        || q[nameAttr] != null\n                    )\n                    ? {\n                        mainType: mainType,\n                        // subType will be filtered finally.\n                        index: q[indexAttr],\n                        id: q[idAttr],\n                        name: q[nameAttr]\n                    }\n                    : null;\n            }\n\n            function doFilter(res) {\n                return condition.filter\n                     ? filter(res, condition.filter)\n                     : res;\n            }\n        },\n\n        /**\n         * @usage\n         * eachComponent('legend', function (legendModel, index) {\n         *     ...\n         * });\n         * eachComponent(function (componentType, model, index) {\n         *     // componentType does not include subType\n         *     // (componentType is 'xxx' but not 'xxx.aa')\n         * });\n         * eachComponent(\n         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n         *     function (model, index) {...}\n         * );\n         * eachComponent(\n         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n         *     function (model, index) {...}\n         * );\n         *\n         * @param {string|Object=} mainType When mainType is object, the definition\n         *                                  is the same as the method 'findComponents'.\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachComponent: function (mainType, cb, context) {\n            var componentsMap = this._componentsMap;\n\n            if (typeof mainType === 'function') {\n                context = cb;\n                cb = mainType;\n                componentsMap.each(function (components, componentType) {\n                    each(components, function (component, index) {\n                        cb.call(context, componentType, component, index);\n                    });\n                });\n            }\n            else if (zrUtil.isString(mainType)) {\n                each(componentsMap.get(mainType), cb, context);\n            }\n            else if (isObject(mainType)) {\n                var queryResult = this.findComponents(mainType);\n                each(queryResult, cb, context);\n            }\n        },\n\n        /**\n         * @param {string} name\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByName: function (name) {\n            var series = this._componentsMap.get('series');\n            return filter(series, function (oneSeries) {\n                return oneSeries.name === name;\n            });\n        },\n\n        /**\n         * @param {number} seriesIndex\n         * @return {module:echarts/model/Series}\n         */\n        getSeriesByIndex: function (seriesIndex) {\n            return this._componentsMap.get('series')[seriesIndex];\n        },\n\n        /**\n         * @param {string} subType\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeriesByType: function (subType) {\n            var series = this._componentsMap.get('series');\n            return filter(series, function (oneSeries) {\n                return oneSeries.subType === subType;\n            });\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Series>}\n         */\n        getSeries: function () {\n            return this._componentsMap.get('series').slice();\n        },\n\n        /**\n         * After filtering, series may be different\n         * frome raw series.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.get('series')[rawSeriesIndex];\n                cb.call(context, series, rawSeriesIndex);\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered.\n         *\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeries: function (cb, context) {\n            each(this._componentsMap.get('series'), cb, context);\n        },\n\n        /**\n         * After filtering, series may be different.\n         * frome raw series.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachSeriesByType: function (subType, cb, context) {\n            assertSeriesInitialized(this);\n            each(this._seriesIndices, function (rawSeriesIndex) {\n                var series = this._componentsMap.get('series')[rawSeriesIndex];\n                if (series.subType === subType) {\n                    cb.call(context, series, rawSeriesIndex);\n                }\n            }, this);\n        },\n\n        /**\n         * Iterate raw series before filtered of given type.\n         *\n         * @parma {string} subType\n         * @param {Function} cb\n         * @param {*} context\n         */\n        eachRawSeriesByType: function (subType, cb, context) {\n            return each(this.getSeriesByType(subType), cb, context);\n        },\n\n        /**\n         * @param {module:echarts/model/Series} seriesModel\n         */\n        isSeriesFiltered: function (seriesModel) {\n            assertSeriesInitialized(this);\n            return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getCurrentSeriesIndices: function () {\n            return (this._seriesIndices || []).slice();\n        },\n\n        /**\n         * @param {Function} cb\n         * @param {*} context\n         */\n        filterSeries: function (cb, context) {\n            assertSeriesInitialized(this);\n            var filteredSeries = filter(\n                this._componentsMap.get('series'), cb, context\n            );\n            this._seriesIndices = createSeriesIndices(filteredSeries);\n        },\n\n        restoreData: function () {\n            var componentsMap = this._componentsMap;\n\n            this._seriesIndices = createSeriesIndices(componentsMap.get('series'));\n\n            var componentTypes = [];\n            componentsMap.each(function (components, componentType) {\n                componentTypes.push(componentType);\n            });\n\n            ComponentModel.topologicalTravel(\n                componentTypes,\n                ComponentModel.getAllClassMainTypes(),\n                function (componentType, dependencies) {\n                    each(componentsMap.get(componentType), function (component) {\n                        component.restoreData();\n                    });\n                }\n            );\n        }\n\n    });\n\n    /**\n     * @inner\n     */\n    function mergeTheme(option, theme) {\n        zrUtil.each(theme, function (themeItem, name) {\n            //  component model  merge  model \n            if (!ComponentModel.hasClass(name)) {\n                if (typeof themeItem === 'object') {\n                    option[name] = !option[name]\n                        ? zrUtil.clone(themeItem)\n                        : zrUtil.merge(option[name], themeItem, false);\n                }\n                else {\n                    if (option[name] == null) {\n                        option[name] = themeItem;\n                    }\n                }\n            }\n        });\n    }\n\n    function initBase(baseOption) {\n        baseOption = baseOption;\n\n        // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n        this.option = {};\n        this.option[OPTION_INNER_KEY] = 1;\n\n        /**\n         * Init with series: [], in case of calling findSeries method\n         * before series initialized.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @private\n         */\n        this._componentsMap = zrUtil.createHashMap({series: []});\n\n        /**\n         * Mapping between filtered series list and raw series list.\n         * key: filtered series indices, value: raw series indices.\n         * @type {Array.<nubmer>}\n         * @private\n         */\n        this._seriesIndices = null;\n\n        mergeTheme(baseOption, this._theme.option);\n\n        // TODO Needs clone when merging to the unexisted property\n        zrUtil.merge(baseOption, globalDefault, false);\n\n        this.mergeOption(baseOption);\n    }\n\n    /**\n     * @inner\n     * @param {Array.<string>|string} types model types\n     * @return {Object} key: {string} type, value: {Array.<Object>} models\n     */\n    function getComponentsByTypes(componentsMap, types) {\n        if (!zrUtil.isArray(types)) {\n            types = types ? [types] : [];\n        }\n\n        var ret = {};\n        each(types, function (type) {\n            ret[type] = (componentsMap.get(type) || []).slice();\n        });\n\n        return ret;\n    }\n\n    /**\n     * @inner\n     */\n    function determineSubType(mainType, newCptOption, existComponent) {\n        var subType = newCptOption.type\n            ? newCptOption.type\n            : existComponent\n            ? existComponent.subType\n            // Use determineSubType only when there is no existComponent.\n            : ComponentModel.determineSubType(mainType, newCptOption);\n\n        // tooltip, markline, markpoint may always has no subType\n        return subType;\n    }\n\n    /**\n     * @inner\n     */\n    function createSeriesIndices(seriesModels) {\n        return map(seriesModels, function (series) {\n            return series.componentIndex;\n        }) || [];\n    }\n\n    /**\n     * @inner\n     */\n    function filterBySubType(components, condition) {\n        // Using hasOwnProperty for restrict. Consider\n        // subType is undefined in user payload.\n        return condition.hasOwnProperty('subType')\n            ? filter(components, function (cpt) {\n                return cpt.subType === condition.subType;\n            })\n            : components;\n    }\n\n    /**\n     * @inner\n     */\n    function assertSeriesInitialized(ecModel) {\n        // Components that use _seriesIndices should depends on series component,\n        // which make sure that their initialization is after series.\n        if (__DEV__) {\n            if (!ecModel._seriesIndices) {\n                throw new Error('Option should contains series.');\n            }\n        }\n    }\n\n    zrUtil.mixin(GlobalModel, require('./mixin/colorPalette'));\n\n    module.exports = GlobalModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/model/Global.js\n// module id = 1079\n// module chunks = 0 1 2","\n    var getLineStyle = require('./makeStyleMapper')(\n        [\n            ['lineWidth', 'width'],\n            ['stroke', 'color'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor']\n        ]\n    );\n    module.exports = {\n        getLineStyle: function (excludes) {\n            var style = getLineStyle.call(this, excludes);\n            var lineDash = this.getLineDash(style.lineWidth);\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getLineDash: function (lineWidth) {\n            if (lineWidth == null) {\n                lineWidth = 1;\n            }\n            var lineType = this.get('type');\n            var dotSize = Math.max(lineWidth, 2);\n            var dashSize = lineWidth * 4;\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize]);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/model/mixin/lineStyle.js\n// module id = 1080\n// module chunks = 0 1 2","\n    module.exports = {\n        getAreaStyle: require('./makeStyleMapper')(\n            [\n                ['fill', 'color'],\n                ['shadowBlur'],\n                ['shadowOffsetX'],\n                ['shadowOffsetY'],\n                ['opacity'],\n                ['shadowColor']\n            ]\n        )\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/model/mixin/areaStyle.js\n// module id = 1081\n// module chunks = 0 1 2","\n\n    var textContain = require('zrender/lib/contain/text');\n    var graphicUtil = require('../../util/graphic');\n\n    var PATH_COLOR = ['textStyle', 'color'];\n\n    module.exports = {\n        /**\n         * Get color property or get color from option.textStyle.color\n         * @param {boolean} [isEmphasis]\n         * @return {string}\n         */\n        getTextColor: function (isEmphasis) {\n            var ecModel = this.ecModel;\n            return this.getShallow('color')\n                || (\n                    (!isEmphasis && ecModel) ? ecModel.get(PATH_COLOR) : null\n                );\n        },\n\n        /**\n         * Create font string from fontStyle, fontWeight, fontSize, fontFamily\n         * @return {string}\n         */\n        getFont: function () {\n            return graphicUtil.getFont({\n                fontStyle: this.getShallow('fontStyle'),\n                fontWeight: this.getShallow('fontWeight'),\n                fontSize: this.getShallow('fontSize'),\n                fontFamily: this.getShallow('fontFamily')\n            }, this.ecModel);\n        },\n\n        getTextRect: function (text) {\n            return textContain.getBoundingRect(\n                text,\n                this.getFont(),\n                this.getShallow('align'),\n                this.getShallow('verticalAlign') || this.getShallow('baseline'),\n                this.getShallow('padding'),\n                this.getShallow('rich'),\n                this.getShallow('truncateText')\n            );\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/model/mixin/textStyle.js\n// module id = 1082\n// module chunks = 0 1 2","\n\n    var Path = require('../graphic/Path');\n    var PathProxy = require('../core/PathProxy');\n    var transformPath = require('./transformPath');\n\n    // command chars\n    var cc = [\n        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n    ];\n\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n\n    var vMag = function(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function(u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n                * Math.acos(vRatio(u, v));\n    };\n\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180.0);\n        var xp = mathCos(psi) * (x1 - x2) / 2.0\n                 + mathSin(psi) * (y1 - y2) / 2.0;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n                 + mathCos(psi) * (y1 - y2) / 2.0;\n\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n\n        var f = (fa === fs ? -1 : 1)\n            * mathSqrt((((rx * rx) * (ry * ry))\n                    - ((rx * rx) * (yp * yp))\n                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                    + (ry * ry) * (xp * xp))\n                ) || 0;\n\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n\n        var cx = (x1 + x2) / 2.0\n                 + mathCos(psi) * cxp\n                 - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2.0\n                + mathSin(psi) * cxp\n                + mathCos(psi) * cyp;\n\n        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n        var dTheta = vAngle(u, v);\n\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n\n        // command string\n        var cs = data.replace(/-/g, ' -')\n            .replace(/  /g, ' ')\n            .replace(/ /g, ',')\n            .replace(/,,/g, ',');\n\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n\n                var x1 = cpx;\n                var y1 = cpy;\n\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                    case 'l':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'm':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'l';\n                        break;\n                    case 'M':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'L';\n                        break;\n                    case 'h':\n                        cpx += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'C':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n                        );\n                        cpx = p[off - 2];\n                        cpy = p[off - 1];\n                        break;\n                    case 'c':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy\n                        );\n                        cpx += p[off - 2];\n                        cpy += p[off - 1];\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = cpx + p[off++];\n                        y1 = cpy + p[off++];\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 'Q':\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'q':\n                        x1 = p[off++] + cpx;\n                        y1 = p[off++] + cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                    case 'a':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                }\n            }\n\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n\n            prevCmd = cmd;\n        }\n\n        path.toStatic();\n\n        return path;\n    }\n\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            if (path.setData) {\n                path.setData(pathProxy.data);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            }\n            else {\n                var ctx = path;\n                pathProxy.rebuildPath(ctx);\n            }\n        };\n\n        opts.applyTransform = function (m) {\n            transformPath(pathProxy, m);\n\n            this.dirty(true);\n        };\n\n        return opts;\n    }\n\n    module.exports = {\n        /**\n         * Create a Path object from path string data\n         * http://www.w3.org/TR/SVG/paths.html#PathData\n         * @param  {Object} opts Other options\n         */\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n\n        /**\n         * Create a Path class from path string data\n         * @param  {string} str\n         * @param  {Object} opts Other options\n         */\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n\n        /**\n         * Merge multiple paths\n         */\n        // TODO Apply transform\n        // TODO stroke dash\n        // TODO Optimize double memory cost problem\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (!pathEl.path) {\n                    pathEl.createPathProxy();\n                }\n                if (pathEl.__dirtyPath) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n\n            var pathBundle = new Path(opts);\n            // Need path proxy.\n            pathBundle.createPathProxy();\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n\n            return pathBundle;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/tool/path.js\n// module id = 1083\n// module chunks = 0 1 2","'use strict';\n/**\n * @module zrender/mixin/Animatable\n */\n\n\n    var Animator = require('../animation/Animator');\n    var util = require('../core/util');\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = require('../core/log');\n\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n\n    Animatable.prototype = {\n\n        constructor: Animatable,\n\n        /**\n         * \n         *\n         * @param {string} path The path to fetch value from object, like 'a.b.c'.\n         * @param {boolean} [loop] Whether to loop animation.\n         * @return {module:zrender/animation/Animator}\n         * @example:\n         *     el.animate('style', false)\n         *         .when(1000, {x: 10} )\n         *         .done(function(){ // Animation done })\n         *         .start()\n         */\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            }\n            else {\n                target = el;\n            }\n\n            if (!target) {\n                log(\n                    'Property \"'\n                    + path\n                    + '\" is not existed in element '\n                    + el.id\n                );\n                return;\n            }\n\n            var animators = el.animators;\n\n            var animator = new Animator(target, loop);\n\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            })\n            .done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n\n            animators.push(animator);\n\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n\n            return animator;\n        },\n\n        /**\n         * \n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n\n            return this;\n        },\n\n        /**\n         * Caution: this method will stop previous animation.\n         * So do not use this method to one element twice before\n         * animation starts, unless you know what you are doing.\n         * @param {Object} target\n         * @param {number} [time=500] Time in ms\n         * @param {string} [easing='linear']\n         * @param {number} [delay=0]\n         * @param {Function} [callback]\n         * @param {Function} [forceAnimate] Prevent stop animation and callback\n         *        immediently when target values are the same as current values.\n         *\n         * @example\n         *  // Animate position\n         *  el.animateTo({\n         *      position: [10, 10]\n         *  }, function () { // done })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n         *  el.animateTo({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100, 'cubicOut', function () { // done })\n         */\n         // TODO Return animation key\n        animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }\n            // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }\n            // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }\n            // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }\n            // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i]\n                    .done(done)\n                    .start(easing, forceAnimate);\n            }\n        },\n\n        /**\n         * @private\n         * @param {string} path=''\n         * @param {Object} source=this\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         *\n         * @example\n         *  // Animate position\n         *  el._animateToShallow({\n         *      position: [10, 10]\n         *  })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms\n         *  el._animateToShallow({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100)\n         */\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (!target.hasOwnProperty(name)) {\n                    continue;\n                }\n\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(\n                            path ? path + '.' + name : name,\n                            source[name],\n                            target[name],\n                            time,\n                            delay\n                        );\n                    }\n                    else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                }\n                else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    }\n                    else {  // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n\n            if (propertyCount > 0) {\n                this.animate(path, false)\n                    .when(time == null ? 500 : time, objShallow)\n                    .delay(delay || 0);\n            }\n\n            return this;\n        }\n    };\n\n    module.exports = Animatable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/mixin/Animatable.js\n// module id = 1084\n// module chunks = 0 1 2","/**\n * \n * @config target onframe\n * @config life(1000) \n * @config delay(0) \n * @config loop(true)\n * @config gap(0) \n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\n\n    var easingFuncs = require('./easing');\n\n    function Clip(options) {\n\n        this._target = options.target;\n\n        // \n        this._life = options.life || 1000;\n        // \n        this._delay = options.delay || 0;\n        // \n        // this._startTime = new Date().getTime() + this._delay;// \n        this._initialized = false;\n\n        // \n        this.loop = options.loop == null ? false : options.loop;\n\n        this.gap = options.gap || 0;\n\n        this.easing = options.easing || 'Linear';\n\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n\n        this._pausedTime = 0;\n        this._paused = false;\n    }\n\n    Clip.prototype = {\n\n        constructor: Clip,\n\n        step: function (globalTime, deltaTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n\n            if (this._paused) {\n                this._pausedTime += deltaTime;\n                return;\n            }\n\n            var percent = (globalTime - this._startTime - this._pausedTime) / this._life;\n\n            // \n            if (percent < 0) {\n                return;\n            }\n\n            percent = Math.min(percent, 1);\n\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n\n            this.fire('frame', schedule);\n\n            // \n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart (globalTime);\n                    // \n                    //  stage.update \n                    return 'restart';\n                }\n\n                // \n                // Animation.update\n                this._needsRemove = true;\n                return 'destroy';\n            }\n\n            return null;\n        },\n\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n            this._pausedTime = 0;\n\n            this._needsRemove = false;\n        },\n\n        fire: function (eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        },\n\n        pause: function () {\n            this._paused = true;\n        },\n\n        resume: function () {\n            this._paused = false;\n        }\n    };\n\n    module.exports = Clip;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/animation/Clip.js\n// module id = 1085\n// module chunks = 0 1 2","/**\n *  https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\n\n    var easing = {\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        linear: function (k) {\n            return k;\n        },\n\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n\n        // t^3\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n\n        // t^4\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n\n        // t^5\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n\n        // sin(t)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n\n        // 2^t\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n\n        // sqrt(1-t^2)\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1)) *\n                        Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k) *\n                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n\n        // \n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    module.exports = easing;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/animation/easing.js\n// module id = 1086\n// module chunks = 0 1 2","'use strict';\n\n\n    var CMD = require('../core/PathProxy').CMD;\n    var line = require('./line');\n    var cubic = require('./cubic');\n    var quadratic = require('./quadratic');\n    var arc = require('./arc');\n    var normalizeRadian = require('./util').normalizeRadian;\n    var curve = require('../core/curve');\n\n    var windingLine = require('./windingLine');\n\n    var containStroke = line.containStroke;\n\n    var PI2 = Math.PI * 2;\n\n    var EPSILON = 1e-4;\n\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    // \n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) { // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                }\n                else {\n                    // \n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {   // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            }\n            else {\n                // Remove one endpoint.\n                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {   // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n\n    // TODO\n    // Arc \n    function windingArc(\n        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n    ) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 1e-4) {\n            return 0;\n        }\n        if (diff % PI2 < 1e-4) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (\n                    (angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n                ) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n                //  subpath \n                // if (w !== 0) {\n                //     return true;\n                // }\n            }\n\n            if (i == 1) {\n                //  L, C, Q\n                //  previous point  point\n                //\n                //  Arc \n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo  subpath, \n                    //  closePath \n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // NOTE  L, C, Q  NaN\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    if (isStroke) {\n                        if (cubic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(\n                            xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    if (isStroke) {\n                        if (quadratic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(\n                            xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc \n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    // TODO Arc \n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    var x1 = Math.cos(theta) * rx + cx;\n                    var y1 = Math.sin(theta) * ry + cy;\n                    //  arc \n                    if (i > 1) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        // \n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    // zr scale, x\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (arc.containStroke(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            lineWidth, _x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            _x, y\n                        );\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    var x1 = x0 + width;\n                    var y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n                        ) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // FIXME Clockwise ?\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD.Z:\n                    if (isStroke) {\n                        if (containStroke(\n                            xi, yi, x0, y0, lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // Close a subpath\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                        //  subpath \n                        // FIXME subpaths may overlap\n                        // if (w !== 0) {\n                        //     return true;\n                        // }\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n\n    module.exports = {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/contain/path.js\n// module id = 1087\n// module chunks = 0 1 2","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  x3\n         * @param  {number}  y3\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(\n                x0, y0, x1, y1, x2, y2, x3, y3,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/contain/cubic.js\n// module id = 1088\n// module chunks = 0 1 2","\n\n    var normalizeRadian = require('./util').normalizeRadian;\n    var PI2 = Math.PI * 2;\n\n    module.exports = {\n        /**\n         * \n         * @param  {number}  cx\n         * @param  {number}  cy\n         * @param  {number}  r\n         * @param  {number}  startAngle\n         * @param  {number}  endAngle\n         * @param  {boolean}  anticlockwise\n         * @param  {number} lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {Boolean}\n         */\n        containStroke: function (\n            cx, cy, r, startAngle, endAngle, anticlockwise,\n            lineWidth, x, y\n        ) {\n\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n\n            if ((d - _l > r) || (d + _l < r)) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/contain/arc.js\n// module id = 1089\n// module chunks = 0 1 2","\n\n    var CMD = require('../core/PathProxy').CMD;\n    var vec2 = require('../core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n\n    var points = [[], [], []];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n\n            switch (cmd) {\n                case M:\n                    nPoint = 1;\n                    break;\n                case L:\n                    nPoint = 1;\n                    break;\n                case C:\n                    nPoint = 3;\n                    break;\n                case Q:\n                    nPoint = 2;\n                    break;\n                case A:\n                    var x = m[4];\n                    var y = m[5];\n                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                    // cx\n                    data[i] *= sx;\n                    data[i++] += x;\n                    // cy\n                    data[i] *= sy;\n                    data[i++] += y;\n                    // Scale rx and ry\n                    // FIXME Assume psi is 0 here\n                    data[i++] *= sx;\n                    data[i++] *= sy;\n\n                    // Start angle\n                    data[i++] += angle;\n                    // end angle\n                    data[i++] += angle;\n                    // FIXME psi\n                    i += 2;\n                    j = i;\n                    break;\n                case R:\n                    // x0, y0\n                    p[0] = data[i++];\n                    p[1] = data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n                    // x1, y1\n                    p[0] += data[i++];\n                    p[1] += data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n            }\n\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n\n    module.exports = transformPath;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/tool/transformPath.js\n// module id = 1090\n// module chunks = 0 1 2","'use strict';\n/**\n * \n * @module zrender/shape/Circle\n */\n\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'circle',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n\n\n        buildPath : function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // else {\n            //     if (ctx.allocate && !ctx.data.length) {\n            //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n            //     }\n            // }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/shape/Circle.js\n// module id = 1091\n// module chunks = 0 1 2","/**\n * \n * @module zrender/graphic/shape/Sector\n */\n\n\n\n    var Path = require('../Path');\n    var fixClipWithShadow = require('../helper/fixClipWithShadow');\n\n    module.exports = Path.extend({\n\n        type: 'sector',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r0: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        brush: fixClipWithShadow(Path.prototype.brush),\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n            ctx.lineTo(\n                Math.cos(endAngle) * r0 + x,\n                Math.sin(endAngle) * r0 + y\n            );\n\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n\n            ctx.closePath();\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/shape/Sector.js\n// module id = 1092\n// module chunks = 0 1 2","/**\n * \n * @module zrender/graphic/shape/Ring\n */\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'ring',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/shape/Ring.js\n// module id = 1093\n// module chunks = 0 1 2","/**\n * \n * @module zrender/shape/Polygon\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polygon',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/shape/Polygon.js\n// module id = 1094\n// module chunks = 0 1 2","/**\n * Catmull-Rom spline \n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n    var vec2 = require('../../core/vector');\n\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points \n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    module.exports = function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n\n            var w = pos - idx;\n\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n\n            var w2 = w * w;\n            var w3 = w * w2;\n\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/helper/smoothSpline.js\n// module id = 1095\n// module chunks = 0 1 2","/**\n * \n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n\n    var vec2 = require('../../core/vector');\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n\n    /**\n     * \n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points \n     * @param {number} smooth , 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint \n     *                            [[0, 0], [100, 100]], \n     *                           \n     * @param {Array} \n     */\n    module.exports = function (points, smooth, isLoop, constraint) {\n        var cps = [];\n\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n\n        var min, max;\n        if (constraint) {\n            min = [Infinity, Infinity];\n            max = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // \n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n\n            vec2.sub(v, nextPoint, prevPoint);\n\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n\n        return cps;\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/helper/smoothBezier.js\n// module id = 1096\n// module chunks = 0 1 2","/**\n * @module zrender/graphic/shape/Polyline\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polyline',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        style: {\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/shape/Polyline.js\n// module id = 1097\n// module chunks = 0 1 2","/**\n * \n * @module zrender/graphic/shape/Rect\n */\n\n\n    var roundRectHelper = require('../helper/roundRect');\n\n    module.exports = require('../Path').extend({\n\n        type: 'rect',\n\n        shape: {\n            // r1r2r3r4\n            // r1          [1, 1, 1, 1]\n            // r[1]        [1, 1, 1, 1]\n            // r[1, 2]     [1, 2, 1, 2]\n            // r[1, 2, 3]  [1, 2, 3, 2]\n            r: 0,\n\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/shape/Rect.js\n// module id = 1098\n// module chunks = 0 1 2","/**\n * \n * @module zrender/graphic/shape/Line\n */\n\n    module.exports = require('../Path').extend({\n\n        type: 'line',\n\n        shape: {\n            // Start point\n            x1: 0,\n            y1: 0,\n            // End point\n            x2: 0,\n            y2: 0,\n\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} percent\n         * @return {Array.<number>}\n         */\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/shape/Line.js\n// module id = 1099\n// module chunks = 0 1 2","'use strict';\n/**\n * \n * @module zrender/shape/BezierCurve\n */\n\n\n    var curveTool = require('../../core/curve');\n    var vec2 = require('../../core/vector');\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\n    var out = [];\n\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        }\n        else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    module.exports = require('../Path').extend({\n\n        type: 'bezier-curve',\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            // cpx2: 0,\n            // cpy2: 0\n\n            // Curve show percent, for animating\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(\n                        x1, cpx1, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(\n                        y1, cpy1, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n\n                ctx.quadraticCurveTo(\n                    cpx1, cpy1,\n                    x2, y2\n                );\n            }\n            else {\n                if (percent < 1) {\n                    cubicSubdivide(\n                        x1, cpx1, cpx2, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(\n                        y1, cpy1, cpy2, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(\n                    cpx1, cpy1,\n                    cpx2, cpy2,\n                    x2, y2\n                );\n            }\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n\n        /**\n         * Get tangent at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/shape/BezierCurve.js\n// module id = 1100\n// module chunks = 0 1 2","/**\n * \n * @module zrender/graphic/shape/Arc\n */\n \n\n    module.exports = require('../Path').extend({\n\n        type: 'arc',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        style: {\n\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/shape/Arc.js\n// module id = 1101\n// module chunks = 0 1 2","// CompoundPath to improve performance\n\n\n    var Path = require('./Path');\n\n    module.exports = Path.extend({\n\n        type: 'compound',\n\n        shape: {\n\n            paths: null\n        },\n\n        _updatePathDirty: function () {\n            var dirtyPath = this.__dirtyPath;\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                // Mark as dirty if any subpath is dirty\n                dirtyPath = dirtyPath || paths[i].__dirtyPath;\n            }\n            this.__dirtyPath = dirtyPath;\n            this.__dirty = this.__dirty || dirtyPath;\n        },\n\n        beforeBrush: function () {\n            this._updatePathDirty();\n            var paths = this.shape.paths || [];\n            var scale = this.getGlobalScale();\n            // Update path scale\n            for (var i = 0; i < paths.length; i++) {\n                if (!paths[i].path) {\n                    paths[i].createPathProxy();\n                }\n                paths[i].path.setScale(scale[0], scale[1]);\n            }\n        },\n\n        buildPath: function (ctx, shape) {\n            var paths = shape.paths || [];\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].buildPath(ctx, paths[i].shape, true);\n            }\n        },\n\n        afterBrush: function () {\n            var paths = this.shape.paths;\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].__dirtyPath = false;\n            }\n        },\n\n        getBoundingRect: function () {\n            this._updatePathDirty();\n            return Path.prototype.getBoundingRect.call(this);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/CompoundPath.js\n// module id = 1102\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        // Should do nothing more in this constructor. Because gradient can be\n        // declard by `color: {type: 'radial', colorStops: ...}`, where\n        // this constructor will not be called.\n\n        this.x = x == null ? 0.5 : x;\n\n        this.y = y == null ? 0.5 : y;\n\n        this.r = r == null ? 0.5 : r;\n\n        // Can be cloned\n        this.type = 'radial';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    RadialGradient.prototype = {\n\n        constructor: RadialGradient\n    };\n\n    zrUtil.inherits(RadialGradient, Gradient);\n\n    module.exports = RadialGradient;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/RadialGradient.js\n// module id = 1103\n// module chunks = 0 1 2","\n    var getItemStyle = require('./makeStyleMapper')(\n        [\n            ['fill', 'color'],\n            ['stroke', 'borderColor'],\n            ['lineWidth', 'borderWidth'],\n            ['opacity'],\n            ['shadowBlur'],\n            ['shadowOffsetX'],\n            ['shadowOffsetY'],\n            ['shadowColor'],\n            ['textPosition'],\n            ['textAlign']\n        ]\n    );\n    module.exports = {\n        getItemStyle: function (excludes, includes) {\n            var style = getItemStyle.call(this, excludes, includes);\n            var lineDash = this.getBorderLineDash();\n            lineDash && (style.lineDash = lineDash);\n            return style;\n        },\n\n        getBorderLineDash: function () {\n            var lineType = this.get('borderType');\n            return (lineType === 'solid' || lineType == null) ? null\n                : (lineType === 'dashed' ? [5, 5] : [1, 1]);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/model/mixin/itemStyle.js\n// module id = 1104\n// module chunks = 0 1 2","\n\n    module.exports = {\n        getBoxLayoutParams: function () {\n            return {\n                left: this.get('left'),\n                top: this.get('top'),\n                right: this.get('right'),\n                bottom: this.get('bottom'),\n                width: this.get('width'),\n                height: this.get('height')\n            };\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/model/mixin/boxLayout.js\n// module id = 1105\n// module chunks = 0 1 2","\n    var platform = '';\n    // Navigator not exists in node\n    if (typeof navigator !== 'undefined') {\n        platform = navigator.platform || '';\n    }\n    module.exports = {\n        // \n        // backgroundColor: 'rgba(0,0,0,0)',\n\n        // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization\n        // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],\n        // \n        // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],\n        // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],\n        // \n        color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],\n\n        //  Grid \n        // grid: {},\n        // \n        textStyle: {\n            // color: '#000',\n            // decoration: 'none',\n            // PENDING\n            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n            // fontFamily: 'Arial, Verdana, sans-serif',\n            fontSize: 12,\n            fontStyle: 'normal',\n            fontWeight: 'normal'\n        },\n\n        // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/\n        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n        // Default is source-over\n        blendMode: null,\n\n        animation: 'auto',\n        animationDuration: 1000,\n        animationDurationUpdate: 300,\n        animationEasing: 'exponentialOut',\n        animationEasingUpdate: 'cubicOut',\n\n        animationThreshold: 2000,\n        // Configuration for progressive/incremental rendering\n        progressiveThreshold: 3000,\n        progressive: 400,\n\n        // Threshold of if use single hover layer to optimize.\n        // It is recommended that `hoverLayerThreshold` is equivalent to or less than\n        // `progressiveThreshold`, otherwise hover will cause restart of progressive,\n        // which is unexpected.\n        // see example <echarts/test/heatmap-large.html>.\n        hoverLayerThreshold: 3000,\n\n        // See: module:echarts/scale/Time\n        useUTC: false\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/model/globalDefault.js\n// module id = 1106\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var echartsAPIList = [\n        'getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isDisposed',\n        'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption',\n        'getViewOfComponentModel', 'getViewOfSeriesModel'\n    ];\n    // And `getCoordinateSystems` and `getComponentByElement` will be injected in echarts.js\n\n    function ExtensionAPI(chartInstance) {\n        zrUtil.each(echartsAPIList, function (name) {\n            this[name] = zrUtil.bind(chartInstance[name], chartInstance);\n        }, this);\n    }\n\n    module.exports = ExtensionAPI;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/ExtensionAPI.js\n// module id = 1107\n// module chunks = 0 1 2","/**\n * ECharts option manager\n *\n * @module {echarts/model/OptionManager}\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var each = zrUtil.each;\n    var clone = zrUtil.clone;\n    var map = zrUtil.map;\n    var merge = zrUtil.merge;\n\n    var QUERY_REG = /^(min|max)?(.+)$/;\n\n    /**\n     * TERM EXPLANATIONS:\n     *\n     * [option]:\n     *\n     *     An object that contains definitions of components. For example:\n     *     var option = {\n     *         title: {...},\n     *         legend: {...},\n     *         visualMap: {...},\n     *         series: [\n     *             {data: [...]},\n     *             {data: [...]},\n     *             ...\n     *         ]\n     *     };\n     *\n     * [rawOption]:\n     *\n     *     An object input to echarts.setOption. 'rawOption' may be an\n     *     'option', or may be an object contains multi-options. For example:\n     *     var option = {\n     *         baseOption: {\n     *             title: {...},\n     *             legend: {...},\n     *             series: [\n     *                 {data: [...]},\n     *                 {data: [...]},\n     *                 ...\n     *             ]\n     *         },\n     *         timeline: {...},\n     *         options: [\n     *             {title: {...}, series: {data: [...]}},\n     *             {title: {...}, series: {data: [...]}},\n     *             ...\n     *         ],\n     *         media: [\n     *             {\n     *                 query: {maxWidth: 320},\n     *                 option: {series: {x: 20}, visualMap: {show: false}}\n     *             },\n     *             {\n     *                 query: {minWidth: 320, maxWidth: 720},\n     *                 option: {series: {x: 500}, visualMap: {show: true}}\n     *             },\n     *             {\n     *                 option: {series: {x: 1200}, visualMap: {show: true}}\n     *             }\n     *         ]\n     *     };\n     *\n     * @alias module:echarts/model/OptionManager\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    function OptionManager(api) {\n\n        /**\n         * @private\n         * @type {module:echarts/ExtensionAPI}\n         */\n        this._api = api;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._timelineOptions = [];\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._mediaList = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._mediaDefault;\n\n        /**\n         * -1, means default.\n         * empty means no media.\n         * @private\n         * @type {Array.<number>}\n         */\n        this._currentMediaIndices = [];\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._optionBackup;\n\n        /**\n         * @private\n         * @type {Object}\n         */\n        this._newBaseOption;\n    }\n\n    // timeline.notMerge is not supported in ec3. Firstly there is rearly\n    // case that notMerge is needed. Secondly supporting 'notMerge' requires\n    // rawOption cloned and backuped when timeline changed, which does no\n    // good to performance. What's more, that both timeline and setOption\n    // method supply 'notMerge' brings complex and some problems.\n    // Consider this case:\n    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\n    OptionManager.prototype = {\n\n        constructor: OptionManager,\n\n        /**\n         * @public\n         * @param {Object} rawOption Raw option.\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Array.<Function>} optionPreprocessorFuncs\n         * @return {Object} Init option\n         */\n        setOption: function (rawOption, optionPreprocessorFuncs) {\n            rawOption = clone(rawOption, true);\n\n            // FIXME\n            //  timeline options  media baseOption\n\n            var oldOptionBackup = this._optionBackup;\n            var newParsedOption = parseRawOption.call(\n                this, rawOption, optionPreprocessorFuncs, !oldOptionBackup\n            );\n            this._newBaseOption = newParsedOption.baseOption;\n\n            // For setOption at second time (using merge mode);\n            if (oldOptionBackup) {\n                // Only baseOption can be merged.\n                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);\n\n                // For simplicity, timeline options and media options do not support merge,\n                // that is, if you `setOption` twice and both has timeline options, the latter\n                // timeline opitons will not be merged to the formers, but just substitude them.\n                if (newParsedOption.timelineOptions.length) {\n                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n                }\n                if (newParsedOption.mediaList.length) {\n                    oldOptionBackup.mediaList = newParsedOption.mediaList;\n                }\n                if (newParsedOption.mediaDefault) {\n                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n                }\n            }\n            else {\n                this._optionBackup = newParsedOption;\n            }\n        },\n\n        /**\n         * @param {boolean} isRecreate\n         * @return {Object}\n         */\n        mountOption: function (isRecreate) {\n            var optionBackup = this._optionBackup;\n\n            // TODO\n            // resetclone\n\n            this._timelineOptions = map(optionBackup.timelineOptions, clone);\n            this._mediaList = map(optionBackup.mediaList, clone);\n            this._mediaDefault = clone(optionBackup.mediaDefault);\n            this._currentMediaIndices = [];\n\n            return clone(isRecreate\n                // this._optionBackup.baseOption, which is created at the first `setOption`\n                // called, and is merged into every new option by inner method `mergeOption`\n                // each time `setOption` called, can be only used in `isRecreate`, because\n                // its reliability is under suspicion. In other cases option merge is\n                // performed by `model.mergeOption`.\n                ? optionBackup.baseOption : this._newBaseOption\n            );\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Object}\n         */\n        getTimelineOption: function (ecModel) {\n            var option;\n            var timelineOptions = this._timelineOptions;\n\n            if (timelineOptions.length) {\n                // getTimelineOption can only be called after ecModel inited,\n                // so we can get currentIndex from timelineModel.\n                var timelineModel = ecModel.getComponent('timeline');\n                if (timelineModel) {\n                    option = clone(\n                        timelineOptions[timelineModel.getCurrentIndex()],\n                        true\n                    );\n                }\n            }\n\n            return option;\n        },\n\n        /**\n         * @param {module:echarts/model/Global} ecModel\n         * @return {Array.<Object>}\n         */\n        getMediaOption: function (ecModel) {\n            var ecWidth = this._api.getWidth();\n            var ecHeight = this._api.getHeight();\n            var mediaList = this._mediaList;\n            var mediaDefault = this._mediaDefault;\n            var indices = [];\n            var result = [];\n\n            // No media defined.\n            if (!mediaList.length && !mediaDefault) {\n                return result;\n            }\n\n            // Multi media may be applied, the latter defined media has higher priority.\n            for (var i = 0, len = mediaList.length; i < len; i++) {\n                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n                    indices.push(i);\n                }\n            }\n\n            // FIXME\n            // mediaDefault\n            if (!indices.length && mediaDefault) {\n                indices = [-1];\n            }\n\n            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n                result = map(indices, function (index) {\n                    return clone(\n                        index === -1 ? mediaDefault.option : mediaList[index].option\n                    );\n                });\n            }\n            // Otherwise return nothing.\n\n            this._currentMediaIndices = indices;\n\n            return result;\n        }\n    };\n\n    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n        var timelineOptions = [];\n        var mediaList = [];\n        var mediaDefault;\n        var baseOption;\n\n        // Compatible with ec2.\n        var timelineOpt = rawOption.timeline;\n\n        if (rawOption.baseOption) {\n            baseOption = rawOption.baseOption;\n        }\n\n        // For timeline\n        if (timelineOpt || rawOption.options) {\n            baseOption = baseOption || {};\n            timelineOptions = (rawOption.options || []).slice();\n        }\n\n        // For media query\n        if (rawOption.media) {\n            baseOption = baseOption || {};\n            var media = rawOption.media;\n            each(media, function (singleMedia) {\n                if (singleMedia && singleMedia.option) {\n                    if (singleMedia.query) {\n                        mediaList.push(singleMedia);\n                    }\n                    else if (!mediaDefault) {\n                        // Use the first media default.\n                        mediaDefault = singleMedia;\n                    }\n                }\n            });\n        }\n\n        // For normal option\n        if (!baseOption) {\n            baseOption = rawOption;\n        }\n\n        // Set timelineOpt to baseOption in ec3,\n        // which is convenient for merge option.\n        if (!baseOption.timeline) {\n            baseOption.timeline = timelineOpt;\n        }\n\n        // Preprocess.\n        each([baseOption].concat(timelineOptions)\n            .concat(zrUtil.map(mediaList, function (media) {\n                return media.option;\n            })),\n            function (option) {\n                each(optionPreprocessorFuncs, function (preProcess) {\n                    preProcess(option, isNew);\n                });\n            }\n        );\n\n        return {\n            baseOption: baseOption,\n            timelineOptions: timelineOptions,\n            mediaDefault: mediaDefault,\n            mediaList: mediaList\n        };\n    }\n\n    /**\n     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n     * Support: width, height, aspectRatio\n     * Can use max or min as prefix.\n     */\n    function applyMediaQuery(query, ecWidth, ecHeight) {\n        var realMap = {\n            width: ecWidth,\n            height: ecHeight,\n            aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n        };\n\n        var applicatable = true;\n\n        zrUtil.each(query, function (value, attr) {\n            var matched = attr.match(QUERY_REG);\n\n            if (!matched || !matched[1] || !matched[2]) {\n                return;\n            }\n\n            var operator = matched[1];\n            var realAttr = matched[2].toLowerCase();\n\n            if (!compare(realMap[realAttr], value, operator)) {\n                applicatable = false;\n            }\n        });\n\n        return applicatable;\n    }\n\n    function compare(real, expect, operator) {\n        if (operator === 'min') {\n            return real >= expect;\n        }\n        else if (operator === 'max') {\n            return real <= expect;\n        }\n        else { // Equals\n            return real === expect;\n        }\n    }\n\n    function indicesEquals(indices1, indices2) {\n        // indices is always order by asc and has only finite number.\n        return indices1.join(',') === indices2.join(',');\n    }\n\n    /**\n     * Consider case:\n     * `chart.setOption(opt1);`\n     * Then user do some interaction like dataZoom, dataView changing.\n     * `chart.setOption(opt2);`\n     * Then user press 'reset button' in toolbox.\n     *\n     * After doing that all of the interaction effects should be reset, the\n     * chart should be the same as the result of invoke\n     * `chart.setOption(opt1); chart.setOption(opt2);`.\n     *\n     * Although it is not able ensure that\n     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n     * `chart.setOption(merge(opt1, opt2));` exactly,\n     * this might be the only simple way to implement that feature.\n     *\n     * MEMO: We've considered some other approaches:\n     * 1. Each model handle its self restoration but not uniform treatment.\n     *     (Too complex in logic and error-prone)\n     * 2. Use a shadow ecModel. (Performace expensive)\n     */\n    function mergeOption(oldOption, newOption) {\n        newOption = newOption || {};\n\n        each(newOption, function (newCptOpt, mainType) {\n            if (newCptOpt == null) {\n                return;\n            }\n\n            var oldCptOpt = oldOption[mainType];\n\n            if (!ComponentModel.hasClass(mainType)) {\n                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n            }\n            else {\n                newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n\n                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n\n                oldOption[mainType] = map(mapResult, function (item) {\n                    return (item.option && item.exist)\n                        ? merge(item.exist, item.option, true)\n                        : (item.exist || item.option);\n                });\n            }\n        });\n    }\n\n    module.exports = OptionManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/model/OptionManager.js\n// module id = 1108\n// module chunks = 0 1 2","// Compatitable with 2.0\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var compatStyle = require('./helper/compatStyle');\n\n    function get(opt, path) {\n        path = path.split(',');\n        var obj = opt;\n        for (var i = 0; i < path.length; i++) {\n            obj = obj && obj[path[i]];\n            if (obj == null) {\n                break;\n            }\n        }\n        return obj;\n    }\n\n    function set(opt, path, val, overwrite) {\n        path = path.split(',');\n        var obj = opt;\n        var key;\n        for (var i = 0; i < path.length - 1; i++) {\n            key = path[i];\n            if (obj[key] == null) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        }\n        if (overwrite || obj[path[i]] == null) {\n            obj[path[i]] = val;\n        }\n    }\n\n    function compatLayoutProperties(option) {\n        each(LAYOUT_PROPERTIES, function (prop) {\n            if (prop[0] in option && !(prop[1] in option)) {\n                option[prop[1]] = option[prop[0]];\n            }\n        });\n    }\n\n    var LAYOUT_PROPERTIES = [\n        ['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']\n    ];\n\n    var COMPATITABLE_COMPONENTS = [\n        'grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'\n    ];\n\n    var COMPATITABLE_SERIES = [\n        'bar', 'boxplot', 'candlestick', 'chord', 'effectScatter',\n        'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel',\n        'pie', 'radar', 'sankey', 'scatter', 'treemap'\n    ];\n\n    var each = zrUtil.each;\n\n    module.exports = function (option, isTheme) {\n        compatStyle(option, isTheme);\n\n        var series = option.series;\n        each(zrUtil.isArray(series) ? series : [series], function (seriesOpt) {\n            if (!zrUtil.isObject(seriesOpt)) {\n                return;\n            }\n\n            var seriesType = seriesOpt.type;\n\n            if (seriesType === 'pie' || seriesType === 'gauge') {\n                if (seriesOpt.clockWise != null) {\n                    seriesOpt.clockwise = seriesOpt.clockWise;\n                }\n            }\n            if (seriesType === 'gauge') {\n                var pointerColor = get(seriesOpt, 'pointer.color');\n                pointerColor != null\n                    && set(seriesOpt, 'itemStyle.normal.color', pointerColor);\n            }\n\n            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {\n                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {\n                    compatLayoutProperties(seriesOpt);\n                    break;\n                }\n            }\n        });\n\n        // dataRange has changed to visualMap\n        if (option.dataRange) {\n            option.visualMap = option.dataRange;\n        }\n\n        each(COMPATITABLE_COMPONENTS, function (componentName) {\n            var options = option[componentName];\n            if (options) {\n                if (!zrUtil.isArray(options)) {\n                    options = [options];\n                }\n                each(options, function (option) {\n                    compatLayoutProperties(option);\n                });\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/preprocessor/backwardCompat.js\n// module id = 1109\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n\n    var each = zrUtil.each;\n    var isObject = zrUtil.isObject;\n\n    var POSSIBLE_STYLES = [\n        'areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle',\n        'chordStyle', 'label', 'labelLine'\n    ];\n\n    function compatItemStyle(opt) {\n        var itemStyleOpt = opt && opt.itemStyle;\n        if (!itemStyleOpt) {\n            return;\n        }\n        for (var i = 0, len = POSSIBLE_STYLES.length; i < len; i++) {\n            var styleName = POSSIBLE_STYLES[i];\n            var normalItemStyleOpt = itemStyleOpt.normal;\n            var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n            if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n                opt[styleName] = opt[styleName] || {};\n                if (!opt[styleName].normal) {\n                    opt[styleName].normal = normalItemStyleOpt[styleName];\n                }\n                else {\n                    zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n                }\n                normalItemStyleOpt[styleName] = null;\n            }\n            if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n                opt[styleName] = opt[styleName] || {};\n                if (!opt[styleName].emphasis) {\n                    opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n                }\n                else {\n                    zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n                }\n                emphasisItemStyleOpt[styleName] = null;\n            }\n        }\n    }\n\n    function compatTextStyle(opt, propName) {\n        var labelOptSingle = isObject(opt) && opt[propName];\n        var textStyle = isObject(labelOptSingle) && labelOptSingle.textStyle;\n        if (textStyle) {\n            for (var i = 0, len = modelUtil.TEXT_STYLE_OPTIONS.length; i < len; i++) {\n                var propName = modelUtil.TEXT_STYLE_OPTIONS[i];\n                if (textStyle.hasOwnProperty(propName)) {\n                    labelOptSingle[propName] = textStyle[propName];\n                }\n            }\n        }\n    }\n\n    function compatLabelTextStyle(labelOpt) {\n        if (isObject(labelOpt)) {\n            compatTextStyle(labelOpt, 'normal');\n            compatTextStyle(labelOpt, 'emphasis');\n        }\n    }\n\n    function processSeries(seriesOpt) {\n        if (!isObject(seriesOpt)) {\n            return;\n        }\n\n        compatItemStyle(seriesOpt);\n        compatLabelTextStyle(seriesOpt.label);\n        // treemap\n        compatLabelTextStyle(seriesOpt.upperLabel);\n        // graph\n        compatLabelTextStyle(seriesOpt.edgeLabel);\n\n        var markPoint = seriesOpt.markPoint;\n        compatItemStyle(markPoint);\n        compatLabelTextStyle(markPoint && markPoint.label);\n\n        var markLine = seriesOpt.markLine;\n        compatItemStyle(seriesOpt.markLine);\n        compatLabelTextStyle(markLine && markLine.label);\n\n        var markArea = seriesOpt.markArea;\n        compatLabelTextStyle(markArea && markArea.label);\n\n        // For gauge\n        compatTextStyle(seriesOpt, 'axisLabel');\n        compatTextStyle(seriesOpt, 'title');\n        compatTextStyle(seriesOpt, 'detail');\n\n        var data = seriesOpt.data;\n        if (data) {\n            for (var i = 0; i < data.length; i++) {\n                compatItemStyle(data[i]);\n                compatLabelTextStyle(data[i] && data[i].label);\n            }\n        }\n\n        // mark point data\n        var markPoint = seriesOpt.markPoint;\n        if (markPoint && markPoint.data) {\n            var mpData = markPoint.data;\n            for (var i = 0; i < mpData.length; i++) {\n                compatItemStyle(mpData[i]);\n                compatLabelTextStyle(mpData[i] && mpData[i].label);\n            }\n        }\n        // mark line data\n        var markLine = seriesOpt.markLine;\n        if (markLine && markLine.data) {\n            var mlData = markLine.data;\n            for (var i = 0; i < mlData.length; i++) {\n                if (zrUtil.isArray(mlData[i])) {\n                    compatItemStyle(mlData[i][0]);\n                    compatLabelTextStyle(mlData[i][0] && mlData[i][0].label);\n                    compatItemStyle(mlData[i][1]);\n                    compatLabelTextStyle(mlData[i][1] && mlData[i][1].label);\n                }\n                else {\n                    compatItemStyle(mlData[i]);\n                    compatLabelTextStyle(mlData[i] && mlData[i].label);\n                }\n            }\n        }\n    }\n\n    function toArr(o) {\n        return zrUtil.isArray(o) ? o : o ? [o] : [];\n    }\n\n    function toObj(o) {\n        return (zrUtil.isArray(o) ? o[0] : o) || {};\n    }\n\n    module.exports = function (option, isTheme) {\n        each(toArr(option.series), function (seriesOpt) {\n            isObject(seriesOpt) && processSeries(seriesOpt);\n        });\n\n        var axes = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'parallelAxis', 'radar'];\n        isTheme && axes.push('valueAxis', 'categoryAxis', 'logAxis', 'timeAxis');\n\n        each(\n            axes,\n            function (axisName) {\n                each(toArr(option[axisName]), function (axisOpt) {\n                    if (axisOpt) {\n                        compatTextStyle(axisOpt, 'axisLabel');\n                        compatTextStyle(axisOpt.axisPointer, 'label');\n                    }\n                });\n            }\n        );\n\n        each(toArr(option.parallel), function (parallelOpt) {\n            var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;\n            compatTextStyle(parallelAxisDefault, 'axisLabel');\n            compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, 'label');\n        });\n\n        each(toArr(option.calendar), function (calendarOpt) {\n            compatTextStyle(calendarOpt, 'dayLabel');\n            compatTextStyle(calendarOpt, 'monthLabel');\n            compatTextStyle(calendarOpt, 'yearLabel');\n        });\n\n        // radar.name.textStyle\n        each(toArr(option.radar), function (radarOpt) {\n            compatTextStyle(radarOpt, 'name');\n        });\n\n        each(toArr(option.geo), function (geoOpt) {\n            if (isObject(geoOpt)) {\n                compatLabelTextStyle(geoOpt.label);\n                each(toArr(geoOpt.regions), function (regionObj) {\n                    compatLabelTextStyle(regionObj.label);\n                });\n            }\n        });\n\n        compatLabelTextStyle(toObj(option.timeline).label);\n        compatTextStyle(toObj(option.axisPointer), 'label');\n        compatTextStyle(toObj(option.tooltip).axisPointer, 'label');\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/preprocessor/helper/compatStyle.js\n// module id = 1110\n// module chunks = 0 1 2","'use strict';\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\n    var util = require('./core/util');\n    var vec2 = require('./core/vector');\n    var Draggable = require('./mixin/Draggable');\n\n    var Eventful = require('./mixin/Eventful');\n\n    var SILENT = 'silent';\n\n    function makeEventPacket(eveType, targetInfo, event) {\n        return {\n            type: eveType,\n            event: event,\n            // target can only be an element that is not silent.\n            target: targetInfo.target,\n            // topTarget can be a silent element.\n            topTarget: targetInfo.topTarget,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta,\n            zrByTouch: event.zrByTouch,\n            which: event.which\n        };\n    }\n\n    function EmptyProxy () {}\n    EmptyProxy.prototype.dispose = function () {};\n\n    var handlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n     */\n    var Handler = function(storage, painter, proxy, painterRoot) {\n        Eventful.call(this);\n\n        this.storage = storage;\n\n        this.painter = painter;\n\n        this.painterRoot = painterRoot;\n\n        proxy = proxy || new EmptyProxy();\n\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n\n        // Attach handler\n        proxy.handler = this;\n\n        /**\n         * {target, topTarget, x, y}\n         * @private\n         * @type {Object}\n         */\n        this._hovered = {};\n\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n\n\n        Draggable.call(this);\n\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n\n    Handler.prototype = {\n\n        constructor: Handler,\n\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n\n            var lastHovered = this._hovered;\n            var lastHoveredTarget = lastHovered.target;\n\n            // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call\n            // (like 'setOption' or 'dispatchAction') in event handlers, we should find\n            // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.\n            // See #6198.\n            if (lastHoveredTarget && !lastHoveredTarget.__zr) {\n                lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n                lastHoveredTarget = lastHovered.target;\n            }\n\n            var hovered = this._hovered = this.findHover(x, y);\n            var hoveredTarget = hovered.target;\n\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default');\n\n            // Mouse out on previous hovered element\n            if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n\n            // Mouse over on a new element\n            if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n\n            // There might be some doms created by upper layer application\n            // at the same level of painter.getViewportRoot() (e.g., tooltip\n            // dom created by echarts), where 'globalout' event should not\n            // be triggered when mouse enters these doms. (But 'mouseout'\n            // should be triggered at the original hovered element as usual).\n            var element = event.toElement || event.relatedTarget;\n            var innerDom;\n            do {\n                element = element && element.parentNode;\n            }\n            while (element && element.nodeType != 9 && !(\n                innerDom = element === this.painterRoot\n            ));\n\n            !innerDom && this.trigger('globalout', {event: event});\n        },\n\n        /**\n         * Resize\n         */\n        resize: function (event) {\n            this._hovered = {};\n        },\n\n        /**\n         * Dispatch event\n         * @param {string} eventName\n         * @param {event=} eventArgs\n         */\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n\n        /**\n         * Dispose\n         */\n        dispose: function () {\n\n            this.proxy.dispose();\n\n            this.storage =\n            this.proxy =\n            this.painter = null;\n        },\n\n        /**\n         * cursor style\n         * @param {string} [cursorStyle='default']  crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n\n        /**\n         * \n         *\n         * @private\n         * @param {Object} targetInfo {target, topTarget} \n         * @param {string} eventName \n         * @param {Object} event \n         */\n        dispatchToElement: function (targetInfo, eventName, event) {\n            targetInfo = targetInfo || {};\n            var el = targetInfo.target;\n            if (el && el.silent) {\n                return;\n            }\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\n            while (el) {\n                el[eventHandler]\n                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n                el.trigger(eventName, eventPacket);\n\n                el = el.parent;\n\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n\n            if (!eventPacket.cancelBubble) {\n                //  zrender \n                this.trigger(eventName, eventPacket);\n                // \n                //  click  dispose painter \n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof(layer[eventHandler]) == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {number} x\n         * @param {number} y\n         * @param {module:zrender/graphic/Displayable} exclude\n         * @return {model:zrender/Element}\n         * @method\n         */\n        findHover: function(x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            var out = {x: x, y: y};\n\n            for (var i = list.length - 1; i >= 0 ; i--) {\n                var hoverCheckResult;\n                if (list[i] !== exclude\n                    // getDisplayList may include ignored item in VML mode\n                    && !list[i].ignore\n                    && (hoverCheckResult = isHover(list[i], x, y))\n                ) {\n                    !out.topTarget && (out.topTarget = list[i]);\n                    if (hoverCheckResult !== SILENT) {\n                        out.target = list[i];\n                        break;\n                    }\n                }\n            }\n\n            return out;\n        }\n    };\n\n    // Common handlers\n    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY);\n            var hoveredTarget = hovered.target;\n\n            if (name === 'mousedown') {\n                this._downEl = hoveredTarget;\n                this._downPoint = [event.zrX, event.zrY];\n                // In case click triggered before mouseup\n                this._upEl = hoveredTarget;\n            }\n            else if (name === 'mosueup') {\n                this._upEl = hoveredTarget;\n            }\n            else if (name === 'click') {\n                if (this._downEl !== this._upEl\n                    // Original click event is triggered on the whole canvas element,\n                    // including the case that `mousedown` - `mousemove` - `mouseup`,\n                    // which should be filtered, otherwise it will bring trouble to\n                    // pan and zoom.\n                    || !this._downPoint\n                    // Arbitrary value\n                    || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4\n                ) {\n                    return;\n                }\n                this._downPoint = null;\n            }\n\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            var isSilent;\n            while (el) {\n                // If clipped by ancestor.\n                // FIXME: If clipPath has neither stroke nor fill,\n                // el.clipPath.contain(x, y) will always return false.\n                if (el.clipPath && !el.clipPath.contain(x, y))  {\n                    return false;\n                }\n                if (el.silent) {\n                    isSilent = true;\n                }\n                el = el.parent;\n            }\n            return isSilent ? SILENT : true;\n        }\n\n        return false;\n    }\n\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n\n    module.exports = Handler;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/Handler.js\n// module id = 1111\n// module chunks = 0 1 2","// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\n\n    function Draggable() {\n\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);\n        // this._dropTarget = null;\n        // this._draggingTarget = null;\n\n        // this._x = 0;\n        // this._y = 0;\n    }\n\n    Draggable.prototype = {\n\n        constructor: Draggable,\n\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n\n                this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n            }\n        },\n\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n\n                var dropTarget = this.findHover(x, y, draggingTarget).target;\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n\n            this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\n            if (this._dropTarget) {\n                this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n            }\n\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n\n    };\n\n    function param(target, e) {\n        return {target: target, topTarget: e && e.topTarget};\n    }\n\n    module.exports = Draggable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/mixin/Draggable.js\n// module id = 1112\n// module chunks = 0 1 2","'use strict';\n/**\n * Storage\n * @module zrender/Storage\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n\n\n    var util = require('./core/util');\n    var env = require('./core/env');\n\n    var Group = require('./container/Group');\n\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = require('./core/timsort');\n\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     *  (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        this._roots = [];\n\n        this._displayList = [];\n\n        this._displayListLen = 0;\n    };\n\n    Storage.prototype = {\n\n        constructor: Storage,\n\n        /**\n         * @param  {Function} cb\n         *\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} [update=false] \n         * @param {boolean} [includeIgnore=false]  ignore ,  update  true \n         *\n         * {@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n         * @return {Array.<module:zrender/graphic/Displayable>}\n         */\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n\n        /**\n         * \n         * GroupShapeShape\n         * zlevel > z > \n         * @param {boolean} [includeIgnore=false]  ignore \n         */\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n\n            el.beforeUpdate();\n\n            if (el.__dirty) {\n\n                el.update();\n\n            }\n\n            el.afterUpdate();\n\n            var userSetClipPath = el.clipPath;\n            if (userSetClipPath) {\n\n                // FIXME \n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                }\n                else {\n                    clipPaths = [];\n                }\n\n                var currentClipPath = userSetClipPath;\n                var parentClipPath = el;\n                // Recursively add clip path\n                while (currentClipPath) {\n                    // clipPath  clipPath \n                    currentClipPath.parent = parentClipPath;\n                    currentClipPath.updateTransform();\n\n                    clipPaths.push(currentClipPath);\n\n                    parentClipPath = currentClipPath;\n                    currentClipPath = currentClipPath.clipPath;\n                }\n            }\n\n            if (el.isGroup) {\n                var children = el._children;\n\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n\n                // Mark group clean here\n                el.__dirty = false;\n\n            }\n            else {\n                el.__clipPaths = clipPaths;\n\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {module:zrender/Element} el\n         */\n        addRoot: function (el) {\n            if (el.__storage === this) {\n                return;\n            }\n\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n\n            this.addToStorage(el);\n            this._roots.push(el);\n        },\n\n        /**\n         * (Shape)(Group)\n         * @param {string|Array.<string>} [el] Storage\n         */\n        delRoot: function (el) {\n            if (el == null) {\n                // el\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n\n                return;\n            }\n\n            if (el instanceof Array) {\n                for (var i = 0, l = el.length; i < l; i++) {\n                    this.delRoot(el[i]);\n                }\n                return;\n            }\n\n\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromStorage(el);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n\n        addToStorage: function (el) {\n            el.__storage = this;\n            el.dirty(false);\n\n            return this;\n        },\n\n        delFromStorage: function (el) {\n            if (el) {\n                el.__storage = null;\n            }\n\n            return this;\n        },\n\n        /**\n         * Storage\n         */\n        dispose: function () {\n            this._renderList =\n            this._roots = null;\n        },\n\n        displayableSortFunc: shapeCompareFunc\n    };\n\n    module.exports = Storage;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/Storage.js\n// module id = 1113\n// module chunks = 0 1 2","'use strict';\n/**\n * , \n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n\n    var util = require('../core/util');\n    var Dispatcher = require('../core/event').Dispatcher;\n\n    var requestAnimationFrame = require('./requestAnimationFrame');\n\n    var Animator = require('./Animator');\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n\n        options = options || {};\n\n        this.stage = options.stage || {};\n\n        this.onframe = options.onframe || function() {};\n\n        // private properties\n        this._clips = [];\n\n        this._running = false;\n\n        this._time;\n\n        this._pausedTime;\n\n        this._pauseStart;\n\n        this._paused = false;\n\n        Dispatcher.call(this);\n    };\n\n    Animation.prototype = {\n\n        constructor: Animation,\n        /**\n         *  clip\n         * @param {module:zrender/animation/Clip} clip\n         */\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        /**\n         *  animator\n         * @param {module:zrender/animation/Animator} animator\n         */\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        /**\n         * \n         * @param {module:zrender/animation/Clip} clip\n         */\n        removeClip: function(clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n\n        /**\n         * \n         * @param {module:zrender/animation/Animator} animator\n         */\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n\n        _update: function() {\n\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time, delta);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n\n            this._time = time;\n\n            this.onframe(delta);\n\n            this.trigger('frame', delta);\n\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n\n        _startLoop: function () {\n            var self = this;\n\n            this._running = true;\n\n            function step() {\n                if (self._running) {\n\n                    requestAnimationFrame(step);\n\n                    !self._paused && self._update();\n                }\n            }\n\n            requestAnimationFrame(step);\n        },\n\n        /**\n         * \n         */\n        start: function () {\n\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n\n            this._startLoop();\n        },\n        /**\n         * \n         */\n        stop: function () {\n            this._running = false;\n        },\n\n        /**\n         * Pause\n         */\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n\n        /**\n         * Resume\n         */\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n                this._paused = false;\n            }\n        },\n\n        /**\n         * \n         */\n        clear: function () {\n            this._clips = [];\n        },\n        /**\n         * animator\n         * @param  {Object} target\n         * @param  {Object} options\n         * @param  {boolean} [options.loop=false] \n         * @param  {Function} [options.getter=null]\n         *         gettergetter\n         * @param  {Function} [options.setter=null]\n         *         settersetter\n         * @return {module:zrender/animation/Animation~Animator}\n         */\n        // TODO Gap\n        animate: function (target, options) {\n            options = options || {};\n\n            var animator = new Animator(\n                target,\n                options.loop,\n                options.getter,\n                options.setter\n            );\n\n            this.addAnimator(animator);\n\n            return animator;\n        }\n    };\n\n    util.mixin(Animation, Dispatcher);\n\n    module.exports = Animation;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/animation/Animation.js\n// module id = 1114\n// module chunks = 0 1 2","\n\n    var eventTool = require('../core/event');\n    var zrUtil = require('../core/util');\n    var Eventful = require('../mixin/Eventful');\n    var env = require('../core/env');\n    var GestureMgr = require('../core/GestureMgr');\n\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n\n    var TOUCH_CLICK_DELAY = 300;\n\n    var mouseHandlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n\n    var touchHandlerNames = [\n        'touchstart', 'touchend', 'touchmove'\n    ];\n\n    var pointerEventNames = {\n        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1\n    };\n\n    var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n        var nm = name.replace('mouse', 'pointer');\n        return pointerEventNames[nm] ? nm : name;\n    });\n\n    function eventNameFix(name) {\n        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n    }\n\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n\n        stage === 'start' && gestureMgr.clear();\n\n        var gestureInfo = gestureMgr.recognize(\n            event,\n            proxy.handler.findHover(event.zrX, event.zrY, null).target,\n            proxy.dom\n        );\n\n        stage === 'end' && gestureMgr.clear();\n\n        // Do not do any preventDefault here. Upper application do that if necessary.\n        if (gestureInfo) {\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n\n            proxy.handler.dispatchToElement({target: gestureInfo.target}, type, gestureInfo.event);\n        }\n    }\n\n    // function onMSGestureChange(proxy, event) {\n    //     if (event.translationX || event.translationY) {\n    //         // mousemove is carried by MSGesture to reduce the sensitivity.\n    //         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n    //     }\n    //     if (event.scale !== 1) {\n    //         event.pinchX = event.offsetX;\n    //         event.pinchY = event.offsetY;\n    //         event.pinchScale = event.scale;\n    //         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n    //     }\n    // }\n\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n\n\n    var domHandlers = {\n        /**\n         * Mouse move handler\n         * @inner\n         * @param {Event} event\n         */\n        mousemove: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            this.trigger('mousemove', event);\n        },\n\n        /**\n         * Mouse out handler\n         * @inner\n         * @param {Event} event\n         */\n        mouseout: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            var element = event.toElement || event.relatedTarget;\n            if (element != this.dom) {\n                while (element && element.nodeType != 9) {\n                    // rootdommouseOut\n                    if (element === this.dom) {\n                        return;\n                    }\n\n                    element = element.parentNode;\n                }\n            }\n\n            this.trigger('mouseout', event);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchstart: function (event) {\n            // Default mouse behaviour should not be disabled here.\n            // For example, page may needs to be slided.\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            this._lastTouchMoment = new Date();\n\n            processGesture(this, event, 'start');\n\n            // In touch device, trigger `mousemove`(`mouseover`) should\n            // be triggered, and must before `mousedown` triggered.\n            domHandlers.mousemove.call(this, event);\n\n            domHandlers.mousedown.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchmove: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'change');\n\n            // Mouse move should always be triggered no matter whether\n            // there is gestrue event, because mouse move and pinch may\n            // be used at the same time.\n            domHandlers.mousemove.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch\n         * @inner\n         * @param {Event} event\n         */\n        touchend: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            // Mark touch, which is useful in distinguish touch and\n            // mouse event in upper applicatoin.\n            event.zrByTouch = true;\n\n            processGesture(this, event, 'end');\n\n            domHandlers.mouseup.call(this, event);\n\n            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n            // we can conveniently implement \"hover style\" in both PC and touch device just\n            // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n            // to remove \"hover style\" on an element, without any additional code for\n            // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n            // style\" will remain for user view)\n\n            // click event should always be triggered no matter whether\n            // there is gestrue event. System click can not be prevented.\n            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                domHandlers.click.call(this, event);\n            }\n\n            setTouchTimer(this);\n        },\n\n        pointerdown: function (event) {\n            domHandlers.mousedown.call(this, event);\n\n            // if (useMSGuesture(this, event)) {\n            //     this._msGesture.addPointer(event.pointerId);\n            // }\n        },\n\n        pointermove: function (event) {\n            // FIXME\n            // pointermove is so sensitive that it always triggered when\n            // tap(click) on touch screen, which affect some judgement in\n            // upper application. So, we dont support mousemove on MS touch\n            // device yet.\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mousemove.call(this, event);\n            }\n        },\n\n        pointerup: function (event) {\n            domHandlers.mouseup.call(this, event);\n        },\n\n        pointerout: function (event) {\n            // pointerout will be triggered when tap on touch screen\n            // (IE11+/Edge on MS Surface) after click event triggered,\n            // which is inconsistent with the mousout behavior we defined\n            // in touchend. So we unify them.\n            // (check domHandlers.touchend for detailed explanation)\n            if (!isPointerFromTouch(event)) {\n                domHandlers.mouseout.call(this, event);\n            }\n        }\n    };\n\n    function isPointerFromTouch(event) {\n        var pointerType = event.pointerType;\n        return pointerType === 'pen' || pointerType === 'touch';\n    }\n\n    // function useMSGuesture(handlerProxy, event) {\n    //     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n    // }\n\n    // Common handlers\n    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n\n    /**\n     * dom \n     *\n     * @inner\n     * @param {module:zrender/Handler} instance \n     */\n    function initDomHandler(instance) {\n        zrUtil.each(touchHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(pointerHandlerNames, function (name) {\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        });\n\n        zrUtil.each(mouseHandlerNames, function (name) {\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        });\n\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n\n\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n\n        this.dom = dom;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n\n        this._handlers = {};\n\n        initDomHandler(this);\n\n        if (env.pointerEventsSupported) { // Only IE11+/Edge\n            // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n            // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n            // at the same time.\n            // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n            // screen, which do not occurs in pointer event.\n            // So we use pointer event to both detect touch gesture and mouse behavior.\n            mountHandlers(pointerHandlerNames, this);\n\n            // FIXME\n            // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n            // which does not prevent defuault behavior occasionally (which may cause view port\n            // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n            // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n            // touch screen. And we only support click behavior on MS touch screen now.\n\n            // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n            // We dont support touch on IE on win7.\n            // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n            // if (typeof MSGesture === 'function') {\n            //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n            //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n            // }\n        }\n        else {\n            if (env.touchEventsSupported) {\n                mountHandlers(touchHandlerNames, this);\n                // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n                // addEventListener(root, 'mouseout', this._mouseoutHandler);\n            }\n\n            // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n            // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n            // mouse event can not be handle in those devices.\n            // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n            // mouseevent after touch event triggered, see `setTouchTimer`.\n            mountHandlers(mouseHandlerNames, this);\n        }\n\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n\n    module.exports = HandlerDomProxy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/dom/HandlerProxy.js\n// module id = 1115\n// module chunks = 0 1 2","'use strict';\n/**\n * Only implements needed gestures for mobile.\n */\n\n\n    var eventUtil = require('./event');\n\n    var GestureMgr = function () {\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n\n    GestureMgr.prototype = {\n\n        constructor: GestureMgr,\n\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n\n            if (!touches) {\n                return;\n            }\n\n            var trackItem = {\n                points: [],\n                touches: [],\n                target: target,\n                event: event\n            };\n\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch, {});\n                trackItem.points.push([pos.zrX, pos.zrY]);\n                trackItem.touches.push(touch);\n            }\n\n            this._track.push(trackItem);\n        },\n\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n\n    var recognizers = {\n\n        pinch: function (track, event) {\n            var trackLen = track.length;\n\n            if (!trackLen) {\n                return;\n            }\n\n            var pinchEnd = (track[trackLen - 1] || {}).points;\n            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n            if (pinchPre\n                && pinchPre.length > 1\n                && pinchEnd\n                && pinchEnd.length > 1\n            ) {\n                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                !isFinite(pinchScale) && (pinchScale = 1);\n\n                event.pinchScale = pinchScale;\n\n                var pinchCenter = center(pinchEnd);\n                event.pinchX = pinchCenter[0];\n                event.pinchY = pinchCenter[1];\n\n                return {\n                    type: 'pinch',\n                    target: track[0].target,\n                    event: event\n                };\n            }\n        }\n\n        // Only pinch currently.\n    };\n\n    module.exports = GestureMgr;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/core/GestureMgr.js\n// module id = 1116\n// module chunks = 0 1 2","'use strict';\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n \n\n    var config = require('./config');\n    var util = require('./core/util');\n    var log = require('./core/log');\n    var BoundingRect = require('./core/BoundingRect');\n    var timsort = require('./core/timsort');\n\n    var Layer = require('./Layer');\n\n    var requestAnimationFrame = require('./animation/requestAnimationFrame');\n\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n\n        if (layer.__builtin__) {\n            return true;\n        }\n\n        if (typeof(layer.resize) !== 'function'\n            || typeof(layer.refresh) !== 'function'\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n            return false;\n        }\n\n        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n\n            clipPath.setTransform(ctx);\n            ctx.beginPath();\n            clipPath.buildPath(ctx, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n\n        // domRoot.onselectstart = returnFalse; // \n        domRoot.style.cssText = [\n            'position:relative',\n            'overflow:hidden',\n            'width:' + width + 'px',\n            'height:' + height + 'px',\n            'padding:0',\n            'margin:0',\n            'border-width:0'\n        ].join(';') + ';';\n\n        return domRoot;\n    }\n\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root \n     * @param {module:zrender/Storage} storage\n     * @param {Object} opts\n     */\n    var Painter = function (root, storage, opts) {\n\n        this.type = 'canvas';\n\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName // In node ?\n            || root.nodeName.toUpperCase() === 'CANVAS';\n\n        this._opts = opts = util.extend({}, opts || {});\n\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * \n         * @type {HTMLElement}\n         */\n        this.root = root;\n\n        var rootStyle = root.style;\n\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] =\n            rootStyle['user-select'] =\n            rootStyle['-webkit-touch-callout'] = 'none';\n\n            root.innerHTML = '';\n        }\n\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n\n        if (!singleCanvas) {\n            this._width = this._getSize(0);\n            this._height = this._getSize(1);\n\n            var domRoot = this._domRoot = createRoot(\n                this._width, this._height\n            );\n            root.appendChild(domRoot);\n        }\n        else {\n            if (opts.width != null) {\n                root.width = opts.width;\n            }\n            if (opts.height != null) {\n                root.height = opts.height;\n            }\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n\n            this._domRoot = root;\n        }\n\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n\n        this._hoverElements = [];\n    };\n\n    Painter.prototype = {\n\n        constructor: Painter,\n\n        getType: function () {\n            return 'canvas';\n        },\n\n        /**\n         * If painter use a single canvas\n         * @return {boolean}\n         */\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._domRoot;\n        },\n\n        getViewportRootOffset: function () {\n            var viewportRoot = this.getViewportRoot();\n            if (viewportRoot) {\n                return {\n                    offsetLeft: viewportRoot.offsetLeft || 0,\n                    offsetTop: viewportRoot.offsetTop || 0\n                };\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} [paintAll=false] displayable\n         */\n        refresh: function (paintAll) {\n\n            var list = this.storage.getDisplayList(true);\n\n            var zlevelList = this._zlevelList;\n\n            this._paintList(list, paintAll);\n\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.__builtin__ && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n\n            this.refreshHover();\n\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n\n            return this;\n        },\n\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                style: el.style,\n                shape: el.shape\n            });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n            }\n\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n\n        _startProgessive: function () {\n            var self = this;\n\n            if (!self._furtherProgressive) {\n                return;\n            }\n\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n\n            self._progress++;\n            requestAnimationFrame(step);\n\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n\n                    self._doPaintList(self.storage.getDisplayList());\n\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    }\n                    else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n\n        _paintList: function (list, paintAll) {\n\n            if (paintAll == null) {\n                paintAll = false;\n            }\n\n            this._updateLayerStatus(list);\n\n            this._clearProgressive();\n\n            this.eachBuiltinLayer(preProcessLayer);\n\n            this._doPaintList(list, paintAll);\n\n            this.eachBuiltinLayer(postProcessLayer);\n        },\n\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n\n            // var invTransform = [];\n            var scope;\n\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\n                var elFrame = el.__frame;\n\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n\n                    // Reset scope\n                    scope = {};\n\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n\n                    if (!currentLayer.__builtin__) {\n                        log(\n                            'ZLevel ' + currentZLevel\n                            + ' has been used by unkown layer ' + currentLayer.id\n                        );\n                    }\n\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[\n                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n                        ];\n\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n\n                        if (currentProgressiveLayer\n                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n                        ) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n\n                        layerProgress = currentProgressiveLayer.__progress;\n\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                }\n                else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n\n                el.__dirty = false;\n            }\n\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if (\n                (currentLayer.__dirty || forcePaint)\n                // Ignore invisible element\n                && !el.invisible\n                // Ignore transparent element\n                && el.style.opacity !== 0\n                // Ignore scale 0 element, in some environment like node-canvas\n                // Draw a scale 0 element can cause all following draw wrong\n                // And setTransform with scale 0 will cause set back transform failed.\n                && !(m && !m[0] && !m[3])\n                // Ignore culled element\n                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n            ) {\n\n                var clipPaths = el.__clipPaths;\n\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer\n                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n                ) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n\n        /**\n         *  zlevel \n         * @param {number} zlevel\n         * @return {module:zrender/Layer}\n         */\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.__builtin__ = true;\n\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n\n                this.insertLayer(zlevel, layer);\n\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n\n            return layer;\n        },\n\n        insertLayer: function (zlevel, layer) {\n\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (\n                        zlevelList[i] < zlevel\n                        && zlevelList[i + 1] > zlevel\n                    ) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n\n            layersMap[zlevel] = layer;\n\n            // Vitual layer will not directly show on the screen.\n            // (It can be a WebGL layer and assigned to a ZImage element)\n            // But it still under management of zrender.\n            if (!layer.virtual) {\n                if (prevLayer) {\n                    var prevDom = prevLayer.dom;\n                    if (prevDom.nextSibling) {\n                        domRoot.insertBefore(\n                            layer.dom,\n                            prevDom.nextSibling\n                        );\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n                else {\n                    if (domRoot.firstChild) {\n                        domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n            }\n        },\n\n        // Iterate each layer\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n\n        // Iterate each buildin layer\n        eachBuiltinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        // Iterate each other layer except buildin layer\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (!layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {Array.<module:zrender/Layer>} [prevLayer]\n         */\n        getLayers: function () {\n            return this._layers;\n        },\n\n        _updateLayerStatus: function (list) {\n\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n\n            this.eachBuiltinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n                                'progressive', this, this.dpr\n                            );\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n\n                    currentProgressiveLayer.__maxProgress = Math.max(\n                        currentProgressiveLayer.__maxProgress, elFrame\n                    );\n\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                }\n                else {\n                    el.__frame = -1;\n\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n\n            // \n            this.eachBuiltinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n\n        /**\n         * hover\n         */\n        clear: function () {\n            this.eachBuiltinLayer(this._clearLayer);\n            return this;\n        },\n\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n\n        /**\n         * zlevel\n         *\n         * @param {string} zlevel\n         * @param {Object} config \n         * @param {string} [config.clearColor=0] \n         * @param {string} [config.motionBlur=false] \n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 alpha\n         */\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n\n                var layer = this._layers[zlevel];\n\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {number} zlevel zlevel\n         */\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n\n        /**\n         * \n         */\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n\n            // Save input w/h\n            var opts = this._opts;\n            width != null && (opts.width = width);\n            height != null && (opts.height = height);\n\n            width = this._getSize(0);\n            height = this._getSize(1);\n\n            domRoot.style.display = '';\n\n            // resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n\n                for (var id in this._layers) {\n                    if (this._layers.hasOwnProperty(id)) {\n                        this._layers[id].resize(width, height);\n                    }\n                }\n                util.each(this._progressiveLayers, function (layer) {\n                    layer.resize(width, height);\n                });\n\n                this.refresh(true);\n            }\n\n            this._width = width;\n            this._height = height;\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {number} zlevel\n         */\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n\n        /**\n         * \n         */\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this.root =\n            this.storage =\n\n            this._domRoot =\n            this._layers = null;\n        },\n\n        /**\n         * Get canvas which has all thing rendered\n         * @param {Object} opts\n         * @param {string} [opts.backgroundColor]\n         */\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n\n            var displayList = this.storage.getDisplayList(true);\n\n            var scope = {};\n            var zlevel;\n\n            var self = this;\n            function findAndDrawOtherLayer(smaller, larger) {\n                var zlevelList = self._zlevelList;\n                if (smaller == null) {\n                    smaller = -Infinity;\n                }\n                var intermediateLayer;\n                for (var i = 0; i < zlevelList.length; i++) {\n                    var z = zlevelList[i];\n                    var layer = self._layers[z];\n                    if (!layer.__builtin__ && z > smaller && z < larger) {\n                        intermediateLayer = layer;\n                        break;\n                    }\n                }\n                if (intermediateLayer && intermediateLayer.renderToCanvas) {\n                    imageLayer.ctx.save();\n                    intermediateLayer.renderToCanvas(imageLayer.ctx);\n                    imageLayer.ctx.restore();\n                }\n            }\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n\n                if (el.zlevel !== zlevel) {\n                    findAndDrawOtherLayer(zlevel, el.zlevel);\n                    zlevel = el.zlevel;\n                }\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n\n            findAndDrawOtherLayer(zlevel, Infinity);\n\n            return imageLayer.dom;\n        },\n        /**\n         * \n         */\n        getWidth: function () {\n            return this._width;\n        },\n\n        /**\n         * \n         */\n        getHeight: function () {\n            return this._height;\n        },\n\n        _getSize: function (whIdx) {\n            var opts = this._opts;\n            var wh = ['width', 'height'][whIdx];\n            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n            if (opts[wh] != null && opts[wh] !== 'auto') {\n                return parseFloat(opts[wh]);\n            }\n\n            var root = this.root;\n            // IE8 does not support getComputedStyle, but it use VML.\n            var stl = document.defaultView.getComputedStyle(root);\n\n            return (\n                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n                - (parseInt10(stl[plt]) || 0)\n                - (parseInt10(stl[prb]) || 0)\n            ) | 0;\n        },\n\n        pathToImage: function (path, dpr) {\n            dpr = dpr || this.dpr;\n\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n            var rect = path.getBoundingRect();\n            var style = path.style;\n            var shadowBlurSize = style.shadowBlur;\n            var shadowOffsetX = style.shadowOffsetX;\n            var shadowOffsetY = style.shadowOffsetY;\n            var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n\n            var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n            var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n            var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n            var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n            var width = rect.width + leftMargin + rightMargin;\n            var height = rect.height + topMargin + bottomMargin;\n\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            ctx.scale(dpr, dpr);\n            ctx.clearRect(0, 0, width, height);\n            ctx.dpr = dpr;\n\n            var pathTransform = {\n                position: path.position,\n                rotation: path.rotation,\n                scale: path.scale\n            };\n            path.position = [leftMargin - rect.x, topMargin - rect.y];\n            path.rotation = 0;\n            path.scale = [1, 1];\n            path.updateTransform();\n            if (path) {\n                path.brush(ctx);\n            }\n\n            var ImageShape = require('./graphic/Image');\n            var imgShape = new ImageShape({\n                style: {\n                    x: 0,\n                    y: 0,\n                    image: canvas\n                }\n            });\n\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n\n            return imgShape;\n        }\n    };\n\n    module.exports = Painter;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/Painter.js\n// module id = 1117\n// module chunks = 0 1 2","/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var util = require('./core/util');\n    var config = require('./config');\n    var Style = require('./graphic/Style');\n    var Pattern = require('./graphic/Pattern');\n\n    function returnFalse() {\n        return false;\n    }\n\n    /**\n     * dom\n     *\n     * @inner\n     * @param {string} id dom id \n     * @param {string} type dom typesuch as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n\n        var newDomStyle = newDom.style;\n        // append~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n\n        // id\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function(id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }\n        // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n\n        var domStyle = dom.style;\n        if (domStyle) { // Not in node\n            dom.onselectstart = returnFalse; // \n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n            domStyle['padding'] = 0;\n            domStyle['margin'] = 0;\n            domStyle['border-width'] = 0;\n        }\n\n        this.domBack = null;\n        this.ctxBack = null;\n\n        this.painter = painter;\n\n        this.config = null;\n\n        // Configs\n        /**\n         * \n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * \n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * alpha\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n\n    Layer.prototype = {\n\n        constructor: Layer,\n\n        elCount: 0,\n\n        __dirty: true,\n\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n            this.ctx.__currentValues = {};\n            this.ctx.dpr = this.dpr;\n        },\n\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n            this.ctxBack.__currentValues = {};\n\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n\n        /**\n         * @param  {number} width\n         * @param  {number} height\n         */\n        resize: function (width, height) {\n            var dpr = this.dpr;\n\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n\n        /**\n         * \n         * @param {boolean} clearAll Clear all with out motion blur\n         */\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n\n            var dpr = this.dpr;\n\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(\n                    dom, 0, 0,\n                    width / dpr,\n                    height / dpr\n                );\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }\n                // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n\n    module.exports = Layer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/Layer.js\n// module id = 1118\n// module chunks = 0 1 2","\n    var Gradient = require('zrender/lib/graphic/Gradient');\n    module.exports = function (ecModel) {\n        function encodeColor(seriesModel) {\n            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');\n            var data = seriesModel.getData();\n            var color = seriesModel.get(colorAccessPath) // Set in itemStyle\n                || seriesModel.getColorFromPalette(seriesModel.get('name'));  // Default color\n\n            // FIXME Set color function or use the platte color\n            data.setVisual('color', color);\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof color === 'function' && !(color instanceof Gradient)) {\n                    data.each(function (idx) {\n                        data.setItemVisual(\n                            idx, 'color', color(seriesModel.getDataParams(idx))\n                        );\n                    });\n                }\n\n                // itemStyle in each data item\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var color = itemModel.get(colorAccessPath, true);\n                    if (color != null) {\n                        data.setItemVisual(idx, 'color', color);\n                    }\n                });\n            }\n        }\n        ecModel.eachRawSeries(encodeColor);\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/visual/seriesColor.js\n// module id = 1119\n// module chunks = 0 1 2","\n\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var PI = Math.PI;\n    /**\n     * @param {module:echarts/ExtensionAPI} api\n     * @param {Object} [opts]\n     * @param {string} [opts.text]\n     * @param {string} [opts.color]\n     * @param {string} [opts.textColor]\n     * @return {module:zrender/Element}\n     */\n    module.exports = function (api, opts) {\n        opts = opts || {};\n        zrUtil.defaults(opts, {\n            text: 'loading',\n            color: '#c23531',\n            textColor: '#000',\n            maskColor: 'rgba(255, 255, 255, 0.8)',\n            zlevel: 0\n        });\n        var mask = new graphic.Rect({\n            style: {\n                fill: opts.maskColor\n            },\n            zlevel: opts.zlevel,\n            z: 10000\n        });\n        var arc = new graphic.Arc({\n            shape: {\n                startAngle: -PI / 2,\n                endAngle: -PI / 2 + 0.1,\n                r: 10\n            },\n            style: {\n                stroke: opts.color,\n                lineCap: 'round',\n                lineWidth: 5\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n        var labelRect = new graphic.Rect({\n            style: {\n                fill: 'none',\n                text: opts.text,\n                textPosition: 'right',\n                textDistance: 10,\n                textFill: opts.textColor\n            },\n            zlevel: opts.zlevel,\n            z: 10001\n        });\n\n        arc.animateShape(true)\n            .when(1000, {\n                endAngle: PI * 3 / 2\n            })\n            .start('circularInOut');\n        arc.animateShape(true)\n            .when(1000, {\n                startAngle: PI * 3 / 2\n            })\n            .delay(300)\n            .start('circularInOut');\n\n        var group = new graphic.Group();\n        group.add(arc);\n        group.add(labelRect);\n        group.add(mask);\n        // Inject resize\n        group.resize = function () {\n            var cx = api.getWidth() / 2;\n            var cy = api.getHeight() / 2;\n            arc.setShape({\n                cx: cx,\n                cy: cy\n            });\n            var r = arc.shape.r;\n            labelRect.setShape({\n                x: cx - r,\n                y: cy - r,\n                width: r * 2,\n                height: r * 2\n            });\n\n            mask.setShape({\n                x: 0,\n                y: 0,\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n        };\n        group.resize();\n        return group;\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/loading/default.js\n// module id = 1120\n// module chunks = 0 1 2","/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n\n// FIXME only one data\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Scale = require('./Scale');\n\n    var scaleProto = Scale.prototype;\n\n    var OrdinalScale = Scale.extend({\n\n        type: 'ordinal',\n\n        init: function (data, extent) {\n            this._data = data;\n            this._extent = extent || [0, data.length - 1];\n        },\n\n        parse: function (val) {\n            return typeof val === 'string'\n                ? zrUtil.indexOf(this._data, val)\n                // val might be float.\n                : Math.round(val);\n        },\n\n        contain: function (rank) {\n            rank = this.parse(rank);\n            return scaleProto.contain.call(this, rank)\n                && this._data[rank] != null;\n        },\n\n        /**\n         * Normalize given rank or name to linear [0, 1]\n         * @param {number|string} [val]\n         * @return {number}\n         */\n        normalize: function (val) {\n            return scaleProto.normalize.call(this, this.parse(val));\n        },\n\n        scale: function (val) {\n            return Math.round(scaleProto.scale.call(this, val));\n        },\n\n        /**\n         * @return {Array}\n         */\n        getTicks: function () {\n            var ticks = [];\n            var extent = this._extent;\n            var rank = extent[0];\n\n            while (rank <= extent[1]) {\n                ticks.push(rank);\n                rank++;\n            }\n\n            return ticks;\n        },\n\n        /**\n         * Get item on rank n\n         * @param {number} n\n         * @return {string}\n         */\n        getLabel: function (n) {\n            return this._data[n];\n        },\n\n        /**\n         * @return {number}\n         */\n        count: function () {\n            return this._extent[1] - this._extent[0] + 1;\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, false));\n        },\n\n        niceTicks: zrUtil.noop,\n        niceExtent: zrUtil.noop\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    OrdinalScale.create = function () {\n        return new OrdinalScale();\n    };\n\n    module.exports = OrdinalScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/scale/Ordinal.js\n// module id = 1121\n// module chunks = 0 1 2","/**\n * Interval scale\n * @module echarts/coord/scale/Time\n */\n\n\n\n    // [About UTC and local time zone]:\n    // In most cases, `number.parseDate` will treat input data string as local time\n    // (except time zone is specified in time string). And `format.formateTime` returns\n    // local time by default. option.useUTC is false by default. This design have\n    // concidered these common case:\n    // (1) Time that is persistent in server is in UTC, but it is needed to be diplayed\n    // in local time by default.\n    // (2) By default, the input data string (e.g., '2011-01-02') should be displayed\n    // as its original time, without any time difference.\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n    var scaleHelper = require('./helper');\n\n    var IntervalScale = require('./Interval');\n\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var mathCeil = Math.ceil;\n    var mathFloor = Math.floor;\n    var ONE_SECOND = 1000;\n    var ONE_MINUTE = ONE_SECOND * 60;\n    var ONE_HOUR = ONE_MINUTE * 60;\n    var ONE_DAY = ONE_HOUR * 24;\n\n    // FIXME \n    var bisect = function (a, x, lo, hi) {\n        while (lo < hi) {\n            var mid = lo + hi >>> 1;\n            if (a[mid][2] < x) {\n                lo = mid + 1;\n            }\n            else {\n                hi  = mid;\n            }\n        }\n        return lo;\n    };\n\n    /**\n     * @alias module:echarts/coord/scale/Time\n     * @constructor\n     */\n    var TimeScale = IntervalScale.extend({\n        type: 'time',\n\n        /**\n         * @override\n         */\n        getLabel: function (val) {\n            var stepLvl = this._stepLvl;\n\n            var date = new Date(val);\n\n            return formatUtil.formatTime(stepLvl[0], date, this.getSetting('useUTC'));\n        },\n\n        /**\n         * @override\n         */\n        niceExtent: function (opt) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                // Expand extent\n                extent[0] -= ONE_DAY;\n                extent[1] += ONE_DAY;\n            }\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (extent[1] === -Infinity && extent[0] === Infinity) {\n                var d = new Date();\n                extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());\n                extent[0] = extent[1] - ONE_DAY;\n            }\n\n            this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!opt.fixMin) {\n                extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n            }\n            if (!opt.fixMax) {\n                extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n            }\n        },\n\n        /**\n         * @override\n         */\n        niceTicks: function (approxTickNum, minInterval, maxInterval) {\n            approxTickNum = approxTickNum || 10;\n\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            var approxInterval = span / approxTickNum;\n\n            if (minInterval != null && approxInterval < minInterval) {\n                approxInterval = minInterval;\n            }\n            if (maxInterval != null && approxInterval > maxInterval) {\n                approxInterval = maxInterval;\n            }\n\n            var scaleLevelsLen = scaleLevels.length;\n            var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\n            var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n            var interval = level[2];\n            // Same with interval scale if span is much larger than 1 year\n            if (level[0] === 'year') {\n                var yearSpan = span / interval;\n\n                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                // var niceYearSpan = numberUtil.nice(yearSpan, false);\n                var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\n                interval *= yearStep;\n            }\n\n            var timezoneOffset = this.getSetting('useUTC')\n                ? 0 : (new Date(+extent[0] || +extent[1])).getTimezoneOffset() * 60 * 1000;\n            var niceExtent = [\n                Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset),\n                Math.round(mathFloor((extent[1] - timezoneOffset) / interval) * interval + timezoneOffset)\n            ];\n\n            scaleHelper.fixExtent(niceExtent, extent);\n\n            this._stepLvl = level;\n            // Interval will be used in getTicks\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        parse: function (val) {\n            // val might be float.\n            return +numberUtil.parseDate(val);\n        }\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        TimeScale.prototype[methodName] = function (val) {\n            return intervalScaleProto[methodName].call(this, this.parse(val));\n        };\n    });\n\n    // Steps from d3\n    var scaleLevels = [\n        // Format       step    interval\n        ['hh:mm:ss',    1,      ONE_SECOND],           // 1s\n        ['hh:mm:ss',    5,      ONE_SECOND * 5],       // 5s\n        ['hh:mm:ss',    10,     ONE_SECOND * 10],      // 10s\n        ['hh:mm:ss',    15,     ONE_SECOND * 15],      // 15s\n        ['hh:mm:ss',    30,     ONE_SECOND * 30],      // 30s\n        ['hh:mm\\nMM-dd',1,      ONE_MINUTE],          // 1m\n        ['hh:mm\\nMM-dd',5,      ONE_MINUTE * 5],      // 5m\n        ['hh:mm\\nMM-dd',10,     ONE_MINUTE * 10],     // 10m\n        ['hh:mm\\nMM-dd',15,     ONE_MINUTE * 15],     // 15m\n        ['hh:mm\\nMM-dd',30,     ONE_MINUTE * 30],     // 30m\n        ['hh:mm\\nMM-dd',1,      ONE_HOUR],        // 1h\n        ['hh:mm\\nMM-dd',2,      ONE_HOUR * 2],    // 2h\n        ['hh:mm\\nMM-dd',6,      ONE_HOUR * 6],    // 6h\n        ['hh:mm\\nMM-dd',12,     ONE_HOUR * 12],   // 12h\n        ['MM-dd\\nyyyy', 1,      ONE_DAY],   // 1d\n        ['week',        7,      ONE_DAY * 7],        // 7d\n        ['month',       1,      ONE_DAY * 31],       // 1M\n        ['quarter',     3,      ONE_DAY * 380 / 4],  // 3M\n        ['half-year',   6,      ONE_DAY * 380 / 2],  // 6M\n        ['year',        1,      ONE_DAY * 380]       // 1Y\n    ];\n\n    /**\n     * @param {module:echarts/model/Model}\n     * @return {module:echarts/scale/Time}\n     */\n    TimeScale.create = function (model) {\n        return new TimeScale({useUTC: model.ecModel.get('useUTC')});\n    };\n\n    module.exports = TimeScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/scale/Time.js\n// module id = 1122\n// module chunks = 0 1 2","/**\n * Log scale\n * @module echarts/scale/Log\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Scale = require('./Scale');\n    var numberUtil = require('../util/number');\n\n    // Use some method of IntervalScale\n    var IntervalScale = require('./Interval');\n\n    var scaleProto = Scale.prototype;\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var mathPow = Math.pow;\n\n    var mathLog = Math.log;\n\n    var LogScale = Scale.extend({\n\n        type: 'log',\n\n        base: 10,\n\n        $constructor: function () {\n            Scale.apply(this, arguments);\n            this._originalScale = new IntervalScale();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            var originalScale = this._originalScale;\n            var extent = this._extent;\n            var originalExtent = originalScale.getExtent();\n\n            return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n                var powVal = numberUtil.round(mathPow(this.base, val));\n\n                // Fix #4158\n                powVal = (val === extent[0] && originalScale.__fixMin)\n                    ? fixRoundingError(powVal, originalExtent[0])\n                    : powVal;\n                powVal = (val === extent[1] && originalScale.__fixMax)\n                    ? fixRoundingError(powVal, originalExtent[1])\n                    : powVal;\n\n                return powVal;\n            }, this);\n        },\n\n        /**\n         * @param {number} val\n         * @return {string}\n         */\n        getLabel: intervalScaleProto.getLabel,\n\n        /**\n         * @param  {number} val\n         * @return {number}\n         */\n        scale: function (val) {\n            val = scaleProto.scale.call(this, val);\n            return mathPow(this.base, val);\n        },\n\n        /**\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var base = this.base;\n            start = mathLog(start) / mathLog(base);\n            end = mathLog(end) / mathLog(base);\n            intervalScaleProto.setExtent.call(this, start, end);\n        },\n\n        /**\n         * @return {number} end\n         */\n        getExtent: function () {\n            var base = this.base;\n            var extent = scaleProto.getExtent.call(this);\n            extent[0] = mathPow(base, extent[0]);\n            extent[1] = mathPow(base, extent[1]);\n\n            // Fix #4158\n            var originalScale = this._originalScale;\n            var originalExtent = originalScale.getExtent();\n            originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n            originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n\n            return extent;\n        },\n\n        /**\n         * @param  {Array.<number>} extent\n         */\n        unionExtent: function (extent) {\n            this._originalScale.unionExtent(extent);\n\n            var base = this.base;\n            extent[0] = mathLog(extent[0]) / mathLog(base);\n            extent[1] = mathLog(extent[1]) / mathLog(base);\n            scaleProto.unionExtent.call(this, extent);\n        },\n\n        /**\n         * @override\n         */\n        unionExtentFromData: function (data, dim) {\n            this.unionExtent(data.getDataExtent(dim, true, function (val) {\n                return val > 0;\n            }));\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         * @param  {number} [approxTickNum = 10] Given approx tick number\n         */\n        niceTicks: function (approxTickNum) {\n            approxTickNum = approxTickNum || 10;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (span === Infinity || span <= 0) {\n                return;\n            }\n\n            var interval = numberUtil.quantity(span);\n            var err = approxTickNum / span * interval;\n\n            // Filter ticks to get closer to the desired count.\n            if (err <= 0.5) {\n                interval *= 10;\n            }\n\n            // Interval should be integer\n            while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n                interval *= 10;\n            }\n\n            var niceExtent = [\n                numberUtil.round(mathCeil(extent[0] / interval) * interval),\n                numberUtil.round(mathFloor(extent[1] / interval) * interval)\n            ];\n\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @override\n         */\n        niceExtent: function (opt) {\n            intervalScaleProto.niceExtent.call(this, opt);\n\n            var originalScale = this._originalScale;\n            originalScale.__fixMin = opt.fixMin;\n            originalScale.__fixMax = opt.fixMax;\n        }\n\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        LogScale.prototype[methodName] = function (val) {\n            val = mathLog(val) / mathLog(this.base);\n            return scaleProto[methodName].call(this, val);\n        };\n    });\n\n    LogScale.create = function () {\n        return new LogScale();\n    };\n\n    function fixRoundingError(val, originalVal) {\n        return roundingErrorFix(val, getPrecisionSafe(originalVal));\n    }\n\n    module.exports = LogScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/scale/Log.js\n// module id = 1123\n// module chunks = 0 1 2","\n\n    var createListFromArray = require('./chart/helper/createListFromArray');\n    var symbolUtil = require('./util/symbol');\n    var axisHelper = require('./coord/axisHelper');\n    var axisModelCommonMixin = require('./coord/axisModelCommonMixin');\n    var Model = require('./model/Model');\n    var util = require('zrender/lib/core/util');\n\n    module.exports = {\n        /**\n         * Create a muti dimension List structure from seriesModel.\n         * @param  {module:echarts/model/Model} seriesModel\n         * @return {module:echarts/data/List} list\n         */\n        createList: function (seriesModel) {\n            var data = seriesModel.get('data');\n            return createListFromArray(data, seriesModel, seriesModel.ecModel);\n        },\n\n        /**\n         * @see {module:echarts/data/helper/completeDimensions}\n         */\n        completeDimensions: require('./data/helper/completeDimensions'),\n\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @see http://echarts.baidu.com/option.html#series-scatter.symbol\n         * @param {string} symbolDesc\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: symbolUtil.createSymbol,\n\n        /**\n         * Create scale\n         * @param {Array.<number>} dataExtent\n         * @param {Object|module:echarts/Model} option\n         */\n        createScale: function (dataExtent, option) {\n            var axisModel = option;\n            if (!(option instanceof Model)) {\n                axisModel = new Model(option);\n                util.mixin(axisModel, axisModelCommonMixin);\n            }\n\n            var scale = axisHelper.createScaleByModel(axisModel);\n            scale.setExtent(dataExtent[0], dataExtent[1]);\n\n            axisHelper.niceScaleExtent(scale, axisModel);\n            return scale;\n        },\n\n        /**\n         * Mixin common methods to axis model,\n         *\n         * Inlcude methods\n         * `getFormattedLabels() => Array.<string>`\n         * `getCategories() => Array.<string>`\n         * `getMin(origin: boolean) => number`\n         * `getMax(origin: boolean) => number`\n         * `getNeedCrossZero() => boolean`\n         * `setRange(start: number, end: number)`\n         * `resetRange()`\n         */\n        mixinAxisModelCommonMethods: function (Model) {\n            util.mixin(Model, axisModelCommonMixin);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/helper.js\n// module id = 1124\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n    var modelHelper = require('./modelHelper');\n    var findPointFromSeries = require('./findPointFromSeries');\n\n    var each = zrUtil.each;\n    var curry = zrUtil.curry;\n    var get = modelUtil.makeGetter();\n\n    /**\n     * Basic logic: check all axis, if they do not demand show/highlight,\n     * then hide/downplay them.\n     *\n     * @param {Object} coordSysAxesInfo\n     * @param {Object} payload\n     * @param {string} [payload.currTrigger] 'click' | 'mousemove' | 'leave'\n     * @param {Array.<number>} [payload.x] x and y, which are mandatory, specify a point to\n     *              trigger axisPointer and tooltip.\n     * @param {Array.<number>} [payload.y] x and y, which are mandatory, specify a point to\n     *              trigger axisPointer and tooltip.\n     * @param {Object} [payload.seriesIndex] finder, optional, restrict target axes.\n     * @param {Object} [payload.dataIndex] finder, restrict target axes.\n     * @param {Object} [payload.axesInfo] finder, restrict target axes.\n     *        [{\n     *          axisDim: 'x'|'y'|'angle'|...,\n     *          axisIndex: ...,\n     *          value: ...\n     *        }, ...]\n     * @param {Function} [payload.dispatchAction]\n     * @param {Object} [payload.tooltipOption]\n     * @param {Object|Array.<number>|Function} [payload.position] Tooltip position,\n     *        which can be specified in dispatchAction\n     * @param {module:echarts/model/Global} ecModel\n     * @param {module:echarts/ExtensionAPI} api\n     * @return {Object} content of event obj for echarts.connect.\n     */\n    function axisTrigger(payload, ecModel, api) {\n        var currTrigger = payload.currTrigger;\n        var point = [payload.x, payload.y];\n        var finder = payload;\n        var dispatchAction = payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n        var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n        // Pending\n        // See #6121. But we are not able to reproduce it yet.\n        if (!coordSysAxesInfo) {\n            return;\n        }\n\n        if (illegalPoint(point)) {\n            // Used in the default behavior of `connection`: use the sample seriesIndex\n            // and dataIndex. And also used in the tooltipView trigger.\n            point = findPointFromSeries({\n                seriesIndex: finder.seriesIndex,\n                // Do not use dataIndexInside from other ec instance.\n                // FIXME: auto detect it?\n                dataIndex: finder.dataIndex\n            }, ecModel).point;\n        }\n        var isIllegalPoint = illegalPoint(point);\n\n        // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).\n        // Notice: In this case, it is difficult to get the `point` (which is necessary to show\n        // tooltip, so if point is not given, we just use the point found by sample seriesIndex\n        // and dataIndex.\n        var inputAxesInfo = finder.axesInfo;\n\n        var axesInfo = coordSysAxesInfo.axesInfo;\n        var shouldHide = currTrigger === 'leave' || illegalPoint(point);\n        var outputFinder = {};\n\n        var showValueMap = {};\n        var dataByCoordSys = {list: [], map: {}};\n        var updaters = {\n            showPointer: curry(showPointer, showValueMap),\n            showTooltip: curry(showTooltip, dataByCoordSys)\n        };\n\n        // Process for triggered axes.\n        each(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {\n            // If a point given, it must be contained by the coordinate system.\n            var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);\n\n            each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {\n                var axis = axisInfo.axis;\n                var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);\n                // If no inputAxesInfo, no axis is restricted.\n                if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {\n                    var val = inputAxisInfo && inputAxisInfo.value;\n                    if (val == null && !isIllegalPoint) {\n                        val = axis.pointToData(point);\n                    }\n                    val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);\n                }\n            });\n        });\n\n        // Process for linked axes.\n        var linkTriggers = {};\n        each(axesInfo, function (tarAxisInfo, tarKey) {\n            var linkGroup = tarAxisInfo.linkGroup;\n\n            // If axis has been triggered in the previous stage, it should not be triggered by link.\n            if (linkGroup && !showValueMap[tarKey]) {\n                each(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {\n                    var srcValItem = showValueMap[srcKey];\n                    // If srcValItem exist, source axis is triggered, so link to target axis.\n                    if (srcAxisInfo !== tarAxisInfo && srcValItem) {\n                        var val = srcValItem.value;\n                        linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(\n                            val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo)\n                        )));\n                        linkTriggers[tarAxisInfo.key] = val;\n                    }\n                });\n            }\n        });\n        each(linkTriggers, function (val, tarKey) {\n            processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);\n        });\n\n        updateModelActually(showValueMap, axesInfo, outputFinder);\n        dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);\n        dispatchHighDownActually(axesInfo, dispatchAction, api);\n\n        return outputFinder;\n    }\n\n    function processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {\n        var axis = axisInfo.axis;\n\n        if (axis.scale.isBlank() || !axis.containData(newValue)) {\n            return;\n        }\n\n        if (!axisInfo.involveSeries) {\n            updaters.showPointer(axisInfo, newValue);\n            return;\n        }\n\n        // Heavy calculation. So put it after axis.containData checking.\n        var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);\n        var payloadBatch = payloadInfo.payloadBatch;\n        var snapToValue = payloadInfo.snapToValue;\n\n        // Fill content of event obj for echarts.connect.\n        // By defualt use the first involved series data as a sample to connect.\n        if (payloadBatch[0] && outputFinder.seriesIndex == null) {\n            zrUtil.extend(outputFinder, payloadBatch[0]);\n        }\n\n        // If no linkSource input, this process is for collecting link\n        // target, where snap should not be accepted.\n        if (!dontSnap && axisInfo.snap) {\n            if (axis.containData(snapToValue) && snapToValue != null) {\n                newValue = snapToValue;\n            }\n        }\n\n        updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder);\n        // Tooltip should always be snapToValue, otherwise there will be\n        // incorrect \"axis value ~ series value\" mapping displayed in tooltip.\n        updaters.showTooltip(axisInfo, payloadInfo, snapToValue);\n    }\n\n    function buildPayloadsBySeries(value, axisInfo) {\n        var axis = axisInfo.axis;\n        var dim = axis.dim;\n        var snapToValue = value;\n        var payloadBatch = [];\n        var minDist = Number.MAX_VALUE;\n        var minDiff = -1;\n\n        each(axisInfo.seriesModels, function (series, idx) {\n            var dataDim = series.coordDimToDataDim(dim);\n            var seriesNestestValue;\n            var dataIndices;\n\n            if (series.getAxisTooltipData) {\n                var result = series.getAxisTooltipData(dataDim, value, axis);\n                dataIndices = result.dataIndices;\n                seriesNestestValue = result.nestestValue;\n            }\n            else {\n                dataIndices = series.getData().indicesOfNearest(\n                    dataDim[0],\n                    value,\n                    // Add a threshold to avoid find the wrong dataIndex\n                    // when data length is not same.\n                    false, axis.type === 'category' ? 0.5 : null\n                );\n                if (!dataIndices.length) {\n                    return;\n                }\n                seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);\n            }\n\n            if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {\n                return;\n            }\n\n            var diff = value - seriesNestestValue;\n            var dist = Math.abs(diff);\n            // Consider category case\n            if (dist <= minDist) {\n                if (dist < minDist || (diff >= 0 && minDiff < 0)) {\n                    minDist = dist;\n                    minDiff = diff;\n                    snapToValue = seriesNestestValue;\n                    payloadBatch.length = 0;\n                }\n                each(dataIndices, function (dataIndex) {\n                    payloadBatch.push({\n                        seriesIndex: series.seriesIndex,\n                        dataIndexInside: dataIndex,\n                        dataIndex: series.getData().getRawIndex(dataIndex)\n                    });\n                });\n            }\n        });\n\n        return {\n            payloadBatch: payloadBatch,\n            snapToValue: snapToValue\n        };\n    }\n\n    function showPointer(showValueMap, axisInfo, value, payloadBatch) {\n        showValueMap[axisInfo.key] = {value: value, payloadBatch: payloadBatch};\n    }\n\n    function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {\n        var payloadBatch = payloadInfo.payloadBatch;\n        var axis = axisInfo.axis;\n        var axisModel = axis.model;\n        var axisPointerModel = axisInfo.axisPointerModel;\n\n        // If no data, do not create anything in dataByCoordSys,\n        // whose length will be used to judge whether dispatch action.\n        if (!axisInfo.triggerTooltip || !payloadBatch.length) {\n            return;\n        }\n\n        var coordSysModel = axisInfo.coordSys.model;\n        var coordSysKey = modelHelper.makeKey(coordSysModel);\n        var coordSysItem = dataByCoordSys.map[coordSysKey];\n        if (!coordSysItem) {\n            coordSysItem = dataByCoordSys.map[coordSysKey] = {\n                coordSysId: coordSysModel.id,\n                coordSysIndex: coordSysModel.componentIndex,\n                coordSysType: coordSysModel.type,\n                coordSysMainType: coordSysModel.mainType,\n                dataByAxis: []\n            };\n            dataByCoordSys.list.push(coordSysItem);\n        }\n\n        coordSysItem.dataByAxis.push({\n            axisDim: axis.dim,\n            axisIndex: axisModel.componentIndex,\n            axisType: axisModel.type,\n            axisId: axisModel.id,\n            value: value,\n            // Caustion: viewHelper.getValueLabel is actually on \"view stage\", which\n            // depends that all models have been updated. So it should not be performed\n            // here. Considering axisPointerModel used here is volatile, which is hard\n            // to be retrieve in TooltipView, we prepare parameters here.\n            valueLabelOpt: {\n                precision: axisPointerModel.get('label.precision'),\n                formatter: axisPointerModel.get('label.formatter')\n            },\n            seriesDataIndices: payloadBatch.slice()\n        });\n    }\n\n    function updateModelActually(showValueMap, axesInfo, outputFinder) {\n        var outputAxesInfo = outputFinder.axesInfo = [];\n        // Basic logic: If no 'show' required, 'hide' this axisPointer.\n        each(axesInfo, function (axisInfo, key) {\n            var option = axisInfo.axisPointerModel.option;\n            var valItem = showValueMap[key];\n\n            if (valItem) {\n                !axisInfo.useHandle && (option.status = 'show');\n                option.value = valItem.value;\n                // For label formatter param and highlight.\n                option.seriesDataIndices = (valItem.payloadBatch || []).slice();\n            }\n            // When always show (e.g., handle used), remain\n            // original value and status.\n            else {\n                // If hide, value still need to be set, consider\n                // click legend to toggle axis blank.\n                !axisInfo.useHandle && (option.status = 'hide');\n            }\n\n            // If status is 'hide', should be no info in payload.\n            option.status === 'show' && outputAxesInfo.push({\n                axisDim: axisInfo.axis.dim,\n                axisIndex: axisInfo.axis.model.componentIndex,\n                value: option.value\n            });\n        });\n    }\n\n    function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {\n        // Basic logic: If no showTip required, hideTip will be dispatched.\n        if (illegalPoint(point) || !dataByCoordSys.list.length) {\n            dispatchAction({type: 'hideTip'});\n            return;\n        }\n\n        // In most case only one axis (or event one series is used). It is\n        // convinient to fetch payload.seriesIndex and payload.dataIndex\n        // dirtectly. So put the first seriesIndex and dataIndex of the first\n        // axis on the payload.\n        var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};\n\n        dispatchAction({\n            type: 'showTip',\n            escapeConnect: true,\n            x: point[0],\n            y: point[1],\n            tooltipOption: payload.tooltipOption,\n            position: payload.position,\n            dataIndexInside: sampleItem.dataIndexInside,\n            dataIndex: sampleItem.dataIndex,\n            seriesIndex: sampleItem.seriesIndex,\n            dataByCoordSys: dataByCoordSys.list\n        });\n    }\n\n    function dispatchHighDownActually(axesInfo, dispatchAction, api) {\n        // FIXME\n        // highlight status modification shoule be a stage of main process?\n        // (Consider confilct (e.g., legend and axisPointer) and setOption)\n\n        var zr = api.getZr();\n        var highDownKey = 'axisPointerLastHighlights';\n        var lastHighlights = get(zr)[highDownKey] || {};\n        var newHighlights = get(zr)[highDownKey] = {};\n\n        // Update highlight/downplay status according to axisPointer model.\n        // Build hash map and remove duplicate incidentally.\n        each(axesInfo, function (axisInfo, key) {\n            var option = axisInfo.axisPointerModel.option;\n            option.status === 'show' && each(option.seriesDataIndices, function (batchItem) {\n                var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;\n                newHighlights[key] = batchItem;\n            });\n        });\n\n        // Diff.\n        var toHighlight = [];\n        var toDownplay = [];\n        zrUtil.each(lastHighlights, function (batchItem, key) {\n            !newHighlights[key] && toDownplay.push(batchItem);\n        });\n        zrUtil.each(newHighlights, function (batchItem, key) {\n            !lastHighlights[key] && toHighlight.push(batchItem);\n        });\n\n        toDownplay.length && api.dispatchAction({\n            type: 'downplay', escapeConnect: true, batch: toDownplay\n        });\n        toHighlight.length && api.dispatchAction({\n            type: 'highlight', escapeConnect: true, batch: toHighlight\n        });\n    }\n\n    function findInputAxisInfo(inputAxesInfo, axisInfo) {\n        for (var i = 0; i < (inputAxesInfo || []).length; i++) {\n            var inputAxisInfo = inputAxesInfo[i];\n            if (axisInfo.axis.dim === inputAxisInfo.axisDim\n                && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex\n            ) {\n                return inputAxisInfo;\n            }\n        }\n    }\n\n    function makeMapperParam(axisInfo) {\n        var axisModel = axisInfo.axis.model;\n        var item = {};\n        var dim = item.axisDim = axisInfo.axis.dim;\n        item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;\n        item.axisName = item[dim + 'AxisName'] = axisModel.name;\n        item.axisId = item[dim + 'AxisId'] = axisModel.id;\n        return item;\n    }\n\n    function illegalPoint(point) {\n        return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);\n    }\n\n    module.exports = axisTrigger;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/axisTrigger.js\n// module id = 1125\n// module chunks = 0 1 2","\n\n    var echarts = require('../../echarts');\n\n    var AxisPointerModel = echarts.extendComponentModel({\n\n        type: 'axisPointer',\n\n        coordSysAxesInfo: null,\n\n        defaultOption: {\n            // 'auto' means that show when triggered by tooltip or handle.\n            show: 'auto',\n            // 'click' | 'mousemove' | 'none'\n            triggerOn: null, // set default in AxisPonterView.js\n\n            zlevel: 0,\n            z: 50,\n\n            type: 'line',\n            // axispointer triggered by tootip determine snap automatically,\n            // see `modelHelper`.\n            snap: false,\n            triggerTooltip: true,\n\n            value: null,\n            status: null, // Init value depends on whether handle is used.\n\n            // [group0, group1, ...]\n            // Each group can be: {\n            //      mapper: function () {},\n            //      singleTooltip: 'multiple',  // 'multiple' or 'single'\n            //      xAxisId: ...,\n            //      yAxisName: ...,\n            //      angleAxisIndex: ...\n            // }\n            // mapper: can be ignored.\n            //      input: {axisInfo, value}\n            //      output: {axisInfo, value}\n            link: [],\n\n            // Do not set 'auto' here, otherwise global animation: false\n            // will not effect at this axispointer.\n            animation: null,\n            animationDurationUpdate: 200,\n\n            lineStyle: {\n                color: '#aaa',\n                width: 1,\n                type: 'solid'\n            },\n\n            shadowStyle: {\n                color: 'rgba(150,150,150,0.3)'\n            },\n\n            label: {\n                show: true,\n                formatter: null, // string | Function\n                precision: 'auto', // Or a number like 0, 1, 2 ...\n                margin: 3,\n                color: '#fff',\n                padding: [5, 7, 5, 7],\n                backgroundColor: 'auto', // default: axis line color\n                borderColor: null,\n                borderWidth: 0,\n                shadowBlur: 3,\n                shadowColor: '#aaa'\n                // Considering applicability, common style should\n                // better not have shadowOffset.\n                // shadowOffsetX: 0,\n                // shadowOffsetY: 2\n            },\n\n            handle: {\n                show: false,\n                icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z', // jshint ignore:line\n                size: 45,\n                // handle margin is from symbol center to axis, which is stable when circular move.\n                margin: 50,\n                // color: '#1b8bbd'\n                // color: '#2f4554'\n                color: '#333',\n                shadowBlur: 3,\n                shadowColor: '#aaa',\n                shadowOffsetX: 0,\n                shadowOffsetY: 2,\n\n                // For mobile performance\n                throttle: 40\n            }\n        }\n\n    });\n\n    module.exports = AxisPointerModel;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js\n// module id = 1126\n// module chunks = 0 1 2","\n\n    var globalListener = require('./globalListener');\n\n    var AxisPonterView = require('../../echarts').extendComponentView({\n\n        type: 'axisPointer',\n\n        render: function (globalAxisPointerModel, ecModel, api) {\n            var globalTooltipModel = ecModel.getComponent('tooltip');\n            var triggerOn = globalAxisPointerModel.get('triggerOn')\n                || (globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click');\n\n            // Register global listener in AxisPointerView to enable\n            // AxisPointerView to be independent to Tooltip.\n            globalListener.register(\n                'axisPointer',\n                api,\n                function (currTrigger, e, dispatchAction) {\n                    // If 'none', it is not controlled by mouse totally.\n                    if (triggerOn !== 'none'\n                        && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)\n                    ) {\n                        dispatchAction({\n                            type: 'updateAxisPointer',\n                            currTrigger: currTrigger,\n                            x: e && e.offsetX,\n                            y: e && e.offsetY\n                        });\n                    }\n                }\n            );\n        },\n\n        /**\n         * @override\n         */\n        remove: function (ecModel, api) {\n            globalListener.disopse(api.getZr(), 'axisPointer');\n            AxisPonterView.superApply(this._model, 'remove', arguments);\n        },\n\n        /**\n         * @override\n         */\n        dispose: function (ecModel, api) {\n            globalListener.unregister('axisPointer', api);\n            AxisPonterView.superApply(this._model, 'dispose', arguments);\n        }\n\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/axisPointer/AxisPointerView.js\n// module id = 1127\n// module chunks = 0 1 2","\n\n    require('../../echarts').extendComponentModel({\n\n        type: 'tooltip',\n\n        dependencies: ['axisPointer'],\n\n        defaultOption: {\n            zlevel: 0,\n\n            z: 8,\n\n            show: true,\n\n            // tooltip\n            showContent: true,\n\n            // 'trigger' only works on coordinate system.\n            // 'item' | 'axis' | 'none'\n            trigger: 'item',\n\n            // 'click' | 'mousemove' | 'none'\n            triggerOn: 'mousemove|click',\n\n            alwaysShowContent: false,\n\n            displayMode: 'single', // 'single' | 'multipleByCoordSys'\n\n            //  {Array} | {Function}\n            // position: null\n            // Consider triggered from axisPointer handle, verticalAlign should be 'middle'\n            // align: null,\n            // verticalAlign: null,\n\n            //  content  viewRect  false \n            confine: false,\n\n            // {string}Template  {Function}\n            // formatter: null\n\n            showDelay: 0,\n\n            // ms\n            hideDelay: 100,\n\n            // s\n            transitionDuration: 0.4,\n\n            enterable: false,\n\n            // 0.7\n            backgroundColor: 'rgba(50,50,50,0.7)',\n\n            // \n            borderColor: '#333',\n\n            // px4\n            borderRadius: 4,\n\n            // px0\n            borderWidth: 0,\n\n            // px5\n            // css\n            padding: 5,\n\n            // Extra css text\n            extraCssText: '',\n\n            // \n            axisPointer: {\n                // \n                // 'line' | 'shadow' | 'cross'\n                type: 'line',\n\n                // type  line  tooltip line \n                //  'x' | 'y' | 'angle' | 'radius' | 'auto'\n                //  'auto' cateogry  x \n                //  angle \n                axis: 'auto',\n\n                animation: 'auto',\n                animationDurationUpdate: 200,\n                animationEasingUpdate: 'exponentialOut',\n\n                crossStyle: {\n                    color: '#999',\n                    width: 1,\n                    type: 'dashed',\n\n                    // TODO formatter\n                    textStyle: {}\n                }\n\n                // lineStyle and shadowStyle should not be specified here,\n                // otherwise it will always override those styles on option.axisPointer.\n            },\n            textStyle: {\n                color: '#fff',\n                fontSize: 14\n            }\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/tooltip/TooltipModel.js\n// module id = 1128\n// module chunks = 0 1 2","\n\n    var TooltipContent = require('./TooltipContent');\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../../util/format');\n    var numberUtil = require('../../util/number');\n    var graphic = require('../../util/graphic');\n    var findPointFromSeries = require('../axisPointer/findPointFromSeries');\n    var layoutUtil = require('../../util/layout');\n    var env = require('zrender/lib/core/env');\n    var Model = require('../../model/Model');\n    var globalListener = require('../axisPointer/globalListener');\n    var axisHelper = require('../../coord/axisHelper');\n    var axisPointerViewHelper = require('../axisPointer/viewHelper');\n\n    var bind = zrUtil.bind;\n    var each = zrUtil.each;\n    var parsePercent = numberUtil.parsePercent;\n\n\n    var proxyRect = new graphic.Rect({\n        shape: {x: -1, y: -1, width: 2, height: 2}\n    });\n\n    require('../../echarts').extendComponentView({\n\n        type: 'tooltip',\n\n        init: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            var tooltipContent = new TooltipContent(api.getDom(), api);\n            this._tooltipContent = tooltipContent;\n        },\n\n        render: function (tooltipModel, ecModel, api) {\n            if (env.node) {\n                return;\n            }\n\n            // Reset\n            this.group.removeAll();\n\n            /**\n             * @private\n             * @type {module:echarts/component/tooltip/TooltipModel}\n             */\n            this._tooltipModel = tooltipModel;\n\n            /**\n             * @private\n             * @type {module:echarts/model/Global}\n             */\n            this._ecModel = ecModel;\n\n            /**\n             * @private\n             * @type {module:echarts/ExtensionAPI}\n             */\n            this._api = api;\n\n            /**\n             * Should be cleaned when render.\n             * @private\n             * @type {Array.<Array.<Object>>}\n             */\n            this._lastDataByCoordSys = null;\n\n            /**\n             * @private\n             * @type {boolean}\n             */\n            this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n\n            var tooltipContent = this._tooltipContent;\n            tooltipContent.update();\n            tooltipContent.setEnterable(tooltipModel.get('enterable'));\n\n            this._initGlobalListener();\n\n            this._keepShow();\n        },\n\n        _initGlobalListener: function () {\n            var tooltipModel = this._tooltipModel;\n            var triggerOn = tooltipModel.get('triggerOn');\n\n            globalListener.register(\n                'itemTooltip',\n                this._api,\n                bind(function (currTrigger, e, dispatchAction) {\n                    // If 'none', it is not controlled by mouse totally.\n                    if (triggerOn !== 'none') {\n                        if (triggerOn.indexOf(currTrigger) >= 0) {\n                            this._tryShow(e, dispatchAction);\n                        }\n                        else if (currTrigger === 'leave') {\n                            this._hide(dispatchAction);\n                        }\n                    }\n                }, this)\n            );\n        },\n\n        _keepShow: function () {\n            var tooltipModel = this._tooltipModel;\n            var ecModel = this._ecModel;\n            var api = this._api;\n\n            // Try to keep the tooltip show when refreshing\n            if (this._lastX != null\n                && this._lastY != null\n                // When user is willing to control tooltip totally using API,\n                // self.manuallyShowTip({x, y}) might cause tooltip hide,\n                // which is not expected.\n                && tooltipModel.get('triggerOn') !== 'none'\n            ) {\n                var self = this;\n                clearTimeout(this._refreshUpdateTimeout);\n                this._refreshUpdateTimeout = setTimeout(function () {\n                    // Show tip next tick after other charts are rendered\n                    // In case highlight action has wrong result\n                    // FIXME\n                    self.manuallyShowTip(tooltipModel, ecModel, api, {\n                        x: self._lastX,\n                        y: self._lastY\n                    });\n                });\n            }\n        },\n\n        /**\n         * Show tip manually by\n         * dispatchAction({\n         *     type: 'showTip',\n         *     x: 10,\n         *     y: 10\n         * });\n         * Or\n         * dispatchAction({\n         *      type: 'showTip',\n         *      seriesIndex: 0,\n         *      dataIndex or dataIndexInside or name\n         * });\n         *\n         *  TODO Batch\n         */\n        manuallyShowTip: function (tooltipModel, ecModel, api, payload) {\n            if (payload.from === this.uid || env.node) {\n                return;\n            }\n\n            var dispatchAction = makeDispatchAction(payload, api);\n\n            // Reset ticket\n            this._ticket = '';\n\n            // When triggered from axisPointer.\n            var dataByCoordSys = payload.dataByCoordSys;\n\n            if (payload.tooltip && payload.x != null && payload.y != null) {\n                var el = proxyRect;\n                el.position = [payload.x, payload.y];\n                el.update();\n                el.tooltip = payload.tooltip;\n                // Manually show tooltip while view is not using zrender elements.\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    target: el\n                }, dispatchAction);\n            }\n            else if (dataByCoordSys) {\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    position: payload.position,\n                    event: {},\n                    dataByCoordSys: payload.dataByCoordSys,\n                    tooltipOption: payload.tooltipOption\n                }, dispatchAction);\n            }\n            else if (payload.seriesIndex != null) {\n\n                if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {\n                    return;\n                }\n\n                var pointInfo = findPointFromSeries(payload, ecModel);\n                var cx = pointInfo.point[0];\n                var cy = pointInfo.point[1];\n                if (cx != null && cy != null) {\n                    this._tryShow({\n                        offsetX: cx,\n                        offsetY: cy,\n                        position: payload.position,\n                        target: pointInfo.el,\n                        event: {}\n                    }, dispatchAction);\n                }\n            }\n            else if (payload.x != null && payload.y != null) {\n                // FIXME\n                // should wrap dispatchAction like `axisPointer/globalListener` ?\n                api.dispatchAction({\n                    type: 'updateAxisPointer',\n                    x: payload.x,\n                    y: payload.y\n                });\n\n                this._tryShow({\n                    offsetX: payload.x,\n                    offsetY: payload.y,\n                    position: payload.position,\n                    target: api.getZr().findHover(payload.x, payload.y).target,\n                    event: {}\n                }, dispatchAction);\n            }\n        },\n\n        manuallyHideTip: function (tooltipModel, ecModel, api, payload) {\n            var tooltipContent = this._tooltipContent;\n\n            if (!this._alwaysShowContent) {\n                tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n            }\n\n            this._lastX = this._lastY = null;\n\n            if (payload.from !== this.uid) {\n                this._hide(makeDispatchAction(payload, api));\n            }\n        },\n\n        // Be compatible with previous design, that is, when tooltip.type is 'axis' and\n        // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer\n        // and tooltip.\n        _manuallyAxisShowTip: function (tooltipModel, ecModel, api, payload) {\n            var seriesIndex = payload.seriesIndex;\n            var dataIndex = payload.dataIndex;\n            var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n            if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {\n                return;\n            }\n\n            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n            if (!seriesModel) {\n                return;\n            }\n\n            var data = seriesModel.getData();\n            var tooltipModel = buildTooltipModel([\n                data.getItemModel(dataIndex),\n                seriesModel,\n                (seriesModel.coordinateSystem || {}).model,\n                tooltipModel\n            ]);\n\n            if (tooltipModel.get('trigger') !== 'axis') {\n                return;\n            }\n\n            api.dispatchAction({\n                type: 'updateAxisPointer',\n                seriesIndex: seriesIndex,\n                dataIndex: dataIndex,\n                position: payload.position\n            });\n\n            return true;\n        },\n\n        _tryShow: function (e, dispatchAction) {\n            var el = e.target;\n            var tooltipModel = this._tooltipModel;\n\n            if (!tooltipModel) {\n                return;\n            }\n\n            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n            this._lastX = e.offsetX;\n            this._lastY = e.offsetY;\n\n            var dataByCoordSys = e.dataByCoordSys;\n            if (dataByCoordSys && dataByCoordSys.length) {\n                this._showAxisTooltip(dataByCoordSys, e);\n            }\n            // Always show item tooltip if mouse is on the element with dataIndex\n            else if (el && el.dataIndex != null) {\n                this._lastDataByCoordSys = null;\n                this._showSeriesItemTooltip(e, el, dispatchAction);\n            }\n            // Tooltip provided directly. Like legend.\n            else if (el && el.tooltip) {\n                this._lastDataByCoordSys = null;\n                this._showComponentItemTooltip(e, el, dispatchAction);\n            }\n            else {\n                this._lastDataByCoordSys = null;\n                this._hide(dispatchAction);\n            }\n        },\n\n        _showOrMove: function (tooltipModel, cb) {\n            // showDelay is used in this case: tooltip.enterable is set\n            // as true. User intent to move mouse into tooltip and click\n            // something. `showDelay` makes it easyer to enter the content\n            // but tooltip do not move immediately.\n            var delay = tooltipModel.get('showDelay');\n            cb = zrUtil.bind(cb, this);\n            clearTimeout(this._showTimout);\n            delay > 0\n                ? (this._showTimout = setTimeout(cb, delay))\n                : cb();\n        },\n\n        _showAxisTooltip: function (dataByCoordSys, e) {\n            var ecModel = this._ecModel;\n            var globalTooltipModel = this._tooltipModel;\n            var point = [e.offsetX, e.offsetY];\n            var singleDefaultHTML = [];\n            var singleParamsList = [];\n            var singleTooltipModel = buildTooltipModel([\n                e.tooltipOption,\n                globalTooltipModel\n            ]);\n\n            each(dataByCoordSys, function (itemCoordSys) {\n                // var coordParamList = [];\n                // var coordDefaultHTML = [];\n                // var coordTooltipModel = buildTooltipModel([\n                //     e.tooltipOption,\n                //     itemCoordSys.tooltipOption,\n                //     ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex),\n                //     globalTooltipModel\n                // ]);\n                // var displayMode = coordTooltipModel.get('displayMode');\n                // var paramsList = displayMode === 'single' ? singleParamsList : [];\n\n                each(itemCoordSys.dataByAxis, function (item) {\n                    var axisModel = ecModel.getComponent(item.axisDim + 'Axis', item.axisIndex);\n                    var axisValue = item.value;\n                    var seriesDefaultHTML = [];\n\n                    if (!axisModel || axisValue == null) {\n                        return;\n                    }\n\n                    var valueLabel = axisPointerViewHelper.getValueLabel(\n                        axisValue, axisModel.axis, ecModel,\n                        item.seriesDataIndices,\n                        item.valueLabelOpt\n                    );\n\n                    zrUtil.each(item.seriesDataIndices, function (idxItem) {\n                        var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n                        var dataIndex = idxItem.dataIndexInside;\n                        var dataParams = series && series.getDataParams(dataIndex);\n                        dataParams.axisDim = item.axisDim;\n                        dataParams.axisIndex = item.axisIndex;\n                        dataParams.axisType = item.axisType;\n                        dataParams.axisId = item.axisId;\n                        dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue);\n                        dataParams.axisValueLabel = valueLabel;\n\n                        if (dataParams) {\n                            singleParamsList.push(dataParams);\n                            seriesDefaultHTML.push(series.formatTooltip(dataIndex, true));\n                        }\n                    });\n\n                    // Default tooltip content\n                    // FIXME\n                    // (1) shold be the first data which has name?\n                    // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n                    var firstLine = valueLabel;\n                    singleDefaultHTML.push(\n                        (firstLine ? formatUtil.encodeHTML(firstLine) + '<br />' : '')\n                        + seriesDefaultHTML.join('<br />')\n                    );\n                });\n            }, this);\n\n            // In most case, the second axis is shown upper than the first one.\n            singleDefaultHTML.reverse();\n            singleDefaultHTML = singleDefaultHTML.join('<br /><br />');\n\n            var positionExpr = e.position;\n            this._showOrMove(singleTooltipModel, function () {\n                if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {\n                    this._updatePosition(\n                        singleTooltipModel,\n                        positionExpr,\n                        point[0], point[1],\n                        this._tooltipContent,\n                        singleParamsList\n                    );\n                }\n                else {\n                    this._showTooltipContent(\n                        singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(),\n                        point[0], point[1], positionExpr\n                    );\n                }\n            });\n\n            // Do not trigger events here, because this branch only be entered\n            // from dispatchAction.\n        },\n\n        _showSeriesItemTooltip: function (e, el, dispatchAction) {\n            var ecModel = this._ecModel;\n            // Use dataModel in element if possible\n            // Used when mouseover on a element like markPoint or edge\n            // In which case, the data is not main data in series.\n            var seriesIndex = el.seriesIndex;\n            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n\n            // For example, graph link.\n            var dataModel = el.dataModel || seriesModel;\n            var dataIndex = el.dataIndex;\n            var dataType = el.dataType;\n            var data = dataModel.getData();\n\n            var tooltipModel = buildTooltipModel([\n                data.getItemModel(dataIndex),\n                dataModel,\n                seriesModel && (seriesModel.coordinateSystem || {}).model,\n                this._tooltipModel\n            ]);\n\n            var tooltipTrigger = tooltipModel.get('trigger');\n            if (tooltipTrigger != null && tooltipTrigger !== 'item') {\n                return;\n            }\n\n            var params = dataModel.getDataParams(dataIndex, dataType);\n            var defaultHtml = dataModel.formatTooltip(dataIndex, false, dataType);\n            var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;\n\n            this._showOrMove(tooltipModel, function () {\n                this._showTooltipContent(\n                    tooltipModel, defaultHtml, params, asyncTicket,\n                    e.offsetX, e.offsetY, e.position, e.target\n                );\n            });\n\n            // FIXME\n            // duplicated showtip if manuallyShowTip is called from dispatchAction.\n            dispatchAction({\n                type: 'showTip',\n                dataIndexInside: dataIndex,\n                dataIndex: data.getRawIndex(dataIndex),\n                seriesIndex: seriesIndex,\n                from: this.uid\n            });\n        },\n\n        _showComponentItemTooltip: function (e, el, dispatchAction) {\n            var tooltipOpt = el.tooltip;\n            if (typeof tooltipOpt === 'string') {\n                var content = tooltipOpt;\n                tooltipOpt = {\n                    content: content,\n                    // Fixed formatter\n                    formatter: content\n                };\n            }\n            var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel);\n            var defaultHtml = subTooltipModel.get('content');\n            var asyncTicket = Math.random();\n\n            // Do not check whether `trigger` is 'none' here, because `trigger`\n            // only works on cooridinate system. In fact, we have not found case\n            // that requires setting `trigger` nothing on component yet.\n\n            this._showOrMove(subTooltipModel, function () {\n                this._showTooltipContent(\n                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},\n                    asyncTicket, e.offsetX, e.offsetY, e.position, el\n                );\n            });\n\n            // If not dispatch showTip, tip may be hide triggered by axis.\n            dispatchAction({\n                type: 'showTip',\n                from: this.uid\n            });\n        },\n\n        _showTooltipContent: function (\n            tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el\n        ) {\n            // Reset ticket\n            this._ticket = '';\n\n            if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {\n                return;\n            }\n\n            var tooltipContent = this._tooltipContent;\n\n            var formatter = tooltipModel.get('formatter');\n            positionExpr = positionExpr || tooltipModel.get('position');\n            var html = defaultHtml;\n\n            if (formatter && typeof formatter === 'string') {\n                html = formatUtil.formatTpl(formatter, params, true);\n            }\n            else if (typeof formatter === 'function') {\n                var callback = bind(function (cbTicket, html) {\n                    if (cbTicket === this._ticket) {\n                        tooltipContent.setContent(html);\n                        this._updatePosition(\n                            tooltipModel, positionExpr, x, y, tooltipContent, params, el\n                        );\n                    }\n                }, this);\n                this._ticket = asyncTicket;\n                html = formatter(params, asyncTicket, callback);\n            }\n\n            tooltipContent.setContent(html);\n            tooltipContent.show(tooltipModel);\n\n            this._updatePosition(\n                tooltipModel, positionExpr, x, y, tooltipContent, params, el\n            );\n        },\n\n        /**\n         * @param  {string|Function|Array.<number>|Object} positionExpr\n         * @param  {number} x Mouse x\n         * @param  {number} y Mouse y\n         * @param  {boolean} confine Whether confine tooltip content in view rect.\n         * @param  {Object|<Array.<Object>} params\n         * @param  {module:zrender/Element} el target element\n         * @param  {module:echarts/ExtensionAPI} api\n         * @return {Array.<number>}\n         */\n        _updatePosition: function (tooltipModel, positionExpr, x, y, content, params, el) {\n            var viewWidth = this._api.getWidth();\n            var viewHeight = this._api.getHeight();\n            positionExpr = positionExpr || tooltipModel.get('position');\n\n            var contentSize = content.getSize();\n            var align = tooltipModel.get('align');\n            var vAlign = tooltipModel.get('verticalAlign');\n            var rect = el && el.getBoundingRect().clone();\n            el && rect.applyTransform(el.transform);\n\n            if (typeof positionExpr === 'function') {\n                // Callback of position can be an array or a string specify the position\n                positionExpr = positionExpr([x, y], params, content.el, rect, {\n                    viewSize: [viewWidth, viewHeight],\n                    contentSize: contentSize.slice()\n                });\n            }\n\n            if (zrUtil.isArray(positionExpr)) {\n                x = parsePercent(positionExpr[0], viewWidth);\n                y = parsePercent(positionExpr[1], viewHeight);\n            }\n            else if (zrUtil.isObject(positionExpr)) {\n                positionExpr.width = contentSize[0];\n                positionExpr.height = contentSize[1];\n                var layoutRect = layoutUtil.getLayoutRect(\n                    positionExpr, {width: viewWidth, height: viewHeight}\n                );\n                x = layoutRect.x;\n                y = layoutRect.y;\n                align = null;\n                // When positionExpr is left/top/right/bottom,\n                // align and verticalAlign will not work.\n                vAlign = null;\n            }\n            // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n            else if (typeof positionExpr === 'string' && el) {\n                var pos = calcTooltipPosition(\n                    positionExpr, rect, contentSize\n                );\n                x = pos[0];\n                y = pos[1];\n            }\n            else {\n                var pos = refixTooltipPosition(\n                    x, y, content.el, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20\n                );\n                x = pos[0];\n                y = pos[1];\n            }\n\n            align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);\n            vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);\n\n            if (tooltipModel.get('confine')) {\n                var pos = confineTooltipPosition(\n                    x, y, content.el, viewWidth, viewHeight\n                );\n                x = pos[0];\n                y = pos[1];\n            }\n\n            content.moveTo(x, y);\n        },\n\n        // FIXME\n        // Should we remove this but leave this to user?\n        _updateContentNotChangedOnAxis: function (dataByCoordSys) {\n            var lastCoordSys = this._lastDataByCoordSys;\n            var contentNotChanged = !!lastCoordSys\n                && lastCoordSys.length === dataByCoordSys.length;\n\n            contentNotChanged && each(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {\n                var lastDataByAxis = lastItemCoordSys.dataByAxis || {};\n                var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};\n                var thisDataByAxis = thisItemCoordSys.dataByAxis || [];\n                contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;\n\n                contentNotChanged && each(lastDataByAxis, function (lastItem, indexAxis) {\n                    var thisItem = thisDataByAxis[indexAxis] || {};\n                    var lastIndices = lastItem.seriesDataIndices || [];\n                    var newIndices = thisItem.seriesDataIndices || [];\n\n                    contentNotChanged &=\n                        lastItem.value === thisItem.value\n                        && lastItem.axisType === thisItem.axisType\n                        && lastItem.axisId === thisItem.axisId\n                        && lastIndices.length === newIndices.length;\n\n                    contentNotChanged && each(lastIndices, function (lastIdxItem, j) {\n                        var newIdxItem = newIndices[j];\n                        contentNotChanged &=\n                            lastIdxItem.seriesIndex === newIdxItem.seriesIndex\n                            && lastIdxItem.dataIndex === newIdxItem.dataIndex;\n                    });\n                });\n            });\n\n            this._lastDataByCoordSys = dataByCoordSys;\n\n            return !!contentNotChanged;\n        },\n\n        _hide: function (dispatchAction) {\n            // Do not directly hideLater here, because this behavior may be prevented\n            // in dispatchAction when showTip is dispatched.\n\n            // FIXME\n            // duplicated hideTip if manuallyHideTip is called from dispatchAction.\n            this._lastDataByCoordSys = null;\n            dispatchAction({\n                type: 'hideTip',\n                from: this.uid\n            });\n        },\n\n        dispose: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            this._tooltipContent.hide();\n            globalListener.unregister('itemTooltip', api);\n        }\n    });\n\n\n    /**\n     * @param {Array.<Object|module:echarts/model/Model>} modelCascade\n     * From top to bottom. (the last one should be globalTooltipModel);\n     */\n    function buildTooltipModel(modelCascade) {\n        var resultModel = modelCascade.pop();\n        while (modelCascade.length) {\n            var tooltipOpt = modelCascade.pop();\n            if (tooltipOpt) {\n                if (tooltipOpt instanceof Model) {\n                    tooltipOpt = tooltipOpt.get('tooltip', true);\n                }\n                // In each data item tooltip can be simply write:\n                // {\n                //  value: 10,\n                //  tooltip: 'Something you need to know'\n                // }\n                if (typeof tooltipOpt === 'string') {\n                    tooltipOpt = {formatter: tooltipOpt};\n                }\n                resultModel = new Model(tooltipOpt, resultModel, resultModel.ecModel);\n            }\n        }\n        return resultModel;\n    }\n\n    function makeDispatchAction(payload, api) {\n        return payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);\n    }\n\n    function refixTooltipPosition(x, y, el, viewWidth, viewHeight, gapH, gapV) {\n        var size = getOuterSize(el);\n        var width = size.width;\n        var height = size.height;\n\n        if (gapH != null) {\n            if (x + width + gapH > viewWidth) {\n                x -= width + gapH;\n            }\n            else {\n                x += gapH;\n            }\n        }\n        if (gapV != null) {\n            if (y + height + gapV > viewHeight) {\n                y -= height + gapV;\n            }\n            else {\n                y += gapV;\n            }\n        }\n        return [x, y];\n    }\n\n    function confineTooltipPosition(x, y, el, viewWidth, viewHeight) {\n        var size = getOuterSize(el);\n        var width = size.width;\n        var height = size.height;\n\n        x = Math.min(x + width, viewWidth) - width;\n        y = Math.min(y + height, viewHeight) - height;\n        x = Math.max(x, 0);\n        y = Math.max(y, 0);\n\n        return [x, y];\n    }\n\n    function getOuterSize(el) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n\n        // Consider browser compatibility.\n        // IE8 does not support getComputedStyle.\n        if (document.defaultView && document.defaultView.getComputedStyle) {\n            var stl = document.defaultView.getComputedStyle(el);\n            if (stl) {\n                width += parseInt(stl.paddingLeft, 10) + parseInt(stl.paddingRight, 10)\n                    + parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10);\n                height += parseInt(stl.paddingTop, 10) + parseInt(stl.paddingBottom, 10)\n                    + parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10);\n            }\n        }\n\n        return {width: width, height: height};\n    }\n\n    function calcTooltipPosition(position, rect, contentSize) {\n        var domWidth = contentSize[0];\n        var domHeight = contentSize[1];\n        var gap = 5;\n        var x = 0;\n        var y = 0;\n        var rectWidth = rect.width;\n        var rectHeight = rect.height;\n        switch (position) {\n            case 'inside':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'top':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y - domHeight - gap;\n                break;\n            case 'bottom':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight + gap;\n                break;\n            case 'left':\n                x = rect.x - domWidth - gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'right':\n                x = rect.x + rectWidth + gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n        }\n        return [x, y];\n    }\n\n    function isCenterAlign(align) {\n        return align === 'center' || align === 'middle';\n    }\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/tooltip/TooltipView.js\n// module id = 1129\n// module chunks = 0 1 2","/**\n * @module echarts/component/tooltip/TooltipContent\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var zrColor = require('zrender/lib/tool/color');\n    var eventUtil = require('zrender/lib/core/event');\n    var formatUtil = require('../../util/format');\n    var each = zrUtil.each;\n    var toCamelCase = formatUtil.toCamelCase;\n    var env = require('zrender/lib/core/env');\n\n    var vendors = ['', '-webkit-', '-moz-', '-o-'];\n\n    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n\n    /**\n     * @param {number} duration\n     * @return {string}\n     * @inner\n     */\n    function assembleTransition(duration) {\n        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','\n                            + 'top ' + duration + 's ' + transitionCurve;\n        return zrUtil.map(vendors, function (vendorPrefix) {\n            return vendorPrefix + 'transition:' + transitionText;\n        }).join(';');\n    }\n\n    /**\n     * @param {Object} textStyle\n     * @return {string}\n     * @inner\n     */\n    function assembleFont(textStyleModel) {\n        var cssText = [];\n\n        var fontSize = textStyleModel.get('fontSize');\n        var color = textStyleModel.getTextColor();\n\n        color && cssText.push('color:' + color);\n\n        cssText.push('font:' + textStyleModel.getFont());\n\n        fontSize &&\n            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n\n        each(['decoration', 'align'], function (name) {\n            var val = textStyleModel.get(name);\n            val && cssText.push('text-' + name + ':' + val);\n        });\n\n        return cssText.join(';');\n    }\n\n    /**\n     * @param {Object} tooltipModel\n     * @return {string}\n     * @inner\n     */\n    function assembleCssText(tooltipModel) {\n\n        var cssText = [];\n\n        var transitionDuration = tooltipModel.get('transitionDuration');\n        var backgroundColor = tooltipModel.get('backgroundColor');\n        var textStyleModel = tooltipModel.getModel('textStyle');\n        var padding = tooltipModel.get('padding');\n\n        // Animation transition. Do not animate when transitionDuration is 0.\n        transitionDuration &&\n            cssText.push(assembleTransition(transitionDuration));\n\n        if (backgroundColor) {\n            if (env.canvasSupported) {\n                cssText.push('background-Color:' + backgroundColor);\n            }\n            else {\n                // for ie\n                cssText.push(\n                    'background-Color:#' + zrColor.toHex(backgroundColor)\n                );\n                cssText.push('filter:alpha(opacity=70)');\n            }\n        }\n\n        // Border style\n        each(['width', 'color', 'radius'], function (name) {\n            var borderName = 'border-' + name;\n            var camelCase = toCamelCase(borderName);\n            var val = tooltipModel.get(camelCase);\n            val != null &&\n                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n        });\n\n        // Text style\n        cssText.push(assembleFont(textStyleModel));\n\n        // Padding\n        if (padding != null) {\n            cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n        }\n\n        return cssText.join(';') + ';';\n    }\n\n    /**\n     * @alias module:echarts/component/tooltip/TooltipContent\n     * @constructor\n     */\n    function TooltipContent(container, api) {\n        var el = document.createElement('div');\n        var zr = this._zr = api.getZr();\n\n        this.el = el;\n\n        this._x = api.getWidth() / 2;\n        this._y = api.getHeight() / 2;\n\n        container.appendChild(el);\n\n        this._container = container;\n\n        this._show = false;\n\n        /**\n         * @private\n         */\n        this._hideTimeout;\n\n        var self = this;\n        el.onmouseenter = function () {\n            // clear the timeout in hideLater and keep showing tooltip\n            if (self._enterable) {\n                clearTimeout(self._hideTimeout);\n                self._show = true;\n            }\n            self._inContent = true;\n        };\n        el.onmousemove = function (e) {\n            e = e || window.event;\n            if (!self._enterable) {\n                // Try trigger zrender event to avoid mouse\n                // in and out shape too frequently\n                var handler = zr.handler;\n                eventUtil.normalizeEvent(container, e, true);\n                handler.dispatch('mousemove', e);\n            }\n        };\n        el.onmouseleave = function () {\n            if (self._enterable) {\n                if (self._show) {\n                    self.hideLater(self._hideDelay);\n                }\n            }\n            self._inContent = false;\n        };\n    }\n\n    TooltipContent.prototype = {\n\n        constructor: TooltipContent,\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        _enterable: true,\n\n        /**\n         * Update when tooltip is rendered\n         */\n        update: function () {\n            // FIXME\n            // Move this logic to ec main?\n            var container = this._container;\n            var stl = container.currentStyle\n                || document.defaultView.getComputedStyle(container);\n            var domStyle = container.style;\n            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n                domStyle.position = 'relative';\n            }\n            // Hide the tooltip\n            // PENDING\n            // this.hide();\n        },\n\n        show: function (tooltipModel) {\n            clearTimeout(this._hideTimeout);\n            var el = this.el;\n\n            el.style.cssText = gCssText + assembleCssText(tooltipModel)\n                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n                + ';left:' + this._x + 'px;top:' + this._y + 'px;'\n                + (tooltipModel.get('extraCssText') || '');\n\n            el.style.display = el.innerHTML ?  'block' : 'none';\n\n            this._show = true;\n        },\n\n        setContent: function (content) {\n            this.el.innerHTML = content == null ? '' : content;\n        },\n\n        setEnterable: function (enterable) {\n            this._enterable = enterable;\n        },\n\n        getSize: function () {\n            var el = this.el;\n            return [el.clientWidth, el.clientHeight];\n        },\n\n        moveTo: function (x, y) {\n            // xy should be based on canvas root. But tooltipContent is\n            // the sibling of canvas root. So padding of ec container\n            // should be considered here.\n            var zr = this._zr;\n            var viewportRootOffset;\n            if (zr && zr.painter && (viewportRootOffset = zr.painter.getViewportRootOffset())) {\n                x += viewportRootOffset.offsetLeft;\n                y += viewportRootOffset.offsetTop;\n            }\n\n            var style = this.el.style;\n            style.left = x + 'px';\n            style.top = y + 'px';\n\n            this._x = x;\n            this._y = y;\n        },\n\n        hide: function () {\n            this.el.style.display = 'none';\n            this._show = false;\n        },\n\n        hideLater: function (time) {\n            if (this._show && !(this._inContent && this._enterable)) {\n                if (time) {\n                    this._hideDelay = time;\n                    // Set show false to avoid invoke hideLater mutiple times\n                    this._show = false;\n                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n                }\n                else {\n                    this.hide();\n                }\n            }\n        },\n\n        isShow: function () {\n            return this._show;\n        }\n    };\n\n    module.exports = TooltipContent;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/tooltip/TooltipContent.js\n// module id = 1130\n// module chunks = 0 1 2","/**\n * @file Legend action\n */\n\n\n    var echarts = require('../../echarts');\n    var zrUtil = require('zrender/lib/core/util');\n\n    function legendSelectActionHandler(methodName, payload, ecModel) {\n        var selectedMap = {};\n        var isToggleSelect = methodName === 'toggleSelected';\n        var isSelected;\n        // Update all legend components\n        ecModel.eachComponent('legend', function (legendModel) {\n            if (isToggleSelect && isSelected != null) {\n                // Force other legend has same selected status\n                // Or the first is toggled to true and other are toggled to false\n                // In the case one legend has some item unSelected in option. And if other legend\n                // doesn't has the item, they will assume it is selected.\n                legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n            }\n            else {\n                legendModel[methodName](payload.name);\n                isSelected = legendModel.isSelected(payload.name);\n            }\n            var legendData = legendModel.getData();\n            zrUtil.each(legendData, function (model) {\n                var name = model.get('name');\n                // Wrap element\n                if (name === '\\n' || name === '') {\n                    return;\n                }\n                var isItemSelected = legendModel.isSelected(name);\n                if (selectedMap.hasOwnProperty(name)) {\n                    // Unselected if any legend is unselected\n                    selectedMap[name] = selectedMap[name] && isItemSelected;\n                }\n                else {\n                    selectedMap[name] = isItemSelected;\n                }\n            });\n        });\n        // Return the event explicitly\n        return {\n            name: payload.name,\n            selected: selectedMap\n        };\n    }\n    /**\n     * @event legendToggleSelect\n     * @type {Object}\n     * @property {string} type 'legendToggleSelect'\n     * @property {string} [from]\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendToggleSelect', 'legendselectchanged',\n        zrUtil.curry(legendSelectActionHandler, 'toggleSelected')\n    );\n\n    /**\n     * @event legendSelect\n     * @type {Object}\n     * @property {string} type 'legendSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendSelect', 'legendselected',\n        zrUtil.curry(legendSelectActionHandler, 'select')\n    );\n\n    /**\n     * @event legendUnSelect\n     * @type {Object}\n     * @property {string} type 'legendUnSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendUnSelect', 'legendunselected',\n        zrUtil.curry(legendSelectActionHandler, 'unSelect')\n    );\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/legendAction.js\n// module id = 1131\n// module chunks = 0 1 2","\n   module.exports = function (ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (legendModels && legendModels.length) {\n            ecModel.filterSeries(function (series) {\n                // If in any legend component the status is not selected.\n                // Because in legend series is assumed selected when it is not in the legend data.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(series.name)) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/legend/legendFilter.js\n// module id = 1132\n// module chunks = 0 1 2","/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n *\n * @module echarts/chart/helper/DataSelectable\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    module.exports = {\n\n        updateSelectedMap: function (targetList) {\n            this._targetList = targetList.slice();\n            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n                targetMap.set(target.name, target);\n                return targetMap;\n            }, zrUtil.createHashMap());\n        },\n\n        /**\n         * Either name or id should be passed as input here.\n         * If both of them are defined, id is used.\n         *\n         * @param {string|undefined} name name of data\n         * @param {number|undefined} id dataIndex of data\n         */\n        // PENGING If selectedMode is null ?\n        select: function (name, id) {\n            var target = id != null\n                ? this._targetList[id]\n                : this._selectTargetMap.get(name);\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                this._selectTargetMap.each(function (target) {\n                    target.selected = false;\n                });\n            }\n            target && (target.selected = true);\n        },\n\n        /**\n         * Either name or id should be passed as input here.\n         * If both of them are defined, id is used.\n         *\n         * @param {string|undefined} name name of data\n         * @param {number|undefined} id dataIndex of data\n         */\n        unSelect: function (name, id) {\n            var target = id != null\n                ? this._targetList[id]\n                : this._selectTargetMap.get(name);\n            // var selectedMode = this.get('selectedMode');\n            // selectedMode !== 'single' && target && (target.selected = false);\n            target && (target.selected = false);\n        },\n\n        /**\n         * Either name or id should be passed as input here.\n         * If both of them are defined, id is used.\n         *\n         * @param {string|undefined} name name of data\n         * @param {number|undefined} id dataIndex of data\n         */\n        toggleSelected: function (name, id) {\n            var target = id != null\n                ? this._targetList[id]\n                : this._selectTargetMap.get(name);\n            if (target != null) {\n                this[target.selected ? 'unSelect' : 'select'](name, id);\n                return target.selected;\n            }\n        },\n\n        /**\n         * Either name or id should be passed as input here.\n         * If both of them are defined, id is used.\n         *\n         * @param {string|undefined} name name of data\n         * @param {number|undefined} id dataIndex of data\n         */\n        isSelected: function (name, id) {\n            var target = id != null\n                ? this._targetList[id]\n                : this._selectTargetMap.get(name);\n            return target && target.selected;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/helper/selectableMixin.js\n// module id = 1133\n// module chunks = 0 2","// Pick color from palette for each data item.\n// Applicable for charts that require applying color palette\n// in data level (like pie, funnel, chord).\n\n\n    module.exports = function (seriesType, ecModel) {\n        // Pie and funnel may use diferrent scope\n        var paletteScope = {};\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var dataAll = seriesModel.getRawData();\n            var idxMap = {};\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                var data = seriesModel.getData();\n                data.each(function (idx) {\n                    var rawIdx = data.getRawIndex(idx);\n                    idxMap[rawIdx] = idx;\n                });\n                dataAll.each(function (rawIdx) {\n                    var filteredIdx = idxMap[rawIdx];\n\n                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n                    var singleDataColor = filteredIdx != null\n                        && data.getItemVisual(filteredIdx, 'color', true);\n\n                    if (!singleDataColor) {\n                        // FIXME Performance\n                        var itemModel = dataAll.getItemModel(rawIdx);\n                        var color = itemModel.get('itemStyle.normal.color')\n                            || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n                        // Legend may use the visual info in data before processed\n                        dataAll.setItemVisual(rawIdx, 'color', color);\n\n                        // Data is not filtered\n                        if (filteredIdx != null) {\n                            data.setItemVisual(filteredIdx, 'color', color);\n                        }\n                    }\n                    else {\n                        // Set data all color for legend\n                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n                    }\n                });\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/visual/dataColor.js\n// module id = 1134\n// module chunks = 0 2","\n\n    var featureManager = require('./featureManager');\n    var zrUtil = require('zrender/lib/core/util');\n\n    var ToolboxModel = require('../../echarts').extendComponentModel({\n\n        type: 'toolbox',\n\n        layoutMode: {\n            type: 'box',\n            ignoreSize: true\n        },\n\n        mergeDefaultAndTheme: function (option) {\n            ToolboxModel.superApply(this, 'mergeDefaultAndTheme', arguments);\n\n            zrUtil.each(this.option.feature, function (featureOpt, featureName) {\n                var Feature = featureManager.get(featureName);\n                Feature && zrUtil.merge(featureOpt, Feature.defaultOption);\n            });\n        },\n\n        defaultOption: {\n\n            show: true,\n\n            z: 6,\n\n            zlevel: 0,\n\n            orient: 'horizontal',\n\n            left: 'right',\n\n            top: 'top',\n\n            // right\n            // bottom\n\n            backgroundColor: 'transparent',\n\n            borderColor: '#ccc',\n\n            borderRadius: 0,\n\n            borderWidth: 0,\n\n            padding: 5,\n\n            itemSize: 15,\n\n            itemGap: 8,\n\n            showTitle: true,\n\n            iconStyle: {\n                normal: {\n                    borderColor: '#666',\n                    color: 'none'\n                },\n                emphasis: {\n                    borderColor: '#3E98C5'\n                }\n            }\n            // textStyle: {},\n\n            // feature\n        }\n    });\n\n    module.exports = ToolboxModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/ToolboxModel.js\n// module id = 1135\n// module chunks = 0 1 2","\n\n    var featureManager = require('./featureManager');\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n    var Model = require('../../model/Model');\n    var DataDiffer = require('../../data/DataDiffer');\n    var listComponentHelper = require('../helper/listComponent');\n    var textContain = require('zrender/lib/contain/text');\n\n    module.exports = require('../../echarts').extendComponentView({\n\n        type: 'toolbox',\n\n        render: function (toolboxModel, ecModel, api, payload) {\n            var group = this.group;\n            group.removeAll();\n\n            if (!toolboxModel.get('show')) {\n                return;\n            }\n\n            var itemSize = +toolboxModel.get('itemSize');\n            var featureOpts = toolboxModel.get('feature') || {};\n            var features = this._features || (this._features = {});\n\n            var featureNames = [];\n            zrUtil.each(featureOpts, function (opt, name) {\n                featureNames.push(name);\n            });\n\n            (new DataDiffer(this._featureNames || [], featureNames))\n                .add(process)\n                .update(process)\n                .remove(zrUtil.curry(process, null))\n                .execute();\n\n            // Keep for diff.\n            this._featureNames = featureNames;\n\n            function process(newIndex, oldIndex) {\n                var featureName = featureNames[newIndex];\n                var oldName = featureNames[oldIndex];\n                var featureOpt = featureOpts[featureName];\n                var featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel);\n                var feature;\n\n                if (featureName && !oldName) { // Create\n                    if (isUserFeatureName(featureName)) {\n                        feature = {\n                            model: featureModel,\n                            onclick: featureModel.option.onclick,\n                            featureName: featureName\n                        };\n                    }\n                    else {\n                        var Feature = featureManager.get(featureName);\n                        if (!Feature) {\n                            return;\n                        }\n                        feature = new Feature(featureModel, ecModel, api);\n                    }\n                    features[featureName] = feature;\n                }\n                else {\n                    feature = features[oldName];\n                    // If feature does not exsit.\n                    if (!feature) {\n                        return;\n                    }\n                    feature.model = featureModel;\n                    feature.ecModel = ecModel;\n                    feature.api = api;\n                }\n\n                if (!featureName && oldName) {\n                    feature.dispose && feature.dispose(ecModel, api);\n                    return;\n                }\n\n                if (!featureModel.get('show') || feature.unusable) {\n                    feature.remove && feature.remove(ecModel, api);\n                    return;\n                }\n\n                createIconPaths(featureModel, feature, featureName);\n\n                featureModel.setIconStatus = function (iconName, status) {\n                    var option = this.option;\n                    var iconPaths = this.iconPaths;\n                    option.iconStatus = option.iconStatus || {};\n                    option.iconStatus[iconName] = status;\n                    // FIXME\n                    iconPaths[iconName] && iconPaths[iconName].trigger(status);\n                };\n\n                if (feature.render) {\n                    feature.render(featureModel, ecModel, api, payload);\n                }\n            }\n\n            function createIconPaths(featureModel, feature, featureName) {\n                var iconStyleModel = featureModel.getModel('iconStyle');\n\n                // If one feature has mutiple icon. they are orginaized as\n                // {\n                //     icon: {\n                //         foo: '',\n                //         bar: ''\n                //     },\n                //     title: {\n                //         foo: '',\n                //         bar: ''\n                //     }\n                // }\n                var icons = feature.getIcons ? feature.getIcons() : featureModel.get('icon');\n                var titles = featureModel.get('title') || {};\n                if (typeof icons === 'string') {\n                    var icon = icons;\n                    var title = titles;\n                    icons = {};\n                    titles = {};\n                    icons[featureName] = icon;\n                    titles[featureName] = title;\n                }\n                var iconPaths = featureModel.iconPaths = {};\n                zrUtil.each(icons, function (iconStr, iconName) {\n                    var path = graphic.createIcon(\n                        iconStr,\n                        {},\n                        {\n                            x: -itemSize / 2,\n                            y: -itemSize / 2,\n                            width: itemSize,\n                            height: itemSize\n                        }\n                    );\n                    path.setStyle(iconStyleModel.getModel('normal').getItemStyle());\n                    path.hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();\n\n                    graphic.setHoverStyle(path);\n\n                    if (toolboxModel.get('showTitle')) {\n                        path.__title = titles[iconName];\n                        path.on('mouseover', function () {\n                                // Should not reuse above hoverStyle, which might be modified.\n                                var hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();\n                                path.setStyle({\n                                    text: titles[iconName],\n                                    textPosition: hoverStyle.textPosition || 'bottom',\n                                    textFill: hoverStyle.fill || hoverStyle.stroke || '#000',\n                                    textAlign: hoverStyle.textAlign || 'center'\n                                });\n                            })\n                            .on('mouseout', function () {\n                                path.setStyle({\n                                    textFill: null\n                                });\n                            });\n                    }\n                    path.trigger(featureModel.get('iconStatus.' + iconName) || 'normal');\n\n                    group.add(path);\n                    path.on('click', zrUtil.bind(\n                        feature.onclick, feature, ecModel, api, iconName\n                    ));\n\n                    iconPaths[iconName] = path;\n                });\n            }\n\n            listComponentHelper.layout(group, toolboxModel, api);\n            // Render background after group is layout\n            // FIXME\n            group.add(listComponentHelper.makeBackground(group.getBoundingRect(), toolboxModel));\n\n            // Adjust icon title positions to avoid them out of screen\n            group.eachChild(function (icon) {\n                var titleText = icon.__title;\n                var hoverStyle = icon.hoverStyle;\n                // May be background element\n                if (hoverStyle && titleText) {\n                    var rect = textContain.getBoundingRect(\n                        titleText, textContain.makeFont(hoverStyle)\n                    );\n                    var offsetX = icon.position[0] + group.position[0];\n                    var offsetY = icon.position[1] + group.position[1] + itemSize;\n\n                    var needPutOnTop = false;\n                    if (offsetY + rect.height > api.getHeight()) {\n                        hoverStyle.textPosition = 'top';\n                        needPutOnTop = true;\n                    }\n                    var topOffset = needPutOnTop ? (-5 - rect.height) : (itemSize + 8);\n                    if (offsetX + rect.width /  2 > api.getWidth()) {\n                        hoverStyle.textPosition = ['100%', topOffset];\n                        hoverStyle.textAlign = 'right';\n                    }\n                    else if (offsetX - rect.width / 2 < 0) {\n                        hoverStyle.textPosition = [0, topOffset];\n                        hoverStyle.textAlign = 'left';\n                    }\n                }\n            });\n        },\n\n        updateView: function (toolboxModel, ecModel, api, payload) {\n            zrUtil.each(this._features, function (feature) {\n                feature.updateView && feature.updateView(feature.model, ecModel, api, payload);\n            });\n        },\n\n        updateLayout: function (toolboxModel, ecModel, api, payload) {\n            zrUtil.each(this._features, function (feature) {\n                feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);\n            });\n        },\n\n        remove: function (ecModel, api) {\n            zrUtil.each(this._features, function (feature) {\n                feature.remove && feature.remove(ecModel, api);\n            });\n            this.group.removeAll();\n        },\n\n        dispose: function (ecModel, api) {\n            zrUtil.each(this._features, function (feature) {\n                feature.dispose && feature.dispose(ecModel, api);\n            });\n        }\n    });\n\n    function isUserFeatureName(featureName) {\n        return featureName.indexOf('my') === 0;\n    }\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/ToolboxView.js\n// module id = 1136\n// module chunks = 0 1 2","\n\n    var env = require('zrender/lib/core/env');\n    var lang = require('../../../lang').toolbox.saveAsImage;\n\n    function SaveAsImage (model) {\n        this.model = model;\n    }\n\n    SaveAsImage.defaultOption = {\n        show: true,\n        icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',\n        title: lang.title,\n        type: 'png',\n        // Default use option.backgroundColor\n        // backgroundColor: '#fff',\n        name: '',\n        excludeComponents: ['toolbox'],\n        pixelRatio: 1,\n        lang: lang.lang.slice()\n    };\n\n    SaveAsImage.prototype.unusable = !env.canvasSupported;\n\n    var proto = SaveAsImage.prototype;\n\n    proto.onclick = function (ecModel, api) {\n        var model = this.model;\n        var title = model.get('name') || ecModel.get('title.0.text') || 'echarts';\n        var $a = document.createElement('a');\n        var type = model.get('type', true) || 'png';\n        $a.download = title + '.' + type;\n        $a.target = '_blank';\n        var url = api.getConnectedDataURL({\n            type: type,\n            backgroundColor: model.get('backgroundColor', true)\n                || ecModel.get('backgroundColor') || '#fff',\n            excludeComponents: model.get('excludeComponents'),\n            pixelRatio: model.get('pixelRatio')\n        });\n        $a.href = url;\n        // Chrome and Firefox\n        if (typeof MouseEvent === 'function' && !env.browser.ie && !env.browser.edge) {\n            var evt = new MouseEvent('click', {\n                view: window,\n                bubbles: true,\n                cancelable: false\n            });\n            $a.dispatchEvent(evt);\n        }\n        // IE\n        else {\n            if (window.navigator.msSaveOrOpenBlob) {\n                var bstr = atob(url.split(',')[1]);\n                var n = bstr.length;\n                var u8arr = new Uint8Array(n);\n                while(n--) {\n                    u8arr[n] = bstr.charCodeAt(n);\n                }\n                var blob = new Blob([u8arr]);\n                window.navigator.msSaveOrOpenBlob(blob, title + '.' + type);\n            }\n            else {\n                var lang = model.get('lang');\n                var html = '' +\n                    '<body style=\"margin:0;\">' +\n                    '<img src=\"' + url + '\" style=\"max-width:100%;\" title=\"' + ((lang && lang[0]) || '') + '\" />' +\n                    '</body>';\n                var tab = window.open();\n                tab.document.write(html);\n            }\n        }\n    };\n\n    require('../featureManager').register(\n        'saveAsImage', SaveAsImage\n    );\n\n    module.exports = SaveAsImage;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js\n// module id = 1137\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var lang = require('../../../lang').toolbox.magicType;\n\n    function MagicType(model) {\n        this.model = model;\n    }\n\n    MagicType.defaultOption = {\n        show: true,\n        type: [],\n        // Icon group\n        icon: {\n            line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',\n            bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',\n            stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z', // jshint ignore:line\n            tiled: 'M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z'\n        },\n        // `line`, `bar`, `stack`, `tiled`\n        title: zrUtil.clone(lang.title),\n        option: {},\n        seriesIndex: {}\n    };\n\n    var proto = MagicType.prototype;\n\n    proto.getIcons = function () {\n        var model = this.model;\n        var availableIcons = model.get('icon');\n        var icons = {};\n        zrUtil.each(model.get('type'), function (type) {\n            if (availableIcons[type]) {\n                icons[type] = availableIcons[type];\n            }\n        });\n        return icons;\n    };\n\n    var seriesOptGenreator = {\n        'line': function (seriesType, seriesId, seriesModel, model) {\n            if (seriesType === 'bar') {\n                return zrUtil.merge({\n                    id: seriesId,\n                    type: 'line',\n                    // Preserve data related option\n                    data: seriesModel.get('data'),\n                    stack: seriesModel.get('stack'),\n                    markPoint: seriesModel.get('markPoint'),\n                    markLine: seriesModel.get('markLine')\n                }, model.get('option.line') || {}, true);\n            }\n        },\n        'bar': function (seriesType, seriesId, seriesModel, model) {\n            if (seriesType === 'line') {\n                return zrUtil.merge({\n                    id: seriesId,\n                    type: 'bar',\n                    // Preserve data related option\n                    data: seriesModel.get('data'),\n                    stack: seriesModel.get('stack'),\n                    markPoint: seriesModel.get('markPoint'),\n                    markLine: seriesModel.get('markLine')\n                }, model.get('option.bar') || {}, true);\n            }\n        },\n        'stack': function (seriesType, seriesId, seriesModel, model) {\n            if (seriesType === 'line' || seriesType === 'bar') {\n                return zrUtil.merge({\n                    id: seriesId,\n                    stack: '__ec_magicType_stack__'\n                }, model.get('option.stack') || {}, true);\n            }\n        },\n        'tiled': function (seriesType, seriesId, seriesModel, model) {\n            if (seriesType === 'line' || seriesType === 'bar') {\n                return zrUtil.merge({\n                    id: seriesId,\n                    stack: ''\n                }, model.get('option.tiled') || {}, true);\n            }\n        }\n    };\n\n    var radioTypes = [\n        ['line', 'bar'],\n        ['stack', 'tiled']\n    ];\n\n    proto.onclick = function (ecModel, api, type) {\n        var model = this.model;\n        var seriesIndex = model.get('seriesIndex.' + type);\n        // Not supported magicType\n        if (!seriesOptGenreator[type]) {\n            return;\n        }\n        var newOption = {\n            series: []\n        };\n        var generateNewSeriesTypes = function (seriesModel) {\n            var seriesType = seriesModel.subType;\n            var seriesId = seriesModel.id;\n            var newSeriesOpt = seriesOptGenreator[type](\n                seriesType, seriesId, seriesModel, model\n            );\n            if (newSeriesOpt) {\n                // PENDING If merge original option?\n                zrUtil.defaults(newSeriesOpt, seriesModel.option);\n                newOption.series.push(newSeriesOpt);\n            }\n            // Modify boundaryGap\n            var coordSys = seriesModel.coordinateSystem;\n            if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {\n                var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n                if (categoryAxis) {\n                    var axisDim = categoryAxis.dim;\n                    var axisType = axisDim + 'Axis';\n                    var axisModel = ecModel.queryComponents({\n                        mainType: axisType,\n                        index: seriesModel.get(name + 'Index'),\n                        id: seriesModel.get(name + 'Id')\n                    })[0];\n                    var axisIndex = axisModel.componentIndex;\n\n                    newOption[axisType] = newOption[axisType] || [];\n                    for (var i = 0; i <= axisIndex; i++) {\n                        newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};\n                    }\n                    newOption[axisType][axisIndex].boundaryGap = type === 'bar' ? true : false;\n                }\n            }\n        };\n\n        zrUtil.each(radioTypes, function (radio) {\n            if (zrUtil.indexOf(radio, type) >= 0) {\n                zrUtil.each(radio, function (item) {\n                    model.setIconStatus(item, 'normal');\n                });\n            }\n        });\n\n        model.setIconStatus(type, 'emphasis');\n\n        ecModel.eachComponent(\n            {\n                mainType: 'series',\n                query: seriesIndex == null ? null : {\n                    seriesIndex: seriesIndex\n                }\n            }, generateNewSeriesTypes\n        );\n        api.dispatchAction({\n            type: 'changeMagicType',\n            currentType: type,\n            newOption: newOption\n        });\n    };\n\n    var echarts = require('../../../echarts');\n    echarts.registerAction({\n        type: 'changeMagicType',\n        event: 'magicTypeChanged',\n        update: 'prepareAndUpdate'\n    }, function (payload, ecModel) {\n        ecModel.mergeOption(payload.newOption);\n    });\n\n    require('../featureManager').register('magicType', MagicType);\n\n    module.exports = MagicType;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/feature/MagicType.js\n// module id = 1138\n// module chunks = 0 1 2","/**\n * @module echarts/component/toolbox/feature/DataView\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var eventTool = require('zrender/lib/core/event');\n    var lang = require('../../../lang').toolbox.dataView;\n\n    var BLOCK_SPLITER = new Array(60).join('-');\n    var ITEM_SPLITER = '\\t';\n    /**\n     * Group series into two types\n     *  1. on category axis, like line, bar\n     *  2. others, like scatter, pie\n     * @param {module:echarts/model/Global} ecModel\n     * @return {Object}\n     * @inner\n     */\n    function groupSeries(ecModel) {\n        var seriesGroupByCategoryAxis = {};\n        var otherSeries = [];\n        var meta = [];\n        ecModel.eachRawSeries(function (seriesModel) {\n            var coordSys = seriesModel.coordinateSystem;\n\n            if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {\n                var baseAxis = coordSys.getBaseAxis();\n                if (baseAxis.type === 'category') {\n                    var key = baseAxis.dim + '_' + baseAxis.index;\n                    if (!seriesGroupByCategoryAxis[key]) {\n                        seriesGroupByCategoryAxis[key] = {\n                            categoryAxis: baseAxis,\n                            valueAxis: coordSys.getOtherAxis(baseAxis),\n                            series: []\n                        };\n                        meta.push({\n                            axisDim: baseAxis.dim,\n                            axisIndex: baseAxis.index\n                        });\n                    }\n                    seriesGroupByCategoryAxis[key].series.push(seriesModel);\n                }\n                else {\n                    otherSeries.push(seriesModel);\n                }\n            }\n            else {\n                otherSeries.push(seriesModel);\n            }\n        });\n\n        return {\n            seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,\n            other: otherSeries,\n            meta: meta\n        };\n    }\n\n    /**\n     * Assemble content of series on cateogory axis\n     * @param {Array.<module:echarts/model/Series>} series\n     * @return {string}\n     * @inner\n     */\n    function assembleSeriesWithCategoryAxis(series) {\n        var tables = [];\n        zrUtil.each(series, function (group, key) {\n            var categoryAxis = group.categoryAxis;\n            var valueAxis = group.valueAxis;\n            var valueAxisDim = valueAxis.dim;\n\n            var headers = [' '].concat(zrUtil.map(group.series, function (series) {\n                return series.name;\n            }));\n            var columns = [categoryAxis.model.getCategories()];\n            zrUtil.each(group.series, function (series) {\n                columns.push(series.getRawData().mapArray(valueAxisDim, function (val) {\n                    return val;\n                }));\n            });\n            // Assemble table content\n            var lines = [headers.join(ITEM_SPLITER)];\n            for (var i = 0; i < columns[0].length; i++) {\n                var items = [];\n                for (var j = 0; j < columns.length; j++) {\n                    items.push(columns[j][i]);\n                }\n                lines.push(items.join(ITEM_SPLITER));\n            }\n            tables.push(lines.join('\\n'));\n        });\n        return tables.join('\\n\\n' +  BLOCK_SPLITER + '\\n\\n');\n    }\n\n    /**\n     * Assemble content of other series\n     * @param {Array.<module:echarts/model/Series>} series\n     * @return {string}\n     * @inner\n     */\n    function assembleOtherSeries(series) {\n        return zrUtil.map(series, function (series) {\n            var data = series.getRawData();\n            var lines = [series.name];\n            var vals = [];\n            data.each(data.dimensions, function () {\n                var argLen = arguments.length;\n                var dataIndex = arguments[argLen - 1];\n                var name = data.getName(dataIndex);\n                for (var i = 0; i < argLen - 1; i++) {\n                    vals[i] = arguments[i];\n                }\n                lines.push((name ? (name + ITEM_SPLITER) : '') + vals.join(ITEM_SPLITER));\n            });\n            return lines.join('\\n');\n        }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n');\n    }\n\n    /**\n     * @param {module:echarts/model/Global}\n     * @return {Object}\n     * @inner\n     */\n    function getContentFromModel(ecModel) {\n\n        var result = groupSeries(ecModel);\n\n        return {\n            value: zrUtil.filter([\n                    assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis),\n                    assembleOtherSeries(result.other)\n                ], function (str) {\n                    return str.replace(/[\\n\\t\\s]/g, '');\n                }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n'),\n\n            meta: result.meta\n        };\n    }\n\n\n    function trim(str) {\n        return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n    }\n    /**\n     * If a block is tsv format\n     */\n    function isTSVFormat(block) {\n        // Simple method to find out if a block is tsv format\n        var firstLine = block.slice(0, block.indexOf('\\n'));\n        if (firstLine.indexOf(ITEM_SPLITER) >= 0) {\n            return true;\n        }\n    }\n\n    var itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g');\n    /**\n     * @param {string} tsv\n     * @return {Object}\n     */\n    function parseTSVContents(tsv) {\n        var tsvLines = tsv.split(/\\n+/g);\n        var headers = trim(tsvLines.shift()).split(itemSplitRegex);\n\n        var categories = [];\n        var series = zrUtil.map(headers, function (header) {\n            return {\n                name: header,\n                data: []\n            };\n        });\n        for (var i = 0; i < tsvLines.length; i++) {\n            var items = trim(tsvLines[i]).split(itemSplitRegex);\n            categories.push(items.shift());\n            for (var j = 0; j < items.length; j++) {\n                series[j] && (series[j].data[i] = items[j]);\n            }\n        }\n        return {\n            series: series,\n            categories: categories\n        };\n    }\n\n    /**\n     * @param {string} str\n     * @return {Array.<Object>}\n     * @inner\n     */\n    function parseListContents(str) {\n        var lines = str.split(/\\n+/g);\n        var seriesName = trim(lines.shift());\n\n        var data = [];\n        for (var i = 0; i < lines.length; i++) {\n            var items = trim(lines[i]).split(itemSplitRegex);\n            var name = '';\n            var value;\n            var hasName = false;\n            if (isNaN(items[0])) { // First item is name\n                hasName = true;\n                name = items[0];\n                items = items.slice(1);\n                data[i] = {\n                    name: name,\n                    value: []\n                };\n                value = data[i].value;\n            }\n            else {\n                value = data[i] = [];\n            }\n            for (var j = 0; j < items.length; j++) {\n                value.push(+items[j]);\n            }\n            if (value.length === 1) {\n                hasName ? (data[i].value = value[0]) : (data[i] = value[0]);\n            }\n        }\n\n        return {\n            name: seriesName,\n            data: data\n        };\n    }\n\n    /**\n     * @param {string} str\n     * @param {Array.<Object>} blockMetaList\n     * @return {Object}\n     * @inner\n     */\n    function parseContents(str, blockMetaList) {\n        var blocks = str.split(new RegExp('\\n*' + BLOCK_SPLITER + '\\n*', 'g'));\n        var newOption = {\n            series: []\n        };\n        zrUtil.each(blocks, function (block, idx) {\n            if (isTSVFormat(block)) {\n                var result = parseTSVContents(block);\n                var blockMeta = blockMetaList[idx];\n                var axisKey = blockMeta.axisDim + 'Axis';\n\n                if (blockMeta) {\n                    newOption[axisKey] = newOption[axisKey] || [];\n                    newOption[axisKey][blockMeta.axisIndex] = {\n                        data: result.categories\n                    };\n                    newOption.series = newOption.series.concat(result.series);\n                }\n            }\n            else {\n                var result = parseListContents(block);\n                newOption.series.push(result);\n            }\n        });\n        return newOption;\n    }\n\n    /**\n     * @alias {module:echarts/component/toolbox/feature/DataView}\n     * @constructor\n     * @param {module:echarts/model/Model} model\n     */\n    function DataView(model) {\n\n        this._dom = null;\n\n        this.model = model;\n    }\n\n    DataView.defaultOption = {\n        show: true,\n        readOnly: false,\n        optionToContent: null,\n        contentToOption: null,\n\n        icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',\n        title: zrUtil.clone(lang.title),\n        lang: zrUtil.clone(lang.lang),\n        backgroundColor: '#fff',\n        textColor: '#000',\n        textareaColor: '#fff',\n        textareaBorderColor: '#333',\n        buttonColor: '#c23531',\n        buttonTextColor: '#fff'\n    };\n\n    DataView.prototype.onclick = function (ecModel, api) {\n        var container = api.getDom();\n        var model = this.model;\n        if (this._dom) {\n            container.removeChild(this._dom);\n        }\n        var root = document.createElement('div');\n        root.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;';\n        root.style.backgroundColor = model.get('backgroundColor') || '#fff';\n\n        // Create elements\n        var header = document.createElement('h4');\n        var lang = model.get('lang') || [];\n        header.innerHTML = lang[0] || model.get('title');\n        header.style.cssText = 'margin: 10px 20px;';\n        header.style.color = model.get('textColor');\n\n        var viewMain = document.createElement('div');\n        var textarea = document.createElement('textarea');\n        viewMain.style.cssText = 'display:block;width:100%;overflow:auto;';\n\n        var optionToContent = model.get('optionToContent');\n        var contentToOption = model.get('contentToOption');\n        var result = getContentFromModel(ecModel);\n        if (typeof optionToContent === 'function') {\n            var htmlOrDom = optionToContent(api.getOption());\n            if (typeof htmlOrDom === 'string') {\n                viewMain.innerHTML = htmlOrDom;\n            }\n            else if (zrUtil.isDom(htmlOrDom)) {\n                viewMain.appendChild(htmlOrDom);\n            }\n        }\n        else {\n            // Use default textarea\n            viewMain.appendChild(textarea);\n            textarea.readOnly = model.get('readOnly');\n            textarea.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;';\n            textarea.style.color = model.get('textColor');\n            textarea.style.borderColor = model.get('textareaBorderColor');\n            textarea.style.backgroundColor = model.get('textareaColor');\n            textarea.value = result.value;\n        }\n\n        var blockMetaList = result.meta;\n\n        var buttonContainer = document.createElement('div');\n        buttonContainer.style.cssText = 'position:absolute;bottom:0;left:0;right:0;';\n\n        var buttonStyle = 'float:right;margin-right:20px;border:none;'\n            + 'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';\n        var closeButton = document.createElement('div');\n        var refreshButton = document.createElement('div');\n\n        buttonStyle += ';background-color:' + model.get('buttonColor');\n        buttonStyle += ';color:' + model.get('buttonTextColor');\n\n        var self = this;\n\n        function close() {\n            container.removeChild(root);\n            self._dom = null;\n        }\n        eventTool.addEventListener(closeButton, 'click', close);\n\n        eventTool.addEventListener(refreshButton, 'click', function () {\n            var newOption;\n            try {\n                if (typeof contentToOption === 'function') {\n                    newOption = contentToOption(viewMain, api.getOption());\n                }\n                else {\n                    newOption = parseContents(textarea.value, blockMetaList);\n                }\n            }\n            catch (e) {\n                close();\n                throw new Error('Data view format error ' + e);\n            }\n            if (newOption) {\n                api.dispatchAction({\n                    type: 'changeDataView',\n                    newOption: newOption\n                });\n            }\n\n            close();\n        });\n\n        closeButton.innerHTML = lang[1];\n        refreshButton.innerHTML = lang[2];\n        refreshButton.style.cssText = buttonStyle;\n        closeButton.style.cssText = buttonStyle;\n\n        !model.get('readOnly') && buttonContainer.appendChild(refreshButton);\n        buttonContainer.appendChild(closeButton);\n\n        // http://stackoverflow.com/questions/6637341/use-tab-to-indent-in-textarea\n        eventTool.addEventListener(textarea, 'keydown', function (e) {\n            if ((e.keyCode || e.which) === 9) {\n                // get caret position/selection\n                var val = this.value;\n                var start = this.selectionStart;\n                var end = this.selectionEnd;\n\n                // set textarea value to: text before caret + tab + text after caret\n                this.value = val.substring(0, start) + ITEM_SPLITER + val.substring(end);\n\n                // put caret at right position again\n                this.selectionStart = this.selectionEnd = start + 1;\n\n                // prevent the focus lose\n                eventTool.stop(e);\n            }\n        });\n\n        root.appendChild(header);\n        root.appendChild(viewMain);\n        root.appendChild(buttonContainer);\n\n        viewMain.style.height = (container.clientHeight - 80) + 'px';\n\n        container.appendChild(root);\n        this._dom = root;\n    };\n\n    DataView.prototype.remove = function (ecModel, api) {\n        this._dom && api.getDom().removeChild(this._dom);\n    };\n\n    DataView.prototype.dispose = function (ecModel, api) {\n        this.remove(ecModel, api);\n    };\n\n    /**\n     * @inner\n     */\n    function tryMergeDataOption(newData, originalData) {\n        return zrUtil.map(newData, function (newVal, idx) {\n            var original = originalData && originalData[idx];\n            if (zrUtil.isObject(original) && !zrUtil.isArray(original)) {\n                if (zrUtil.isObject(newVal) && !zrUtil.isArray(newVal)) {\n                    newVal = newVal.value;\n                }\n                // Original data has option\n                return zrUtil.defaults({\n                    value: newVal\n                }, original);\n            }\n            else {\n                return newVal;\n            }\n        });\n    }\n\n    require('../featureManager').register('dataView', DataView);\n\n    require('../../../echarts').registerAction({\n        type: 'changeDataView',\n        event: 'dataViewChanged',\n        update: 'prepareAndUpdate'\n    }, function (payload, ecModel) {\n        var newSeriesOptList = [];\n        zrUtil.each(payload.newOption.series, function (seriesOpt) {\n            var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];\n            if (!seriesModel) {\n                // New created series\n                // Geuss the series type\n                newSeriesOptList.push(zrUtil.extend({\n                    // Default is scatter\n                    type: 'scatter'\n                }, seriesOpt));\n            }\n            else {\n                var originalData = seriesModel.get('data');\n                newSeriesOptList.push({\n                    name: seriesOpt.name,\n                    data: tryMergeDataOption(seriesOpt.data, originalData)\n                });\n            }\n        });\n\n        ecModel.mergeOption(zrUtil.defaults({\n            series: newSeriesOptList\n        }, payload.newOption));\n    });\n\n    module.exports = DataView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/feature/DataView.js\n// module id = 1139\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var BrushController = require('../../helper/BrushController');\n    var BrushTargetManager = require('../../helper/BrushTargetManager');\n    var history = require('../../dataZoom/history');\n    var sliderMove = require('../../helper/sliderMove');\n    var lang = require('../../../lang').toolbox.dataZoom;\n\n    var each = zrUtil.each;\n\n    // Use dataZoomSelect\n    require('../../dataZoomSelect');\n\n    // Spectial component id start with \\0ec\\0, see echarts/model/Global.js~hasInnerId\n    var DATA_ZOOM_ID_BASE = '\\0_ec_\\0toolbox-dataZoom_';\n\n    function DataZoom(model, ecModel, api) {\n\n        /**\n         * @private\n         * @type {module:echarts/component/helper/BrushController}\n         */\n        (this._brushController = new BrushController(api.getZr()))\n            .on('brush', zrUtil.bind(this._onBrush, this))\n            .mount();\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._isZoomActive;\n    }\n\n    DataZoom.defaultOption = {\n        show: true,\n        // Icon group\n        icon: {\n            zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',\n            back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'\n        },\n        // `zoom`, `back`\n        title: zrUtil.clone(lang.title)\n    };\n\n    var proto = DataZoom.prototype;\n\n    proto.render = function (featureModel, ecModel, api, payload) {\n        this.model = featureModel;\n        this.ecModel = ecModel;\n        this.api = api;\n\n        updateZoomBtnStatus(featureModel, ecModel, this, payload, api);\n        updateBackBtnStatus(featureModel, ecModel);\n    };\n\n    proto.onclick = function (ecModel, api, type) {\n        handlers[type].call(this);\n    };\n\n    proto.remove = function (ecModel, api) {\n        this._brushController.unmount();\n    };\n\n    proto.dispose = function (ecModel, api) {\n        this._brushController.dispose();\n    };\n\n    /**\n     * @private\n     */\n    var handlers = {\n\n        zoom: function () {\n            var nextActive = !this._isZoomActive;\n\n            this.api.dispatchAction({\n                type: 'takeGlobalCursor',\n                key: 'dataZoomSelect',\n                dataZoomSelectActive: nextActive\n            });\n        },\n\n        back: function () {\n            this._dispatchZoomAction(history.pop(this.ecModel));\n        }\n    };\n\n    /**\n     * @private\n     */\n    proto._onBrush = function (areas, opt) {\n        if (!opt.isEnd || !areas.length) {\n            return;\n        }\n        var snapshot = {};\n        var ecModel = this.ecModel;\n\n        this._brushController.updateCovers([]); // remove cover\n\n        var brushTargetManager = new BrushTargetManager(\n            retrieveAxisSetting(this.model.option), ecModel, {include: ['grid']}\n        );\n        brushTargetManager.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n            if (coordSys.type !== 'cartesian2d') {\n                return;\n            }\n\n            var brushType = area.brushType;\n            if (brushType === 'rect') {\n                setBatch('x', coordSys, coordRange[0]);\n                setBatch('y', coordSys, coordRange[1]);\n            }\n            else {\n                setBatch(({lineX: 'x', lineY: 'y'})[brushType], coordSys, coordRange);\n            }\n        });\n\n        history.push(ecModel, snapshot);\n\n        this._dispatchZoomAction(snapshot);\n\n        function setBatch(dimName, coordSys, minMax) {\n            var axis = coordSys.getAxis(dimName);\n            var axisModel = axis.model;\n            var dataZoomModel = findDataZoom(dimName, axisModel, ecModel);\n\n            // Restrict range.\n            var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();\n            if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {\n                minMax = sliderMove(\n                    0, minMax.slice(), axis.scale.getExtent(), 0,\n                    minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan\n                );\n            }\n\n            dataZoomModel && (snapshot[dataZoomModel.id] = {\n                dataZoomId: dataZoomModel.id,\n                startValue: minMax[0],\n                endValue: minMax[1]\n            });\n        }\n\n        function findDataZoom(dimName, axisModel, ecModel) {\n            var found;\n            ecModel.eachComponent({mainType: 'dataZoom', subType: 'select'}, function (dzModel) {\n                var has = dzModel.getAxisModel(dimName, axisModel.componentIndex);\n                has && (found = dzModel);\n            });\n            return found;\n        }\n    };\n\n    /**\n     * @private\n     */\n    proto._dispatchZoomAction = function (snapshot) {\n        var batch = [];\n\n        // Convert from hash map to array.\n        each(snapshot, function (batchItem, dataZoomId) {\n            batch.push(zrUtil.clone(batchItem));\n        });\n\n        batch.length && this.api.dispatchAction({\n            type: 'dataZoom',\n            from: this.uid,\n            batch: batch\n        });\n    };\n\n    function retrieveAxisSetting(option) {\n        var setting = {};\n        // Compatible with previous setting: null => all axis, false => no axis.\n        zrUtil.each(['xAxisIndex', 'yAxisIndex'], function (name) {\n            setting[name] = option[name];\n            setting[name] == null && (setting[name] = 'all');\n            (setting[name] === false || setting[name] === 'none') && (setting[name] = []);\n        });\n        return setting;\n    }\n\n    function updateBackBtnStatus(featureModel, ecModel) {\n        featureModel.setIconStatus(\n            'back',\n            history.count(ecModel) > 1 ? 'emphasis' : 'normal'\n        );\n    }\n\n    function updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {\n        var zoomActive = view._isZoomActive;\n\n        if (payload && payload.type === 'takeGlobalCursor') {\n            zoomActive = payload.key === 'dataZoomSelect'\n                ? payload.dataZoomSelectActive : false;\n        }\n\n        view._isZoomActive = zoomActive;\n\n        featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal');\n\n        var brushTargetManager = new BrushTargetManager(\n            retrieveAxisSetting(featureModel.option), ecModel, {include: ['grid']}\n        );\n\n        view._brushController\n            .setPanels(brushTargetManager.makePanelOpts(api, function (targetInfo) {\n                return (targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared)\n                    ? 'lineX'\n                    : (!targetInfo.xAxisDeclared && targetInfo.yAxisDeclared)\n                    ? 'lineY'\n                    : 'rect';\n            }))\n            .enableBrush(\n                zoomActive\n                ? {\n                    brushType: 'auto',\n                    brushStyle: {\n                        // FIXME user customized?\n                        lineWidth: 0,\n                        fill: 'rgba(0,0,0,0.2)'\n                    }\n                }\n                : false\n            );\n    }\n\n\n    require('../featureManager').register('dataZoom', DataZoom);\n\n\n    // Create special dataZoom option for select\n    require('../../../echarts').registerPreprocessor(function (option) {\n        if (!option) {\n            return;\n        }\n\n        var dataZoomOpts = option.dataZoom || (option.dataZoom = []);\n        if (!zrUtil.isArray(dataZoomOpts)) {\n            option.dataZoom = dataZoomOpts = [dataZoomOpts];\n        }\n\n        var toolboxOpt = option.toolbox;\n        if (toolboxOpt) {\n            // Assume there is only one toolbox\n            if (zrUtil.isArray(toolboxOpt)) {\n                toolboxOpt = toolboxOpt[0];\n            }\n\n            if (toolboxOpt && toolboxOpt.feature) {\n                var dataZoomOpt = toolboxOpt.feature.dataZoom;\n                addForAxis('xAxis', dataZoomOpt);\n                addForAxis('yAxis', dataZoomOpt);\n            }\n        }\n\n        function addForAxis(axisName, dataZoomOpt) {\n            if (!dataZoomOpt) {\n                return;\n            }\n\n            // Try not to modify model, because it is not merged yet.\n            var axisIndicesName = axisName + 'Index';\n            var givenAxisIndices = dataZoomOpt[axisIndicesName];\n            if (givenAxisIndices != null\n                && givenAxisIndices != 'all'\n                && !zrUtil.isArray(givenAxisIndices)\n            ) {\n                givenAxisIndices = (givenAxisIndices === false || givenAxisIndices === 'none') ? [] : [givenAxisIndices];\n            }\n\n            forEachComponent(axisName, function (axisOpt, axisIndex) {\n                if (givenAxisIndices != null\n                    && givenAxisIndices != 'all'\n                    && zrUtil.indexOf(givenAxisIndices, axisIndex) === -1\n                ) {\n                    return;\n                }\n                var newOpt = {\n                    type: 'select',\n                    $fromToolbox: true,\n                    // Id for merge mapping.\n                    id: DATA_ZOOM_ID_BASE + axisName + axisIndex\n                };\n                // FIXME\n                // Only support one axis now.\n                newOpt[axisIndicesName] = axisIndex;\n                dataZoomOpts.push(newOpt);\n            });\n        }\n\n        function forEachComponent(mainType, cb) {\n            var opts = option[mainType];\n            if (!zrUtil.isArray(opts)) {\n                opts = opts ? [opts] : [];\n            }\n            each(opts, cb);\n        }\n    });\n\n    module.exports = DataZoom;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/feature/DataZoom.js\n// module id = 1140\n// module chunks = 0 1 2","/**\n * DataZoom component entry\n */\n\n\n    require('./dataZoom/typeDefaulter');\n\n    require('./dataZoom/DataZoomModel');\n    require('./dataZoom/DataZoomView');\n\n    require('./dataZoom/SelectZoomModel');\n    require('./dataZoom/SelectZoomView');\n\n    require('./dataZoom/dataZoomProcessor');\n    require('./dataZoom/dataZoomAction');\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoomSelect.js\n// module id = 1141\n// module chunks = 0 1 2","/**\n * @file Axis operator\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../../util/number');\n    var helper = require('./helper');\n    var each = zrUtil.each;\n    var asc = numberUtil.asc;\n\n    /**\n     * Operate single axis.\n     * One axis can only operated by one axis operator.\n     * Different dataZoomModels may be defined to operate the same axis.\n     * (i.e. 'inside' data zoom and 'slider' data zoom components)\n     * So dataZoomModels share one axisProxy in that case.\n     *\n     * @class\n     */\n    var AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {\n\n        /**\n         * @private\n         * @type {string}\n         */\n        this._dimName = dimName;\n\n        /**\n         * @private\n         */\n        this._axisIndex = axisIndex;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._valueWindow;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._percentWindow;\n\n        /**\n         * @private\n         * @type {Array.<number>}\n         */\n        this._dataExtent;\n\n        /**\n         * {minSpan, maxSpan, minValueSpan, maxValueSpan}\n         * @private\n         * @type {Object}\n         */\n        this._minMaxSpan;\n\n        /**\n         * @readOnly\n         * @type {module: echarts/model/Global}\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @private\n         * @type {module: echarts/component/dataZoom/DataZoomModel}\n         */\n        this._dataZoomModel = dataZoomModel;\n    };\n\n    AxisProxy.prototype = {\n\n        constructor: AxisProxy,\n\n        /**\n         * Whether the axisProxy is hosted by dataZoomModel.\n         *\n         * @public\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         * @return {boolean}\n         */\n        hostedBy: function (dataZoomModel) {\n            return this._dataZoomModel === dataZoomModel;\n        },\n\n        /**\n         * @return {Array.<number>} Value can only be NaN or finite value.\n         */\n        getDataValueWindow: function () {\n            return this._valueWindow.slice();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getDataPercentWindow: function () {\n            return this._percentWindow.slice();\n        },\n\n        /**\n         * @public\n         * @param {number} axisIndex\n         * @return {Array} seriesModels\n         */\n        getTargetSeriesModels: function () {\n            var seriesModels = [];\n            var ecModel = this.ecModel;\n\n            ecModel.eachSeries(function (seriesModel) {\n                if (helper.isCoordSupported(seriesModel.get('coordinateSystem'))) {\n                    var dimName = this._dimName;\n                    var axisModel = ecModel.queryComponents({\n                        mainType: dimName + 'Axis',\n                        index: seriesModel.get(dimName + 'AxisIndex'),\n                        id: seriesModel.get(dimName + 'AxisId')\n                    })[0];\n                    if (this._axisIndex === (axisModel && axisModel.componentIndex)) {\n                        seriesModels.push(seriesModel);\n                    }\n                }\n            }, this);\n\n            return seriesModels;\n        },\n\n        getAxisModel: function () {\n            return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n        },\n\n        getOtherAxisModel: function () {\n            var axisDim = this._dimName;\n            var ecModel = this.ecModel;\n            var axisModel = this.getAxisModel();\n            var isCartesian = axisDim === 'x' || axisDim === 'y';\n            var otherAxisDim;\n            var coordSysIndexName;\n            if (isCartesian) {\n                coordSysIndexName = 'gridIndex';\n                otherAxisDim = axisDim === 'x' ? 'y' : 'x';\n            }\n            else {\n                coordSysIndexName = 'polarIndex';\n                otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';\n            }\n            var foundOtherAxisModel;\n            ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {\n                if ((otherAxisModel.get(coordSysIndexName) || 0)\n                    === (axisModel.get(coordSysIndexName) || 0)\n                ) {\n                    foundOtherAxisModel = otherAxisModel;\n                }\n            });\n            return foundOtherAxisModel;\n        },\n\n        getMinMaxSpan: function () {\n            return zrUtil.clone(this._minMaxSpan);\n        },\n\n        /**\n         * Only calculate by given range and this._dataExtent, do not change anything.\n         *\n         * @param {Object} opt\n         * @param {number} [opt.start]\n         * @param {number} [opt.end]\n         * @param {number} [opt.startValue]\n         * @param {number} [opt.endValue]\n         */\n        calculateDataWindow: function (opt) {\n            var dataExtent = this._dataExtent;\n            var axisModel = this.getAxisModel();\n            var scale = axisModel.axis.scale;\n            var rangePropMode = this._dataZoomModel.getRangePropMode();\n            var percentExtent = [0, 100];\n            var percentWindow = [\n                opt.start,\n                opt.end\n            ];\n            var valueWindow = [];\n\n            each(['startValue', 'endValue'], function (prop) {\n                valueWindow.push(opt[prop] != null ? scale.parse(opt[prop]) : null);\n            });\n\n            // Normalize bound.\n            each([0, 1], function (idx) {\n                var boundValue = valueWindow[idx];\n                var boundPercent = percentWindow[idx];\n\n                // Notice: dataZoom is based either on `percentProp` ('start', 'end') or\n                // on `valueProp` ('startValue', 'endValue'). The former one is suitable\n                // for cases that a dataZoom component controls multiple axes with different\n                // unit or extent, and the latter one is suitable for accurate zoom by pixel\n                // (e.g., in dataZoomSelect). `valueProp` can be calculated from `percentProp`,\n                // but it is awkward that `percentProp` can not be obtained from `valueProp`\n                // accurately (because all of values that are overflow the `dataExtent` will\n                // be calculated to percent '100%'). So we have to use\n                // `dataZoom.getRangePropMode()` to mark which prop is used.\n                // `rangePropMode` is updated only when setOption or dispatchAction, otherwise\n                // it remains its original value.\n\n                if (rangePropMode[idx] === 'percent') {\n                    if (boundPercent == null) {\n                        boundPercent = percentExtent[idx];\n                    }\n                    // Use scale.parse to math round for category or time axis.\n                    boundValue = scale.parse(numberUtil.linearMap(\n                        boundPercent, percentExtent, dataExtent, true\n                    ));\n                }\n                else {\n                    // Calculating `percent` from `value` may be not accurate, because\n                    // This calculation can not be inversed, because all of values that\n                    // are overflow the `dataExtent` will be calculated to percent '100%'\n                    boundPercent = numberUtil.linearMap(\n                        boundValue, dataExtent, percentExtent, true\n                    );\n                }\n\n                // valueWindow[idx] = round(boundValue);\n                // percentWindow[idx] = round(boundPercent);\n                valueWindow[idx] = boundValue;\n                percentWindow[idx] = boundPercent;\n            });\n\n            return {\n                valueWindow: asc(valueWindow),\n                percentWindow: asc(percentWindow)\n            };\n        },\n\n        /**\n         * Notice: reset should not be called before series.restoreData() called,\n         * so it is recommanded to be called in \"process stage\" but not \"model init\n         * stage\".\n         *\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         */\n        reset: function (dataZoomModel) {\n            if (dataZoomModel !== this._dataZoomModel) {\n                return;\n            }\n\n            // Culculate data window and data extent, and record them.\n            this._dataExtent = calculateDataExtent(\n                this, this._dimName, this.getTargetSeriesModels()\n            );\n\n            var dataWindow = this.calculateDataWindow(dataZoomModel.option);\n\n            this._valueWindow = dataWindow.valueWindow;\n            this._percentWindow = dataWindow.percentWindow;\n\n            setMinMaxSpan(this);\n\n            // Update axis setting then.\n            setAxisModel(this);\n        },\n\n        /**\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         */\n        restore: function (dataZoomModel) {\n            if (dataZoomModel !== this._dataZoomModel) {\n                return;\n            }\n\n            this._valueWindow = this._percentWindow = null;\n            setAxisModel(this, true);\n        },\n\n        /**\n         * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel\n         */\n        filterData: function (dataZoomModel) {\n            if (dataZoomModel !== this._dataZoomModel) {\n                return;\n            }\n\n            var axisDim = this._dimName;\n            var seriesModels = this.getTargetSeriesModels();\n            var filterMode = dataZoomModel.get('filterMode');\n            var valueWindow = this._valueWindow;\n\n            if (filterMode === 'none') {\n                return;\n            }\n\n            // FIXME\n            // Toolbox may has dataZoom injected. And if there are stacked bar chart\n            // with NaN data, NaN will be filtered and stack will be wrong.\n            // So we need to force the mode to be set empty.\n            // In fect, it is not a big deal that do not support filterMode-'filter'\n            // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis\n            // selection\" some day, which might need \"adapt to data extent on the\n            // otherAxis\", which is disabled by filterMode-'empty'.\n            var otherAxisModel = this.getOtherAxisModel();\n            if (dataZoomModel.get('$fromToolbox')\n                && otherAxisModel\n                && otherAxisModel.get('type') === 'category'\n            ) {\n                filterMode = 'empty';\n            }\n\n            // Process series data\n            each(seriesModels, function (seriesModel) {\n                var seriesData = seriesModel.getData();\n                var dataDims = seriesModel.coordDimToDataDim(axisDim);\n\n                if (filterMode === 'weakFilter') {\n                    seriesData && seriesData.filterSelf(function (dataIndex) {\n                        var leftOut;\n                        var rightOut;\n                        var hasValue;\n                        for (var i = 0; i < dataDims.length; i++) {\n                            var value = seriesData.get(dataDims[i], dataIndex);\n                            var thisHasValue = !isNaN(value);\n                            var thisLeftOut = value < valueWindow[0];\n                            var thisRightOut = value > valueWindow[1];\n                            if (thisHasValue && !thisLeftOut && !thisRightOut) {\n                                return true;\n                            }\n                            thisHasValue && (hasValue = true);\n                            thisLeftOut && (leftOut = true);\n                            thisRightOut && (rightOut = true);\n                        }\n                        // If both left out and right out, do not filter.\n                        return hasValue && leftOut && rightOut;\n                    });\n                }\n                else {\n                    seriesData && each(dataDims, function (dim) {\n                        if (filterMode === 'empty') {\n                            seriesModel.setData(\n                                seriesData.map(dim, function (value) {\n                                    return !isInWindow(value) ? NaN : value;\n                                })\n                            );\n                        }\n                        else {\n                            seriesData.filterSelf(dim, isInWindow);\n                        }\n                    });\n                }\n            });\n\n            function isInWindow(value) {\n                return value >= valueWindow[0] && value <= valueWindow[1];\n            }\n        }\n    };\n\n    function calculateDataExtent(axisProxy, axisDim, seriesModels) {\n        var dataExtent = [Infinity, -Infinity];\n\n        each(seriesModels, function (seriesModel) {\n            var seriesData = seriesModel.getData();\n            if (seriesData) {\n                each(seriesModel.coordDimToDataDim(axisDim), function (dim) {\n                    var seriesExtent = seriesData.getDataExtent(dim);\n                    seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n                    seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n                });\n            }\n        });\n\n        if (dataExtent[1] < dataExtent[0]) {\n            dataExtent = [NaN, NaN];\n        }\n\n        // It is important to get \"consistent\" extent when more then one axes is\n        // controlled by a `dataZoom`, otherwise those axes will not be synchronized\n        // when zooming. But it is difficult to know what is \"consistent\", considering\n        // axes have different type or even different meanings (For example, two\n        // time axes are used to compare data of the same date in different years).\n        // So basically dataZoom just obtains extent by series.data (in category axis\n        // extent can be obtained from axis.data).\n        // Nevertheless, user can set min/max/scale on axes to make extent of axes\n        // consistent.\n        fixExtentByAxis(axisProxy, dataExtent);\n\n        return dataExtent;\n    }\n\n    function fixExtentByAxis(axisProxy, dataExtent) {\n        var axisModel = axisProxy.getAxisModel();\n        var min = axisModel.getMin(true);\n\n        // For category axis, if min/max/scale are not set, extent is determined\n        // by axis.data by default.\n        var isCategoryAxis = axisModel.get('type') === 'category';\n        var axisDataLen = isCategoryAxis && (axisModel.get('data') || []).length;\n\n        if (min != null && min !== 'dataMin' && typeof min !== 'function') {\n            dataExtent[0] = min;\n        }\n        else if (isCategoryAxis) {\n            dataExtent[0] = axisDataLen > 0 ? 0 : NaN;\n        }\n\n        var max = axisModel.getMax(true);\n        if (max != null && max !== 'dataMax' && typeof max !== 'function') {\n            dataExtent[1] = max;\n        }\n        else if (isCategoryAxis) {\n            dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;\n        }\n\n        if (!axisModel.get('scale', true)) {\n            dataExtent[0] > 0 && (dataExtent[0] = 0);\n            dataExtent[1] < 0 && (dataExtent[1] = 0);\n        }\n\n        // For value axis, if min/max/scale are not set, we just use the extent obtained\n        // by series data, which may be a little different from the extent calculated by\n        // `axisHelper.getScaleExtent`. But the different just affects the experience a\n        // little when zooming. So it will not be fixed until some users require it strongly.\n\n        return dataExtent;\n    }\n\n    function setAxisModel(axisProxy, isRestore) {\n        var axisModel = axisProxy.getAxisModel();\n\n        var percentWindow = axisProxy._percentWindow;\n        var valueWindow = axisProxy._valueWindow;\n\n        if (!percentWindow) {\n            return;\n        }\n\n        // [0, 500]: arbitrary value, guess axis extent.\n        var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);\n        precision = Math.min(precision, 20);\n        // isRestore or isFull\n        var useOrigin = isRestore || (percentWindow[0] === 0 && percentWindow[1] === 100);\n\n        axisModel.setRange(\n            useOrigin ? null : +valueWindow[0].toFixed(precision),\n            useOrigin ? null : +valueWindow[1].toFixed(precision)\n        );\n    }\n\n    function setMinMaxSpan(axisProxy) {\n        var minMaxSpan = axisProxy._minMaxSpan = {};\n        var dataZoomModel = axisProxy._dataZoomModel;\n\n        each(['min', 'max'], function (minMax) {\n            minMaxSpan[minMax + 'Span'] = dataZoomModel.get(minMax + 'Span');\n\n            // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan\n            var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');\n            if (valueSpan != null) {\n                minMaxSpan[minMax + 'ValueSpan'] = valueSpan;\n\n                valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan);\n                if (valueSpan != null) {\n                    minMaxSpan[minMax + 'Span'] = numberUtil.linearMap(\n                        valueSpan, axisProxy._dataExtent, [0, 100], true\n                    );\n                }\n            }\n        });\n    }\n\n    module.exports = AxisProxy;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/AxisProxy.js\n// module id = 1142\n// module chunks = 0 1 2","/**\n * @file Data zoom model\n */\n\n\n    var DataZoomModel = require('./DataZoomModel');\n\n    module.exports = DataZoomModel.extend({\n\n        type: 'dataZoom.select'\n\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js\n// module id = 1143\n// module chunks = 0 1 2","\n\n    module.exports = require('./DataZoomView').extend({\n\n        type: 'dataZoom.select'\n\n    });\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/dataZoom/SelectZoomView.js\n// module id = 1144\n// module chunks = 0 1 2","'use strict';\n\n\n    var history = require('../../dataZoom/history');\n    var lang = require('../../../lang').toolbox.restore;\n\n    function Restore(model) {\n        this.model = model;\n    }\n\n    Restore.defaultOption = {\n        show: true,\n        icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',\n        title: lang.title\n    };\n\n    var proto = Restore.prototype;\n\n    proto.onclick = function (ecModel, api, type) {\n        history.clear(ecModel);\n\n        api.dispatchAction({\n            type: 'restore',\n            from: this.uid\n        });\n    };\n\n\n    require('../featureManager').register('restore', Restore);\n\n\n    require('../../../echarts').registerAction(\n        {type: 'restore', event: 'restore', update: 'prepareAndUpdate'},\n        function (payload, ecModel) {\n            ecModel.resetOption('recreate');\n        }\n    );\n\n    module.exports = Restore;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/feature/Restore.js\n// module id = 1145\n// module chunks = 0 1 2","\n    var echarts = require('../echarts');\n    var zrUtil = require('zrender/lib/core/util');\n    module.exports = function (seriesType, actionInfos) {\n        zrUtil.each(actionInfos, function (actionInfo) {\n            actionInfo.update = 'updateView';\n            /**\n             * @payload\n             * @property {string} seriesName\n             * @property {string} name\n             */\n            echarts.registerAction(actionInfo, function (payload, ecModel) {\n                var selected = {};\n                ecModel.eachComponent(\n                    {mainType: 'series', subType: seriesType, query: payload},\n                    function (seriesModel) {\n                        if (seriesModel[actionInfo.method]) {\n                            seriesModel[actionInfo.method](\n                                payload.name,\n                                payload.dataIndex\n                            );\n                        }\n                        var data = seriesModel.getData();\n                        // Create selected map\n                        data.each(function (idx) {\n                            var name = data.getName(idx);\n                            selected[name] = seriesModel.isSelected(name)\n                                || false;\n                        });\n                    }\n                );\n                return {\n                    name: payload.name,\n                    selected: selected\n                };\n            });\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/action/createDataSelectAction.js\n// module id = 1149\n// module chunks = 0 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n\n    require('./pie/PieSeries');\n    require('./pie/PieView');\n\n    require('../action/createDataSelectAction')('pie', [{\n        type: 'pieToggleSelect',\n        event: 'pieselectchanged',\n        method: 'toggleSelected'\n    }, {\n        type: 'pieSelect',\n        event: 'pieselected',\n        method: 'select'\n    }, {\n        type: 'pieUnSelect',\n        event: 'pieunselected',\n        method: 'unSelect'\n    }]);\n\n    echarts.registerVisual(zrUtil.curry(require('../visual/dataColor'), 'pie'));\n\n    echarts.registerLayout(zrUtil.curry(\n        require('./pie/pieLayout'), 'pie'\n    ));\n\n    echarts.registerProcessor(zrUtil.curry(require('../processor/dataFilter'), 'pie'));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie.js\n// module id = 1157\n// module chunks = 0 2","'use strict';\n\n\n    var List = require('../../data/List');\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n    var numberUtil = require('../../util/number');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n\n    var dataSelectableMixin = require('../../component/helper/selectableMixin');\n\n    var PieSeries = require('../../echarts').extendSeriesModel({\n\n        type: 'series.pie',\n\n        // Overwrite\n        init: function (option) {\n            PieSeries.superApply(this, 'init', arguments);\n\n            // Enable legend selection for each data item\n            // Use a function instead of direct access because data reference may changed\n            this.legendDataProvider = function () {\n                return this.getRawData();\n            };\n\n            this.updateSelectedMap(option.data);\n\n            this._defaultLabelLine(option);\n        },\n\n        // Overwrite\n        mergeOption: function (newOption) {\n            PieSeries.superCall(this, 'mergeOption', newOption);\n            this.updateSelectedMap(this.option.data);\n        },\n\n        getInitialData: function (option, ecModel) {\n            var dimensions = completeDimensions(['value'], option.data);\n            var list = new List(dimensions, this);\n            list.initData(option.data);\n            return list;\n        },\n\n        // Overwrite\n        getDataParams: function (dataIndex) {\n            var data = this.getData();\n            var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n            // FIXME toFixed?\n\n            var valueList = [];\n            data.each('value', function (value) {\n                valueList.push(value);\n            });\n\n            params.percent = numberUtil.getPercentWithPrecision(\n                valueList,\n                dataIndex,\n                data.hostModel.get('percentPrecision')\n            );\n\n            params.$vars.push('percent');\n            return params;\n        },\n\n        _defaultLabelLine: function (option) {\n            // Extend labelLine emphasis\n            modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\n            var labelLineNormalOpt = option.labelLine.normal;\n            var labelLineEmphasisOpt = option.labelLine.emphasis;\n            // Not show label line if `label.normal.show = false`\n            labelLineNormalOpt.show = labelLineNormalOpt.show\n                && option.label.normal.show;\n            labelLineEmphasisOpt.show = labelLineEmphasisOpt.show\n                && option.label.emphasis.show;\n        },\n\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // \n            center: ['50%', '50%'],\n            radius: [0, '75%'],\n            // \n            clockwise: true,\n            startAngle: 90,\n            // 0\n            minAngle: 0,\n            // \n            selectedOffset: 10,\n            // \n            hoverOffset: 10,\n\n            // If use strategy to avoid label overlapping\n            avoidLabelOverlap: true,\n            // singlemultiple\n            // selectedMode: false,\n            // 'radius' | 'area'\n            // roseType: null,\n\n            percentPrecision: 2,\n\n            // If still show when all data zero.\n            stillShowZeroSum: true,\n\n            // cursor: null,\n\n            label: {\n                normal: {\n                    // If rotate around circle\n                    rotate: false,\n                    show: true,\n                    // 'outer', 'inside', 'center'\n                    position: 'outer'\n                    // formatter: Tooltip.formatter\n                    // TEXTSTYLE\n                    // distance: positioninnerlabel()\n                },\n                emphasis: {}\n            },\n            // Enabled when label.normal.position is 'outer'\n            labelLine: {\n                normal: {\n                    show: true,\n                    // \n                    length: 15,\n                    // \n                    length2: 15,\n                    smooth: false,\n                    lineStyle: {\n                        // color: ,\n                        width: 1,\n                        type: 'solid'\n                    }\n                }\n            },\n            itemStyle: {\n                normal: {\n                    borderWidth: 1\n                },\n                emphasis: {}\n            },\n\n            // Animation type canbe expansion, scale\n            animationType: 'expansion',\n\n            animationEasing: 'cubicOut',\n\n            data: []\n        }\n    });\n\n    zrUtil.mixin(PieSeries, dataSelectableMixin);\n\n    module.exports = PieSeries;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/PieSeries.js\n// module id = 1158\n// module chunks = 0 2","\n\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n\n    /**\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n        var data = seriesModel.getData();\n        var dataIndex = this.dataIndex;\n        var name = data.getName(dataIndex);\n        var selectedOffset = seriesModel.get('selectedOffset');\n\n        api.dispatchAction({\n            type: 'pieToggleSelect',\n            from: uid,\n            name: name,\n            seriesId: seriesModel.id\n        });\n\n        data.each(function (idx) {\n            toggleItemSelected(\n                data.getItemGraphicEl(idx),\n                data.getItemLayout(idx),\n                seriesModel.isSelected(data.getName(idx)),\n                selectedOffset,\n                hasAnimation\n            );\n        });\n    }\n\n    /**\n     * @param {module:zrender/graphic/Sector} el\n     * @param {Object} layout\n     * @param {boolean} isSelected\n     * @param {number} selectedOffset\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\n        var dx = Math.cos(midAngle);\n        var dy = Math.sin(midAngle);\n\n        var offset = isSelected ? selectedOffset : 0;\n        var position = [dx * offset, dy * offset];\n\n        hasAnimation\n            // animateTo will stop revious animation like update transition\n            ? el.animate()\n                .when(200, {\n                    position: position\n                })\n                .start('bounceOut')\n            : el.attr('position', position);\n    }\n\n    /**\n     * Piece of pie including Sector, Label, LabelLine\n     * @constructor\n     * @extends {module:zrender/graphic/Group}\n     */\n    function PiePiece(data, idx) {\n\n        graphic.Group.call(this);\n\n        var sector = new graphic.Sector({\n            z2: 2\n        });\n        var polyline = new graphic.Polyline();\n        var text = new graphic.Text();\n        this.add(sector);\n        this.add(polyline);\n        this.add(text);\n\n        this.updateData(data, idx, true);\n\n        // Hover to change label and labelLine\n        function onEmphasis() {\n            polyline.ignore = polyline.hoverIgnore;\n            text.ignore = text.hoverIgnore;\n        }\n        function onNormal() {\n            polyline.ignore = polyline.normalIgnore;\n            text.ignore = text.normalIgnore;\n        }\n        this.on('emphasis', onEmphasis)\n            .on('normal', onNormal)\n            .on('mouseover', onEmphasis)\n            .on('mouseout', onNormal);\n    }\n\n    var piePieceProto = PiePiece.prototype;\n\n    piePieceProto.updateData = function (data, idx, firstCreate) {\n\n        var sector = this.childAt(0);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var sectorShape = zrUtil.extend({}, layout);\n        sectorShape.label = null;\n\n        if (firstCreate) {\n            sector.setShape(sectorShape);\n\n            var animationType = seriesModel.getShallow('animationType');\n            if (animationType === 'scale') {\n                sector.shape.r = layout.r0;\n                graphic.initProps(sector, {\n                    shape: {\n                        r: layout.r\n                    }\n                }, seriesModel, idx);\n            }\n            // Expansion\n            else {\n                sector.shape.endAngle = layout.startAngle;\n                graphic.updateProps(sector, {\n                    shape: {\n                        endAngle: layout.endAngle\n                    }\n                }, seriesModel, idx);\n            }\n\n        }\n        else {\n            graphic.updateProps(sector, {\n                shape: sectorShape\n            }, seriesModel, idx);\n        }\n\n        // Update common style\n        var itemStyleModel = itemModel.getModel('itemStyle');\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        sector.useStyle(\n            zrUtil.defaults(\n                {\n                    lineJoin: 'bevel',\n                    fill: visualColor\n                },\n                itemStyleModel.getModel('normal').getItemStyle()\n            )\n        );\n        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\n        var cursorStyle = itemModel.getShallow('cursor');\n        cursorStyle && sector.attr('cursor', cursorStyle);\n\n        // Toggle selected\n        toggleItemSelected(\n            this,\n            data.getItemLayout(idx),\n            itemModel.get('selected'),\n            seriesModel.get('selectedOffset'),\n            seriesModel.get('animation')\n        );\n\n        function onEmphasis() {\n            // Sector may has animation of updating data. Force to move to the last frame\n            // Or it may stopped on the wrong shape\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r + seriesModel.get('hoverOffset')\n                }\n            }, 300, 'elasticOut');\n        }\n        function onNormal() {\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r\n                }\n            }, 300, 'elasticOut');\n        }\n        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n        if (itemModel.get('hoverAnimation') && seriesModel.isAnimationEnabled()) {\n            sector\n                .on('mouseover', onEmphasis)\n                .on('mouseout', onNormal)\n                .on('emphasis', onEmphasis)\n                .on('normal', onNormal);\n        }\n\n        this._updateLabel(data, idx);\n\n        graphic.setHoverStyle(this);\n    };\n\n    piePieceProto._updateLabel = function (data, idx) {\n\n        var labelLine = this.childAt(1);\n        var labelText = this.childAt(2);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var labelLayout = layout.label;\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        graphic.updateProps(labelLine, {\n            shape: {\n                points: labelLayout.linePoints || [\n                    [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]\n                ]\n            }\n        }, seriesModel, idx);\n\n        graphic.updateProps(labelText, {\n            style: {\n                x: labelLayout.x,\n                y: labelLayout.y\n            }\n        }, seriesModel, idx);\n        labelText.attr({\n            rotation: labelLayout.rotation,\n            origin: [labelLayout.x, labelLayout.y],\n            z2: 10\n        });\n\n        var labelModel = itemModel.getModel('label.normal');\n        var labelHoverModel = itemModel.getModel('label.emphasis');\n        var labelLineModel = itemModel.getModel('labelLine.normal');\n        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        graphic.setLabelStyle(\n            labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel,\n            {\n                labelFetcher: data.hostModel,\n                labelDataIndex: idx,\n                defaultText: data.getName(idx),\n                autoColor: visualColor,\n                useInsideStyle: !!labelLayout.inside\n            },\n            {\n                textAlign: labelLayout.textAlign,\n                textVerticalAlign: labelLayout.verticalAlign,\n                opacity: data.getItemVisual(idx, 'opacity')\n            }\n        );\n\n        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n        labelText.hoverIgnore = !labelHoverModel.get('show');\n\n        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\n        // Default use item visual color\n        labelLine.setStyle({\n            stroke: visualColor,\n            opacity: data.getItemVisual(idx, 'opacity')\n        });\n        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\n        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n\n        var smooth = labelLineModel.get('smooth');\n        if (smooth && smooth === true) {\n            smooth = 0.4;\n        }\n        labelLine.setShape({\n            smooth: smooth\n        });\n    };\n\n    zrUtil.inherits(PiePiece, graphic.Group);\n\n\n    // Pie view\n    var Pie = require('../../view/Chart').extend({\n\n        type: 'pie',\n\n        init: function () {\n            var sectorGroup = new graphic.Group();\n            this._sectorGroup = sectorGroup;\n        },\n\n        render: function (seriesModel, ecModel, api, payload) {\n            if (payload && (payload.from === this.uid)) {\n                return;\n            }\n\n            var data = seriesModel.getData();\n            var oldData = this._data;\n            var group = this.group;\n\n            var hasAnimation = ecModel.get('animation');\n            var isFirstRender = !oldData;\n            var animationType = seriesModel.get('animationType');\n\n            var onSectorClick = zrUtil.curry(\n                updateDataSelected, this.uid, seriesModel, hasAnimation, api\n            );\n\n            var selectedMode = seriesModel.get('selectedMode');\n\n            data.diff(oldData)\n                .add(function (idx) {\n                    var piePiece = new PiePiece(data, idx);\n                    // Default expansion animation\n                    if (isFirstRender && animationType !== 'scale') {\n                        piePiece.eachChild(function (child) {\n                            child.stopAnimation(true);\n                        });\n                    }\n\n                    selectedMode && piePiece.on('click', onSectorClick);\n\n                    data.setItemGraphicEl(idx, piePiece);\n\n                    group.add(piePiece);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\n                    piePiece.updateData(data, newIdx);\n\n                    piePiece.off('click');\n                    selectedMode && piePiece.on('click', onSectorClick);\n                    group.add(piePiece);\n                    data.setItemGraphicEl(newIdx, piePiece);\n                })\n                .remove(function (idx) {\n                    var piePiece = oldData.getItemGraphicEl(idx);\n                    group.remove(piePiece);\n                })\n                .execute();\n\n            if (\n                hasAnimation && isFirstRender && data.count() > 0\n                // Default expansion animation\n                && animationType !== 'scale'\n            ) {\n                var shape = data.getItemLayout(0);\n                var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n\n                var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n                group.setClipPath(this._createClipPath(\n                    shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel\n                ));\n            }\n\n            this._data = data;\n        },\n\n        dispose: function () {},\n\n        _createClipPath: function (\n            cx, cy, r, startAngle, clockwise, cb, seriesModel\n        ) {\n            var clipPath = new graphic.Sector({\n                shape: {\n                    cx: cx,\n                    cy: cy,\n                    r0: 0,\n                    r: r,\n                    startAngle: startAngle,\n                    endAngle: startAngle,\n                    clockwise: clockwise\n                }\n            });\n\n            graphic.initProps(clipPath, {\n                shape: {\n                    endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n                }\n            }, seriesModel, cb);\n\n            return clipPath;\n        },\n\n        /**\n         * @implement\n         */\n        containPoint: function (point, seriesModel) {\n            var data = seriesModel.getData();\n            var itemLayout = data.getItemLayout(0);\n            if (itemLayout) {\n                var dx = point[0] - itemLayout.cx;\n                var dy = point[1] - itemLayout.cy;\n                var radius = Math.sqrt(dx * dx + dy * dy);\n                return radius <= itemLayout.r && radius >= itemLayout.r0;\n            }\n        }\n\n    });\n\n    module.exports = Pie;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/PieView.js\n// module id = 1159\n// module chunks = 0 2","\n\n    var numberUtil = require('../../util/number');\n    var parsePercent = numberUtil.parsePercent;\n    var labelLayout = require('./labelLayout');\n    var zrUtil = require('zrender/lib/core/util');\n\n    var PI2 = Math.PI * 2;\n    var RADIAN = Math.PI / 180;\n\n    module.exports = function (seriesType, ecModel, api, payload) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var center = seriesModel.get('center');\n            var radius = seriesModel.get('radius');\n\n            if (!zrUtil.isArray(radius)) {\n                radius = [0, radius];\n            }\n            if (!zrUtil.isArray(center)) {\n                center = [center, center];\n            }\n\n            var width = api.getWidth();\n            var height = api.getHeight();\n            var size = Math.min(width, height);\n            var cx = parsePercent(center[0], width);\n            var cy = parsePercent(center[1], height);\n            var r0 = parsePercent(radius[0], size / 2);\n            var r = parsePercent(radius[1], size / 2);\n\n            var data = seriesModel.getData();\n\n            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n\n            var minAngle = seriesModel.get('minAngle') * RADIAN;\n\n            var validDataCount = 0;\n            data.each('value', function (value) {\n                !isNaN(value) && validDataCount++;\n            });\n\n            var sum = data.getSum('value');\n            // Sum may be 0\n            var unitRadian = Math.PI / (sum || validDataCount) * 2;\n\n            var clockwise = seriesModel.get('clockwise');\n\n            var roseType = seriesModel.get('roseType');\n            var stillShowZeroSum = seriesModel.get('stillShowZeroSum');\n\n            // [0...max]\n            var extent = data.getDataExtent('value');\n            extent[0] = 0;\n\n            // In the case some sector angle is smaller than minAngle\n            var restAngle = PI2;\n            var valueSumLargerThanMinAngle = 0;\n\n            var currentAngle = startAngle;\n            var dir = clockwise ? 1 : -1;\n\n            data.each('value', function (value, idx) {\n                var angle;\n                if (isNaN(value)) {\n                    data.setItemLayout(idx, {\n                        angle: NaN,\n                        startAngle: NaN,\n                        endAngle: NaN,\n                        clockwise: clockwise,\n                        cx: cx,\n                        cy: cy,\n                        r0: r0,\n                        r: roseType\n                            ? NaN\n                            : r\n                    });\n                    return;\n                }\n\n                // FIXME  2.0  roseType  area \n                if (roseType !== 'area') {\n                    angle = (sum === 0 && stillShowZeroSum)\n                        ? unitRadian : (value * unitRadian);\n                }\n                else {\n                    angle = PI2 / validDataCount;\n                }\n\n                if (angle < minAngle) {\n                    angle = minAngle;\n                    restAngle -= minAngle;\n                }\n                else {\n                    valueSumLargerThanMinAngle += value;\n                }\n\n                var endAngle = currentAngle + dir * angle;\n                data.setItemLayout(idx, {\n                    angle: angle,\n                    startAngle: currentAngle,\n                    endAngle: endAngle,\n                    clockwise: clockwise,\n                    cx: cx,\n                    cy: cy,\n                    r0: r0,\n                    r: roseType\n                        ? numberUtil.linearMap(value, extent, [r0, r])\n                        : r\n                });\n\n                currentAngle = endAngle;\n            }, true);\n\n            // Some sector is constrained by minAngle\n            // Rest sectors needs recalculate angle\n            if (restAngle < PI2 && validDataCount) {\n                // Average the angle if rest angle is not enough after all angles is\n                // Constrained by minAngle\n                if (restAngle <= 1e-3) {\n                    var angle = PI2 / validDataCount;\n                    data.each('value', function (value, idx) {\n                        if (!isNaN(value)) {\n                            var layout = data.getItemLayout(idx);\n                            layout.angle = angle;\n                            layout.startAngle = startAngle + dir * idx * angle;\n                            layout.endAngle = startAngle + dir * (idx + 1) * angle;\n                        }\n                    });\n                }\n                else {\n                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n                    currentAngle = startAngle;\n                    data.each('value', function (value, idx) {\n                        if (!isNaN(value)) {\n                            var layout = data.getItemLayout(idx);\n                            var angle = layout.angle === minAngle\n                                ? minAngle : value * unitRadian;\n                            layout.startAngle = currentAngle;\n                            layout.endAngle = currentAngle + dir * angle;\n                            currentAngle += dir * angle;\n                        }\n                    });\n                }\n            }\n\n            labelLayout(seriesModel, r, width, height);\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/pieLayout.js\n// module id = 1160\n// module chunks = 0 2","'use strict';\n// FIXME emphasis label position is not same with normal label position\n\n\n    var textContain = require('zrender/lib/contain/text');\n\n    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n        list.sort(function (a, b) {\n            return a.y - b.y;\n        });\n\n        // \n        function shiftDown(start, end, delta, dir) {\n            for (var j = start; j < end; j++) {\n                list[j].y += delta;\n                if (j > start\n                    && j + 1 < end\n                    && list[j + 1].y > list[j].y + list[j].height\n                ) {\n                    shiftUp(j, delta / 2);\n                    return;\n                }\n            }\n\n            shiftUp(end - 1, delta / 2);\n        }\n\n        // \n        function shiftUp(end, delta) {\n            for (var j = end; j >= 0; j--) {\n                list[j].y -= delta;\n                if (j > 0\n                    && list[j].y > list[j - 1].y + list[j - 1].height\n                ) {\n                    break;\n                }\n            }\n        }\n\n        function changeX(list, isDownList, cx, cy, r, dir) {\n            var lastDeltaX = dir > 0\n                ? isDownList                // \n                    ? Number.MAX_VALUE      // \n                    : 0                     // \n                : isDownList                // \n                    ? Number.MAX_VALUE      // \n                    : 0;                    // \n\n            for (var i = 0, l = list.length; i < l; i++) {\n                // Not change x for center label\n                if (list[i].position === 'center') {\n                    continue;\n                }\n                var deltaY = Math.abs(list[i].y - cy);\n                var length = list[i].len;\n                var length2 = list[i].len2;\n                var deltaX = (deltaY < r + length)\n                    ? Math.sqrt(\n                          (r + length + length2) * (r + length + length2)\n                          - deltaY * deltaY\n                      )\n                    : Math.abs(list[i].x - cx);\n                if (isDownList && deltaX >= lastDeltaX) {\n                    // \n                    deltaX = lastDeltaX - 10;\n                }\n                if (!isDownList && deltaX <= lastDeltaX) {\n                    // \n                    deltaX = lastDeltaX + 10;\n                }\n\n                list[i].x = cx + deltaX * dir;\n                lastDeltaX = deltaX;\n            }\n        }\n\n        var lastY = 0;\n        var delta;\n        var len = list.length;\n        var upList = [];\n        var downList = [];\n        for (var i = 0; i < len; i++) {\n            delta = list[i].y - lastY;\n            if (delta < 0) {\n                shiftDown(i, len, -delta, dir);\n            }\n            lastY = list[i].y + list[i].height;\n        }\n        if (viewHeight - lastY < 0) {\n            shiftUp(len - 1, lastY - viewHeight);\n        }\n        for (var i = 0; i < len; i++) {\n            if (list[i].y >= cy) {\n                downList.push(list[i]);\n            }\n            else {\n                upList.push(list[i]);\n            }\n        }\n        changeX(upList, false, cx, cy, r, dir);\n        changeX(downList, true, cx, cy, r, dir);\n    }\n\n    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n        var leftList = [];\n        var rightList = [];\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            if (labelLayoutList[i].x < cx) {\n                leftList.push(labelLayoutList[i]);\n            }\n            else {\n                rightList.push(labelLayoutList[i]);\n            }\n        }\n\n        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            var linePoints = labelLayoutList[i].linePoints;\n            if (linePoints) {\n                var dist = linePoints[1][0] - linePoints[2][0];\n                if (labelLayoutList[i].x < cx) {\n                    linePoints[2][0] = labelLayoutList[i].x + 3;\n                }\n                else {\n                    linePoints[2][0] = labelLayoutList[i].x - 3;\n                }\n                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n                linePoints[1][0] = linePoints[2][0] + dist;\n            }\n        }\n    }\n\n    module.exports = function (seriesModel, r, viewWidth, viewHeight) {\n        var data = seriesModel.getData();\n        var labelLayoutList = [];\n        var cx;\n        var cy;\n        var hasLabelRotate = false;\n\n        data.each(function (idx) {\n            var layout = data.getItemLayout(idx);\n\n            var itemModel = data.getItemModel(idx);\n            var labelModel = itemModel.getModel('label.normal');\n            // Use position in normal or emphasis\n            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n\n            var labelLineModel = itemModel.getModel('labelLine.normal');\n            var labelLineLen = labelLineModel.get('length');\n            var labelLineLen2 = labelLineModel.get('length2');\n\n            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n            var dx = Math.cos(midAngle);\n            var dy = Math.sin(midAngle);\n\n            var textX;\n            var textY;\n            var linePoints;\n            var textAlign;\n\n            cx = layout.cx;\n            cy = layout.cy;\n\n            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n            if (labelPosition === 'center') {\n                textX = layout.cx;\n                textY = layout.cy;\n                textAlign = 'center';\n            }\n            else {\n                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n\n                textX = x1 + dx * 3;\n                textY = y1 + dy * 3;\n\n                if (!isLabelInside) {\n                    // For roseType\n                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n                    var x3 = x2 + ((dx < 0 ? -1 : 1) * labelLineLen2);\n                    var y3 = y2;\n\n                    textX = x3 + (dx < 0 ? -5 : 5);\n                    textY = y3;\n                    linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n                }\n\n                textAlign = isLabelInside ? 'center' : (dx > 0 ? 'left' : 'right');\n            }\n            var font = labelModel.getFont();\n\n            var labelRotate = labelModel.get('rotate')\n                ? (dx < 0 ? -midAngle + Math.PI : -midAngle) : 0;\n            var text = seriesModel.getFormattedLabel(idx, 'normal')\n                        || data.getName(idx);\n            var textRect = textContain.getBoundingRect(\n                text, font, textAlign, 'top'\n            );\n            hasLabelRotate = !!labelRotate;\n            layout.label = {\n                x: textX,\n                y: textY,\n                position: labelPosition,\n                height: textRect.height,\n                len: labelLineLen,\n                len2: labelLineLen2,\n                linePoints: linePoints,\n                textAlign: textAlign,\n                verticalAlign: 'middle',\n                rotation: labelRotate,\n                inside: isLabelInside\n            };\n\n            // Not layout the inside label\n            if (!isLabelInside) {\n                labelLayoutList.push(layout.label);\n            }\n        });\n        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/chart/pie/labelLayout.js\n// module id = 1161\n// module chunks = 0 2","import React from 'react'\nimport echarts from 'echarts/lib/echarts' //\nimport 'echarts/lib/component/tooltip'\nimport 'echarts/lib/component/legend'\nimport 'echarts/lib/chart/pie'\nimport 'echarts/lib/component/toolbox'\n\nexport default class PieReact extends React.Component {\n  \n  constructor(props) {\n    super(props)\n    this.initPie = this.initPie.bind(this)\n  }\n  \n  initPie() {\n    const { option={} } = this.props; //data\n    let myChart = echarts.init(this.ID); //echarts\n\n    //options\n    myChart.setOption(option)\n    window.onresize = function() {\n      myChart.resize()\n    }\n  }\n  \n  componentDidMount() {\n    this.initPie()\n  }\n  \n  componentDidUpdate() {\n    this.initPie()\n  }\n  \n  render() {\n    const { width=\"100%\", height = '300px' } = this.props\n    return <div ref={ID => this.ID = ID} style={{width, height}}></div>\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/Echarts/PieReact.js","/**\n * @module zrender/core/util\n */\n\n\n    // mergeDate\n    var BUILTIN_OBJECT = {\n        '[object Function]': 1,\n        '[object RegExp]': 1,\n        '[object Date]': 1,\n        '[object Error]': 1,\n        '[object CanvasGradient]': 1,\n        '[object CanvasPattern]': 1,\n        // For node-canvas\n        '[object Image]': 1,\n        '[object Canvas]': 1\n    };\n\n    var TYPED_ARRAY = {\n        '[object Int8Array]': 1,\n        '[object Uint8Array]': 1,\n        '[object Uint8ClampedArray]': 1,\n        '[object Int16Array]': 1,\n        '[object Uint16Array]': 1,\n        '[object Int32Array]': 1,\n        '[object Uint32Array]': 1,\n        '[object Float32Array]': 1,\n        '[object Float64Array]': 1\n    };\n\n    var objToString = Object.prototype.toString;\n\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n\n    /**\n     * Those data types can be cloned:\n     *     Plain object, Array, TypedArray, number, string, null, undefined.\n     * Those data types will be assgined using the orginal data:\n     *     BUILTIN_OBJECT\n     * Instance of user defined class will be cloned to a plain object, without\n     * properties in prototype.\n     * Other data types is not supported (not sure what will happen).\n     *\n     * Caution: do not support clone Date, for performance consideration.\n     * (There might be a large number of date in `series.data`).\n     * So date should not be modified in and out of echarts.\n     *\n     * @param {*} source\n     * @return {*} new\n     */\n    function clone(source) {\n        if (source == null || typeof source != 'object') {\n            return source;\n        }\n\n        var result = source;\n        var typeStr = objToString.call(source);\n\n        if (typeStr === '[object Array]') {\n            result = [];\n            for (var i = 0, len = source.length; i < len; i++) {\n                result[i] = clone(source[i]);\n            }\n        }\n        else if (TYPED_ARRAY[typeStr]) {\n            var Ctor = source.constructor;\n            if (source.constructor.from) {\n                result = Ctor.from(source);\n            }\n            else {\n                result = new Ctor(source.length);\n                for (var i = 0, len = source.length; i < len; i++) {\n                    result[i] = clone(source[i]);\n                }\n            }\n        }\n        else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n            result = {};\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    result[key] = clone(source[key]);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuiltInObject(sourceProp)\n                    && !isBuiltInObject(targetProp)\n                    && !isPrimitive(sourceProp)\n                    && !isPrimitive(targetProp)\n                ) {\n                    // merge\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    // overwritetrue\n                    // NOTE target[key] \n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)\n                && (overlay ? source[key] != null : target[key] == null)\n            ) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n\n    /**\n     * index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * \n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz \n     * @param {Function} baseClazz \n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {}\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n\n        defaults(target, source, overlay);\n    }\n\n    /**\n     * Consider typed array.\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (! data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        }\n        else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        }\n        else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuiltInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return typeof value === 'object'\n            && typeof value.nodeType === 'number'\n            && typeof value.ownerDocument === 'object';\n    }\n\n    /**\n     * Whether is exactly NaN. Notice isNaN('a') returns true.\n     * @param {*} value\n     * @return {boolean}\n     */\n    function eqNaN(value) {\n        return value !== value;\n    }\n\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * Low performance.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n\n    function retrieve2(value0, value1) {\n        return value0 != null\n            ? value0\n            : value1;\n    }\n\n    function retrieve3(value0, value1, value2) {\n        return value0 != null\n            ? value0\n            : value1 != null\n            ? value1\n            : value2;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n\n    /**\n     * Normalize css liked array configuration\n     * e.g.\n     *  3 => [3, 3, 3, 3]\n     *  [4, 2] => [4, 2, 4, 2]\n     *  [4, 3, 2] => [4, 3, 2, 3]\n     * @param {number|Array.<number>} val\n     * @return {Array.<number>}\n     */\n    function normalizeCssArray(val) {\n        if (typeof (val) === 'number') {\n            return [val, val, val, val];\n        }\n        var len = val.length;\n        if (len === 2) {\n            // vertical | horizontal\n            return [val[0], val[1], val[0], val[1]];\n        }\n        else if (len === 3) {\n            // top | horizontal | bottom\n            return [val[0], val[1], val[2], val[1]];\n        }\n        return val;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n\n    var primitiveKey = '__ec_primitive__';\n    /**\n     * Set an object as primitive to be ignored traversing children in clone or merge\n     */\n    function setAsPrimitive(obj) {\n        obj[primitiveKey] = true;\n    }\n\n    function isPrimitive(obj) {\n        return obj[primitiveKey];\n    }\n\n    /**\n     * @constructor\n     * @param {Object} obj Only apply `ownProperty`.\n     */\n    function HashMap(obj) {\n        obj && each(obj, function (value, key) {\n            this.set(key, value);\n        }, this);\n    }\n\n    // Add prefix to avoid conflict with Object.prototype.\n    var HASH_MAP_PREFIX = '_ec_';\n    var HASH_MAP_PREFIX_LENGTH = 4;\n\n    HashMap.prototype = {\n        constructor: HashMap,\n        // Do not provide `has` method to avoid defining what is `has`.\n        // (We usually treat `null` and `undefined` as the same, different\n        // from ES6 Map).\n        get: function (key) {\n            return this[HASH_MAP_PREFIX + key];\n        },\n        set: function (key, value) {\n            this[HASH_MAP_PREFIX + key] = value;\n            // Comparing with invocation chaining, `return value` is more commonly\n            // used in this case: `var someVal = map.set('a', genVal());`\n            return value;\n        },\n        // Although util.each can be performed on this hashMap directly, user\n        // should not use the exposed keys, who are prefixed.\n        each: function (cb, context) {\n            context !== void 0 && (cb = bind(cb, context));\n            for (var prefixedKey in this) {\n                this.hasOwnProperty(prefixedKey)\n                    && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH));\n            }\n        },\n        // Do not use this method if performance sensitive.\n        removeKey: function (key) {\n            delete this[HASH_MAP_PREFIX + key];\n        }\n    };\n\n    function createHashMap(obj) {\n        return new HashMap(obj);\n    }\n\n    var util = {\n        inherits: inherits,\n        mixin: mixin,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n        getContext: getContext,\n        createCanvas: createCanvas,\n        indexOf: indexOf,\n        slice: slice,\n        find: find,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        isBuiltInObject: isBuiltInObject,\n        isDom: isDom,\n        eqNaN: eqNaN,\n        retrieve: retrieve,\n        retrieve2: retrieve2,\n        retrieve3: retrieve3,\n        assert: assert,\n        setAsPrimitive: setAsPrimitive,\n        createHashMap: createHashMap,\n        normalizeCssArray: normalizeCssArray,\n        noop: function () {}\n    };\n    module.exports = util;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/core/util.js\n// module id = 971\n// module chunks = 0 1 2","// Enable DEV mode when using source code without build. which has no __DEV__ variable\n// In build process 'typeof __DEV__' will be replace with 'boolean'\n// So this code will be removed or disabled anyway after built.\nif (typeof __DEV__ === 'undefined') {\n    // In browser\n    if (typeof window !== 'undefined') {\n        window.__DEV__ = true;\n    }\n    // In node\n    else if (typeof global !== 'undefined') {\n        global.__DEV__ = true;\n    }\n}\n\n/*!\n * ECharts, a javascript interactive chart library.\n *\n * Copyright (c) 2015, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt\n */\n\n/**\n * @module echarts\n */\n\n\n    var env = require('zrender/lib/core/env');\n\n    var GlobalModel = require('./model/Global');\n    var ExtensionAPI = require('./ExtensionAPI');\n    var CoordinateSystemManager = require('./CoordinateSystem');\n    var OptionManager = require('./model/OptionManager');\n    var backwardCompat = require('./preprocessor/backwardCompat');\n\n    var ComponentModel = require('./model/Component');\n    var SeriesModel = require('./model/Series');\n\n    var ComponentView = require('./view/Component');\n    var ChartView = require('./view/Chart');\n    var graphic = require('./util/graphic');\n    var modelUtil = require('./util/model');\n    var throttle = require('./util/throttle');\n\n    var zrender = require('zrender/lib/zrender');\n    var zrUtil = require('zrender/lib/core/util');\n    var colorTool = require('zrender/lib/tool/color');\n    var Eventful = require('zrender/lib/mixin/Eventful');\n    var timsort = require('zrender/lib/core/timsort');\n\n\n    var each = zrUtil.each;\n    var parseClassType = ComponentModel.parseClassType;\n\n    var PRIORITY_PROCESSOR_FILTER = 1000;\n    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n\n\n    var PRIORITY_VISUAL_LAYOUT = 1000;\n    var PRIORITY_VISUAL_GLOBAL = 2000;\n    var PRIORITY_VISUAL_CHART = 3000;\n    var PRIORITY_VISUAL_COMPONENT = 4000;\n    // FIXME\n    // necessary?\n    var PRIORITY_VISUAL_BRUSH = 5000;\n\n    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,\n    // where they must not be invoked nestedly, except the only case: invoke\n    // dispatchAction with updateMethod \"none\" in main process.\n    // This flag is used to carry out this rule.\n    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).\n    var IN_MAIN_PROCESS = '__flagInMainProcess';\n    var HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';\n    var OPTION_UPDATED = '__optionUpdated';\n    var ACTION_REG = /^[a-zA-Z0-9_]+$/;\n\n\n    function createRegisterEventWithLowercaseName(method) {\n        return function (eventName, handler, context) {\n            // Event name is all lowercase\n            eventName = eventName && eventName.toLowerCase();\n            Eventful.prototype[method].call(this, eventName, handler, context);\n        };\n    }\n\n    /**\n     * @module echarts~MessageCenter\n     */\n    function MessageCenter() {\n        Eventful.call(this);\n    }\n    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');\n    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');\n    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');\n    zrUtil.mixin(MessageCenter, Eventful);\n\n    /**\n     * @module echarts~ECharts\n     */\n    function ECharts(dom, theme, opts) {\n        opts = opts || {};\n\n        // Get theme by name\n        if (typeof theme === 'string') {\n            theme = themeStorage[theme];\n        }\n\n        /**\n         * @type {string}\n         */\n        this.id;\n        /**\n         * Group id\n         * @type {string}\n         */\n        this.group;\n        /**\n         * @type {HTMLElement}\n         * @private\n         */\n        this._dom = dom;\n        /**\n         * @type {module:zrender/ZRender}\n         * @private\n         */\n        var zr = this._zr = zrender.init(dom, {\n            renderer: opts.renderer || 'canvas',\n            devicePixelRatio: opts.devicePixelRatio,\n            width: opts.width,\n            height: opts.height\n        });\n\n        /**\n         * Expect 60 pfs.\n         * @type {Function}\n         * @private\n         */\n        this._throttledZrFlush = throttle.throttle(zrUtil.bind(zr.flush, zr), 17);\n\n        var theme = zrUtil.clone(theme);\n        theme && backwardCompat(theme, true);\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._theme = theme;\n\n        /**\n         * @type {Array.<module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Chart>}\n         * @private\n         */\n        this._chartsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsViews = [];\n\n        /**\n         * @type {Object.<string, module:echarts/view/Component>}\n         * @private\n         */\n        this._componentsMap = {};\n\n        /**\n         * @type {module:echarts/CoordinateSystem}\n         * @private\n         */\n        this._coordSysMgr = new CoordinateSystemManager();\n\n        /**\n         * @type {module:echarts/ExtensionAPI}\n         * @private\n         */\n        this._api = createExtensionAPI(this);\n\n        Eventful.call(this);\n\n        /**\n         * @type {module:echarts~MessageCenter}\n         * @private\n         */\n        this._messageCenter = new MessageCenter();\n\n        // Init mouse events\n        this._initEvents();\n\n        // In case some people write `window.onresize = chart.resize`\n        this.resize = zrUtil.bind(this.resize, this);\n\n        // Can't dispatch action during rendering procedure\n        this._pendingActions = [];\n        // Sort on demand\n        function prioritySortFunc(a, b) {\n            return a.prio - b.prio;\n        }\n        timsort(visualFuncs, prioritySortFunc);\n        timsort(dataProcessorFuncs, prioritySortFunc);\n\n        zr.animation.on('frame', this._onframe, this);\n\n        // ECharts instance can be used as value.\n        zrUtil.setAsPrimitive(this);\n    }\n\n    var echartsProto = ECharts.prototype;\n\n    echartsProto._onframe = function () {\n        // Lazy update\n        if (this[OPTION_UPDATED]) {\n            var silent = this[OPTION_UPDATED].silent;\n\n            this[IN_MAIN_PROCESS] = true;\n\n            updateMethods.prepareAndUpdate.call(this);\n\n            this[IN_MAIN_PROCESS] = false;\n\n            this[OPTION_UPDATED] = false;\n\n            flushPendingActions.call(this, silent);\n\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n    /**\n     * @return {HTMLElement}\n     */\n    echartsProto.getDom = function () {\n        return this._dom;\n    };\n\n    /**\n     * @return {module:zrender~ZRender}\n     */\n    echartsProto.getZr = function () {\n        return this._zr;\n    };\n\n    /**\n     * Usage:\n     * chart.setOption(option, notMerge, lazyUpdate);\n     * chart.setOption(option, {\n     *     notMerge: ...,\n     *     lazyUpdate: ...,\n     *     silent: ...\n     * });\n     *\n     * @param {Object} option\n     * @param {Object|boolean} [opts] opts or notMerge.\n     * @param {boolean} [opts.notMerge=false]\n     * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently.\n     */\n    echartsProto.setOption = function (option, notMerge, lazyUpdate) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');\n        }\n\n        var silent;\n        if (zrUtil.isObject(notMerge)) {\n            lazyUpdate = notMerge.lazyUpdate;\n            silent = notMerge.silent;\n            notMerge = notMerge.notMerge;\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        if (!this._model || notMerge) {\n            var optionManager = new OptionManager(this._api);\n            var theme = this._theme;\n            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);\n            ecModel.init(null, null, theme, optionManager);\n        }\n\n        this._model.setOption(option, optionPreprocessorFuncs);\n\n        if (lazyUpdate) {\n            this[OPTION_UPDATED] = {silent: silent};\n            this[IN_MAIN_PROCESS] = false;\n        }\n        else {\n            updateMethods.prepareAndUpdate.call(this);\n            // Ensure zr refresh sychronously, and then pixel in canvas can be\n            // fetched after `setOption`.\n            this._zr.flush();\n\n            this[OPTION_UPDATED] = false;\n            this[IN_MAIN_PROCESS] = false;\n\n            flushPendingActions.call(this, silent);\n            triggerUpdatedEvent.call(this, silent);\n        }\n    };\n\n    /**\n     * @DEPRECATED\n     */\n    echartsProto.setTheme = function () {\n        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n    };\n\n    /**\n     * @return {module:echarts/model/Global}\n     */\n    echartsProto.getModel = function () {\n        return this._model;\n    };\n\n    /**\n     * @return {Object}\n     */\n    echartsProto.getOption = function () {\n        return this._model && this._model.getOption();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getWidth = function () {\n        return this._zr.getWidth();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getHeight = function () {\n        return this._zr.getHeight();\n    };\n\n    /**\n     * @return {number}\n     */\n    echartsProto.getDevicePixelRatio = function () {\n        return this._zr.painter.dpr || window.devicePixelRatio || 1;\n    };\n\n    /**\n     * Get canvas which has all thing rendered\n     * @param {Object} opts\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getRenderedCanvas = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        opts = opts || {};\n        opts.pixelRatio = opts.pixelRatio || 1;\n        opts.backgroundColor = opts.backgroundColor\n            || this._model.get('backgroundColor');\n        var zr = this._zr;\n        var list = zr.storage.getDisplayList();\n        // Stop animations\n        zrUtil.each(list, function (el) {\n            el.stopAnimation(true);\n        });\n        return zr.painter.getRenderedCanvas(opts);\n    };\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     * @param {string} [opts.excludeComponents]\n     */\n    echartsProto.getDataURL = function (opts) {\n        opts = opts || {};\n        var excludeComponents = opts.excludeComponents;\n        var ecModel = this._model;\n        var excludesComponentViews = [];\n        var self = this;\n\n        each(excludeComponents, function (componentType) {\n            ecModel.eachComponent({\n                mainType: componentType\n            }, function (component) {\n                var view = self._componentsMap[component.__viewId];\n                if (!view.group.ignore) {\n                    excludesComponentViews.push(view);\n                    view.group.ignore = true;\n                }\n            });\n        });\n\n        var url = this.getRenderedCanvas(opts).toDataURL(\n            'image/' + (opts && opts.type || 'png')\n        );\n\n        each(excludesComponentViews, function (view) {\n            view.group.ignore = false;\n        });\n        return url;\n    };\n\n\n    /**\n     * @return {string}\n     * @param {Object} opts\n     * @param {string} [opts.type='png']\n     * @param {string} [opts.pixelRatio=1]\n     * @param {string} [opts.backgroundColor]\n     */\n    echartsProto.getConnectedDataURL = function (opts) {\n        if (!env.canvasSupported) {\n            return;\n        }\n        var groupId = this.group;\n        var mathMin = Math.min;\n        var mathMax = Math.max;\n        var MAX_NUMBER = Infinity;\n        if (connectedGroups[groupId]) {\n            var left = MAX_NUMBER;\n            var top = MAX_NUMBER;\n            var right = -MAX_NUMBER;\n            var bottom = -MAX_NUMBER;\n            var canvasList = [];\n            var dpr = (opts && opts.pixelRatio) || 1;\n\n            zrUtil.each(instances, function (chart, id) {\n                if (chart.group === groupId) {\n                    var canvas = chart.getRenderedCanvas(\n                        zrUtil.clone(opts)\n                    );\n                    var boundingRect = chart.getDom().getBoundingClientRect();\n                    left = mathMin(boundingRect.left, left);\n                    top = mathMin(boundingRect.top, top);\n                    right = mathMax(boundingRect.right, right);\n                    bottom = mathMax(boundingRect.bottom, bottom);\n                    canvasList.push({\n                        dom: canvas,\n                        left: boundingRect.left,\n                        top: boundingRect.top\n                    });\n                }\n            });\n\n            left *= dpr;\n            top *= dpr;\n            right *= dpr;\n            bottom *= dpr;\n            var width = right - left;\n            var height = bottom - top;\n            var targetCanvas = zrUtil.createCanvas();\n            targetCanvas.width = width;\n            targetCanvas.height = height;\n            var zr = zrender.init(targetCanvas);\n\n            each(canvasList, function (item) {\n                var img = new graphic.Image({\n                    style: {\n                        x: item.left * dpr - left,\n                        y: item.top * dpr - top,\n                        image: item.dom\n                    }\n                });\n                zr.add(img);\n            });\n            zr.refreshImmediately();\n\n            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n        }\n        else {\n            return this.getDataURL(opts);\n        }\n    };\n\n    /**\n     * Convert from logical coordinate system to pixel coordinate system.\n     * See CoordinateSystem#convertToPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId, geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');\n\n    /**\n     * Convert from pixel coordinate system to logical coordinate system.\n     * See CoordinateSystem#convertFromPixel.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {Array|number} result\n     */\n    echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');\n\n    function doConvertPixel(methodName, finder, value) {\n        var ecModel = this._model;\n        var coordSysList = this._coordSysMgr.getCoordinateSystems();\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        for (var i = 0; i < coordSysList.length; i++) {\n            var coordSys = coordSysList[i];\n            if (coordSys[methodName]\n                && (result = coordSys[methodName](ecModel, finder, value)) != null\n            ) {\n                return result;\n            }\n        }\n\n        if (__DEV__) {\n            console.warn(\n                'No coordinate system that supports ' + methodName + ' found by the given finder.'\n            );\n        }\n    }\n\n    /**\n     * Is the specified coordinate systems or components contain the given pixel point.\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            geoIndex / geoId / geoName,\n     *            bmapIndex / bmapId / bmapName,\n     *            xAxisIndex / xAxisId / xAxisName,\n     *            yAxisIndex / yAxisId / yAxisName,\n     *            gridIndex / gridId / gridName,\n     *            ... (can be extended)\n     *        }\n     * @param {Array|number} value\n     * @return {boolean} result\n     */\n    echartsProto.containPixel = function (finder, value) {\n        var ecModel = this._model;\n        var result;\n\n        finder = modelUtil.parseFinder(ecModel, finder);\n\n        zrUtil.each(finder, function (models, key) {\n            key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {\n                var coordSys = model.coordinateSystem;\n                if (coordSys && coordSys.containPoint) {\n                    result |= !!coordSys.containPoint(value);\n                }\n                else if (key === 'seriesModels') {\n                    var view = this._chartsMap[model.__viewId];\n                    if (view && view.containPoint) {\n                        result |= view.containPoint(value, model);\n                    }\n                    else {\n                        if (__DEV__) {\n                            console.warn(key + ': ' + (view\n                                ? 'The found component do not support containPoint.'\n                                : 'No view mapping to the found component.'\n                            ));\n                        }\n                    }\n                }\n                else {\n                    if (__DEV__) {\n                        console.warn(key + ': containPoint is not supported');\n                    }\n                }\n            }, this);\n        }, this);\n\n        return !!result;\n    };\n\n    /**\n     * Get visual from series or data.\n     * @param {string|Object} finder\n     *        If string, e.g., 'series', means {seriesIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex / seriesId / seriesName,\n     *            dataIndex / dataIndexInside\n     *        }\n     *        If dataIndex is not specified, series visual will be fetched,\n     *        but not data item visual.\n     *        If all of seriesIndex, seriesId, seriesName are not specified,\n     *        visual will be fetched from first series.\n     * @param {string} visualType 'color', 'symbol', 'symbolSize'\n     */\n    echartsProto.getVisual = function (finder, visualType) {\n        var ecModel = this._model;\n\n        finder = modelUtil.parseFinder(ecModel, finder, {defaultMainType: 'series'});\n\n        var seriesModel = finder.seriesModel;\n\n        if (__DEV__) {\n            if (!seriesModel) {\n                console.warn('There is no specified seires model');\n            }\n        }\n\n        var data = seriesModel.getData();\n\n        var dataIndexInside = finder.hasOwnProperty('dataIndexInside')\n            ? finder.dataIndexInside\n            : finder.hasOwnProperty('dataIndex')\n            ? data.indexOfRawIndex(finder.dataIndex)\n            : null;\n\n        return dataIndexInside != null\n            ? data.getItemVisual(dataIndexInside, visualType)\n            : data.getVisual(visualType);\n    };\n\n    /**\n     * Get view of corresponding component model\n     * @param  {module:echarts/model/Component} componentModel\n     * @return {module:echarts/view/Component}\n     */\n    echartsProto.getViewOfComponentModel = function (componentModel) {\n        return this._componentsMap[componentModel.__viewId];\n    };\n\n    /**\n     * Get view of corresponding series model\n     * @param  {module:echarts/model/Series} seriesModel\n     * @return {module:echarts/view/Chart}\n     */\n    echartsProto.getViewOfSeriesModel = function (seriesModel) {\n        return this._chartsMap[seriesModel.__viewId];\n    };\n\n\n    var updateMethods = {\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        update: function (payload) {\n            // console.profile && console.profile('update');\n\n            var ecModel = this._model;\n            var api = this._api;\n            var coordSysMgr = this._coordSysMgr;\n            var zr = this._zr;\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            // Fixme First time update ?\n            ecModel.restoreData();\n\n            // TODO\n            // Save total ecModel here for undo/redo (after restoring data and before processing data).\n            // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.\n\n            // Create new coordinate system each update\n            // In LineView may save the old coordinate system and use it to get the orignal point\n            coordSysMgr.create(this._model, this._api);\n\n            processData.call(this, ecModel, api);\n\n            stackSeriesData.call(this, ecModel);\n\n            coordSysMgr.update(ecModel, api);\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            doRender.call(this, ecModel, payload);\n\n            // Set background\n            var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n\n            var painter = zr.painter;\n            // TODO all use clearColor ?\n            if (painter.isSingleCanvas && painter.isSingleCanvas()) {\n                zr.configLayer(0, {\n                    clearColor: backgroundColor\n                });\n            }\n            else {\n                // In IE8\n                if (!env.canvasSupported) {\n                    var colorArr = colorTool.parse(backgroundColor);\n                    backgroundColor = colorTool.stringify(colorArr, 'rgb');\n                    if (colorArr[3] === 0) {\n                        backgroundColor = 'transparent';\n                    }\n                }\n                if (backgroundColor.colorStops || backgroundColor.image) {\n                    // Gradient background\n                    // FIXME Fixed layer\n                    zr.configLayer(0, {\n                        clearColor: backgroundColor\n                    });\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = true;\n\n                    this._dom.style.background = 'transparent';\n                }\n                else {\n                    if (this[HAS_GRADIENT_OR_PATTERN_BG]) {\n                        zr.configLayer(0, {\n                            clearColor: null\n                        });\n                    }\n                    this[HAS_GRADIENT_OR_PATTERN_BG] = false;\n\n                    this._dom.style.background = backgroundColor;\n                }\n            }\n\n            each(postUpdateFuncs, function (func) {\n                func(ecModel, api);\n            });\n\n            // console.profile && console.profileEnd('update');\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateView: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateView', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateVisual: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            ecModel.eachSeries(function (seriesModel) {\n                seriesModel.getData().clearAllVisual();\n            });\n\n            doVisualEncoding.call(this, ecModel, payload, true);\n\n            invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        updateLayout: function (payload) {\n            var ecModel = this._model;\n\n            // update before setOption\n            if (!ecModel) {\n                return;\n            }\n\n            doLayout.call(this, ecModel, payload);\n\n            invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);\n        },\n\n        /**\n         * @param {Object} payload\n         * @private\n         */\n        prepareAndUpdate: function (payload) {\n            var ecModel = this._model;\n\n            prepareView.call(this, 'component', ecModel);\n\n            prepareView.call(this, 'chart', ecModel);\n\n            updateMethods.update.call(this, payload);\n        }\n    };\n\n    /**\n     * @private\n     */\n    function updateDirectly(ecIns, method, payload, mainType, subType) {\n        var ecModel = ecIns._model;\n\n        // broadcast\n        if (!mainType) {\n            each(ecIns._componentsViews.concat(ecIns._chartsViews), callView);\n            return;\n        }\n\n        var query = {};\n        query[mainType + 'Id'] = payload[mainType + 'Id'];\n        query[mainType + 'Index'] = payload[mainType + 'Index'];\n        query[mainType + 'Name'] = payload[mainType + 'Name'];\n\n        var condition = {mainType: mainType, query: query};\n        subType && (condition.subType = subType); // subType may be '' by parseClassType;\n\n        // If dispatchAction before setOption, do nothing.\n        ecModel && ecModel.eachComponent(condition, function (model, index) {\n            callView(ecIns[\n                mainType === 'series' ? '_chartsMap' : '_componentsMap'\n            ][model.__viewId]);\n        }, ecIns);\n\n        function callView(view) {\n            view && view.__alive && view[method] && view[method](\n                view.__model, ecModel, ecIns._api, payload\n            );\n        }\n    }\n\n    /**\n     * Resize the chart\n     * @param {Object} opts\n     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n     * @param {boolean} [opts.silent=false]\n     */\n    echartsProto.resize = function (opts) {\n        if (__DEV__) {\n            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');\n        }\n\n        this[IN_MAIN_PROCESS] = true;\n\n        this._zr.resize(opts);\n\n        var optionChanged = this._model && this._model.resetOption('media');\n        var updateMethod = optionChanged ? 'prepareAndUpdate' : 'update';\n\n        updateMethods[updateMethod].call(this);\n\n        // Resize loading effect\n        this._loadingFX && this._loadingFX.resize();\n\n        this[IN_MAIN_PROCESS] = false;\n\n        var silent = opts && opts.silent;\n\n        flushPendingActions.call(this, silent);\n\n        triggerUpdatedEvent.call(this, silent);\n    };\n\n    /**\n     * Show loading effect\n     * @param  {string} [name='default']\n     * @param  {Object} [cfg]\n     */\n    echartsProto.showLoading = function (name, cfg) {\n        if (zrUtil.isObject(name)) {\n            cfg = name;\n            name = '';\n        }\n        name = name || 'default';\n\n        this.hideLoading();\n        if (!loadingEffects[name]) {\n            if (__DEV__) {\n                console.warn('Loading effects ' + name + ' not exists.');\n            }\n            return;\n        }\n        var el = loadingEffects[name](this._api, cfg);\n        var zr = this._zr;\n        this._loadingFX = el;\n\n        zr.add(el);\n    };\n\n    /**\n     * Hide loading effect\n     */\n    echartsProto.hideLoading = function () {\n        this._loadingFX && this._zr.remove(this._loadingFX);\n        this._loadingFX = null;\n    };\n\n    /**\n     * @param {Object} eventObj\n     * @return {Object}\n     */\n    echartsProto.makeActionFromEvent = function (eventObj) {\n        var payload = zrUtil.extend({}, eventObj);\n        payload.type = eventActionMap[eventObj.type];\n        return payload;\n    };\n\n    /**\n     * @pubilc\n     * @param {Object} payload\n     * @param {string} [payload.type] Action type\n     * @param {Object|boolean} [opt] If pass boolean, means opt.silent\n     * @param {boolean} [opt.silent=false] Whether trigger events.\n     * @param {boolean} [opt.flush=undefined]\n     *                  true: Flush immediately, and then pixel in canvas can be fetched\n     *                      immediately. Caution: it might affect performance.\n     *                  false: Not not flush.\n     *                  undefined: Auto decide whether perform flush.\n     */\n    echartsProto.dispatchAction = function (payload, opt) {\n        if (!zrUtil.isObject(opt)) {\n            opt = {silent: !!opt};\n        }\n\n        if (!actions[payload.type]) {\n            return;\n        }\n\n        // Avoid dispatch action before setOption. Especially in `connect`.\n        if (!this._model) {\n            return;\n        }\n\n        // May dispatchAction in rendering procedure\n        if (this[IN_MAIN_PROCESS]) {\n            this._pendingActions.push(payload);\n            return;\n        }\n\n        doDispatchAction.call(this, payload, opt.silent);\n\n        if (opt.flush) {\n            this._zr.flush(true);\n        }\n        else if (opt.flush !== false && env.browser.weChat) {\n            // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`\n            // hang when sliding page (on touch event), which cause that zr does not\n            // refresh util user interaction finished, which is not expected.\n            // But `dispatchAction` may be called too frequently when pan on touch\n            // screen, which impacts performance if do not throttle them.\n            this._throttledZrFlush();\n        }\n\n        flushPendingActions.call(this, opt.silent);\n\n        triggerUpdatedEvent.call(this, opt.silent);\n    };\n\n    function doDispatchAction(payload, silent) {\n        var payloadType = payload.type;\n        var escapeConnect = payload.escapeConnect;\n        var actionWrap = actions[payloadType];\n        var actionInfo = actionWrap.actionInfo;\n\n        var cptType = (actionInfo.update || 'update').split(':');\n        var updateMethod = cptType.pop();\n        cptType = cptType[0] != null && parseClassType(cptType[0]);\n\n        this[IN_MAIN_PROCESS] = true;\n\n        var payloads = [payload];\n        var batched = false;\n        // Batch action\n        if (payload.batch) {\n            batched = true;\n            payloads = zrUtil.map(payload.batch, function (item) {\n                item = zrUtil.defaults(zrUtil.extend({}, item), payload);\n                item.batch = null;\n                return item;\n            });\n        }\n\n        var eventObjBatch = [];\n        var eventObj;\n        var isHighDown = payloadType === 'highlight' || payloadType === 'downplay';\n\n        each(payloads, function (batchItem) {\n            // Action can specify the event by return it.\n            eventObj = actionWrap.action(batchItem, this._model, this._api);\n            // Emit event outside\n            eventObj = eventObj || zrUtil.extend({}, batchItem);\n            // Convert type to eventType\n            eventObj.type = actionInfo.event || eventObj.type;\n            eventObjBatch.push(eventObj);\n\n            // light update does not perform data process, layout and visual.\n            if (isHighDown) {\n                // method, payload, mainType, subType\n                updateDirectly(this, updateMethod, batchItem, 'series');\n            }\n            else if (cptType) {\n                updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);\n            }\n        }, this);\n\n        if (updateMethod !== 'none' && !isHighDown && !cptType) {\n            // Still dirty\n            if (this[OPTION_UPDATED]) {\n                // FIXME Pass payload ?\n                updateMethods.prepareAndUpdate.call(this, payload);\n                this[OPTION_UPDATED] = false;\n            }\n            else {\n                updateMethods[updateMethod].call(this, payload);\n            }\n        }\n\n        // Follow the rule of action batch\n        if (batched) {\n            eventObj = {\n                type: actionInfo.event || payloadType,\n                escapeConnect: escapeConnect,\n                batch: eventObjBatch\n            };\n        }\n        else {\n            eventObj = eventObjBatch[0];\n        }\n\n        this[IN_MAIN_PROCESS] = false;\n\n        !silent && this._messageCenter.trigger(eventObj.type, eventObj);\n    }\n\n    function flushPendingActions(silent) {\n        var pendingActions = this._pendingActions;\n        while (pendingActions.length) {\n            var payload = pendingActions.shift();\n            doDispatchAction.call(this, payload, silent);\n        }\n    }\n\n    function triggerUpdatedEvent(silent) {\n        !silent && this.trigger('updated');\n    }\n\n    /**\n     * Register event\n     * @method\n     */\n    echartsProto.on = createRegisterEventWithLowercaseName('on');\n    echartsProto.off = createRegisterEventWithLowercaseName('off');\n    echartsProto.one = createRegisterEventWithLowercaseName('one');\n\n    /**\n     * @param {string} methodName\n     * @private\n     */\n    function invokeUpdateMethod(methodName, ecModel, payload) {\n        var api = this._api;\n\n        // Update all components\n        each(this._componentsViews, function (component) {\n            var componentModel = component.__model;\n            component[methodName](componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, component);\n        }, this);\n\n        // Upate all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chart = this._chartsMap[seriesModel.__viewId];\n            chart[methodName](seriesModel, ecModel, api, payload);\n\n            updateZ(seriesModel, chart);\n\n            updateProgressiveAndBlend(seriesModel, chart);\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Post render\n        each(postUpdateFuncs, function (func) {\n            func(ecModel, api);\n        });\n    }\n\n    /**\n     * Prepare view instances of charts and components\n     * @param  {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function prepareView(type, ecModel) {\n        var isComponent = type === 'component';\n        var viewList = isComponent ? this._componentsViews : this._chartsViews;\n        var viewMap = isComponent ? this._componentsMap : this._chartsMap;\n        var zr = this._zr;\n\n        for (var i = 0; i < viewList.length; i++) {\n            viewList[i].__alive = false;\n        }\n\n        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {\n            if (isComponent) {\n                if (componentType === 'series') {\n                    return;\n                }\n            }\n            else {\n                model = componentType;\n            }\n\n            // Consider: id same and type changed.\n            var viewId = '_ec_' + model.id + '_' + model.type;\n            var view = viewMap[viewId];\n            if (!view) {\n                var classType = parseClassType(model.type);\n                var Clazz = isComponent\n                    ? ComponentView.getClass(classType.main, classType.sub)\n                    : ChartView.getClass(classType.sub);\n                if (Clazz) {\n                    view = new Clazz();\n                    view.init(ecModel, this._api);\n                    viewMap[viewId] = view;\n                    viewList.push(view);\n                    zr.add(view.group);\n                }\n                else {\n                    // Error\n                    return;\n                }\n            }\n\n            model.__viewId = view.__id = viewId;\n            view.__alive = true;\n            view.__model = model;\n            view.group.__ecComponentInfo = {\n                mainType: model.mainType,\n                index: model.componentIndex\n            };\n        }, this);\n\n        for (var i = 0; i < viewList.length;) {\n            var view = viewList[i];\n            if (!view.__alive) {\n                zr.remove(view.group);\n                view.dispose(ecModel, this._api);\n                viewList.splice(i, 1);\n                delete viewMap[view.__id];\n                view.__id = view.group.__ecComponentInfo = null;\n            }\n            else {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * Processor data in each series\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function processData(ecModel, api) {\n        each(dataProcessorFuncs, function (process) {\n            process.func(ecModel, api);\n        });\n    }\n\n    /**\n     * @private\n     */\n    function stackSeriesData(ecModel) {\n        var stackedDataMap = {};\n        ecModel.eachSeries(function (series) {\n            var stack = series.get('stack');\n            var data = series.getData();\n            if (stack && data.type === 'list') {\n                var previousStack = stackedDataMap[stack];\n                // Avoid conflict with Object.prototype\n                if (stackedDataMap.hasOwnProperty(stack) && previousStack) {\n                    data.stackedOn = previousStack;\n                }\n                stackedDataMap[stack] = data;\n            }\n        });\n    }\n\n    /**\n     * Layout before each chart render there series, special visual encoding stage\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @private\n     */\n    function doLayout(ecModel, payload) {\n        var api = this._api;\n        each(visualFuncs, function (visual) {\n            if (visual.isLayout) {\n                visual.func(ecModel, api, payload);\n            }\n        });\n    }\n\n    /**\n     * Encode visual infomation from data after data processing\n     *\n     * @param {module:echarts/model/Global} ecModel\n     * @param {object} layout\n     * @param {boolean} [excludesLayout]\n     * @private\n     */\n    function doVisualEncoding(ecModel, payload, excludesLayout) {\n        var api = this._api;\n        ecModel.clearColorPalette();\n        ecModel.eachSeries(function (seriesModel) {\n            seriesModel.clearColorPalette();\n        });\n        each(visualFuncs, function (visual) {\n            (!excludesLayout || !visual.isLayout)\n                && visual.func(ecModel, api, payload);\n        });\n    }\n\n    /**\n     * Render each chart and component\n     * @private\n     */\n    function doRender(ecModel, payload) {\n        var api = this._api;\n        // Render all components\n        each(this._componentsViews, function (componentView) {\n            var componentModel = componentView.__model;\n            componentView.render(componentModel, ecModel, api, payload);\n\n            updateZ(componentModel, componentView);\n        }, this);\n\n        each(this._chartsViews, function (chart) {\n            chart.__alive = false;\n        }, this);\n\n        // Render all charts\n        ecModel.eachSeries(function (seriesModel, idx) {\n            var chartView = this._chartsMap[seriesModel.__viewId];\n            chartView.__alive = true;\n            chartView.render(seriesModel, ecModel, api, payload);\n\n            chartView.group.silent = !!seriesModel.get('silent');\n\n            updateZ(seriesModel, chartView);\n\n            updateProgressiveAndBlend(seriesModel, chartView);\n\n        }, this);\n\n        // If use hover layer\n        updateHoverLayerStatus(this._zr, ecModel);\n\n        // Remove groups of unrendered charts\n        each(this._chartsViews, function (chart) {\n            if (!chart.__alive) {\n                chart.remove(ecModel, api);\n            }\n        }, this);\n    }\n\n    var MOUSE_EVENT_NAMES = [\n        'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove',\n        'mousedown', 'mouseup', 'globalout', 'contextmenu'\n    ];\n    /**\n     * @private\n     */\n    echartsProto._initEvents = function () {\n        each(MOUSE_EVENT_NAMES, function (eveName) {\n            this._zr.on(eveName, function (e) {\n                var ecModel = this.getModel();\n                var el = e.target;\n                var params;\n\n                // no e.target when 'globalout'.\n                if (eveName === 'globalout') {\n                    params = {};\n                }\n                else if (el && el.dataIndex != null) {\n                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                    params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};\n                }\n                // If element has custom eventData of components\n                else if (el && el.eventData) {\n                    params = zrUtil.extend({}, el.eventData);\n                }\n\n                if (params) {\n                    params.event = e;\n                    params.type = eveName;\n                    this.trigger(eveName, params);\n                }\n\n            }, this);\n        }, this);\n\n        each(eventActionMap, function (actionType, eventType) {\n            this._messageCenter.on(eventType, function (event) {\n                this.trigger(eventType, event);\n            }, this);\n        }, this);\n    };\n\n    /**\n     * @return {boolean}\n     */\n    echartsProto.isDisposed = function () {\n        return this._disposed;\n    };\n\n    /**\n     * Clear\n     */\n    echartsProto.clear = function () {\n        this.setOption({ series: [] }, true);\n    };\n\n    /**\n     * Dispose instance\n     */\n    echartsProto.dispose = function () {\n        if (this._disposed) {\n            if (__DEV__) {\n                console.warn('Instance ' + this.id + ' has been disposed');\n            }\n            return;\n        }\n        this._disposed = true;\n\n        var api = this._api;\n        var ecModel = this._model;\n\n        each(this._componentsViews, function (component) {\n            component.dispose(ecModel, api);\n        });\n        each(this._chartsViews, function (chart) {\n            chart.dispose(ecModel, api);\n        });\n\n        // Dispose after all views disposed\n        this._zr.dispose();\n\n        delete instances[this.id];\n    };\n\n    zrUtil.mixin(ECharts, Eventful);\n\n    function updateHoverLayerStatus(zr, ecModel) {\n        var storage = zr.storage;\n        var elCount = 0;\n        storage.traverse(function (el) {\n            if (!el.isGroup) {\n                elCount++;\n            }\n        });\n        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {\n            storage.traverse(function (el) {\n                if (!el.isGroup) {\n                    el.useHoverLayer = true;\n                }\n            });\n        }\n    }\n\n    /**\n     * Update chart progressive and blend.\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateProgressiveAndBlend(seriesModel, chartView) {\n        // Progressive configuration\n        var elCount = 0;\n        chartView.group.traverse(function (el) {\n            if (el.type !== 'group' && !el.ignore) {\n                elCount++;\n            }\n        });\n        var frameDrawNum = +seriesModel.get('progressive');\n        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;\n        if (needProgressive) {\n            chartView.group.traverse(function (el) {\n                // FIXME marker and other components\n                if (!el.isGroup) {\n                    el.progressive = needProgressive ?\n                        Math.floor(elCount++ / frameDrawNum) : -1;\n                    if (needProgressive) {\n                        el.stopAnimation(true);\n                    }\n                }\n            });\n        }\n\n        // Blend configration\n        var blendMode = seriesModel.get('blendMode') || null;\n        if (__DEV__) {\n            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n                console.warn('Only canvas support blendMode');\n            }\n        }\n        chartView.group.traverse(function (el) {\n            // FIXME marker and other components\n            if (!el.isGroup) {\n                el.setStyle('blend', blendMode);\n            }\n        });\n    }\n\n    /**\n     * @param {module:echarts/model/Series|module:echarts/model/Component} model\n     * @param {module:echarts/view/Component|module:echarts/view/Chart} view\n     */\n    function updateZ(model, view) {\n        var z = model.get('z');\n        var zlevel = model.get('zlevel');\n        // Set z and zlevel\n        view.group.traverse(function (el) {\n            if (el.type !== 'group') {\n                z != null && (el.z = z);\n                zlevel != null && (el.zlevel = zlevel);\n            }\n        });\n    }\n\n    function createExtensionAPI(ecInstance) {\n        var coordSysMgr = ecInstance._coordSysMgr;\n        return zrUtil.extend(new ExtensionAPI(ecInstance), {\n            // Inject methods\n            getCoordinateSystems: zrUtil.bind(\n                coordSysMgr.getCoordinateSystems, coordSysMgr\n            ),\n            getComponentByElement: function (el) {\n                while (el) {\n                    var modelInfo = el.__ecComponentInfo;\n                    if (modelInfo != null) {\n                        return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index);\n                    }\n                    el = el.parent;\n                }\n            }\n        });\n    }\n\n    /**\n     * @type {Object} key: actionType.\n     * @inner\n     */\n    var actions = {};\n\n    /**\n     * Map eventType to actionType\n     * @type {Object}\n     */\n    var eventActionMap = {};\n\n    /**\n     * Data processor functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var dataProcessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var optionPreprocessorFuncs = [];\n\n    /**\n     * @type {Array.<Function>}\n     * @inner\n     */\n    var postUpdateFuncs = [];\n\n    /**\n     * Visual encoding functions of each stage\n     * @type {Array.<Object.<string, Function>>}\n     * @inner\n     */\n    var visualFuncs = [];\n    /**\n     * Theme storage\n     * @type {Object.<key, Object>}\n     */\n    var themeStorage = {};\n    /**\n     * Loading effects\n     */\n    var loadingEffects = {};\n\n\n    var instances = {};\n    var connectedGroups = {};\n\n    var idBase = new Date() - 0;\n    var groupIdBase = new Date() - 0;\n    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n\n    /**\n     * @alias module:echarts\n     */\n    var echarts = {\n        /**\n         * @type {number}\n         */\n        version: '3.7.2',\n        dependencies: {\n            zrender: '3.6.2'\n        }\n    };\n\n    function enableConnect(chart) {\n        var STATUS_PENDING = 0;\n        var STATUS_UPDATING = 1;\n        var STATUS_UPDATED = 2;\n        var STATUS_KEY = '__connectUpdateStatus';\n\n        function updateConnectedChartsStatus(charts, status) {\n            for (var i = 0; i < charts.length; i++) {\n                var otherChart = charts[i];\n                otherChart[STATUS_KEY] = status;\n            }\n        }\n\n        zrUtil.each(eventActionMap, function (actionType, eventType) {\n            chart._messageCenter.on(eventType, function (event) {\n                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {\n                    if (event && event.escapeConnect) {\n                        return;\n                    }\n\n                    var action = chart.makeActionFromEvent(event);\n                    var otherCharts = [];\n\n                    zrUtil.each(instances, function (otherChart) {\n                        if (otherChart !== chart && otherChart.group === chart.group) {\n                            otherCharts.push(otherChart);\n                        }\n                    });\n\n                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);\n                    each(otherCharts, function (otherChart) {\n                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {\n                            otherChart.dispatchAction(action);\n                        }\n                    });\n                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);\n                }\n            });\n        });\n    }\n\n    /**\n     * @param {HTMLElement} dom\n     * @param {Object} [theme]\n     * @param {Object} opts\n     * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default\n     * @param {string} [opts.renderer] Currently only 'canvas' is supported.\n     * @param {number} [opts.width] Use clientWidth of the input `dom` by default.\n     *                              Can be 'auto' (the same as null/undefined)\n     * @param {number} [opts.height] Use clientHeight of the input `dom` by default.\n     *                               Can be 'auto' (the same as null/undefined)\n     */\n    echarts.init = function (dom, theme, opts) {\n        if (__DEV__) {\n            // Check version\n            if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) {\n                throw new Error(\n                    'ZRender ' + zrender.version\n                    + ' is too old for ECharts ' + echarts.version\n                    + '. Current version need ZRender '\n                    + echarts.dependencies.zrender + '+'\n                );\n            }\n\n            if (!dom) {\n                throw new Error('Initialize failed: invalid dom.');\n            }\n        }\n\n        var existInstance = echarts.getInstanceByDom(dom);\n        if (existInstance) {\n            if (__DEV__) {\n                console.warn('There is a chart instance already initialized on the dom.');\n            }\n            return existInstance;\n        }\n\n        if (__DEV__) {\n            if (zrUtil.isDom(dom)\n                && dom.nodeName.toUpperCase() !== 'CANVAS'\n                && (\n                    (!dom.clientWidth && (!opts || opts.width == null))\n                    || (!dom.clientHeight && (!opts || opts.height == null))\n                )\n            ) {\n                console.warn('Can\\'t get dom width or height');\n            }\n        }\n\n        var chart = new ECharts(dom, theme, opts);\n        chart.id = 'ec_' + idBase++;\n        instances[chart.id] = chart;\n\n        if (dom.setAttribute) {\n            dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);\n        }\n        else {\n            dom[DOM_ATTRIBUTE_KEY] = chart.id;\n        }\n\n        enableConnect(chart);\n\n        return chart;\n    };\n\n    /**\n     * @return {string|Array.<module:echarts~ECharts>} groupId\n     */\n    echarts.connect = function (groupId) {\n        // Is array of charts\n        if (zrUtil.isArray(groupId)) {\n            var charts = groupId;\n            groupId = null;\n            // If any chart has group\n            zrUtil.each(charts, function (chart) {\n                if (chart.group != null) {\n                    groupId = chart.group;\n                }\n            });\n            groupId = groupId || ('g_' + groupIdBase++);\n            zrUtil.each(charts, function (chart) {\n                chart.group = groupId;\n            });\n        }\n        connectedGroups[groupId] = true;\n        return groupId;\n    };\n\n    /**\n     * @DEPRECATED\n     * @return {string} groupId\n     */\n    echarts.disConnect = function (groupId) {\n        connectedGroups[groupId] = false;\n    };\n\n    /**\n     * @return {string} groupId\n     */\n    echarts.disconnect = echarts.disConnect;\n\n    /**\n     * Dispose a chart instance\n     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart\n     */\n    echarts.dispose = function (chart) {\n        if (typeof chart === 'string') {\n            chart = instances[chart];\n        }\n        else if (!(chart instanceof ECharts)){\n            // Try to treat as dom\n            chart = echarts.getInstanceByDom(chart);\n        }\n        if ((chart instanceof ECharts) && !chart.isDisposed()) {\n            chart.dispose();\n        }\n    };\n\n    /**\n     * @param  {HTMLElement} dom\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceByDom = function (dom) {\n        var key;\n        if (dom.getAttribute) {\n            key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\n        }\n        else {\n            key = dom[DOM_ATTRIBUTE_KEY];\n        }\n        return instances[key];\n    };\n\n    /**\n     * @param {string} key\n     * @return {echarts~ECharts}\n     */\n    echarts.getInstanceById = function (key) {\n        return instances[key];\n    };\n\n    /**\n     * Register theme\n     */\n    echarts.registerTheme = function (name, theme) {\n        themeStorage[name] = theme;\n    };\n\n    /**\n     * Register option preprocessor\n     * @param {Function} preprocessorFunc\n     */\n    echarts.registerPreprocessor = function (preprocessorFunc) {\n        optionPreprocessorFuncs.push(preprocessorFunc);\n    };\n\n    /**\n     * @param {number} [priority=1000]\n     * @param {Function} processorFunc\n     */\n    echarts.registerProcessor = function (priority, processorFunc) {\n        if (typeof priority === 'function') {\n            processorFunc = priority;\n            priority = PRIORITY_PROCESSOR_FILTER;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown processor priority');\n            }\n        }\n        dataProcessorFuncs.push({\n            prio: priority,\n            func: processorFunc\n        });\n    };\n\n    /**\n     * Register postUpdater\n     * @param {Function} postUpdateFunc\n     */\n    echarts.registerPostUpdate = function (postUpdateFunc) {\n        postUpdateFuncs.push(postUpdateFunc);\n    };\n\n    /**\n     * Usage:\n     * registerAction('someAction', 'someEvent', function () { ... });\n     * registerAction('someAction', function () { ... });\n     * registerAction(\n     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},\n     *     function () { ... }\n     * );\n     *\n     * @param {(string|Object)} actionInfo\n     * @param {string} actionInfo.type\n     * @param {string} [actionInfo.event]\n     * @param {string} [actionInfo.update]\n     * @param {string} [eventName]\n     * @param {Function} action\n     */\n    echarts.registerAction = function (actionInfo, eventName, action) {\n        if (typeof eventName === 'function') {\n            action = eventName;\n            eventName = '';\n        }\n        var actionType = zrUtil.isObject(actionInfo)\n            ? actionInfo.type\n            : ([actionInfo, actionInfo = {\n                event: eventName\n            }][0]);\n\n        // Event name is all lowercase\n        actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n        eventName = actionInfo.event;\n\n        // Validate action type and event name.\n        zrUtil.assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));\n\n        if (!actions[actionType]) {\n            actions[actionType] = {action: action, actionInfo: actionInfo};\n        }\n        eventActionMap[eventName] = actionType;\n    };\n\n    /**\n     * @param {string} type\n     * @param {*} CoordinateSystem\n     */\n    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {\n        CoordinateSystemManager.register(type, CoordinateSystem);\n    };\n\n    /**\n     * Get dimensions of specified coordinate system.\n     * @param {string} type\n     * @return {Array.<string|Object>}\n     */\n    echarts.getCoordinateSystemDimensions = function (type) {\n        var coordSysCreator = CoordinateSystemManager.get(type);\n        if (coordSysCreator) {\n            return coordSysCreator.getDimensionsInfo\n                    ? coordSysCreator.getDimensionsInfo()\n                    : coordSysCreator.dimensions.slice();\n        }\n    };\n\n    /**\n     * Layout is a special stage of visual encoding\n     * Most visual encoding like color are common for different chart\n     * But each chart has it's own layout algorithm\n     *\n     * @param {number} [priority=1000]\n     * @param {Function} layoutFunc\n     */\n    echarts.registerLayout = function (priority, layoutFunc) {\n        if (typeof priority === 'function') {\n            layoutFunc = priority;\n            priority = PRIORITY_VISUAL_LAYOUT;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown layout priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: layoutFunc,\n            isLayout: true\n        });\n    };\n\n    /**\n     * @param {number} [priority=3000]\n     * @param {Function} visualFunc\n     */\n    echarts.registerVisual = function (priority, visualFunc) {\n        if (typeof priority === 'function') {\n            visualFunc = priority;\n            priority = PRIORITY_VISUAL_CHART;\n        }\n        if (__DEV__) {\n            if (isNaN(priority)) {\n                throw new Error('Unkown visual priority');\n            }\n        }\n        visualFuncs.push({\n            prio: priority,\n            func: visualFunc\n        });\n    };\n\n    /**\n     * @param {string} name\n     */\n    echarts.registerLoading = function (name, loadingFx) {\n        loadingEffects[name] = loadingFx;\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentModel = function (opts/*, superClass*/) {\n        // var Clazz = ComponentModel;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendComponentView = function (opts/*, superClass*/) {\n        // var Clazz = ComponentView;\n        // if (superClass) {\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentView.getClass(classType.main, classType.sub, true);\n        // }\n        return ComponentView.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendSeriesModel = function (opts/*, superClass*/) {\n        // var Clazz = SeriesModel;\n        // if (superClass) {\n        //     superClass = 'series.' + superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ComponentModel.getClass(classType.main, classType.sub, true);\n        // }\n        return SeriesModel.extend(opts);\n    };\n\n    /**\n     * @param {Object} opts\n     * @param {string} [superClass]\n     */\n    echarts.extendChartView = function (opts/*, superClass*/) {\n        // var Clazz = ChartView;\n        // if (superClass) {\n        //     superClass = superClass.replace('series.', '');\n        //     var classType = parseClassType(superClass);\n        //     Clazz = ChartView.getClass(classType.main, true);\n        // }\n        return ChartView.extend(opts);\n    };\n\n    /**\n     * ZRender need a canvas context to do measureText.\n     * But in node environment canvas may be created by node-canvas.\n     * So we need to specify how to create a canvas instead of using document.createElement('canvas')\n     *\n     * Be careful of using it in the browser.\n     *\n     * @param {Function} creator\n     * @example\n     *     var Canvas = require('canvas');\n     *     var echarts = require('echarts');\n     *     echarts.setCanvasCreator(function () {\n     *         // Small size is enough.\n     *         return new Canvas(32, 32);\n     *     });\n     */\n    echarts.setCanvasCreator = function (creator) {\n        zrUtil.createCanvas = creator;\n    };\n\n    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, require('./visual/seriesColor'));\n    echarts.registerPreprocessor(backwardCompat);\n    echarts.registerLoading('default', require('./loading/default'));\n\n    // Default action\n    echarts.registerAction({\n        type: 'highlight',\n        event: 'highlight',\n        update: 'highlight'\n    }, zrUtil.noop);\n    echarts.registerAction({\n        type: 'downplay',\n        event: 'downplay',\n        update: 'downplay'\n    }, zrUtil.noop);\n\n    // --------\n    // Exports\n    // --------\n    echarts.zrender = zrender;\n\n    echarts.List = require('./data/List');\n    echarts.Model = require('./model/Model');\n\n    echarts.Axis = require('./coord/Axis');\n\n    echarts.graphic = require('./util/graphic');\n    echarts.number = require('./util/number');\n    echarts.format = require('./util/format');\n    echarts.throttle = throttle.throttle;\n    echarts.matrix = require('zrender/lib/core/matrix');\n    echarts.vector = require('zrender/lib/core/vector');\n    echarts.color = require('zrender/lib/tool/color');\n\n    echarts.util = {};\n    each([\n            'map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter',\n            'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction',\n            'extend', 'defaults', 'clone', 'merge'\n        ],\n        function (name) {\n            echarts.util[name] = zrUtil[name];\n        }\n    );\n\n    echarts.helper = require('./helper');\n\n\n    // PRIORITY\n    echarts.PRIORITY = {\n        PROCESSOR: {\n            FILTER: PRIORITY_PROCESSOR_FILTER,\n            STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n        },\n        VISUAL: {\n            LAYOUT: PRIORITY_VISUAL_LAYOUT,\n            GLOBAL: PRIORITY_VISUAL_GLOBAL,\n            CHART: PRIORITY_VISUAL_CHART,\n            COMPONENT: PRIORITY_VISUAL_COMPONENT,\n            BRUSH: PRIORITY_VISUAL_BRUSH\n        }\n    };\n\n    module.exports = echarts;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/echarts.js\n// module id = 972\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var pathTool = require('zrender/lib/tool/path');\n    var Path = require('zrender/lib/graphic/Path');\n    var colorTool = require('zrender/lib/tool/color');\n    var matrix = require('zrender/lib/core/matrix');\n    var vector = require('zrender/lib/core/vector');\n    var Transformable = require('zrender/lib/mixin/Transformable');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n\n    var round = Math.round;\n    var mathMax = Math.max;\n    var mathMin = Math.min;\n\n    var EMPTY_OBJ = {};\n\n    var graphic = {};\n\n    graphic.Group = require('zrender/lib/container/Group');\n\n    graphic.Image = require('zrender/lib/graphic/Image');\n\n    graphic.Text = require('zrender/lib/graphic/Text');\n\n    graphic.Circle = require('zrender/lib/graphic/shape/Circle');\n\n    graphic.Sector = require('zrender/lib/graphic/shape/Sector');\n\n    graphic.Ring = require('zrender/lib/graphic/shape/Ring');\n\n    graphic.Polygon = require('zrender/lib/graphic/shape/Polygon');\n\n    graphic.Polyline = require('zrender/lib/graphic/shape/Polyline');\n\n    graphic.Rect = require('zrender/lib/graphic/shape/Rect');\n\n    graphic.Line = require('zrender/lib/graphic/shape/Line');\n\n    graphic.BezierCurve = require('zrender/lib/graphic/shape/BezierCurve');\n\n    graphic.Arc = require('zrender/lib/graphic/shape/Arc');\n\n    graphic.CompoundPath = require('zrender/lib/graphic/CompoundPath');\n\n    graphic.LinearGradient = require('zrender/lib/graphic/LinearGradient');\n\n    graphic.RadialGradient = require('zrender/lib/graphic/RadialGradient');\n\n    graphic.BoundingRect = BoundingRect;\n\n    /**\n     * Extend shape with parameters\n     */\n    graphic.extendShape = function (opts) {\n        return Path.extend(opts);\n    };\n\n    /**\n     * Extend path\n     */\n    graphic.extendPath = function (pathData, opts) {\n        return pathTool.extendFromString(pathData, opts);\n    };\n\n    /**\n     * Create a path element from path data string\n     * @param {string} pathData\n     * @param {Object} opts\n     * @param {module:zrender/core/BoundingRect} rect\n     * @param {string} [layout=cover] 'center' or 'cover'\n     */\n    graphic.makePath = function (pathData, opts, rect, layout) {\n        var path = pathTool.createFromString(pathData, opts);\n        var boundingRect = path.getBoundingRect();\n        if (rect) {\n            var aspect = boundingRect.width / boundingRect.height;\n\n            if (layout === 'center') {\n                // Set rect to center, keep width / height ratio.\n                var width = rect.height * aspect;\n                var height;\n                if (width <= rect.width) {\n                    height = rect.height;\n                }\n                else {\n                    width = rect.width;\n                    height = width / aspect;\n                }\n                var cx = rect.x + rect.width / 2;\n                var cy = rect.y + rect.height / 2;\n\n                rect.x = cx - width / 2;\n                rect.y = cy - height / 2;\n                rect.width = width;\n                rect.height = height;\n            }\n\n            graphic.resizePath(path, rect);\n        }\n        return path;\n    };\n\n    graphic.mergePath = pathTool.mergePath,\n\n    /**\n     * Resize a path to fit the rect\n     * @param {module:zrender/graphic/Path} path\n     * @param {Object} rect\n     */\n    graphic.resizePath = function (path, rect) {\n        if (!path.applyTransform) {\n            return;\n        }\n\n        var pathRect = path.getBoundingRect();\n\n        var m = pathRect.calculateTransform(rect);\n\n        path.applyTransform(m);\n    };\n\n    /**\n     * Sub pixel optimize line for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x1]\n     * @param {number} [param.shape.y1]\n     * @param {number} [param.shape.x2]\n     * @param {number} [param.shape.y2]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeLine = function (param) {\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n        }\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n        }\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize rect for canvas\n     *\n     * @param {Object} param\n     * @param {Object} [param.shape]\n     * @param {number} [param.shape.x]\n     * @param {number} [param.shape.y]\n     * @param {number} [param.shape.width]\n     * @param {number} [param.shape.height]\n     * @param {Object} [param.style]\n     * @param {number} [param.style.lineWidth]\n     * @return {Object} Modified param\n     */\n    graphic.subPixelOptimizeRect = function (param) {\n        var shape = param.shape;\n        var lineWidth = param.style.lineWidth;\n        var originX = shape.x;\n        var originY = shape.y;\n        var originWidth = shape.width;\n        var originHeight = shape.height;\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\n        shape.width = Math.max(\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\n            originWidth === 0 ? 0 : 1\n        );\n        shape.height = Math.max(\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\n            originHeight === 0 ? 0 : 1\n        );\n        return param;\n    };\n\n    /**\n     * Sub pixel optimize for canvas\n     *\n     * @param {number} position Coordinate, such as x, y\n     * @param {number} lineWidth Should be nonnegative integer.\n     * @param {boolean=} positiveOrNegative Default false (negative).\n     * @return {number} Optimized position.\n     */\n    var subPixelOptimize = graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\n        // Assure that (position + lineWidth / 2) is near integer edge,\n        // otherwise line will be fuzzy in canvas.\n        var doubledPosition = round(position * 2);\n        return (doubledPosition + round(lineWidth)) % 2 === 0\n            ? doubledPosition / 2\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n    };\n\n    function hasFillOrStroke(fillOrStroke) {\n        return fillOrStroke != null && fillOrStroke != 'none';\n    }\n\n    function liftColor(color) {\n        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;\n    }\n\n    /**\n     * @private\n     */\n    function cacheElementStl(el) {\n        if (el.__hoverStlDirty) {\n            var stroke = el.style.stroke;\n            var fill = el.style.fill;\n\n            // Create hoverStyle on mouseover\n            var hoverStyle = el.__hoverStl;\n            hoverStyle.fill = hoverStyle.fill\n                || (hasFillOrStroke(fill) ? liftColor(fill) : null);\n            hoverStyle.stroke = hoverStyle.stroke\n                || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);\n\n            var normalStyle = {};\n            for (var name in hoverStyle) {\n                // See comment in `doSingleEnterHover`.\n                if (hoverStyle[name] != null) {\n                    normalStyle[name] = el.style[name];\n                }\n            }\n\n            el.__normalStl = normalStyle;\n\n            el.__hoverStlDirty = false;\n        }\n    }\n\n    /**\n     * @private\n     */\n    function doSingleEnterHover(el) {\n        if (el.__isHover) {\n            return;\n        }\n\n        cacheElementStl(el);\n\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.addHover(el, el.__hoverStl);\n        }\n        else {\n            var style = el.style;\n            var insideRollbackOpt = style.insideRollbackOpt;\n\n            // Consider case: only `position: 'top'` is set on emphasis, then text\n            // color should be returned to `autoColor`, rather than remain '#fff'.\n            // So we should rollback then apply again after style merging.\n            insideRollbackOpt && rollbackInsideStyle(style);\n\n            // styles can be:\n            // {\n            //     label: {\n            //         normal: {\n            //             show: false,\n            //             position: 'outside',\n            //             fontSize: 18\n            //         },\n            //         emphasis: {\n            //             show: true\n            //         }\n            //     }\n            // },\n            // where properties of `emphasis` may not appear in `normal`. We previously use\n            // module:echarts/util/model#defaultEmphasis to merge `normal` to `emphasis`.\n            // But consider rich text and setOption in merge mode, it is impossible to cover\n            // all properties in merge. So we use merge mode when setting style here, where\n            // only properties that is not `null/undefined` can be set. The disadventage:\n            // null/undefined can not be used to remove style any more in `emphasis`.\n            style.extendFrom(el.__hoverStl);\n\n            // Do not save `insideRollback`.\n            if (insideRollbackOpt) {\n                applyInsideStyle(style, style.insideOriginalTextPosition, insideRollbackOpt);\n\n                // textFill may be rollbacked to null.\n                if (style.textFill == null) {\n                    style.textFill = insideRollbackOpt.autoColor;\n                }\n            }\n\n            el.dirty(false);\n            el.z2 += 1;\n        }\n\n        el.__isHover = true;\n    }\n\n    /**\n     * @inner\n     */\n    function doSingleLeaveHover(el) {\n        if (!el.__isHover) {\n            return;\n        }\n\n        var normalStl = el.__normalStl;\n        if (el.useHoverLayer) {\n            el.__zr && el.__zr.removeHover(el);\n        }\n        else {\n            // Consider null/undefined value, should use\n            // `setStyle` but not `extendFrom(stl, true)`.\n            normalStl && el.setStyle(normalStl);\n            el.z2 -= 1;\n        }\n\n        el.__isHover = false;\n    }\n\n    /**\n     * @inner\n     */\n    function doEnterHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleEnterHover(child);\n                }\n            })\n            : doSingleEnterHover(el);\n    }\n\n    function doLeaveHover(el) {\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    doSingleLeaveHover(child);\n                }\n            })\n            : doSingleLeaveHover(el);\n    }\n\n    /**\n     * @inner\n     */\n    function setElementHoverStl(el, hoverStl) {\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\n        // Often used when item group has a label element and it's hoverStyle is different\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\n        el.__hoverStlDirty = true;\n\n        if (el.__isHover) {\n            cacheElementStl(el);\n        }\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOver(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function onElementMouseOut(e) {\n        if (this.__hoverSilentOnTouch && e.zrByTouch) {\n            return;\n        }\n\n        // Only if element is not in emphasis status\n        !this.__isEmphasis && doLeaveHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function enterEmphasis() {\n        this.__isEmphasis = true;\n        doEnterHover(this);\n    }\n\n    /**\n     * @inner\n     */\n    function leaveEmphasis() {\n        this.__isEmphasis = false;\n        doLeaveHover(this);\n    }\n\n    /**\n     * Set hover style of element.\n     * This method can be called repeatly without side-effects.\n     * @param {module:zrender/Element} el\n     * @param {Object} [hoverStyle]\n     * @param {Object} [opt]\n     * @param {boolean} [opt.hoverSilentOnTouch=false]\n     *        In touch device, mouseover event will be trigger on touchstart event\n     *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can\n     *        conviniently use hoverStyle when tap on touch screen without additional\n     *        code for compatibility.\n     *        But if the chart/component has select feature, which usually also use\n     *        hoverStyle, there might be conflict between 'select-highlight' and\n     *        'hover-highlight' especially when roam is enabled (see geo for example).\n     *        In this case, hoverSilentOnTouch should be used to disable hover-highlight\n     *        on touch device.\n     */\n    graphic.setHoverStyle = function (el, hoverStyle, opt) {\n        el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;\n\n        el.type === 'group'\n            ? el.traverse(function (child) {\n                if (child.type !== 'group') {\n                    setElementHoverStl(child, hoverStyle);\n                }\n            })\n            : setElementHoverStl(el, hoverStyle);\n\n        // Duplicated function will be auto-ignored, see Eventful.js.\n        el.on('mouseover', onElementMouseOver)\n          .on('mouseout', onElementMouseOut);\n\n        // Emphasis, normal can be triggered manually\n        el.on('emphasis', enterEmphasis)\n          .on('normal', leaveEmphasis);\n    };\n\n    /**\n     * @param {Object|module:zrender/graphic/Style} normalStyle\n     * @param {Object} emphasisStyle\n     * @param {module:echarts/model/Model} normalModel\n     * @param {module:echarts/model/Model} emphasisModel\n     * @param {Object} opt Check `opt` of `setTextStyleCommon` to find other props.\n     * @param {Object} [opt.defaultText]\n     * @param {module:echarts/model/Model} [opt.labelFetcher] Fetch text by\n     *      `opt.labelFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`\n     * @param {module:echarts/model/Model} [opt.labelDataIndex] Fetch text by\n     *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`\n     * @param {module:echarts/model/Model} [opt.labelDimIndex] Fetch text by\n     *      `opt.textFetcher.getFormattedLabel(opt.labelDataIndex, 'normal'/'emphasis', null, opt.labelDimIndex)`\n     * @param {Object} [normalSpecified]\n     * @param {Object} [emphasisSpecified]\n     */\n    graphic.setLabelStyle = function (\n        normalStyle, emphasisStyle,\n        normalModel, emphasisModel,\n        opt,\n        normalSpecified, emphasisSpecified\n    ) {\n        opt = opt || EMPTY_OBJ;\n        var labelFetcher = opt.labelFetcher;\n        var labelDataIndex = opt.labelDataIndex;\n        var labelDimIndex = opt.labelDimIndex;\n\n        // This scenario, `label.normal.show = true; label.emphasis.show = false`,\n        // is not supported util someone requests.\n\n        var showNormal = normalModel.getShallow('show');\n        var showEmphasis = emphasisModel.getShallow('show');\n\n        // Consider performance, only fetch label when necessary.\n        // If `normal.show` is `false` and `emphasis.show` is `true` and `emphasis.formatter` is not set,\n        // label should be displayed, where text is fetched by `normal.formatter` or `opt.defaultText`.\n        var baseText = (showNormal || showEmphasis)\n            ? zrUtil.retrieve2(\n                labelFetcher\n                    ? labelFetcher.getFormattedLabel(labelDataIndex, 'normal', null, labelDimIndex)\n                    : null,\n                opt.defaultText\n            )\n            : null;\n        var normalStyleText = showNormal ? baseText : null;\n        var emphasisStyleText = showEmphasis\n            ? zrUtil.retrieve2(\n                labelFetcher\n                    ? labelFetcher.getFormattedLabel(labelDataIndex, 'emphasis', null, labelDimIndex)\n                    : null,\n                baseText\n            )\n            : null;\n\n        // Optimize: If style.text is null, text will not be drawn.\n        if (normalStyleText != null || emphasisStyleText != null) {\n            // Always set `textStyle` even if `normalStyle.text` is null, because default\n            // values have to be set on `normalStyle`.\n            // If we set default values on `emphasisStyle`, consider case:\n            // Firstly, `setOption(... label: {normal: {text: null}, emphasis: {show: true}} ...);`\n            // Secondly, `setOption(... label: {noraml: {show: true, text: 'abc', color: 'red'} ...);`\n            // Then the 'red' will not work on emphasis.\n            setTextStyle(normalStyle, normalModel, normalSpecified, opt);\n            setTextStyle(emphasisStyle, emphasisModel, emphasisSpecified, opt, true);\n        }\n\n        normalStyle.text = normalStyleText;\n        emphasisStyle.text = emphasisStyleText;\n    };\n\n    /**\n     * Set basic textStyle properties.\n     * @param {Object|module:zrender/graphic/Style} textStyle\n     * @param {module:echarts/model/Model} model\n     * @param {Object} [specifiedTextStyle] Can be overrided by settings in model.\n     * @param {Object} [opt] See `opt` of `setTextStyleCommon`.\n     * @param {boolean} [isEmphasis]\n     */\n    var setTextStyle = graphic.setTextStyle = function (\n        textStyle, textStyleModel, specifiedTextStyle, opt, isEmphasis\n    ) {\n        setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis);\n        specifiedTextStyle && zrUtil.extend(textStyle, specifiedTextStyle);\n        textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);\n\n        return textStyle;\n    };\n\n    /**\n     * Set text option in the style.\n     * @deprecated\n     * @param {Object} textStyle\n     * @param {module:echarts/model/Model} labelModel\n     * @param {string|boolean} defaultColor Default text color.\n     *        If set as false, it will be processed as a emphasis style.\n     */\n    graphic.setText = function (textStyle, labelModel, defaultColor) {\n        var opt = {isRectText: true};\n        var isEmphasis;\n\n        if (defaultColor === false) {\n            isEmphasis = true;\n        }\n        else {\n            // Support setting color as 'auto' to get visual color.\n            opt.autoColor = defaultColor;\n        }\n        setTextStyleCommon(textStyle, labelModel, opt, isEmphasis);\n        textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);\n    };\n\n    /**\n     * {\n     *      disableBox: boolean, Whether diable drawing box of block (outer most).\n     *      isRectText: boolean,\n     *      autoColor: string, specify a color when color is 'auto',\n     *              for textFill, textStroke, textBackgroundColor, and textBorderColor.\n     *              If autoColor specified, it is used as default textFill.\n     *      useInsideStyle:\n     *              `true`: Use inside style (textFill, textStroke, textStrokeWidth)\n     *                  if `textFill` is not specified.\n     *              `false`: Do not use inside style.\n     *              `null/undefined`: use inside style if `isRectText` is true and\n     *                  `textFill` is not specified and textPosition contains `'inside'`.\n     *      forceRich: boolean\n     * }\n     */\n    function setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis) {\n        // Consider there will be abnormal when merge hover style to normal style if given default value.\n        opt = opt || EMPTY_OBJ;\n\n        if (opt.isRectText) {\n            var textPosition = textStyleModel.getShallow('position')\n                || (isEmphasis ? null : 'inside');\n            // 'outside' is not a valid zr textPostion value, but used\n            // in bar series, and magric type should be considered.\n            textPosition === 'outside' && (textPosition = 'top');\n            textStyle.textPosition = textPosition;\n            textStyle.textOffset = textStyleModel.getShallow('offset');\n            var labelRotate = textStyleModel.getShallow('rotate');\n            labelRotate != null && (labelRotate *= Math.PI / 180);\n            textStyle.textRotation = labelRotate;\n            textStyle.textDistance = zrUtil.retrieve2(\n                textStyleModel.getShallow('distance'), isEmphasis ? null : 5\n            );\n        }\n\n        var ecModel = textStyleModel.ecModel;\n        var globalTextStyle = ecModel && ecModel.option.textStyle;\n\n        // Consider case:\n        // {\n        //     data: [{\n        //         value: 12,\n        //         label: {\n        //             normal: {\n        //                 rich: {\n        //                     // no 'a' here but using parent 'a'.\n        //                 }\n        //             }\n        //         }\n        //     }],\n        //     rich: {\n        //         a: { ... }\n        //     }\n        // }\n        var richItemNames = getRichItemNames(textStyleModel);\n        var richResult;\n        if (richItemNames) {\n            richResult = {};\n            for (var name in richItemNames) {\n                if (richItemNames.hasOwnProperty(name)) {\n                    // Cascade is supported in rich.\n                    var richTextStyle = textStyleModel.getModel(['rich', name]);\n                    // In rich, never `disableBox`.\n                    setTokenTextStyle(richResult[name] = {}, richTextStyle, globalTextStyle, opt, isEmphasis);\n                }\n            }\n        }\n        textStyle.rich = richResult;\n\n        setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, true);\n\n        if (opt.forceRich && !opt.textStyle) {\n            opt.textStyle = {};\n        }\n\n        return textStyle;\n    }\n\n    // Consider case:\n    // {\n    //     data: [{\n    //         value: 12,\n    //         label: {\n    //             normal: {\n    //                 rich: {\n    //                     // no 'a' here but using parent 'a'.\n    //                 }\n    //             }\n    //         }\n    //     }],\n    //     rich: {\n    //         a: { ... }\n    //     }\n    // }\n    function getRichItemNames(textStyleModel) {\n        // Use object to remove duplicated names.\n        var richItemNameMap;\n        while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {\n            var rich = (textStyleModel.option || EMPTY_OBJ).rich;\n            if (rich) {\n                richItemNameMap = richItemNameMap || {};\n                for (var name in rich) {\n                    if (rich.hasOwnProperty(name)) {\n                        richItemNameMap[name] = 1;\n                    }\n                }\n            }\n            textStyleModel = textStyleModel.parentModel;\n        }\n        return richItemNameMap;\n    }\n\n    function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, isBlock) {\n        // In merge mode, default value should not be given.\n        globalTextStyle = !isEmphasis && globalTextStyle || EMPTY_OBJ;\n\n        textStyle.textFill = getAutoColor(textStyleModel.getShallow('color'), opt)\n            || globalTextStyle.color;\n        textStyle.textStroke = getAutoColor(textStyleModel.getShallow('textBorderColor'), opt)\n            || globalTextStyle.textBorderColor;\n        textStyle.textStrokeWidth = zrUtil.retrieve2(\n            textStyleModel.getShallow('textBorderWidth'),\n            globalTextStyle.textBorderWidth\n        );\n\n        if (!isEmphasis) {\n            if (isBlock) {\n                // Always set `insideRollback`, for clearing previous.\n                var originalTextPosition = textStyle.textPosition;\n                textStyle.insideRollback = applyInsideStyle(textStyle, originalTextPosition, opt);\n                // Save original textPosition, because style.textPosition will be repalced by\n                // real location (like [10, 30]) in zrender.\n                textStyle.insideOriginalTextPosition = originalTextPosition;\n                textStyle.insideRollbackOpt = opt;\n            }\n\n            // Set default finally.\n            if (textStyle.textFill == null) {\n                textStyle.textFill = opt.autoColor;\n            }\n        }\n\n        // Do not use `getFont` here, because merge should be supported, where\n        // part of these properties may be changed in emphasis style, and the\n        // others should remain their original value got from normal style.\n        textStyle.fontStyle = textStyleModel.getShallow('fontStyle') || globalTextStyle.fontStyle;\n        textStyle.fontWeight = textStyleModel.getShallow('fontWeight') || globalTextStyle.fontWeight;\n        textStyle.fontSize = textStyleModel.getShallow('fontSize') || globalTextStyle.fontSize;\n        textStyle.fontFamily = textStyleModel.getShallow('fontFamily') || globalTextStyle.fontFamily;\n\n        textStyle.textAlign = textStyleModel.getShallow('align');\n        textStyle.textVerticalAlign = textStyleModel.getShallow('verticalAlign')\n            || textStyleModel.getShallow('baseline');\n\n        textStyle.textLineHeight = textStyleModel.getShallow('lineHeight');\n        textStyle.textWidth = textStyleModel.getShallow('width');\n        textStyle.textHeight = textStyleModel.getShallow('height');\n        textStyle.textTag = textStyleModel.getShallow('tag');\n\n        if (!isBlock || !opt.disableBox) {\n            textStyle.textBackgroundColor = getAutoColor(textStyleModel.getShallow('backgroundColor'), opt);\n            textStyle.textPadding = textStyleModel.getShallow('padding');\n            textStyle.textBorderColor = getAutoColor(textStyleModel.getShallow('borderColor'), opt);\n            textStyle.textBorderWidth = textStyleModel.getShallow('borderWidth');\n            textStyle.textBorderRadius = textStyleModel.getShallow('borderRadius');\n\n            textStyle.textBoxShadowColor = textStyleModel.getShallow('shadowColor');\n            textStyle.textBoxShadowBlur = textStyleModel.getShallow('shadowBlur');\n            textStyle.textBoxShadowOffsetX = textStyleModel.getShallow('shadowOffsetX');\n            textStyle.textBoxShadowOffsetY = textStyleModel.getShallow('shadowOffsetY');\n        }\n\n        textStyle.textShadowColor = textStyleModel.getShallow('textShadowColor')\n            || globalTextStyle.textShadowColor;\n        textStyle.textShadowBlur = textStyleModel.getShallow('textShadowBlur')\n            || globalTextStyle.textShadowBlur;\n        textStyle.textShadowOffsetX = textStyleModel.getShallow('textShadowOffsetX')\n            || globalTextStyle.textShadowOffsetX;\n        textStyle.textShadowOffsetY = textStyleModel.getShallow('textShadowOffsetY')\n            || globalTextStyle.textShadowOffsetY;\n    }\n\n    function getAutoColor(color, opt) {\n        return color !== 'auto' ? color : (opt && opt.autoColor) ? opt.autoColor : null;\n    }\n\n    function applyInsideStyle(textStyle, textPosition, opt) {\n        var useInsideStyle = opt.useInsideStyle;\n        var insideRollback;\n\n        if (textStyle.textFill == null\n            && useInsideStyle !== false\n            && (useInsideStyle === true\n                || (opt.isRectText\n                    && textPosition\n                    // textPosition can be [10, 30]\n                    && typeof textPosition === 'string'\n                    && textPosition.indexOf('inside') >= 0\n                )\n            )\n        ) {\n            insideRollback = {\n                textFill: null,\n                textStroke: textStyle.textStroke,\n                textStrokeWidth: textStyle.textStrokeWidth\n            };\n            textStyle.textFill = '#fff';\n            // Consider text with #fff overflow its container.\n            if (textStyle.textStroke == null) {\n                textStyle.textStroke = opt.autoColor;\n                textStyle.textStrokeWidth == null && (textStyle.textStrokeWidth = 2);\n            }\n        }\n\n        return insideRollback;\n    }\n\n    function rollbackInsideStyle(style) {\n        var insideRollback = style.insideRollback;\n        if (insideRollback) {\n            style.textFill = insideRollback.textFill;\n            style.textStroke = insideRollback.textStroke;\n            style.textStrokeWidth = insideRollback.textStrokeWidth;\n        }\n    }\n\n    graphic.getFont = function (opt, ecModel) {\n        // ecModel or default text style model.\n        var gTextStyleModel = ecModel || ecModel.getModel('textStyle');\n        return [\n            // FIXME in node-canvas fontWeight is before fontStyle\n            opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow('fontStyle') || '',\n            opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow('fontWeight') || '',\n            (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow('fontSize') || 12) + 'px',\n            opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow('fontFamily') || 'sans-serif'\n        ].join(' ');\n    };\n\n    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {\n        if (typeof dataIndex === 'function') {\n            cb = dataIndex;\n            dataIndex = null;\n        }\n        // Do not check 'animation' property directly here. Consider this case:\n        // animation model is an `itemModel`, whose does not have `isAnimationEnabled`\n        // but its parent model (`seriesModel`) does.\n        var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();\n\n        if (animationEnabled) {\n            var postfix = isUpdate ? 'Update' : '';\n            var duration = animatableModel.getShallow('animationDuration' + postfix);\n            var animationEasing = animatableModel.getShallow('animationEasing' + postfix);\n            var animationDelay = animatableModel.getShallow('animationDelay' + postfix);\n            if (typeof animationDelay === 'function') {\n                animationDelay = animationDelay(\n                    dataIndex,\n                    animatableModel.getAnimationDelayParams\n                        ? animatableModel.getAnimationDelayParams(el, dataIndex)\n                        : null\n                );\n            }\n            if (typeof duration === 'function') {\n                duration = duration(dataIndex);\n            }\n\n            duration > 0\n                ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb, !!cb)\n                : (el.stopAnimation(), el.attr(props), cb && cb());\n        }\n        else {\n            el.stopAnimation();\n            el.attr(props);\n            cb && cb();\n        }\n    }\n\n    /**\n     * Update graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} [cb]\n     * @example\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n     *     // Or\n     *     graphic.updateProps(el, {\n     *         position: [100, 100]\n     *     }, seriesModel, function () { console.log('Animation done!'); });\n     */\n    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Init graphic element properties with or without animation according to the configuration in series\n     * @param {module:zrender/Element} el\n     * @param {Object} props\n     * @param {module:echarts/model/Model} [animatableModel]\n     * @param {number} [dataIndex]\n     * @param {Function} cb\n     */\n    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {\n        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);\n    };\n\n    /**\n     * Get transform matrix of target (param target),\n     * in coordinate of its ancestor (param ancestor)\n     *\n     * @param {module:zrender/mixin/Transformable} target\n     * @param {module:zrender/mixin/Transformable} [ancestor]\n     */\n    graphic.getTransform = function (target, ancestor) {\n        var mat = matrix.identity([]);\n\n        while (target && target !== ancestor) {\n            matrix.mul(mat, target.getLocalTransform(), mat);\n            target = target.parent;\n        }\n\n        return mat;\n    };\n\n    /**\n     * Apply transform to an vertex.\n     * @param {Array.<number>} target [x, y]\n     * @param {Array.<number>|TypedArray.<number>|Object} transform Can be:\n     *      + Transform matrix: like [1, 0, 0, 1, 0, 0]\n     *      + {position, rotation, scale}, the same as `zrender/Transformable`.\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {Array.<number>} [x, y]\n     */\n    graphic.applyTransform = function (target, transform, invert) {\n        if (transform && !zrUtil.isArrayLike(transform)) {\n            transform = Transformable.getLocalTransform(transform);\n        }\n\n        if (invert) {\n            transform = matrix.invert([], transform);\n        }\n        return vector.applyTransform([], target, transform);\n    };\n\n    /**\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n     * @param {boolean=} invert Whether use invert matrix.\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\n     */\n    graphic.transformDirection = function (direction, transform, invert) {\n\n        // Pick a base, ensure that transform result will not be (0, 0).\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\n\n        var vertex = [\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\n        ];\n\n        vertex = graphic.applyTransform(vertex, transform, invert);\n\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\n            ? (vertex[0] > 0 ? 'right' : 'left')\n            : (vertex[1] > 0 ? 'bottom' : 'top');\n    };\n\n    /**\n     * Apply group transition animation from g1 to g2.\n     * If no animatableModel, no animation.\n     */\n    graphic.groupTransition = function (g1, g2, animatableModel, cb) {\n        if (!g1 || !g2) {\n            return;\n        }\n\n        function getElMap(g) {\n            var elMap = {};\n            g.traverse(function (el) {\n                if (!el.isGroup && el.anid) {\n                    elMap[el.anid] = el;\n                }\n            });\n            return elMap;\n        }\n        function getAnimatableProps(el) {\n            var obj = {\n                position: vector.clone(el.position),\n                rotation: el.rotation\n            };\n            if (el.shape) {\n                obj.shape = zrUtil.extend({}, el.shape);\n            }\n            return obj;\n        }\n        var elMap1 = getElMap(g1);\n\n        g2.traverse(function (el) {\n            if (!el.isGroup && el.anid) {\n                var oldEl = elMap1[el.anid];\n                if (oldEl) {\n                    var newProp = getAnimatableProps(el);\n                    el.attr(getAnimatableProps(oldEl));\n                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);\n                }\n                // else {\n                //     if (el.previousProps) {\n                //         graphic.updateProps\n                //     }\n                // }\n            }\n        });\n    };\n\n    /**\n     * @param {Array.<Array.<number>>} points Like: [[23, 44], [53, 66], ...]\n     * @param {Object} rect {x, y, width, height}\n     * @return {Array.<Array.<number>>} A new clipped points.\n     */\n    graphic.clipPointsByRect = function (points, rect) {\n        return zrUtil.map(points, function (point) {\n            var x = point[0];\n            x = mathMax(x, rect.x);\n            x = mathMin(x, rect.x + rect.width);\n            var y = point[1];\n            y = mathMax(y, rect.y);\n            y = mathMin(y, rect.y + rect.height);\n            return [x, y];\n        });\n    };\n\n    /**\n     * @param {Object} targetRect {x, y, width, height}\n     * @param {Object} rect {x, y, width, height}\n     * @return {Object} A new clipped rect. If rect size are negative, return undefined.\n     */\n    graphic.clipRectByRect = function (targetRect, rect) {\n        var x = mathMax(targetRect.x, rect.x);\n        var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);\n        var y = mathMax(targetRect.y, rect.y);\n        var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);\n\n        if (x2 >= x && y2 >= y) {\n            return {\n                x: x,\n                y: y,\n                width: x2 - x,\n                height: y2 - y\n            };\n        }\n    };\n\n    /**\n     * @param {string} iconStr Support 'image://' or 'path://' or direct svg path.\n     * @param {Object} [opt] Properties of `module:zrender/Element`, except `style`.\n     * @param {Object} [rect] {x, y, width, height}\n     * @return {module:zrender/Element} Icon path or image element.\n     */\n    graphic.createIcon = function (iconStr, opt, rect) {\n        opt = zrUtil.extend({rectHover: true}, opt);\n        var style = opt.style = {strokeNoScale: true};\n        rect = rect || {x: -1, y: -1, width: 2, height: 2};\n\n        if (iconStr) {\n            return iconStr.indexOf('image://') === 0\n                ? (\n                    style.image = iconStr.slice(8),\n                    zrUtil.defaults(style, rect),\n                    new graphic.Image(opt)\n                )\n                : (\n                    graphic.makePath(\n                        iconStr.replace('path://', ''),\n                        opt,\n                        rect,\n                        'center'\n                    )\n                );\n        }\n\n    };\n\n    module.exports = graphic;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/util/graphic.js\n// module id = 973\n// module chunks = 0 1 2","/**\n * \n * @module echarts/util/number\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var number = {};\n\n    var RADIAN_EPSILON = 1e-4;\n\n    function _trim(str) {\n        return str.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    }\n\n    /**\n     * Linear mapping a value from domain to range\n     * @memberOf module:echarts/util/number\n     * @param  {(number|Array.<number>)} val\n     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]\n     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]\n     * @param  {boolean} clamp\n     * @return {(number|Array.<number>}\n     */\n    number.linearMap = function (val, domain, range, clamp) {\n        var subDomain = domain[1] - domain[0];\n        var subRange = range[1] - range[0];\n\n        if (subDomain === 0) {\n            return subRange === 0\n                ? range[0]\n                : (range[0] + range[1]) / 2;\n        }\n\n        // Avoid accuracy problem in edge, such as\n        // 146.39 - 62.83 === 83.55999999999999.\n        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError\n        // It is a little verbose for efficiency considering this method\n        // is a hotspot.\n        if (clamp) {\n            if (subDomain > 0) {\n                if (val <= domain[0]) {\n                    return range[0];\n                }\n                else if (val >= domain[1]) {\n                    return range[1];\n                }\n            }\n            else {\n                if (val >= domain[0]) {\n                    return range[0];\n                }\n                else if (val <= domain[1]) {\n                    return range[1];\n                }\n            }\n        }\n        else {\n            if (val === domain[0]) {\n                return range[0];\n            }\n            if (val === domain[1]) {\n                return range[1];\n            }\n        }\n\n        return (val - domain[0]) / subDomain * subRange + range[0];\n    };\n\n    /**\n     * Convert a percent string to absolute number.\n     * Returns NaN if percent is not a valid string or number\n     * @memberOf module:echarts/util/number\n     * @param {string|number} percent\n     * @param {number} all\n     * @return {number}\n     */\n    number.parsePercent = function(percent, all) {\n        switch (percent) {\n            case 'center':\n            case 'middle':\n                percent = '50%';\n                break;\n            case 'left':\n            case 'top':\n                percent = '0%';\n                break;\n            case 'right':\n            case 'bottom':\n                percent = '100%';\n                break;\n        }\n        if (typeof percent === 'string') {\n            if (_trim(percent).match(/%$/)) {\n                return parseFloat(percent) / 100 * all;\n            }\n\n            return parseFloat(percent);\n        }\n\n        return percent == null ? NaN : +percent;\n    };\n\n    /**\n     * (1) Fix rounding error of float numbers.\n     * (2) Support return string to avoid scientific notation like '3.5e-7'.\n     *\n     * @param {number} x\n     * @param {number} [precision]\n     * @param {boolean} [returnStr]\n     * @return {number|string}\n     */\n    number.round = function (x, precision, returnStr) {\n        if (precision == null) {\n            precision = 10;\n        }\n        // Avoid range error\n        precision = Math.min(Math.max(0, precision), 20);\n        x = (+x).toFixed(precision);\n        return returnStr ? x : +x;\n    };\n\n    number.asc = function (arr) {\n        arr.sort(function (a, b) {\n            return a - b;\n        });\n        return arr;\n    };\n\n    /**\n     * Get precision\n     * @param {number} val\n     */\n    number.getPrecision = function (val) {\n        val = +val;\n        if (isNaN(val)) {\n            return 0;\n        }\n        // It is much faster than methods converting number to string as follows\n        //      var tmp = val.toString();\n        //      return tmp.length - 1 - tmp.indexOf('.');\n        // especially when precision is low\n        var e = 1;\n        var count = 0;\n        while (Math.round(val * e) / e !== val) {\n            e *= 10;\n            count++;\n        }\n        return count;\n    };\n\n    /**\n     * @param {string|number} val\n     * @return {number}\n     */\n    number.getPrecisionSafe = function (val) {\n        var str = val.toString();\n\n        // Consider scientific notation: '3.4e-12' '3.4e+12'\n        var eIndex = str.indexOf('e');\n        if (eIndex > 0) {\n            var precision = +str.slice(eIndex + 1);\n            return precision < 0 ? -precision : 0;\n        }\n        else {\n            var dotIndex = str.indexOf('.');\n            return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;\n        }\n    };\n\n    /**\n     * Minimal dicernible data precisioin according to a single pixel.\n     *\n     * @param {Array.<number>} dataExtent\n     * @param {Array.<number>} pixelExtent\n     * @return {number} precision\n     */\n    number.getPixelPrecision = function (dataExtent, pixelExtent) {\n        var log = Math.log;\n        var LN10 = Math.LN10;\n        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n        // toFixed() digits argument must be between 0 and 20.\n        var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n        return !isFinite(precision) ? 20 : precision;\n    };\n\n    /**\n     * Get a data of given precision, assuring the sum of percentages\n     * in valueList is 1.\n     * The largest remainer method is used.\n     * https://en.wikipedia.org/wiki/Largest_remainder_method\n     *\n     * @param {Array.<number>} valueList a list of all data\n     * @param {number} idx index of the data to be processed in valueList\n     * @param {number} precision integer number showing digits of precision\n     * @return {number} percent ranging from 0 to 100\n     */\n    number.getPercentWithPrecision = function (valueList, idx, precision) {\n        if (!valueList[idx]) {\n            return 0;\n        }\n\n        var sum = zrUtil.reduce(valueList, function (acc, val) {\n            return acc + (isNaN(val) ? 0 : val);\n        }, 0);\n        if (sum === 0) {\n            return 0;\n        }\n\n        var digits = Math.pow(10, precision);\n        var votesPerQuota = zrUtil.map(valueList, function (val) {\n            return (isNaN(val) ? 0 : val) / sum * digits * 100;\n        });\n        var targetSeats = digits * 100;\n\n        var seats = zrUtil.map(votesPerQuota, function (votes) {\n            // Assign automatic seats.\n            return Math.floor(votes);\n        });\n        var currentSum = zrUtil.reduce(seats, function (acc, val) {\n            return acc + val;\n        }, 0);\n\n        var remainder = zrUtil.map(votesPerQuota, function (votes, idx) {\n            return votes - seats[idx];\n        });\n\n        // Has remainding votes.\n        while (currentSum < targetSeats) {\n            // Find next largest remainder.\n            var max = Number.NEGATIVE_INFINITY;\n            var maxId = null;\n            for (var i = 0, len = remainder.length; i < len; ++i) {\n                if (remainder[i] > max) {\n                    max = remainder[i];\n                    maxId = i;\n                }\n            }\n\n            // Add a vote to max remainder.\n            ++seats[maxId];\n            remainder[maxId] = 0;\n            ++currentSum;\n        }\n\n        return seats[idx] / digits;\n    };\n\n    // Number.MAX_SAFE_INTEGER, ie do not support.\n    number.MAX_SAFE_INTEGER = 9007199254740991;\n\n    /**\n     * To 0 - 2 * PI, considering negative radian.\n     * @param {number} radian\n     * @return {number}\n     */\n    number.remRadian = function (radian) {\n        var pi2 = Math.PI * 2;\n        return (radian % pi2 + pi2) % pi2;\n    };\n\n    /**\n     * @param {type} radian\n     * @return {boolean}\n     */\n    number.isRadianAroundZero = function (val) {\n        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n    };\n\n    var TIME_REG = /^(?:(\\d{4})(?:[-\\/](\\d{1,2})(?:[-\\/](\\d{1,2})(?:[T ](\\d{1,2})(?::(\\d\\d)(?::(\\d\\d)(?:[.,](\\d+))?)?)?(Z|[\\+\\-]\\d\\d:?\\d\\d)?)?)?)?)?$/; // jshint ignore:line\n\n    /**\n     * Consider DST, it is incorrect to provide a method `getTimezoneOffset`\n     * without time specified. So this method is removed.\n     *\n     * @return {number} in minutes\n     */\n    // number.getTimezoneOffset = function () {\n    //     return (new Date()).getTimezoneOffset();\n    // };\n\n    /**\n     * @param {string|Date|number} value These values can be accepted:\n     *   + An instance of Date, represent a time in its own time zone.\n     *   + Or string in a subset of ISO 8601, only including:\n     *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',\n     *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',\n     *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',\n     *     all of which will be treated as local time if time zone is not specified\n     *     (see <https://momentjs.com/>).\n     *   + Or other string format, including (all of which will be treated as loacal time):\n     *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',\n     *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'\n     *   + a timestamp, which represent a time in UTC.\n     * @return {Date} date\n     */\n    number.parseDate = function (value) {\n        if (value instanceof Date) {\n            return value;\n        }\n        else if (typeof value === 'string') {\n            // Different browsers parse date in different way, so we parse it manually.\n            // Some other issues:\n            // new Date('1970-01-01') is UTC,\n            // new Date('1970/01/01') and new Date('1970-1-01') is local.\n            // See issue #3623\n            var match = TIME_REG.exec(value);\n\n            if (!match) {\n                // return Invalid Date.\n                return new Date(NaN);\n            }\n\n            // Use local time when no timezone offset specifed.\n            if (!match[8]) {\n                // match[n] can only be string or undefined.\n                // But take care of '12' + 1 => '121'.\n                return new Date(\n                    +match[1],\n                    +(match[2] || 1) - 1,\n                    +match[3] || 1,\n                    +match[4] || 0,\n                    +(match[5] || 0),\n                    +match[6] || 0,\n                    +match[7] || 0\n                );\n            }\n            // Timezoneoffset of Javascript Date has considered DST (Daylight Saving Time,\n            // https://tc39.github.io/ecma262/#sec-daylight-saving-time-adjustment).\n            // For example, system timezone is set as \"Time Zone: America/Toronto\",\n            // then these code will get different result:\n            // `new Date(1478411999999).getTimezoneOffset();  // get 240`\n            // `new Date(1478412000000).getTimezoneOffset();  // get 300`\n            // So we should not use `new Date`, but use `Date.UTC`.\n            else {\n                var hour = +match[4] || 0;\n                if (match[8].toUpperCase() !== 'Z') {\n                    hour -= match[8].slice(0, 3);\n                }\n                return new Date(Date.UTC(\n                    +match[1],\n                    +(match[2] || 1) - 1,\n                    +match[3] || 1,\n                    hour,\n                    +(match[5] || 0),\n                    +match[6] || 0,\n                    +match[7] || 0\n                ));\n            }\n        }\n        else if (value == null) {\n            return new Date(NaN);\n        }\n\n        return new Date(Math.round(value));\n    };\n\n    /**\n     * Quantity of a number. e.g. 0.1, 1, 10, 100\n     *\n     * @param  {number} val\n     * @return {number}\n     */\n    number.quantity = function (val) {\n        return Math.pow(10, quantityExponent(val));\n    };\n\n    function quantityExponent(val) {\n        return Math.floor(Math.log(val) / Math.LN10);\n    }\n\n    /**\n     * find a nice number approximately equal to x. Round the number if round = true,\n     * take ceiling if round = false. The primary observation is that the nicest\n     * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.\n     *\n     * See \"Nice Numbers for Graph Labels\" of Graphic Gems.\n     *\n     * @param  {number} val Non-negative value.\n     * @param  {boolean} round\n     * @return {number}\n     */\n    number.nice = function (val, round) {\n        var exponent = quantityExponent(val);\n        var exp10 = Math.pow(10, exponent);\n        var f = val / exp10; // 1 <= f < 10\n        var nf;\n        if (round) {\n            if (f < 1.5) { nf = 1; }\n            else if (f < 2.5) { nf = 2; }\n            else if (f < 4) { nf = 3; }\n            else if (f < 7) { nf = 5; }\n            else { nf = 10; }\n        }\n        else {\n            if (f < 1) { nf = 1; }\n            else if (f < 2) { nf = 2; }\n            else if (f < 3) { nf = 3; }\n            else if (f < 5) { nf = 5; }\n            else { nf = 10; }\n        }\n        val = nf * exp10;\n\n        // Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).\n        // 20 is the uppper bound of toFixed.\n        return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;\n    };\n\n    /**\n     * Order intervals asc, and split them when overlap.\n     * expect(numberUtil.reformIntervals([\n     *     {interval: [18, 62], close: [1, 1]},\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [1, 1]},\n     *     {interval: [62, 150], close: [1, 1]},\n     *     {interval: [106, 150], close: [1, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ])).toEqual([\n     *     {interval: [-Infinity, -70], close: [0, 0]},\n     *     {interval: [-70, -26], close: [1, 1]},\n     *     {interval: [-26, 18], close: [0, 1]},\n     *     {interval: [18, 62], close: [0, 1]},\n     *     {interval: [62, 150], close: [0, 1]},\n     *     {interval: [150, Infinity], close: [0, 0]}\n     * ]);\n     * @param {Array.<Object>} list, where `close` mean open or close\n     *        of the interval, and Infinity can be used.\n     * @return {Array.<Object>} The origin list, which has been reformed.\n     */\n    number.reformIntervals = function (list) {\n        list.sort(function (a, b) {\n            return littleThan(a, b, 0) ? -1 : 1;\n        });\n\n        var curr = -Infinity;\n        var currClose = 1;\n        for (var i = 0; i < list.length;) {\n            var interval = list[i].interval;\n            var close = list[i].close;\n\n            for (var lg = 0; lg < 2; lg++) {\n                if (interval[lg] <= curr) {\n                    interval[lg] = curr;\n                    close[lg] = !lg ? 1 - currClose : 1;\n                }\n                curr = interval[lg];\n                currClose = close[lg];\n            }\n\n            if (interval[0] === interval[1] && close[0] * close[1] !== 1) {\n                list.splice(i, 1);\n            }\n            else {\n                i++;\n            }\n        }\n\n        return list;\n\n        function littleThan(a, b, lg) {\n            return a.interval[lg] < b.interval[lg]\n                || (\n                    a.interval[lg] === b.interval[lg]\n                    && (\n                        (a.close[lg] - b.close[lg] === (!lg ? 1 : -1))\n                        || (!lg && littleThan(a, b, 1))\n                    )\n                );\n        }\n    };\n\n    /**\n     * parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n     * ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n     * subtraction forces infinities to NaN\n     *\n     * @param {*} v\n     * @return {boolean}\n     */\n    number.isNumeric = function (v) {\n        return v - parseFloat(v) >= 0;\n    };\n\n    module.exports = number;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/util/number.js\n// module id = 974\n// module chunks = 0 1 2","\n\n    var formatUtil = require('./format');\n    var nubmerUtil = require('./number');\n    var Model = require('../model/Model');\n    var zrUtil = require('zrender/lib/core/util');\n    var each = zrUtil.each;\n    var isObject = zrUtil.isObject;\n\n    var modelUtil = {};\n\n    /**\n     * If value is not array, then translate it to array.\n     * @param  {*} value\n     * @return {Array} [value] or value\n     */\n    modelUtil.normalizeToArray = function (value) {\n        return value instanceof Array\n            ? value\n            : value == null\n            ? []\n            : [value];\n    };\n\n    /**\n     * Sync default option between normal and emphasis like `position` and `show`\n     * In case some one will write code like\n     *     label: {\n     *         normal: {\n     *             show: false,\n     *             position: 'outside',\n     *             fontSize: 18\n     *         },\n     *         emphasis: {\n     *             show: true\n     *         }\n     *     }\n     * @param {Object} opt\n     * @param {Array.<string>} subOpts\n     */\n     modelUtil.defaultEmphasis = function (opt, subOpts) {\n        if (opt) {\n            var emphasisOpt = opt.emphasis = opt.emphasis || {};\n            var normalOpt = opt.normal = opt.normal || {};\n\n            // Default emphasis option from normal\n            for (var i = 0, len = subOpts.length; i < len; i++) {\n                var subOptName = subOpts[i];\n                if (!emphasisOpt.hasOwnProperty(subOptName)\n                    && normalOpt.hasOwnProperty(subOptName)\n                ) {\n                    emphasisOpt[subOptName] = normalOpt[subOptName];\n                }\n            }\n        }\n    };\n\n    modelUtil.TEXT_STYLE_OPTIONS = [\n        'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',\n        'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth',\n        'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline',\n        'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY',\n        'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY',\n        'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding'\n    ];\n\n    // modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([\n    //     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',\n    //     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',\n    //     // FIXME: deprecated, check and remove it.\n    //     'textStyle'\n    // ]);\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method retieves value from data.\n     * @param {string|number|Date|Array|Object} dataItem\n     * @return {number|string|Date|Array.<number|string|Date>}\n     */\n    modelUtil.getDataItemValue = function (dataItem) {\n        // Performance sensitive.\n        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n    };\n\n    /**\n     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n     * This helper method determine if dataItem has extra option besides value\n     * @param {string|number|Date|Array|Object} dataItem\n     */\n    modelUtil.isDataItemOption = function (dataItem) {\n        return isObject(dataItem)\n            && !(dataItem instanceof Array);\n            // // markLine data can be array\n            // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n    };\n\n    /**\n     * This helper method convert value in data.\n     * @param {string|number|Date} value\n     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.\n     */\n    modelUtil.converDataValue = function (value, dimInfo) {\n        // Performance sensitive.\n        var dimType = dimInfo && dimInfo.type;\n        if (dimType === 'ordinal') {\n            return value;\n        }\n\n        if (dimType === 'time'\n            // spead up when using timestamp\n            && typeof value !== 'number'\n            && value != null\n            && value !== '-'\n        ) {\n            value = +nubmerUtil.parseDate(value);\n        }\n\n        // dimType defaults 'number'.\n        // If dimType is not ordinal and value is null or undefined or NaN or '-',\n        // parse to NaN.\n        return (value == null || value === '')\n            ? NaN : +value; // If string (like '-'), using '+' parse to NaN\n    };\n\n    /**\n     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.\n     * @param {module:echarts/data/List} data\n     * @param {Object} opt\n     * @param {string} [opt.seriesIndex]\n     * @param {Object} [opt.name]\n     * @param {Object} [opt.mainType]\n     * @param {Object} [opt.subType]\n     */\n    modelUtil.createDataFormatModel = function (data, opt) {\n        var model = new Model();\n        zrUtil.mixin(model, modelUtil.dataFormatMixin);\n        model.seriesIndex = opt.seriesIndex;\n        model.name = opt.name || '';\n        model.mainType = opt.mainType;\n        model.subType = opt.subType;\n\n        model.getData = function () {\n            return data;\n        };\n        return model;\n    };\n\n    // PENDING A little ugly\n    modelUtil.dataFormatMixin = {\n        /**\n         * Get params for formatter\n         * @param {number} dataIndex\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getDataParams: function (dataIndex, dataType) {\n            var data = this.getData(dataType);\n            var rawValue = this.getRawValue(dataIndex, dataType);\n            var rawDataIndex = data.getRawIndex(dataIndex);\n            var name = data.getName(dataIndex, true);\n            var itemOpt = data.getRawDataItem(dataIndex);\n            var color = data.getItemVisual(dataIndex, 'color');\n\n            return {\n                componentType: this.mainType,\n                componentSubType: this.subType,\n                seriesType: this.mainType === 'series' ? this.subType : null,\n                seriesIndex: this.seriesIndex,\n                seriesId: this.id,\n                seriesName: this.name,\n                name: name,\n                dataIndex: rawDataIndex,\n                data: itemOpt,\n                dataType: dataType,\n                value: rawValue,\n                color: color,\n                marker: formatUtil.getTooltipMarker(color),\n\n                // Param name list for mapping `a`, `b`, `c`, `d`, `e`\n                $vars: ['seriesName', 'name', 'value']\n            };\n        },\n\n        /**\n         * Format label\n         * @param {number} dataIndex\n         * @param {string} [status='normal'] 'normal' or 'emphasis'\n         * @param {string} [dataType]\n         * @param {number} [dimIndex]\n         * @param {string} [labelProp='label']\n         * @return {string}\n         */\n        getFormattedLabel: function (dataIndex, status, dataType, dimIndex, labelProp) {\n            status = status || 'normal';\n            var data = this.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n\n            var params = this.getDataParams(dataIndex, dataType);\n            if (dimIndex != null && (params.value instanceof Array)) {\n                params.value = params.value[dimIndex];\n            }\n\n            var formatter = itemModel.get([labelProp || 'label', status, 'formatter']);\n\n            if (typeof formatter === 'function') {\n                params.status = status;\n                return formatter(params);\n            }\n            else if (typeof formatter === 'string') {\n                return formatUtil.formatTpl(formatter, params);\n            }\n        },\n\n        /**\n         * Get raw value in option\n         * @param {number} idx\n         * @param {string} [dataType]\n         * @return {Object}\n         */\n        getRawValue: function (idx, dataType) {\n            var data = this.getData(dataType);\n            var dataItem = data.getRawDataItem(idx);\n            if (dataItem != null) {\n                return (isObject(dataItem) && !(dataItem instanceof Array))\n                    ? dataItem.value : dataItem;\n            }\n        },\n\n        /**\n         * Should be implemented.\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         * @return {string} tooltip string\n         */\n        formatTooltip: zrUtil.noop\n    };\n\n    /**\n     * Mapping to exists for merge.\n     *\n     * @public\n     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists\n     * @param {Object|Array.<Object>} newCptOptions\n     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          index of which is the same as exists.\n     */\n    modelUtil.mappingToExists = function (exists, newCptOptions) {\n        // Mapping by the order by original option (but not order of\n        // new option) in merge mode. Because we should ensure\n        // some specified index (like xAxisIndex) is consistent with\n        // original option, which is easy to understand, espatially in\n        // media query. And in most case, merge option is used to\n        // update partial option but not be expected to change order.\n        newCptOptions = (newCptOptions || []).slice();\n\n        var result = zrUtil.map(exists || [], function (obj, index) {\n            return {exist: obj};\n        });\n\n        // Mapping by id or name if specified.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            // id has highest priority.\n            for (var i = 0; i < result.length; i++) {\n                if (!result[i].option // Consider name: two map to one.\n                    && cptOption.id != null\n                    && result[i].exist.id === cptOption.id + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n\n            for (var i = 0; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option // Consider name: two map to one.\n                    // Can not match when both ids exist but different.\n                    && (exist.id == null || cptOption.id == null)\n                    && cptOption.name != null\n                    && !modelUtil.isIdInner(cptOption)\n                    && !modelUtil.isIdInner(exist)\n                    && exist.name === cptOption.name + ''\n                ) {\n                    result[i].option = cptOption;\n                    newCptOptions[index] = null;\n                    return;\n                }\n            }\n        });\n\n        // Otherwise mapping by index.\n        each(newCptOptions, function (cptOption, index) {\n            if (!isObject(cptOption)) {\n                return;\n            }\n\n            var i = 0;\n            for (; i < result.length; i++) {\n                var exist = result[i].exist;\n                if (!result[i].option\n                    // Existing model that already has id should be able to\n                    // mapped to (because after mapping performed model may\n                    // be assigned with a id, whish should not affect next\n                    // mapping), except those has inner id.\n                    && !modelUtil.isIdInner(exist)\n                    // Caution:\n                    // Do not overwrite id. But name can be overwritten,\n                    // because axis use name as 'show label text'.\n                    // 'exist' always has id and name and we dont\n                    // need to check it.\n                    && cptOption.id == null\n                ) {\n                    result[i].option = cptOption;\n                    break;\n                }\n            }\n\n            if (i >= result.length) {\n                result.push({option: cptOption});\n            }\n        });\n\n        return result;\n    };\n\n    /**\n     * Make id and name for mapping result (result of mappingToExists)\n     * into `keyInfo` field.\n     *\n     * @public\n     * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],\n     *                          which order is the same as exists.\n     * @return {Array.<Object>} The input.\n     */\n    modelUtil.makeIdAndName = function (mapResult) {\n        // We use this id to hash component models and view instances\n        // in echarts. id can be specified by user, or auto generated.\n\n        // The id generation rule ensures new view instance are able\n        // to mapped to old instance when setOption are called in\n        // no-merge mode. So we generate model id by name and plus\n        // type in view id.\n\n        // name can be duplicated among components, which is convenient\n        // to specify multi components (like series) by one name.\n\n        // Ensure that each id is distinct.\n        var idMap = zrUtil.createHashMap();\n\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            existCpt && idMap.set(existCpt.id, item);\n        });\n\n        each(mapResult, function (item, index) {\n            var opt = item.option;\n\n            zrUtil.assert(\n                !opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item,\n                'id duplicates: ' + (opt && opt.id)\n            );\n\n            opt && opt.id != null && idMap.set(opt.id, item);\n            !item.keyInfo && (item.keyInfo = {});\n        });\n\n        // Make name and id.\n        each(mapResult, function (item, index) {\n            var existCpt = item.exist;\n            var opt = item.option;\n            var keyInfo = item.keyInfo;\n\n            if (!isObject(opt)) {\n                return;\n            }\n\n            // name can be overwitten. Consider case: axis.name = '20km'.\n            // But id generated by name will not be changed, which affect\n            // only in that case: setOption with 'not merge mode' and view\n            // instance will be recreated, which can be accepted.\n            keyInfo.name = opt.name != null\n                ? opt.name + ''\n                : existCpt\n                ? existCpt.name\n                : '\\0-'; // name may be displayed on screen, so use '-'.\n\n            if (existCpt) {\n                keyInfo.id = existCpt.id;\n            }\n            else if (opt.id != null) {\n                keyInfo.id = opt.id + '';\n            }\n            else {\n                // Consider this situatoin:\n                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n                //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n                // Series with the same name between optionA and optionB\n                // should be mapped.\n                var idNum = 0;\n                do {\n                    keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n                }\n                while (idMap.get(keyInfo.id));\n            }\n\n            idMap.set(keyInfo.id, item);\n        });\n    };\n\n    /**\n     * @public\n     * @param {Object} cptOption\n     * @return {boolean}\n     */\n    modelUtil.isIdInner = function (cptOption) {\n        return isObject(cptOption)\n            && cptOption.id\n            && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0;\n    };\n\n    /**\n     * A helper for removing duplicate items between batchA and batchB,\n     * and in themselves, and categorize by series.\n     *\n     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]\n     */\n    modelUtil.compressBatches = function (batchA, batchB) {\n        var mapA = {};\n        var mapB = {};\n\n        makeMap(batchA || [], mapA);\n        makeMap(batchB || [], mapB, mapA);\n\n        return [mapToArray(mapA), mapToArray(mapB)];\n\n        function makeMap(sourceBatch, map, otherMap) {\n            for (var i = 0, len = sourceBatch.length; i < len; i++) {\n                var seriesId = sourceBatch[i].seriesId;\n                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);\n                var otherDataIndices = otherMap && otherMap[seriesId];\n\n                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n                    var dataIndex = dataIndices[j];\n\n                    if (otherDataIndices && otherDataIndices[dataIndex]) {\n                        otherDataIndices[dataIndex] = null;\n                    }\n                    else {\n                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n                    }\n                }\n            }\n        }\n\n        function mapToArray(map, isData) {\n            var result = [];\n            for (var i in map) {\n                if (map.hasOwnProperty(i) && map[i] != null) {\n                    if (isData) {\n                        result.push(+i);\n                    }\n                    else {\n                        var dataIndices = mapToArray(map[i], true);\n                        dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});\n                    }\n                }\n            }\n            return result;\n        }\n    };\n\n    /**\n     * @param {module:echarts/data/List} data\n     * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n     *                         each of which can be Array or primary type.\n     * @return {number|Array.<number>} dataIndex If not found, return undefined/null.\n     */\n    modelUtil.queryDataIndex = function (data, payload) {\n        if (payload.dataIndexInside != null) {\n            return payload.dataIndexInside;\n        }\n        else if (payload.dataIndex != null) {\n            return zrUtil.isArray(payload.dataIndex)\n                ? zrUtil.map(payload.dataIndex, function (value) {\n                    return data.indexOfRawIndex(value);\n                })\n                : data.indexOfRawIndex(payload.dataIndex);\n        }\n        else if (payload.name != null) {\n            return zrUtil.isArray(payload.name)\n                ? zrUtil.map(payload.name, function (value) {\n                    return data.indexOfName(value);\n                })\n                : data.indexOfName(payload.name);\n        }\n    };\n\n    /**\n     * Enable property storage to any host object.\n     * Notice: Serialization is not supported.\n     *\n     * For example:\n     * var get = modelUitl.makeGetter();\n     *\n     * function some(hostObj) {\n     *      get(hostObj)._someProperty = 1212;\n     *      ...\n     * }\n     *\n     * @return {Function}\n     */\n    modelUtil.makeGetter = (function () {\n        var index = 0;\n        return function () {\n            var key = '\\0__ec_prop_getter_' + index++;\n            return function (hostObj) {\n                return hostObj[key] || (hostObj[key] = {});\n            };\n        };\n    })();\n\n    /**\n     * @param {module:echarts/model/Global} ecModel\n     * @param {string|Object} finder\n     *        If string, e.g., 'geo', means {geoIndex: 0}.\n     *        If Object, could contain some of these properties below:\n     *        {\n     *            seriesIndex, seriesId, seriesName,\n     *            geoIndex, geoId, geoName,\n     *            bmapIndex, bmapId, bmapName,\n     *            xAxisIndex, xAxisId, xAxisName,\n     *            yAxisIndex, yAxisId, yAxisName,\n     *            gridIndex, gridId, gridName,\n     *            ... (can be extended)\n     *        }\n     *        Each properties can be number|string|Array.<number>|Array.<string>\n     *        For example, a finder could be\n     *        {\n     *            seriesIndex: 3,\n     *            geoId: ['aa', 'cc'],\n     *            gridName: ['xx', 'rr']\n     *        }\n     *        xxxIndex can be set as 'all' (means all xxx) or 'none' (means not specify)\n     *        If nothing or null/undefined specified, return nothing.\n     * @param {Object} [opt]\n     * @param {string} [opt.defaultMainType]\n     * @param {Array.<string>} [opt.includeMainTypes]\n     * @return {Object} result like:\n     *        {\n     *            seriesModels: [seriesModel1, seriesModel2],\n     *            seriesModel: seriesModel1, // The first model\n     *            geoModels: [geoModel1, geoModel2],\n     *            geoModel: geoModel1, // The first model\n     *            ...\n     *        }\n     */\n    modelUtil.parseFinder = function (ecModel, finder, opt) {\n        if (zrUtil.isString(finder)) {\n            var obj = {};\n            obj[finder + 'Index'] = 0;\n            finder = obj;\n        }\n\n        var defaultMainType = opt && opt.defaultMainType;\n        if (defaultMainType\n            && !has(finder, defaultMainType + 'Index')\n            && !has(finder, defaultMainType + 'Id')\n            && !has(finder, defaultMainType + 'Name')\n        ) {\n            finder[defaultMainType + 'Index'] = 0;\n        }\n\n        var result = {};\n\n        each(finder, function (value, key) {\n            var value = finder[key];\n\n            // Exclude 'dataIndex' and other illgal keys.\n            if (key === 'dataIndex' || key === 'dataIndexInside') {\n                result[key] = value;\n                return;\n            }\n\n            var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n            var mainType = parsedKey[1];\n            var queryType = (parsedKey[2] || '').toLowerCase();\n\n            if (!mainType\n                || !queryType\n                || value == null\n                || (queryType === 'index' && value === 'none')\n                || (opt && opt.includeMainTypes && zrUtil.indexOf(opt.includeMainTypes, mainType) < 0)\n            ) {\n                return;\n            }\n\n            var queryParam = {mainType: mainType};\n            if (queryType !== 'index' || value !== 'all') {\n                queryParam[queryType] = value;\n            }\n\n            var models = ecModel.queryComponents(queryParam);\n            result[mainType + 'Models'] = models;\n            result[mainType + 'Model'] = models[0];\n        });\n\n        return result;\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string|number} dataDim\n     * @return {string}\n     */\n    modelUtil.dataDimToCoordDim = function (data, dataDim) {\n        var dimensions = data.dimensions;\n        dataDim = data.getDimension(dataDim);\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimItem = data.getDimensionInfo(dimensions[i]);\n            if (dimItem.name === dataDim) {\n                return dimItem.coordDim;\n            }\n        }\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string} coordDim\n     * @return {Array.<string>} data dimensions on the coordDim.\n     */\n    modelUtil.coordDimToDataDim = function (data, coordDim) {\n        var dataDim = [];\n        each(data.dimensions, function (dimName) {\n            var dimItem = data.getDimensionInfo(dimName);\n            if (dimItem.coordDim === coordDim) {\n                dataDim[dimItem.coordDimIndex] = dimItem.name;\n            }\n        });\n        return dataDim;\n    };\n\n    /**\n     * @see {module:echarts/data/helper/completeDimensions}\n     * @param {module:echarts/data/List} data\n     * @param {string} otherDim Can be `otherDims`\n     *                        like 'label' or 'tooltip'.\n     * @return {Array.<string>} data dimensions on the otherDim.\n     */\n    modelUtil.otherDimToDataDim = function (data, otherDim) {\n        var dataDim = [];\n        each(data.dimensions, function (dimName) {\n            var dimItem = data.getDimensionInfo(dimName);\n            var otherDims = dimItem.otherDims;\n            var dimIndex = otherDims[otherDim];\n            if (dimIndex != null && dimIndex !== false) {\n                dataDim[dimIndex] = dimItem.name;\n            }\n        });\n        return dataDim;\n    };\n\n    function has(obj, prop) {\n        return obj && obj.hasOwnProperty(prop);\n    }\n\n    module.exports = modelUtil;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/util/model.js\n// module id = 975\n// module chunks = 0 1 2","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * \n     * @exports zrender/tool/vector\n     */\n    var vector = {\n        /**\n         * \n         * @param {number} [x=0]\n         * @param {number} [y=0]\n         * @return {Vector2}\n         */\n        create: function (x, y) {\n            var out = new ArrayCtor(2);\n            if (x == null) {\n                x = 0;\n            }\n            if (y == null) {\n                y = 0;\n            }\n            out[0] = x;\n            out[1] = y;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        copy: function (out, v) {\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        clone: function (v) {\n            var out = new ArrayCtor(2);\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {number} a\n         * @param {number} b\n         * @return {Vector2} \n         */\n        set: function (out, a, b) {\n            out[0] = a;\n            out[1] = b;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        add: function (out, v1, v2) {\n            out[0] = v1[0] + v2[0];\n            out[1] = v1[1] + v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} a\n         */\n        scaleAndAdd: function (out, v1, v2, a) {\n            out[0] = v1[0] + v2[0] * a;\n            out[1] = v1[1] + v2[1] * a;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        sub: function (out, v1, v2) {\n            out[0] = v1[0] - v2[0];\n            out[1] = v1[1] - v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        len: function (v) {\n            return Math.sqrt(this.lenSquare(v));\n        },\n\n        /**\n         * \n         * @param {Vector2} v\n         * @return {number}\n         */\n        lenSquare: function (v) {\n            return v[0] * v[0] + v[1] * v[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        mul: function (out, v1, v2) {\n            out[0] = v1[0] * v2[0];\n            out[1] = v1[1] * v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        div: function (out, v1, v2) {\n            out[0] = v1[0] / v2[0];\n            out[1] = v1[1] / v2[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        dot: function (v1, v2) {\n            return v1[0] * v2[0] + v1[1] * v2[1];\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {number} s\n         */\n        scale: function (out, v, s) {\n            out[0] = v[0] * s;\n            out[1] = v[1] * s;\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        normalize: function (out, v) {\n            var d = vector.len(v);\n            if (d === 0) {\n                out[0] = 0;\n                out[1] = 0;\n            }\n            else {\n                out[0] = v[0] / d;\n                out[1] = v[1] / d;\n            }\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distance: function (v1, v2) {\n            return Math.sqrt(\n                (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n            );\n        },\n\n        /**\n         * \n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distanceSquare: function (v1, v2) {\n            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        negate: function (out, v) {\n            out[0] = -v[0];\n            out[1] = -v[1];\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} t\n         */\n        lerp: function (out, v1, v2, t) {\n            out[0] = v1[0] + t * (v2[0] - v1[0]);\n            out[1] = v1[1] + t * (v2[1] - v1[1]);\n            return out;\n        },\n\n        /**\n         * \n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {Vector2} m\n         */\n        applyTransform: function (out, v, m) {\n            var x = v[0];\n            var y = v[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        min: function (out, v1, v2) {\n            out[0] = Math.min(v1[0], v2[0]);\n            out[1] = Math.min(v1[1], v2[1]);\n            return out;\n        },\n        /**\n         * \n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        max: function (out, v1, v2) {\n            out[0] = Math.max(v1[0], v2[0]);\n            out[1] = Math.max(v1[1], v2[1]);\n            return out;\n        }\n    };\n\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n\n    module.exports = vector;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/core/vector.js\n// module id = 976\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('./number');\n    var textContain = require('zrender/lib/contain/text');\n\n    var formatUtil = {};\n\n    /**\n     * ,\n     * @param {string|number} x\n     * @return {string}\n     */\n    formatUtil.addCommas = function (x) {\n        if (isNaN(x)) {\n            return '-';\n        }\n        x = (x + '').split('.');\n        return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,')\n               + (x.length > 1 ? ('.' + x[1]) : '');\n    };\n\n    /**\n     * @param {string} str\n     * @param {boolean} [upperCaseFirst=false]\n     * @return {string} str\n     */\n    formatUtil.toCamelCase = function (str, upperCaseFirst) {\n        str = (str || '').toLowerCase().replace(/-(.)/g, function(match, group1) {\n            return group1.toUpperCase();\n        });\n\n        if (upperCaseFirst && str) {\n            str = str.charAt(0).toUpperCase() + str.slice(1);\n        }\n\n        return str;\n    };\n\n    formatUtil.normalizeCssArray = zrUtil.normalizeCssArray;\n\n    var encodeHTML = formatUtil.encodeHTML = function (source) {\n        return String(source)\n            .replace(/&/g, '&amp;')\n            .replace(/</g, '&lt;')\n            .replace(/>/g, '&gt;')\n            .replace(/\"/g, '&quot;')\n            .replace(/'/g, '&#39;');\n    };\n\n    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\n    var wrapVar = function (varName, seriesIdx) {\n        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n    };\n\n    /**\n     * Template formatter\n     * @param {string} tpl\n     * @param {Array.<Object>|Object} paramsList\n     * @param {boolean} [encode=false]\n     * @return {string}\n     */\n    formatUtil.formatTpl = function (tpl, paramsList, encode) {\n        if (!zrUtil.isArray(paramsList)) {\n            paramsList = [paramsList];\n        }\n        var seriesLen = paramsList.length;\n        if (!seriesLen) {\n            return '';\n        }\n\n        var $vars = paramsList[0].$vars || [];\n        for (var i = 0; i < $vars.length; i++) {\n            var alias = TPL_VAR_ALIAS[i];\n            var val = wrapVar(alias, 0);\n            tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val);\n        }\n        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n            for (var k = 0; k < $vars.length; k++) {\n                var val = paramsList[seriesIdx][$vars[k]];\n                tpl = tpl.replace(\n                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),\n                    encode ? encodeHTML(val) : val\n                );\n            }\n        }\n\n        return tpl;\n    };\n\n    /**\n     * simple Template formatter\n     *\n     * @param {string} tpl\n     * @param {Object} param\n     * @param {boolean} [encode=false]\n     * @return {string}\n     */\n    formatUtil.formatTplSimple = function (tpl, param, encode) {\n        zrUtil.each(param, function (value, key) {\n            tpl = tpl.replace(\n                '{' + key + '}',\n                encode ? encodeHTML(value) : value\n            );\n        });\n        return tpl;\n    };\n\n    /**\n     * @param {string} color\n     * @param {string} [extraCssText]\n     * @return {string}\n     */\n    formatUtil.getTooltipMarker = function (color, extraCssText) {\n        return color\n            ? '<span style=\"display:inline-block;margin-right:5px;'\n                + 'border-radius:10px;width:9px;height:9px;background-color:'\n                + formatUtil.encodeHTML(color) + ';' + (extraCssText || '') + '\"></span>'\n            : '';\n    };\n\n    /**\n     * @param {string} str\n     * @return {string}\n     * @inner\n     */\n    var s2d = function (str) {\n        return str < 10 ? ('0' + str) : str;\n    };\n\n    /**\n     * ISO Date format\n     * @param {string} tpl\n     * @param {number} value\n     * @param {boolean} [isUTC=false] Default in local time.\n     *           see `module:echarts/scale/Time`\n     *           and `module:echarts/util/number#parseDate`.\n     * @inner\n     */\n    formatUtil.formatTime = function (tpl, value, isUTC) {\n        if (tpl === 'week'\n            || tpl === 'month'\n            || tpl === 'quarter'\n            || tpl === 'half-year'\n            || tpl === 'year'\n        ) {\n            tpl = 'MM-dd\\nyyyy';\n        }\n\n        var date = numberUtil.parseDate(value);\n        var utc = isUTC ? 'UTC' : '';\n        var y = date['get' + utc + 'FullYear']();\n        var M = date['get' + utc + 'Month']() + 1;\n        var d = date['get' + utc + 'Date']();\n        var h = date['get' + utc + 'Hours']();\n        var m = date['get' + utc + 'Minutes']();\n        var s = date['get' + utc + 'Seconds']();\n\n        tpl = tpl.replace('MM', s2d(M))\n            .replace('M', M)\n            .replace('yyyy', y)\n            .replace('yy', y % 100)\n            .replace('dd', s2d(d))\n            .replace('d', d)\n            .replace('hh', s2d(h))\n            .replace('h', h)\n            .replace('mm', s2d(m))\n            .replace('m', m)\n            .replace('ss', s2d(s))\n            .replace('s', s);\n\n        return tpl;\n    };\n\n    /**\n     * Capital first\n     * @param {string} str\n     * @return {string}\n     */\n    formatUtil.capitalFirst = function (str) {\n        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n    };\n\n    formatUtil.truncateText = textContain.truncateText;\n\n    formatUtil.getTextRect = textContain.getBoundingRect;\n\n    module.exports = formatUtil;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/util/format.js\n// module id = 977\n// module chunks = 0 1 2","/**\n * echarts\n *\n * @desc echartsCanvasJavascript\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            // Assume canvas is supported\n            canvasSupported: true\n        };\n    }\n    else {\n        env = detect(navigator.userAgent);\n    }\n\n    module.exports = env;\n\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n            // IE 11 Trident/7.0; rv:11.0\n            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n        var weChat = (/micromessenger/i).test(ua);\n\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox) {\n            browser.firefox = true;\n            browser.version = firefox[1];\n        }\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n\n        // It is difficult to detect WeChat in Win Phone precisely, because ua can\n        // not be set on win phone. So we do not consider Win Phone.\n        if (weChat) {\n            browser.weChat = true;\n        }\n\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            // canvas\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n            canvasSupported : document.createElement('canvas').getContext ? true : false,\n            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n            // works on most browsers\n            // IE10/11 does not support touch event, and MS Edge supports them but not by\n            // default, so we dont check navigator.maxTouchPoints for them here.\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            // <http://caniuse.com/#search=pointer%20event>.\n            pointerEventsSupported: 'onpointerdown' in window\n                // Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n                // events currently. So we dont use that on other browsers unless tested sufficiently.\n                // Although IE 10 supports pointer event, it use old style and is different from the\n                // standard. So we exclude that. (IE 10 is hardly used on touch device)\n                && (browser.edge || (browser.ie && browser.version >= 11))\n        };\n    }\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/core/env.js\n// module id = 978\n// module chunks = 0 1 2","/**\n * @module echarts/model/Model\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var clazzUtil = require('../util/clazz');\n    var env = require('zrender/lib/core/env');\n\n    /**\n     * @alias module:echarts/model/Model\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} [parentModel]\n     * @param {module:echarts/model/Global} [ecModel]\n     */\n    function Model(option, parentModel, ecModel) {\n        /**\n         * @type {module:echarts/model/Model}\n         * @readOnly\n         */\n        this.parentModel = parentModel;\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        this.ecModel = ecModel;\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        this.option = option;\n\n        // Simple optimization\n        // if (this.init) {\n        //     if (arguments.length <= 4) {\n        //         this.init(option, parentModel, ecModel, extraOpt);\n        //     }\n        //     else {\n        //         this.init.apply(this, arguments);\n        //     }\n        // }\n    }\n\n    Model.prototype = {\n\n        constructor: Model,\n\n        /**\n         * Model \n         * @param {Object} option\n         */\n        init: null,\n\n        /**\n         *  Option merge\n         */\n        mergeOption: function (option) {\n            zrUtil.merge(this.option, option, true);\n        },\n\n        /**\n         * @param {string|Array.<string>} path\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        get: function (path, ignoreParent) {\n            if (path == null) {\n                return this.option;\n            }\n\n            return doGet(\n                this.option,\n                this.parsePath(path),\n                !ignoreParent && getParent(this, path)\n            );\n        },\n\n        /**\n         * @param {string} key\n         * @param {boolean} [ignoreParent=false]\n         * @return {*}\n         */\n        getShallow: function (key, ignoreParent) {\n            var option = this.option;\n\n            var val = option == null ? option : option[key];\n            var parentModel = !ignoreParent && getParent(this, key);\n            if (val == null && parentModel) {\n                val = parentModel.getShallow(key);\n            }\n            return val;\n        },\n\n        /**\n         * @param {string|Array.<string>} [path]\n         * @param {module:echarts/model/Model} [parentModel]\n         * @return {module:echarts/model/Model}\n         */\n        getModel: function (path, parentModel) {\n            var obj = path == null\n                ? this.option\n                : doGet(this.option, path = this.parsePath(path));\n\n            var thisParentModel;\n            parentModel = parentModel || (\n                (thisParentModel = getParent(this, path))\n                    && thisParentModel.getModel(path)\n            );\n\n            return new Model(obj, parentModel, this.ecModel);\n        },\n\n        /**\n         * If model has option\n         */\n        isEmpty: function () {\n            return this.option == null;\n        },\n\n        restoreData: function () {},\n\n        // Pending\n        clone: function () {\n            var Ctor = this.constructor;\n            return new Ctor(zrUtil.clone(this.option));\n        },\n\n        setReadOnly: function (properties) {\n            clazzUtil.setReadOnly(this, properties);\n        },\n\n        // If path is null/undefined, return null/undefined.\n        parsePath: function(path) {\n            if (typeof path === 'string') {\n                path = path.split('.');\n            }\n            return path;\n        },\n\n        /**\n         * @param {Function} getParentMethod\n         *        param {Array.<string>|string} path\n         *        return {module:echarts/model/Model}\n         */\n        customizeGetParent: function (getParentMethod) {\n            clazzUtil.set(this, 'getParent', getParentMethod);\n        },\n\n        isAnimationEnabled: function () {\n            if (!env.node) {\n                if (this.option.animation != null) {\n                    return !!this.option.animation;\n                }\n                else if (this.parentModel) {\n                    return this.parentModel.isAnimationEnabled();\n                }\n            }\n        }\n    };\n\n    function doGet(obj, pathArr, parentModel) {\n        for (var i = 0; i < pathArr.length; i++) {\n            // Ignore empty\n            if (!pathArr[i]) {\n                continue;\n            }\n            // obj could be number/string/... (like 0)\n            obj = (obj && typeof obj === 'object') ? obj[pathArr[i]] : null;\n            if (obj == null) {\n                break;\n            }\n        }\n        if (obj == null && parentModel) {\n            obj = parentModel.get(pathArr);\n        }\n        return obj;\n    }\n\n    // `path` can be null/undefined\n    function getParent(model, path) {\n        var getParentMethod = clazzUtil.get(model, 'getParent');\n        return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;\n    }\n\n    // Enable Model.extend.\n    clazzUtil.enableClassExtend(Model);\n\n    var mixin = zrUtil.mixin;\n    mixin(Model, require('./mixin/lineStyle'));\n    mixin(Model, require('./mixin/areaStyle'));\n    mixin(Model, require('./mixin/textStyle'));\n    mixin(Model, require('./mixin/itemStyle'));\n\n    module.exports = Model;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/model/Model.js\n// module id = 979\n// module chunks = 0 1 2","/**\n * Path element\n * @module zrender/graphic/Path\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var PathProxy = require('../core/PathProxy');\n    var pathContain = require('../contain/path');\n\n    var Pattern = require('./Pattern');\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\n    var abs = Math.abs;\n\n    var pathProxyForDraw = new PathProxy(true);\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = null;\n    }\n\n    Path.prototype = {\n\n        constructor: Path,\n\n        type: 'path',\n\n        __dirtyPath: true,\n\n        strokeContainThreshold: 5,\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path || pathProxyForDraw;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!(fill.colorStops);\n            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n            var hasFillPattern = hasFill && !!(fill.image);\n            var hasStrokePattern = hasStroke && !!(stroke.image);\n\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n\n            if (this.__dirty) {\n                var rect;\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    rect = rect || this.getBoundingRect();\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    rect = rect || this.getBoundingRect();\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            }\n            else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            }\n            else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n\n            var ctxLineDash = !!ctx.setLineDash;\n\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath\n                || (lineDash && !ctxLineDash && hasStroke)\n            ) {\n                path.beginPath(ctx);\n\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n\n                this.buildPath(path, this.shape, false);\n\n                // Clear path dirty flag\n                if (this.path) {\n                    this.__dirtyPath = false;\n                }\n            }\n            else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n\n            hasFill && path.fill(ctx);\n\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n\n            hasStroke && path.stroke(ctx);\n\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n        // Like in circle\n        buildPath: function (ctx, shapeCfg, inBundle) {},\n\n        createPathProxy: function () {\n            this.path = new PathProxy();\n        },\n\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (!path) {\n                    // Create path on demand.\n                    path = this.path = new PathProxy();\n                }\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n\n            return rect;\n        },\n\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(\n                            pathData, lineWidth / lineScale, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n\n        /**\n         * @param  {boolean} dirtyPath\n         */\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n\n            this.__dirty = true;\n\n            this.__zr && this.__zr.refresh();\n\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n\n        /**\n         * Alias for animate('shape')\n         * @param {boolean} loop\n         */\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n\n        // Overwrite attrKV\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            }\n            else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        if (key.hasOwnProperty(name)) {\n                            shape[name] = key[name];\n                        }\n                    }\n                }\n                else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        }\n    };\n\n    /**\n     *  Path element, \n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (\n                        ! thisShape.hasOwnProperty(name)\n                        && defaultShape.hasOwnProperty(name)\n                    ) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n\n            defaults.init && defaults.init.call(this, opts);\n        };\n\n        zrUtil.inherits(Sub, Path);\n\n        // FIXME  extend position, rotation \n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n\n        return Sub;\n    };\n\n    zrUtil.inherits(Path, Displayable);\n\n    module.exports = Path;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/graphic/Path.js\n// module id = 980\n// module chunks = 0 1 2","'use strict';\n// Layout helpers for each component positioning\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n    var numberUtil = require('./number');\n    var formatUtil = require('./format');\n    var parsePercent = numberUtil.parsePercent;\n    var each = zrUtil.each;\n\n    var layout = {};\n\n    /**\n     * @public\n     */\n    var LOCATION_PARAMS = layout.LOCATION_PARAMS = [\n        'left', 'right', 'top', 'bottom', 'width', 'height'\n    ];\n\n    /**\n     * @public\n     */\n    var HV_NAMES = layout.HV_NAMES = [\n        ['width', 'left', 'right'],\n        ['height', 'top', 'bottom']\n    ];\n\n    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n        var x = 0;\n        var y = 0;\n\n        if (maxWidth == null) {\n            maxWidth = Infinity;\n        }\n        if (maxHeight == null) {\n            maxHeight = Infinity;\n        }\n        var currentLineMaxSize = 0;\n\n        group.eachChild(function (child, idx) {\n            var position = child.position;\n            var rect = child.getBoundingRect();\n            var nextChild = group.childAt(idx + 1);\n            var nextChildRect = nextChild && nextChild.getBoundingRect();\n            var nextX;\n            var nextY;\n\n            if (orient === 'horizontal') {\n                var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);\n                nextX = x + moveX;\n                // Wrap when width exceeds maxWidth or meet a `newline` group\n                // FIXME compare before adding gap?\n                if (nextX > maxWidth || child.newline) {\n                    x = 0;\n                    nextX = moveX;\n                    y += currentLineMaxSize + gap;\n                    currentLineMaxSize = rect.height;\n                }\n                else {\n                    // FIXME: consider rect.y is not `0`?\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n                }\n            }\n            else {\n                var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);\n                nextY = y + moveY;\n                // Wrap when width exceeds maxHeight or meet a `newline` group\n                if (nextY > maxHeight || child.newline) {\n                    x += currentLineMaxSize + gap;\n                    y = 0;\n                    nextY = moveY;\n                    currentLineMaxSize = rect.width;\n                }\n                else {\n                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n                }\n            }\n\n            if (child.newline) {\n                return;\n            }\n\n            position[0] = x;\n            position[1] = y;\n\n            orient === 'horizontal'\n                ? (x = nextX + gap)\n                : (y = nextY + gap);\n        });\n    }\n\n    /**\n     * VBox or HBox layouting\n     * @param {string} orient\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.box = boxLayout;\n\n    /**\n     * VBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.vbox = zrUtil.curry(boxLayout, 'vertical');\n\n    /**\n     * HBox layouting\n     * @param {module:zrender/container/Group} group\n     * @param {number} gap\n     * @param {number} [width=Infinity]\n     * @param {number} [height=Infinity]\n     */\n    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');\n\n    /**\n     * If x or x2 is not specified or 'center' 'left' 'right',\n     * the width would be as long as possible.\n     * If y or y2 is not specified or 'middle' 'top' 'bottom',\n     * the height would be as long as possible.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.x]\n     * @param {number|string} [positionInfo.y]\n     * @param {number|string} [positionInfo.x2]\n     * @param {number|string} [positionInfo.y2]\n     * @param {Object} containerRect {width, height}\n     * @param {string|number} margin\n     * @return {Object} {width, height}\n     */\n    layout.getAvailableSize = function (positionInfo, containerRect, margin) {\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var x = parsePercent(positionInfo.x, containerWidth);\n        var y = parsePercent(positionInfo.y, containerHeight);\n        var x2 = parsePercent(positionInfo.x2, containerWidth);\n        var y2 = parsePercent(positionInfo.y2, containerHeight);\n\n        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);\n        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);\n        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);\n        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);\n\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        return {\n            width: Math.max(x2 - x - margin[1] - margin[3], 0),\n            height: Math.max(y2 - y - margin[0] - margin[2], 0)\n        };\n    };\n\n    /**\n     * Parse position info.\n     *\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {number|string} [positionInfo.width]\n     * @param {number|string} [positionInfo.height]\n     * @param {number|string} [positionInfo.aspect] Aspect is width / height\n     * @param {Object} containerRect\n     * @param {string|number} [margin]\n     *\n     * @return {module:zrender/core/BoundingRect}\n     */\n    layout.getLayoutRect = function (\n        positionInfo, containerRect, margin\n    ) {\n        margin = formatUtil.normalizeCssArray(margin || 0);\n\n        var containerWidth = containerRect.width;\n        var containerHeight = containerRect.height;\n\n        var left = parsePercent(positionInfo.left, containerWidth);\n        var top = parsePercent(positionInfo.top, containerHeight);\n        var right = parsePercent(positionInfo.right, containerWidth);\n        var bottom = parsePercent(positionInfo.bottom, containerHeight);\n        var width = parsePercent(positionInfo.width, containerWidth);\n        var height = parsePercent(positionInfo.height, containerHeight);\n\n        var verticalMargin = margin[2] + margin[0];\n        var horizontalMargin = margin[1] + margin[3];\n        var aspect = positionInfo.aspect;\n\n        // If width is not specified, calculate width from left and right\n        if (isNaN(width)) {\n            width = containerWidth - right - horizontalMargin - left;\n        }\n        if (isNaN(height)) {\n            height = containerHeight - bottom - verticalMargin - top;\n        }\n\n        if (aspect != null) {\n            // If width and height are not given\n            // 1. Graph should not exceeds the container\n            // 2. Aspect must be keeped\n            // 3. Graph should take the space as more as possible\n            // FIXME\n            // Margin is not considered, because there is no case that both\n            // using margin and aspect so far.\n            if (isNaN(width) && isNaN(height)) {\n                if (aspect > containerWidth / containerHeight) {\n                    width = containerWidth * 0.8;\n                }\n                else {\n                    height = containerHeight * 0.8;\n                }\n            }\n\n            // Calculate width or height with given aspect\n            if (isNaN(width)) {\n                width = aspect * height;\n            }\n            if (isNaN(height)) {\n                height = width / aspect;\n            }\n        }\n\n        // If left is not specified, calculate left from right and width\n        if (isNaN(left)) {\n            left = containerWidth - right - width - horizontalMargin;\n        }\n        if (isNaN(top)) {\n            top = containerHeight - bottom - height - verticalMargin;\n        }\n\n        // Align left and top\n        switch (positionInfo.left || positionInfo.right) {\n            case 'center':\n                left = containerWidth / 2 - width / 2 - margin[3];\n                break;\n            case 'right':\n                left = containerWidth - width - horizontalMargin;\n                break;\n        }\n        switch (positionInfo.top || positionInfo.bottom) {\n            case 'middle':\n            case 'center':\n                top = containerHeight / 2 - height / 2 - margin[0];\n                break;\n            case 'bottom':\n                top = containerHeight - height - verticalMargin;\n                break;\n        }\n        // If something is wrong and left, top, width, height are calculated as NaN\n        left = left || 0;\n        top = top || 0;\n        if (isNaN(width)) {\n            // Width may be NaN if only one value is given except width\n            width = containerWidth - horizontalMargin - left - (right || 0);\n        }\n        if (isNaN(height)) {\n            // Height may be NaN if only one value is given except height\n            height = containerHeight - verticalMargin - top - (bottom || 0);\n        }\n\n        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n        rect.margin = margin;\n        return rect;\n    };\n\n\n    /**\n     * Position a zr element in viewport\n     *  Group position is specified by either\n     *  {left, top}, {right, bottom}\n     *  If all properties exists, right and bottom will be igonred.\n     *\n     * Logic:\n     *     1. Scale (against origin point in parent coord)\n     *     2. Rotate (against origin point in parent coord)\n     *     3. Traslate (with el.position by this method)\n     * So this method only fixes the last step 'Traslate', which does not affect\n     * scaling and rotating.\n     *\n     * If be called repeatly with the same input el, the same result will be gotten.\n     *\n     * @param {module:zrender/Element} el Should have `getBoundingRect` method.\n     * @param {Object} positionInfo\n     * @param {number|string} [positionInfo.left]\n     * @param {number|string} [positionInfo.top]\n     * @param {number|string} [positionInfo.right]\n     * @param {number|string} [positionInfo.bottom]\n     * @param {number|string} [positionInfo.width] Only for opt.boundingModel: 'raw'\n     * @param {number|string} [positionInfo.height] Only for opt.boundingModel: 'raw'\n     * @param {Object} containerRect\n     * @param {string|number} margin\n     * @param {Object} [opt]\n     * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.\n     * @param {Array.<number>} [opt.boundingMode='all']\n     *        Specify how to calculate boundingRect when locating.\n     *        'all': Position the boundingRect that is transformed and uioned\n     *               both itself and its descendants.\n     *               This mode simplies confine the elements in the bounding\n     *               of their container (e.g., using 'right: 0').\n     *        'raw': Position the boundingRect that is not transformed and only itself.\n     *               This mode is useful when you want a element can overflow its\n     *               container. (Consider a rotated circle needs to be located in a corner.)\n     *               In this mode positionInfo.width/height can only be number.\n     */\n    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {\n        var h = !opt || !opt.hv || opt.hv[0];\n        var v = !opt || !opt.hv || opt.hv[1];\n        var boundingMode = opt && opt.boundingMode || 'all';\n\n        if (!h && !v) {\n            return;\n        }\n\n        var rect;\n        if (boundingMode === 'raw') {\n            rect = el.type === 'group'\n                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)\n                : el.getBoundingRect();\n        }\n        else {\n            rect = el.getBoundingRect();\n            if (el.needLocalTransform()) {\n                var transform = el.getLocalTransform();\n                // Notice: raw rect may be inner object of el,\n                // which should not be modified.\n                rect = rect.clone();\n                rect.applyTransform(transform);\n            }\n        }\n\n        // The real width and height can not be specified but calculated by the given el.\n        positionInfo = layout.getLayoutRect(\n            zrUtil.defaults(\n                {width: rect.width, height: rect.height},\n                positionInfo\n            ),\n            containerRect,\n            margin\n        );\n\n        // Because 'tranlate' is the last step in transform\n        // (see zrender/core/Transformable#getLocalTransfrom),\n        // we can just only modify el.position to get final result.\n        var elPos = el.position;\n        var dx = h ? positionInfo.x - rect.x : 0;\n        var dy = v ? positionInfo.y - rect.y : 0;\n\n        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);\n    };\n\n    /**\n     * @param {Object} option Contains some of the properties in HV_NAMES.\n     * @param {number} hvIdx 0: horizontal; 1: vertical.\n     */\n    layout.sizeCalculable = function (option, hvIdx) {\n        return option[HV_NAMES[hvIdx][0]] != null\n            || (option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null);\n    };\n\n    /**\n     * Consider Case:\n     * When defulat option has {left: 0, width: 100}, and we set {right: 0}\n     * through setOption or media query, using normal zrUtil.merge will cause\n     * {right: 0} does not take effect.\n     *\n     * @example\n     * ComponentModel.extend({\n     *     init: function () {\n     *         ...\n     *         var inputPositionParams = layout.getLayoutParams(option);\n     *         this.mergeOption(inputPositionParams);\n     *     },\n     *     mergeOption: function (newOption) {\n     *         newOption && zrUtil.merge(thisOption, newOption, true);\n     *         layout.mergeLayoutParam(thisOption, newOption);\n     *     }\n     * });\n     *\n     * @param {Object} targetOption\n     * @param {Object} newOption\n     * @param {Object|string} [opt]\n     * @param {boolean|Array.<boolean>} [opt.ignoreSize=false] Used for the components\n     *  that width (or height) should not be calculated by left and right (or top and bottom).\n     */\n    layout.mergeLayoutParam = function (targetOption, newOption, opt) {\n        !zrUtil.isObject(opt) && (opt = {});\n\n        var ignoreSize = opt.ignoreSize;\n        !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);\n\n        var hResult = merge(HV_NAMES[0], 0);\n        var vResult = merge(HV_NAMES[1], 1);\n\n        copy(HV_NAMES[0], targetOption, hResult);\n        copy(HV_NAMES[1], targetOption, vResult);\n\n        function merge(names, hvIdx) {\n            var newParams = {};\n            var newValueCount = 0;\n            var merged = {};\n            var mergedValueCount = 0;\n            var enoughParamNumber = 2;\n\n            each(names, function (name) {\n                merged[name] = targetOption[name];\n            });\n            each(names, function (name) {\n                // Consider case: newOption.width is null, which is\n                // set by user for removing width setting.\n                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n                hasValue(newParams, name) && newValueCount++;\n                hasValue(merged, name) && mergedValueCount++;\n            });\n\n            if (ignoreSize[hvIdx]) {\n                // Only one of left/right is premitted to exist.\n                if (hasValue(newOption, names[1])) {\n                    merged[names[2]] = null;\n                }\n                else if (hasValue(newOption, names[2])) {\n                    merged[names[1]] = null;\n                }\n                return merged;\n            }\n\n            // Case: newOption: {width: ..., right: ...},\n            // or targetOption: {right: ...} and newOption: {width: ...},\n            // There is no conflict when merged only has params count\n            // little than enoughParamNumber.\n            if (mergedValueCount === enoughParamNumber || !newValueCount) {\n                return merged;\n            }\n            // Case: newOption: {width: ..., right: ...},\n            // Than we can make sure user only want those two, and ignore\n            // all origin params in targetOption.\n            else if (newValueCount >= enoughParamNumber) {\n                return newParams;\n            }\n            else {\n                // Chose another param from targetOption by priority.\n                for (var i = 0; i < names.length; i++) {\n                    var name = names[i];\n                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {\n                        newParams[name] = targetOption[name];\n                        break;\n                    }\n                }\n                return newParams;\n            }\n        }\n\n        function hasProp(obj, name) {\n            return obj.hasOwnProperty(name);\n        }\n\n        function hasValue(obj, name) {\n            return obj[name] != null && obj[name] !== 'auto';\n        }\n\n        function copy(names, target, source) {\n            each(names, function (name) {\n                target[name] = source[name];\n            });\n        }\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.getLayoutParams = function (source) {\n        return layout.copyLayoutParams({}, source);\n    };\n\n    /**\n     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.\n     * @param {Object} source\n     * @return {Object} Result contains those props.\n     */\n    layout.copyLayoutParams = function (target, source) {\n        source && target && each(LOCATION_PARAMS, function (name) {\n            source.hasOwnProperty(name) && (target[name] = source[name]);\n        });\n        return target;\n    };\n\n    module.exports = layout;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/util/layout.js\n// module id = 981\n// module chunks = 0 1 2","'use strict';\n/**\n * @module echarts/core/BoundingRect\n */\n\n\n    var vec2 = require('./vector');\n    var matrix = require('./matrix');\n\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n\n        if (width < 0) {\n            x = x + width;\n            width = -width;\n        }\n        if (height < 0) {\n            y = y + height;\n            height = -height;\n        }\n\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n\n    BoundingRect.prototype = {\n\n        constructor: BoundingRect,\n\n        /**\n         * @param {module:echarts/core/BoundingRect} other\n         */\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n\n            this.width = mathMax(\n                    other.x + other.width,\n                    this.x + this.width\n                ) - x;\n            this.height = mathMax(\n                    other.y + other.height,\n                    this.y + this.height\n                ) - y;\n            this.x = x;\n            this.y = y;\n        },\n\n        /**\n         * @param {Array.<number>} m\n         * @methods\n         */\n        applyTransform: (function () {\n            var lt = [];\n            var rb = [];\n            var lb = [];\n            var rt = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                lt[0] = lb[0] = this.x;\n                lt[1] = rt[1] = this.y;\n                rb[0] = rt[0] = this.x + this.width;\n                rb[1] = lb[1] = this.y + this.height;\n\n                v2ApplyTransform(lt, lt, m);\n                v2ApplyTransform(rb, rb, m);\n                v2ApplyTransform(lb, lb, m);\n                v2ApplyTransform(rt, rt, m);\n\n                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n                this.width = maxX - this.x;\n                this.height = maxY - this.y;\n            };\n        })(),\n\n        /**\n         * Calculate matrix of transforming from self to target rect\n         * @param  {module:zrender/core/BoundingRect} b\n         * @return {Array.<number>}\n         */\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n\n            var m = matrix.create();\n\n            // \n            matrix.translate(m, m, [-a.x, -a.y]);\n            matrix.scale(m, m, [sx, sy]);\n            matrix.translate(m, m, [b.x, b.y]);\n\n            return m;\n        },\n\n        /**\n         * @param {(module:echarts/core/BoundingRect|Object)} b\n         * @return {boolean}\n         */\n        intersect: function (b) {\n            if (!b) {\n                return false;\n            }\n\n            if (!(b instanceof BoundingRect)) {\n                // Normalize negative width/height.\n                b = BoundingRect.create(b);\n            }\n\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n\n            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        },\n\n        /**\n         * @return {module:echarts/core/BoundingRect}\n         */\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n\n        /**\n         * Copy from another rect\n         */\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        },\n\n        plain: function () {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height\n            };\n        }\n    };\n\n    /**\n     * @param {Object|module:zrender/core/BoundingRect} rect\n     * @param {number} rect.x\n     * @param {number} rect.y\n     * @param {number} rect.width\n     * @param {number} rect.height\n     * @return {module:zrender/core/BoundingRect}\n     */\n    BoundingRect.create = function (rect) {\n        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n    };\n\n    module.exports = BoundingRect;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/core/BoundingRect.js\n// module id = 982\n// module chunks = 0 1 2","/**\n * Component model\n *\n * @module echarts/model/Component\n */\n\n\n    var Model = require('./Model');\n    var zrUtil = require('zrender/lib/core/util');\n    var arrayPush = Array.prototype.push;\n    var componentUtil = require('../util/component');\n    var clazzUtil = require('../util/clazz');\n    var layout = require('../util/layout');\n\n    /**\n     * @alias module:echarts/model/Component\n     * @constructor\n     * @param {Object} option\n     * @param {module:echarts/model/Model} parentModel\n     * @param {module:echarts/model/Model} ecModel\n     */\n    var ComponentModel = Model.extend({\n\n        type: 'component',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        id: '',\n\n        /**\n         * @readOnly\n         */\n        name: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        mainType: '',\n\n        /**\n         * @readOnly\n         * @type {string}\n         */\n        subType: '',\n\n        /**\n         * @readOnly\n         * @type {number}\n         */\n        componentIndex: 0,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * @type {module:echarts/model/Global}\n         * @readOnly\n         */\n        ecModel: null,\n\n        /**\n         * key: componentType\n         * value:  Component model list, can not be null.\n         * @type {Object.<string, Array.<module:echarts/model/Model>>}\n         * @readOnly\n         */\n        dependentModels: [],\n\n        /**\n         * @type {string}\n         * @readOnly\n         */\n        uid: null,\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        $constructor: function (option, parentModel, ecModel, extraOpt) {\n            Model.call(this, option, parentModel, ecModel, extraOpt);\n\n            this.uid = componentUtil.getUID('componentModel');\n        },\n\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n            this.mergeDefaultAndTheme(option, ecModel);\n        },\n\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            var themeModel = ecModel.getTheme();\n            zrUtil.merge(option, themeModel.get(this.mainType));\n            zrUtil.merge(option, this.getDefaultOption());\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (option, extraOpt) {\n            zrUtil.merge(this.option, option, true);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, option, layoutMode);\n            }\n        },\n\n        // Hooker after init or mergeOption\n        optionUpdated: function (newCptOption, isInit) {},\n\n        getDefaultOption: function () {\n            if (!clazzUtil.hasOwn(this, '__defaultOption')) {\n                var optList = [];\n                var Class = this.constructor;\n                while (Class) {\n                    var opt = Class.prototype.defaultOption;\n                    opt && optList.push(opt);\n                    Class = Class.superClass;\n                }\n\n                var defaultOption = {};\n                for (var i = optList.length - 1; i >= 0; i--) {\n                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\n                }\n                clazzUtil.set(this, '__defaultOption', defaultOption);\n            }\n            return clazzUtil.get(this, '__defaultOption');\n        },\n\n        getReferringComponents: function (mainType) {\n            return this.ecModel.queryComponents({\n                mainType: mainType,\n                index: this.get(mainType + 'Index', true),\n                id: this.get(mainType + 'Id', true)\n            });\n        }\n\n    });\n\n    // Reset ComponentModel.extend, add preConstruct.\n    // clazzUtil.enableClassExtend(\n    //     ComponentModel,\n    //     function (option, parentModel, ecModel, extraOpt) {\n    //         // Set dependentModels, componentIndex, name, id, mainType, subType.\n    //         zrUtil.extend(this, extraOpt);\n\n    //         this.uid = componentUtil.getUID('componentModel');\n\n    //         // this.setReadOnly([\n    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',\n    //         //     'dependentModels', 'componentIndex'\n    //         // ]);\n    //     }\n    // );\n\n    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.\n    clazzUtil.enableClassManagement(\n        ComponentModel, {registerWhenExtend: true}\n    );\n    componentUtil.enableSubTypeDefaulter(ComponentModel);\n\n    // Add capability of ComponentModel.topologicalTravel.\n    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);\n\n    function getDependencies(componentType) {\n        var deps = [];\n        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {\n            arrayPush.apply(deps, Clazz.prototype.dependencies || []);\n        });\n        // Ensure main type\n        return zrUtil.map(deps, function (type) {\n            return clazzUtil.parseClassType(type).main;\n        });\n    }\n\n    zrUtil.mixin(ComponentModel, require('./mixin/boxLayout'));\n\n    module.exports = ComponentModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/model/Component.js\n// module id = 983\n// module chunks = 0 1 2","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var clazz = {};\n\n    var TYPE_DELIMITER = '.';\n    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n    var MEMBER_PRIFIX = '\\0ec_\\0';\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name] = value;` (can be right-value)\n     * @public\n     */\n    clazz.set = function (host, name, value) {\n        return (host[MEMBER_PRIFIX + name] = value);\n    };\n\n    /**\n     * Hide private class member.\n     * The same behavior as `host[name];`\n     * @public\n     */\n    clazz.get = function (host, name) {\n        return host[MEMBER_PRIFIX + name];\n    };\n\n    /**\n     * For hidden private class member.\n     * The same behavior as `host.hasOwnProperty(name);`\n     * @public\n     */\n    clazz.hasOwn = function (host, name) {\n        return host.hasOwnProperty(MEMBER_PRIFIX + name);\n    };\n\n    /**\n     * Notice, parseClassType('') should returns {main: '', sub: ''}\n     * @public\n     */\n    var parseClassType = clazz.parseClassType = function (componentType) {\n        var ret = {main: '', sub: ''};\n        if (componentType) {\n            componentType = componentType.split(TYPE_DELIMITER);\n            ret.main = componentType[0] || '';\n            ret.sub = componentType[1] || '';\n        }\n        return ret;\n    };\n\n    /**\n     * @public\n     */\n    function checkClassType(componentType) {\n        zrUtil.assert(\n            /^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType),\n            'componentType \"' + componentType + '\" illegal'\n        );\n    }\n\n    /**\n     * @public\n     */\n    clazz.enableClassExtend = function (RootClass, mandatoryMethods) {\n\n        RootClass.$constructor = RootClass;\n        RootClass.extend = function (proto) {\n\n            if (__DEV__) {\n                zrUtil.each(mandatoryMethods, function (method) {\n                    if (!proto[method]) {\n                        console.warn(\n                            'Method `' + method + '` should be implemented'\n                            + (proto.type ? ' in ' + proto.type : '') + '.'\n                        );\n                    }\n                });\n            }\n\n            var superClass = this;\n            var ExtendedClass = function () {\n                if (!proto.$constructor) {\n                    superClass.apply(this, arguments);\n                }\n                else {\n                    proto.$constructor.apply(this, arguments);\n                }\n            };\n\n            zrUtil.extend(ExtendedClass.prototype, proto);\n\n            ExtendedClass.extend = this.extend;\n            ExtendedClass.superCall = superCall;\n            ExtendedClass.superApply = superApply;\n            zrUtil.inherits(ExtendedClass, this);\n            ExtendedClass.superClass = superClass;\n\n            return ExtendedClass;\n        };\n    };\n\n    // superCall should have class info, which can not be fetch from 'this'.\n    // Consider this case:\n    // class A has method f,\n    // class B inherits class A, overrides method f, f call superApply('f'),\n    // class C inherits class B, do not overrides method f,\n    // then when method of class C is called, dead loop occured.\n    function superCall(context, methodName) {\n        var args = zrUtil.slice(arguments, 2);\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    function superApply(context, methodName, args) {\n        return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    /**\n     * @param {Object} entity\n     * @param {Object} options\n     * @param {boolean} [options.registerWhenExtend]\n     * @public\n     */\n    clazz.enableClassManagement = function (entity, options) {\n        options = options || {};\n\n        /**\n         * Component model classes\n         * key: componentType,\n         * value:\n         *     componentClass, when componentType is 'xxx'\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\n         * @type {Object}\n         */\n        var storage = {};\n\n        entity.registerClass = function (Clazz, componentType) {\n            if (componentType) {\n                checkClassType(componentType);\n                componentType = parseClassType(componentType);\n\n                if (!componentType.sub) {\n                    if (__DEV__) {\n                        if (storage[componentType.main]) {\n                            console.warn(componentType.main + ' exists.');\n                        }\n                    }\n                    storage[componentType.main] = Clazz;\n                }\n                else if (componentType.sub !== IS_CONTAINER) {\n                    var container = makeContainer(componentType);\n                    container[componentType.sub] = Clazz;\n                }\n            }\n            return Clazz;\n        };\n\n        entity.getClass = function (componentMainType, subType, throwWhenNotFound) {\n            var Clazz = storage[componentMainType];\n\n            if (Clazz && Clazz[IS_CONTAINER]) {\n                Clazz = subType ? Clazz[subType] : null;\n            }\n\n            if (throwWhenNotFound && !Clazz) {\n                throw new Error(\n                    !subType\n                        ? componentMainType + '.' + 'type should be specified.'\n                        : 'Component ' + componentMainType + '.' + (subType || '') + ' not exists. Load it first.'\n                );\n            }\n\n            return Clazz;\n        };\n\n        entity.getClassesByMainType = function (componentType) {\n            componentType = parseClassType(componentType);\n\n            var result = [];\n            var obj = storage[componentType.main];\n\n            if (obj && obj[IS_CONTAINER]) {\n                zrUtil.each(obj, function (o, type) {\n                    type !== IS_CONTAINER && result.push(o);\n                });\n            }\n            else {\n                result.push(obj);\n            }\n\n            return result;\n        };\n\n        entity.hasClass = function (componentType) {\n            // Just consider componentType.main.\n            componentType = parseClassType(componentType);\n            return !!storage[componentType.main];\n        };\n\n        /**\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\n         */\n        entity.getAllClassMainTypes = function () {\n            var types = [];\n            zrUtil.each(storage, function (obj, type) {\n                types.push(type);\n            });\n            return types;\n        };\n\n        /**\n         * If a main type is container and has sub types\n         * @param  {string}  mainType\n         * @return {boolean}\n         */\n        entity.hasSubTypes = function (componentType) {\n            componentType = parseClassType(componentType);\n            var obj = storage[componentType.main];\n            return obj && obj[IS_CONTAINER];\n        };\n\n        entity.parseClassType = parseClassType;\n\n        function makeContainer(componentType) {\n            var container = storage[componentType.main];\n            if (!container || !container[IS_CONTAINER]) {\n                container = storage[componentType.main] = {};\n                container[IS_CONTAINER] = true;\n            }\n            return container;\n        }\n\n        if (options.registerWhenExtend) {\n            var originalExtend = entity.extend;\n            if (originalExtend) {\n                entity.extend = function (proto) {\n                    var ExtendedClass = originalExtend.call(this, proto);\n                    return entity.registerClass(ExtendedClass, proto.type);\n                };\n            }\n        }\n\n        return entity;\n    };\n\n    /**\n     * @param {string|Array.<string>} properties\n     */\n    clazz.setReadOnly = function (obj, properties) {\n        // FIXME It seems broken in IE8 simulation of IE11\n        // if (!zrUtil.isArray(properties)) {\n        //     properties = properties != null ? [properties] : [];\n        // }\n        // zrUtil.each(properties, function (prop) {\n        //     var value = obj[prop];\n\n        //     Object.defineProperty\n        //         && Object.defineProperty(obj, prop, {\n        //             value: value, writable: false\n        //         });\n        //     zrUtil.isArray(obj[prop])\n        //         && Object.freeze\n        //         && Object.freeze(obj[prop]);\n        // });\n    };\n\n    module.exports = clazz;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/util/clazz.js\n// module id = 984\n// module chunks = 0 1 2","\n\n    var util = require('../core/util');\n    var BoundingRect = require('../core/BoundingRect');\n    var imageHelper = require('../graphic/helper/image');\n\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n\n    var TEXT_CACHE_MAX = 5000;\n    var STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\n    var DEFAULT_FONT = '12px sans-serif';\n\n    var retrieve2 = util.retrieve2;\n    var retrieve3 = util.retrieve3;\n\n    /**\n     * @public\n     * @param {string} text\n     * @param {string} font\n     * @return {number} width\n     */\n    function getTextWidth(text, font) {\n        font = font || DEFAULT_FONT;\n        var key = text + ':' + font;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // textContain.measureText may be overrided in SVG or VML\n            width = Math.max(textContain.measureText(textLines[i], font).width, width);\n        }\n\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n\n        return width;\n    }\n\n    /**\n     * @public\n     * @param {string} text\n     * @param {string} font\n     * @param {string} [textAlign='left']\n     * @param {string} [textVerticalAlign='top']\n     * @param {Array.<number>} [textPadding]\n     * @param {Object} [rich]\n     * @param {Object} [truncate]\n     * @return {Object} {x, y, width, height, lineHeight}\n     */\n    function getTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n        return rich\n            ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate)\n            : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate);\n    }\n\n    function getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, truncate) {\n        var contentBlock = parsePlainText(text, font, textPadding, truncate);\n        var outerWidth = getTextWidth(text, font);\n        if (textPadding) {\n            outerWidth += textPadding[1] + textPadding[3];\n        }\n        var outerHeight = contentBlock.outerHeight;\n\n        var x = adjustTextX(0, outerWidth, textAlign);\n        var y = adjustTextY(0, outerHeight, textVerticalAlign);\n\n        var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n        rect.lineHeight = contentBlock.lineHeight;\n\n        return rect;\n    }\n\n    function getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate) {\n        var contentBlock = parseRichText(text, {\n            rich: rich,\n            truncate: truncate,\n            font: font,\n            textAlign: textAlign,\n            textPadding: textPadding\n        });\n        var outerWidth = contentBlock.outerWidth;\n        var outerHeight = contentBlock.outerHeight;\n\n        var x = adjustTextX(0, outerWidth, textAlign);\n        var y = adjustTextY(0, outerHeight, textVerticalAlign);\n\n        return new BoundingRect(x, y, outerWidth, outerHeight);\n    }\n\n    /**\n     * @public\n     * @param {number} x\n     * @param {number} width\n     * @param {string} [textAlign='left']\n     * @return {number} Adjusted x.\n     */\n    function adjustTextX(x, width, textAlign) {\n        // FIXME Right to left language\n        if (textAlign === 'right') {\n            x -= width;\n        }\n        else if (textAlign === 'center') {\n            x -= width / 2;\n        }\n        return x;\n    }\n\n    /**\n     * @public\n     * @param {number} y\n     * @param {number} height\n     * @param {string} [textVerticalAlign='top']\n     * @return {number} Adjusted y.\n     */\n    function adjustTextY(y, height, textVerticalAlign) {\n        if (textVerticalAlign === 'middle') {\n            y -= height / 2;\n        }\n        else if (textVerticalAlign === 'bottom') {\n            y -= height;\n        }\n        return y;\n    }\n\n    /**\n     * @public\n     * @param {stirng} textPosition\n     * @param {Object} rect {x, y, width, height}\n     * @param {number} distance\n     * @return {Object} {x, y, textAlign, textVerticalAlign}\n     */\n    function adjustTextPositionOnRect(textPosition, rect, distance) {\n\n        var x = rect.x;\n        var y = rect.y;\n\n        var height = rect.height;\n        var width = rect.width;\n        var halfHeight = height / 2;\n\n        var textAlign = 'left';\n        var textVerticalAlign = 'top';\n\n        switch (textPosition) {\n            case 'left':\n                x -= distance;\n                y += halfHeight;\n                textAlign = 'right';\n                textVerticalAlign = 'middle';\n                break;\n            case 'right':\n                x += distance + width;\n                y += halfHeight;\n                textVerticalAlign = 'middle';\n                break;\n            case 'top':\n                x += width / 2;\n                y -= distance;\n                textAlign = 'center';\n                textVerticalAlign = 'bottom';\n                break;\n            case 'bottom':\n                x += width / 2;\n                y += height + distance;\n                textAlign = 'center';\n                break;\n            case 'inside':\n                x += width / 2;\n                y += halfHeight;\n                textAlign = 'center';\n                textVerticalAlign = 'middle';\n                break;\n            case 'insideLeft':\n                x += distance;\n                y += halfHeight;\n                textVerticalAlign = 'middle';\n                break;\n            case 'insideRight':\n                x += width - distance;\n                y += halfHeight;\n                textAlign = 'right';\n                textVerticalAlign = 'middle';\n                break;\n            case 'insideTop':\n                x += width / 2;\n                y += distance;\n                textAlign = 'center';\n                break;\n            case 'insideBottom':\n                x += width / 2;\n                y += height - distance;\n                textAlign = 'center';\n                textVerticalAlign = 'bottom';\n                break;\n            case 'insideTopLeft':\n                x += distance;\n                y += distance;\n                break;\n            case 'insideTopRight':\n                x += width - distance;\n                y += distance;\n                textAlign = 'right';\n                break;\n            case 'insideBottomLeft':\n                x += distance;\n                y += height - distance;\n                textVerticalAlign = 'bottom';\n                break;\n            case 'insideBottomRight':\n                x += width - distance;\n                y += height - distance;\n                textAlign = 'right';\n                textVerticalAlign = 'bottom';\n                break;\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textVerticalAlign: textVerticalAlign\n        };\n    }\n\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @public\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} font\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, font, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n\n        var textLines = (text + '').split('\\n');\n        options = prepareTruncateOptions(containerWidth, font, ellipsis, options);\n\n        // FIXME\n        // It is not appropriate that every line has '...' when truncate multiple lines.\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            textLines[i] = truncateSingleLine(textLines[i], options);\n        }\n\n        return textLines.join('\\n');\n    }\n\n    function prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n        options = util.extend({}, options);\n\n        options.font = font;\n        var ellipsis = retrieve2(ellipsis, '...');\n        options.maxIterations = retrieve2(options.maxIterations, 2);\n        var minChar = options.minChar = retrieve2(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        options.cnCharWidth = getTextWidth('', font);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = options.ascCharWidth = getTextWidth('a', font);\n        options.placeholder = retrieve2(options.placeholder, '');\n\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '', truncate result: '', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n\n        contentWidth = containerWidth - ellipsisWidth;\n\n        options.ellipsis = ellipsis;\n        options.ellipsisWidth = ellipsisWidth;\n        options.contentWidth = contentWidth;\n        options.containerWidth = containerWidth;\n\n        return options;\n    }\n\n    function truncateSingleLine(textLine, options) {\n        var containerWidth = options.containerWidth;\n        var font = options.font;\n        var contentWidth = options.contentWidth;\n\n        if (!containerWidth) {\n            return '';\n        }\n\n        var lineWidth = getTextWidth(textLine, font);\n\n        if (lineWidth <= containerWidth) {\n            return textLine;\n        }\n\n        for (var j = 0;; j++) {\n            if (lineWidth <= contentWidth || j >= options.maxIterations) {\n                textLine += options.ellipsis;\n                break;\n            }\n\n            var subLength = j === 0\n                ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth)\n                : lineWidth > 0\n                ? Math.floor(textLine.length * contentWidth / lineWidth)\n                : 0;\n\n            textLine = textLine.substr(0, subLength);\n            lineWidth = getTextWidth(textLine, font);\n        }\n\n        if (textLine === '') {\n            textLine = options.placeholder;\n        }\n\n        return textLine;\n    }\n\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n\n    /**\n     * @public\n     * @param {string} font\n     * @return {number} line height\n     */\n    function getLineHeight(font) {\n        // FIXME A rough approach.\n        return getTextWidth('', font);\n    }\n\n    /**\n     * @public\n     * @param {string} text\n     * @param {string} font\n     * @return {Object} width\n     */\n    function measureText(text, font) {\n        var ctx = util.getContext();\n        ctx.font = font || DEFAULT_FONT;\n        return ctx.measureText(text);\n    }\n\n    /**\n     * @public\n     * @param {string} text\n     * @param {string} font\n     * @param {Object} [truncate]\n     * @return {Object} block: {lineHeight, lines, height, outerHeight}\n     *  Notice: for performance, do not calculate outerWidth util needed.\n     */\n    function parsePlainText(text, font, padding, truncate) {\n        text != null && (text += '');\n\n        var lineHeight = getLineHeight(font);\n        var lines = text ? text.split('\\n') : [];\n        var height = lines.length * lineHeight;\n        var outerHeight = height;\n\n        if (padding) {\n            outerHeight += padding[0] + padding[2];\n        }\n\n        if (text && truncate) {\n            var truncOuterHeight = truncate.outerHeight;\n            var truncOuterWidth = truncate.outerWidth;\n            if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n                text = '';\n                lines = [];\n            }\n            else if (truncOuterWidth != null) {\n                var options = prepareTruncateOptions(\n                    truncOuterWidth - (padding ? padding[1] + padding[3] : 0),\n                    font,\n                    truncate.ellipsis,\n                    {minChar: truncate.minChar, placeholder: truncate.placeholder}\n                );\n\n                // FIXME\n                // It is not appropriate that every line has '...' when truncate multiple lines.\n                for (var i = 0, len = lines.length; i < len; i++) {\n                    lines[i] = truncateSingleLine(lines[i], options);\n                }\n            }\n        }\n\n        return {\n            lines: lines,\n            height: height,\n            outerHeight: outerHeight,\n            lineHeight: lineHeight\n        };\n    }\n\n    /**\n     * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n     * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n     *\n     * @public\n     * @param {string} text\n     * @param {Object} style\n     * @return {Object} block\n     * {\n     *      width,\n     *      height,\n     *      lines: [{\n     *          lineHeight,\n     *          width,\n     *          tokens: [[{\n     *              styleName,\n     *              text,\n     *              width,      // include textPadding\n     *              height,     // include textPadding\n     *              textWidth, // pure text width\n     *              textHeight, // pure text height\n     *              lineHeihgt,\n     *              font,\n     *              textAlign,\n     *              textVerticalAlign\n     *          }], [...], ...]\n     *      }, ...]\n     * }\n     * If styleName is undefined, it is plain text.\n     */\n    function parseRichText(text, style) {\n        var contentBlock = {lines: [], width: 0, height: 0};\n\n        text != null && (text += '');\n        if (!text) {\n            return contentBlock;\n        }\n\n        var lastIndex = STYLE_REG.lastIndex = 0;\n        var result;\n        while ((result = STYLE_REG.exec(text)) != null) {\n            var matchedIndex = result.index;\n            if (matchedIndex > lastIndex) {\n                pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n            }\n            pushTokens(contentBlock, result[2], result[1]);\n            lastIndex = STYLE_REG.lastIndex;\n        }\n\n        if (lastIndex < text.length) {\n            pushTokens(contentBlock, text.substring(lastIndex, text.length));\n        }\n\n        var lines = contentBlock.lines;\n        var contentHeight = 0;\n        var contentWidth = 0;\n        // For `textWidth: 100%`\n        var pendingList = [];\n\n        var stlPadding = style.textPadding;\n\n        var truncate = style.truncate;\n        var truncateWidth = truncate && truncate.outerWidth;\n        var truncateHeight = truncate && truncate.outerHeight;\n        if (stlPadding) {\n            truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n            truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n        }\n\n        // Calculate layout info of tokens.\n        for (var i = 0; i < lines.length; i++) {\n            var line = lines[i];\n            var lineHeight = 0;\n            var lineWidth = 0;\n\n            for (var j = 0; j < line.tokens.length; j++) {\n                var token = line.tokens[j];\n                var tokenStyle = token.styleName && style.rich[token.styleName] || {};\n                // textPadding should not inherit from style.\n                var textPadding = token.textPadding = tokenStyle.textPadding;\n\n                // textFont has been asigned to font by `normalizeStyle`.\n                var font = token.font = tokenStyle.font || style.font;\n\n                // textHeight can be used when textVerticalAlign is specified in token.\n                var tokenHeight = token.textHeight = retrieve2(\n                    // textHeight should not be inherited, consider it can be specified\n                    // as box height of the block.\n                    tokenStyle.textHeight, textContain.getLineHeight(font)\n                );\n                textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n                token.height = tokenHeight;\n                token.lineHeight = retrieve3(\n                    tokenStyle.textLineHeight, style.textLineHeight, tokenHeight\n                );\n\n                token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n                token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n                if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n                    return {lines: [], width: 0, height: 0};\n                }\n\n                token.textWidth = textContain.getWidth(token.text, font);\n                var tokenWidth = tokenStyle.textWidth;\n                var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto';\n\n                // Percent width, can be `100%`, can be used in drawing separate\n                // line when box width is needed to be auto.\n                if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n                    token.percentWidth = tokenWidth;\n                    pendingList.push(token);\n                    tokenWidth = 0;\n                    // Do not truncate in this case, because there is no user case\n                    // and it is too complicated.\n                }\n                else {\n                    if (tokenWidthNotSpecified) {\n                        tokenWidth = token.textWidth;\n\n                        // FIXME: If image is not loaded and textWidth is not specified, calling\n                        // `getBoundingRect()` will not get correct result.\n                        var textBackgroundColor = tokenStyle.textBackgroundColor;\n                        var bgImg = textBackgroundColor && textBackgroundColor.image;\n\n                        // Use cases:\n                        // (1) If image is not loaded, it will be loaded at render phase and call\n                        // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n                        // image, and then the right size will be calculated here at the next tick.\n                        // See `graphic/helper/text.js`.\n                        // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n                        // use `imageHelper.findExistImage` to find cached image.\n                        // `imageHelper.findExistImage` will always be called here before\n                        // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n                        // which ensures that image will not be rendered before correct size calcualted.\n                        if (bgImg) {\n                            bgImg = imageHelper.findExistImage(bgImg);\n                            if (imageHelper.isImageReady(bgImg)) {\n                                tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n                            }\n                        }\n                    }\n\n                    var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n                    tokenWidth += paddingW;\n\n                    var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n                    if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n                        if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n                            token.text = '';\n                            token.textWidth = tokenWidth = 0;\n                        }\n                        else {\n                            token.text = truncateText(\n                                token.text, remianTruncWidth - paddingW, font, truncate.ellipsis,\n                                {minChar: truncate.minChar}\n                            );\n                            token.textWidth = textContain.getWidth(token.text, font);\n                            tokenWidth = token.textWidth + paddingW;\n                        }\n                    }\n                }\n\n                lineWidth += (token.width = tokenWidth);\n                tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n            }\n\n            line.width = lineWidth;\n            line.lineHeight = lineHeight;\n            contentHeight += lineHeight;\n            contentWidth = Math.max(contentWidth, lineWidth);\n        }\n\n        contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n        contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n        if (stlPadding) {\n            contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n            contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n        }\n\n        for (var i = 0; i < pendingList.length; i++) {\n            var token = pendingList[i];\n            var percentWidth = token.percentWidth;\n            // Should not base on outerWidth, because token can not be placed out of padding.\n            token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n        }\n\n        return contentBlock;\n    }\n\n    function pushTokens(block, str, styleName) {\n        var isEmptyStr = str === '';\n        var strs = str.split('\\n');\n        var lines = block.lines;\n\n        for (var i = 0; i < strs.length; i++) {\n            var text = strs[i];\n            var token = {\n                styleName: styleName,\n                text: text,\n                isLineHolder: !text && !isEmptyStr\n            };\n\n            // The first token should be appended to the last line.\n            if (!i) {\n                var tokens = (lines[lines.length - 1] || (lines[0] = {tokens: []})).tokens;\n\n                // Consider cases:\n                // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n                // (which is a placeholder) should be replaced by new token.\n                // (2) A image backage, where token likes {a|}.\n                // (3) A redundant '' will affect textAlign in line.\n                // (4) tokens with the same tplName should not be merged, because\n                // they should be displayed in different box (with border and padding).\n                var tokensLen = tokens.length;\n                (tokensLen === 1 && tokens[0].isLineHolder)\n                    ? (tokens[0] = token)\n                    // Consider text is '', only insert when it is the \"lineHolder\" or\n                    // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n                    : ((text || !tokensLen || isEmptyStr) && tokens.push(token));\n            }\n            // Other tokens always start a new line.\n            else {\n                // If there is '', insert it as a placeholder.\n                lines.push({tokens: [token]});\n            }\n        }\n    }\n\n    function makeFont(style) {\n        // FIXME in node-canvas fontWeight is before fontStyle\n        // Use `fontSize` `fontFamily` to check whether font properties are defined.\n        return (style.fontSize || style.fontFamily) && [\n            style.fontStyle,\n            style.fontWeight,\n            (style.fontSize || 12) + 'px',\n            // If font properties are defined, `fontFamily` should not be ignored.\n            style.fontFamily || 'sans-serif'\n        ].join(' ') || style.textFont || style.font;\n    }\n\n    var textContain = {\n\n        getWidth: getTextWidth,\n\n        getBoundingRect: getTextRect,\n\n        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\n        truncateText: truncateText,\n\n        measureText: measureText,\n\n        getLineHeight: getLineHeight,\n\n        parsePlainText: parsePlainText,\n\n        parseRichText: parseRichText,\n\n        adjustTextX: adjustTextX,\n\n        adjustTextY: adjustTextY,\n\n        makeFont: makeFont,\n\n        DEFAULT_FONT: DEFAULT_FONT\n    };\n\n    module.exports = textContain;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/contain/text.js\n// module id = 985\n// module chunks = 0 1 2","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n    /**\n     * 3x2\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n        /**\n         * \n         * @return {Float32Array|Array.<number>}\n         */\n        create : function() {\n            var out = new ArrayCtor(6);\n            matrix.identity(out);\n\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         */\n        identity : function(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m\n         */\n        copy: function(out, m) {\n            out[0] = m[0];\n            out[1] = m[1];\n            out[2] = m[2];\n            out[3] = m[3];\n            out[4] = m[4];\n            out[5] = m[5];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m1\n         * @param {Float32Array|Array.<number>} m2\n         */\n        mul : function (out, m1, m2) {\n            // Consider matrix.mul(m, m2, m);\n            // where out is the same as m2.\n            // So use temp variable to escape error.\n            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = out3;\n            out[4] = out4;\n            out[5] = out5;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        translate : function(out, a, v) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4] + v[0];\n            out[5] = a[5] + v[1];\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {number} rad\n         */\n        rotate : function(out, a, rad) {\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n            var st = Math.sin(rad);\n            var ct = Math.cos(rad);\n\n            out[0] = aa * ct + ab * st;\n            out[1] = -aa * st + ab * ct;\n            out[2] = ac * ct + ad * st;\n            out[3] = -ac * st + ct * ad;\n            out[4] = ct * atx + st * aty;\n            out[5] = ct * aty - st * atx;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        scale : function(out, a, v) {\n            var vx = v[0];\n            var vy = v[1];\n            out[0] = a[0] * vx;\n            out[1] = a[1] * vy;\n            out[2] = a[2] * vx;\n            out[3] = a[3] * vy;\n            out[4] = a[4] * vx;\n            out[5] = a[5] * vy;\n            return out;\n        },\n        /**\n         * \n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         */\n        invert : function(out, a) {\n\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n\n            var det = aa * ad - ab * ac;\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out;\n        }\n    };\n\n    module.exports = matrix;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/core/matrix.js\n// module id = 986\n// module chunks = 0 1 2","/**\n * List for data storage\n * @module echarts/data/List\n */\n\n\n    var UNDEFINED = 'undefined';\n    var globalObj = typeof window === 'undefined' ? global : window;\n    var Float64Array = typeof globalObj.Float64Array === UNDEFINED\n        ? Array : globalObj.Float64Array;\n    var Int32Array = typeof globalObj.Int32Array === UNDEFINED\n        ? Array : globalObj.Int32Array;\n\n    var dataCtors = {\n        'float': Float64Array,\n        'int': Int32Array,\n        // Ordinal data type can be string or int\n        'ordinal': Array,\n        'number': Array,\n        'time': Array\n    };\n\n    var Model = require('../model/Model');\n    var DataDiffer = require('./DataDiffer');\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../util/model');\n    var isObject = zrUtil.isObject;\n\n    var TRANSFERABLE_PROPERTIES = [\n        'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'\n    ];\n\n    function transferProperties(a, b) {\n        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {\n            if (b.hasOwnProperty(propName)) {\n                a[propName] = b[propName];\n            }\n        });\n\n        a.__wrappedMethods = b.__wrappedMethods;\n    }\n\n    function DefaultDataProvider(dataArray) {\n        this._array = dataArray || [];\n    }\n\n    DefaultDataProvider.prototype.pure = false;\n\n    DefaultDataProvider.prototype.count = function () {\n        return this._array.length;\n    };\n    DefaultDataProvider.prototype.getItem = function (idx) {\n        return this._array[idx];\n    };\n\n    /**\n     * @constructor\n     * @alias module:echarts/data/List\n     *\n     * @param {Array.<string|Object>} dimensions\n     *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n     *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n     * @param {module:echarts/model/Model} hostModel\n     */\n    var List = function (dimensions, hostModel) {\n\n        dimensions = dimensions || ['x', 'y'];\n\n        var dimensionInfos = {};\n        var dimensionNames = [];\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimensionName;\n            var dimensionInfo = {};\n            if (typeof dimensions[i] === 'string') {\n                dimensionName = dimensions[i];\n                dimensionInfo = {\n                    name: dimensionName,\n                    coordDim: dimensionName,\n                    coordDimIndex: 0,\n                    stackable: false,\n                    // Type can be 'float', 'int', 'number'\n                    // Default is number, Precision of float may not enough\n                    type: 'number'\n                };\n            }\n            else {\n                dimensionInfo = dimensions[i];\n                dimensionName = dimensionInfo.name;\n                dimensionInfo.type = dimensionInfo.type || 'number';\n                if (!dimensionInfo.coordDim) {\n                    dimensionInfo.coordDim = dimensionName;\n                    dimensionInfo.coordDimIndex = 0;\n                }\n            }\n            dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n            dimensionNames.push(dimensionName);\n            dimensionInfos[dimensionName] = dimensionInfo;\n        }\n\n        /**\n         * @readOnly\n         * @type {Array.<string>}\n         */\n        this.dimensions = dimensionNames;\n\n        /**\n         * Infomation of each data dimension, like data type.\n         * @type {Object}\n         */\n        this._dimensionInfos = dimensionInfos;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.hostModel = hostModel;\n\n        /**\n         * @type {module:echarts/model/Model}\n         */\n        this.dataType;\n\n        /**\n         * Indices stores the indices of data subset after filtered.\n         * This data subset will be used in chart.\n         * @type {Array.<number>}\n         * @readOnly\n         */\n        this.indices = [];\n\n        /**\n         * Data storage\n         * @type {Object.<key, TypedArray|Array>}\n         * @private\n         */\n        this._storage = {};\n\n        /**\n         * @type {Array.<string>}\n         */\n        this._nameList = [];\n        /**\n         * @type {Array.<string>}\n         */\n        this._idList = [];\n\n        /**\n         * Models of data option is stored sparse for optimizing memory cost\n         * @type {Array.<module:echarts/model/Model>}\n         * @private\n         */\n        this._optionModels = [];\n\n        /**\n         * @param {module:echarts/data/List}\n         */\n        this.stackedOn = null;\n\n        /**\n         * Global visual properties after visual coding\n         * @type {Object}\n         * @private\n         */\n        this._visual = {};\n\n        /**\n         * Globel layout properties.\n         * @type {Object}\n         * @private\n         */\n        this._layout = {};\n\n        /**\n         * Item visual properties after visual coding\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemVisuals = [];\n\n        /**\n         * Item layout properties after layout\n         * @type {Array.<Object>}\n         * @private\n         */\n        this._itemLayouts = [];\n\n        /**\n         * Graphic elemnents\n         * @type {Array.<module:zrender/Element>}\n         * @private\n         */\n        this._graphicEls = [];\n\n        /**\n         * @type {Array.<Array|Object>}\n         * @private\n         */\n        this._rawData;\n\n        /**\n         * @type {Object}\n         * @private\n         */\n        this._extent;\n    };\n\n    var listProto = List.prototype;\n\n    listProto.type = 'list';\n\n    /**\n     * If each data item has it's own option\n     * @type {boolean}\n     */\n    listProto.hasItemOption = true;\n\n    /**\n     * Get dimension name\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     * @return {string} Concrete dim name.\n     */\n    listProto.getDimension = function (dim) {\n        if (!isNaN(dim)) {\n            dim = this.dimensions[dim] || dim;\n        }\n        return dim;\n    };\n\n    /**\n     * Get type and stackable info of particular dimension\n     * @param {string|number} dim\n     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n     */\n    listProto.getDimensionInfo = function (dim) {\n        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);\n    };\n\n    /**\n     * Initialize from data\n     * @param {Array.<Object|number|Array>} data\n     * @param {Array.<string>} [nameList]\n     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n     */\n    listProto.initData = function (data, nameList, dimValueGetter) {\n        data = data || [];\n\n        var isDataArray = zrUtil.isArray(data);\n        if (isDataArray) {\n            data = new DefaultDataProvider(data);\n        }\n        if (__DEV__) {\n            if (!isDataArray && (typeof data.getItem != 'function' || typeof data.count != 'function')) {\n                throw new Error('Inavlid data provider.');\n            }\n        }\n\n        this._rawData = data;\n\n        // Clear\n        var storage = this._storage = {};\n        var indices = this.indices = [];\n\n        var dimensions = this.dimensions;\n        var dimensionInfoMap = this._dimensionInfos;\n\n        var size = data.count();\n\n        var idList = [];\n        var nameRepeatCount = {};\n        var nameDimIdx;\n\n        nameList = nameList || [];\n\n        // Init storage\n        for (var i = 0; i < dimensions.length; i++) {\n            var dimInfo = dimensionInfoMap[dimensions[i]];\n            dimInfo.otherDims.itemName === 0 && (nameDimIdx = i);\n            var DataCtor = dataCtors[dimInfo.type];\n            storage[dimensions[i]] = new DataCtor(size);\n        }\n\n        var self = this;\n        if (!dimValueGetter) {\n            self.hasItemOption = false;\n        }\n        // Default dim value getter\n        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {\n            var value = modelUtil.getDataItemValue(dataItem);\n            // If any dataItem is like { value: 10 }\n            if (modelUtil.isDataItemOption(dataItem)) {\n                self.hasItemOption = true;\n            }\n            return modelUtil.converDataValue(\n                (value instanceof Array)\n                    ? value[dimIndex]\n                    // If value is a single number or something else not array.\n                    : value,\n                dimensionInfoMap[dimName]\n            );\n        };\n\n        for (var i = 0; i < size; i++) {\n            // NOTICE: Try not to write things into dataItem\n            var dataItem = data.getItem(i);\n            // Each data item is value\n            // [1, 2]\n            // 2\n            // Bar chart, line chart which uses category axis\n            // only gives the 'y' value. 'x' value is the indices of cateogry\n            // Use a tempValue to normalize the value to be a (x, y) value\n\n            // Store the data by dimensions\n            for (var k = 0; k < dimensions.length; k++) {\n                var dim = dimensions[k];\n                var dimStorage = storage[dim];\n                // PENDING NULL is empty or zero\n                dimStorage[i] = dimValueGetter(dataItem, dim, i, k);\n            }\n\n            indices.push(i);\n        }\n\n        // Use the name in option and create id\n        for (var i = 0; i < size; i++) {\n            var dataItem = data.getItem(i);\n            if (!nameList[i] && dataItem) {\n                if (dataItem.name != null) {\n                    nameList[i] = dataItem.name;\n                }\n                else if (nameDimIdx != null) {\n                    nameList[i] = storage[dimensions[nameDimIdx]][i];\n                }\n            }\n            var name = nameList[i] || '';\n            // Try using the id in option\n            var id = dataItem && dataItem.id;\n\n            if (!id && name) {\n                // Use name as id and add counter to avoid same name\n                nameRepeatCount[name] = nameRepeatCount[name] || 0;\n                id = name;\n                if (nameRepeatCount[name] > 0) {\n                    id += '__ec__' + nameRepeatCount[name];\n                }\n                nameRepeatCount[name]++;\n            }\n            id && (idList[i] = id);\n        }\n\n        this._nameList = nameList;\n        this._idList = idList;\n    };\n\n    /**\n     * @return {number}\n     */\n    listProto.count = function () {\n        return this.indices.length;\n    };\n\n    /**\n     * Get value. Return NaN if idx is out of range.\n     * @param {string} dim Dim must be concrete name.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.get = function (dim, idx, stack) {\n        var storage = this._storage;\n        var dataIndex = this.indices[idx];\n\n        // If value not exists\n        if (dataIndex == null || !storage[dim]) {\n            return NaN;\n        }\n\n        var value = storage[dim][dataIndex];\n        // FIXME ordinal data type is not stackable\n        if (stack) {\n            var dimensionInfo = this._dimensionInfos[dim];\n            if (dimensionInfo && dimensionInfo.stackable) {\n                var stackedOn = this.stackedOn;\n                while (stackedOn) {\n                    // Get no stacked data of stacked on\n                    var stackedValue = stackedOn.get(dim, idx);\n                    // Considering positive stack, negative stack and empty data\n                    if ((value >= 0 && stackedValue > 0)  // Positive stack\n                        || (value <= 0 && stackedValue < 0) // Negative stack\n                    ) {\n                        value += stackedValue;\n                    }\n                    stackedOn = stackedOn.stackedOn;\n                }\n            }\n        }\n        return value;\n    };\n\n    /**\n     * Get value for multi dimensions.\n     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n     * @param {number} idx\n     * @param {boolean} stack\n     * @return {number}\n     */\n    listProto.getValues = function (dimensions, idx, stack) {\n        var values = [];\n\n        if (!zrUtil.isArray(dimensions)) {\n            stack = idx;\n            idx = dimensions;\n            dimensions = this.dimensions;\n        }\n\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            values.push(this.get(dimensions[i], idx, stack));\n        }\n\n        return values;\n    };\n\n    /**\n     * If value is NaN. Inlcuding '-'\n     * @param {string} dim\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.hasValue = function (idx) {\n        var dimensions = this.dimensions;\n        var dimensionInfos = this._dimensionInfos;\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n            if (\n                // Ordinal type can be string or number\n                dimensionInfos[dimensions[i]].type !== 'ordinal'\n                && isNaN(this.get(dimensions[i], idx))\n            ) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    /**\n     * Get extent of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     * @param {Function} filter\n     */\n    listProto.getDataExtent = function (dim, stack, filter) {\n        dim = this.getDimension(dim);\n        var dimData = this._storage[dim];\n        var dimInfo = this.getDimensionInfo(dim);\n        stack = (dimInfo && dimInfo.stackable) && stack;\n        var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];\n        var value;\n        if (dimExtent) {\n            return dimExtent;\n        }\n        // var dimInfo = this._dimensionInfos[dim];\n        if (dimData) {\n            var min = Infinity;\n            var max = -Infinity;\n            // var isOrdinal = dimInfo.type === 'ordinal';\n            for (var i = 0, len = this.count(); i < len; i++) {\n                value = this.get(dim, i, stack);\n                // FIXME\n                // if (isOrdinal && typeof value === 'string') {\n                //     value = zrUtil.indexOf(dimData, value);\n                // }\n                if (!filter || filter(value, dim, i)) {\n                    value < min && (min = value);\n                    value > max && (max = value);\n                }\n            }\n            return (this._extent[dim + !!stack] = [min, max]);\n        }\n        else {\n            return [Infinity, -Infinity];\n        }\n    };\n\n    /**\n     * Get sum of data in one dimension\n     * @param {string} dim\n     * @param {boolean} stack\n     */\n    listProto.getSum = function (dim, stack) {\n        var dimData = this._storage[dim];\n        var sum = 0;\n        if (dimData) {\n            for (var i = 0, len = this.count(); i < len; i++) {\n                var value = this.get(dim, i, stack);\n                if (!isNaN(value)) {\n                    sum += value;\n                }\n            }\n        }\n        return sum;\n    };\n\n    /**\n     * Retreive the index with given value\n     * @param {number} idx\n     * @param {number} value\n     * @return {number}\n     */\n    // FIXME Precision of float value\n    listProto.indexOf = function (dim, value) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var indices = this.indices;\n\n        if (dimData) {\n            for (var i = 0, len = indices.length; i < len; i++) {\n                var rawIndex = indices[i];\n                if (dimData[rawIndex] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given name\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfName = function (name) {\n        var indices = this.indices;\n        var nameList = this._nameList;\n\n        for (var i = 0, len = indices.length; i < len; i++) {\n            var rawIndex = indices[i];\n            if (nameList[rawIndex] === name) {\n                return i;\n            }\n        }\n\n        return -1;\n    };\n\n    /**\n     * Retreive the index with given raw data index\n     * @param {number} idx\n     * @param {number} name\n     * @return {number}\n     */\n    listProto.indexOfRawIndex = function (rawIndex) {\n        // Indices are ascending\n        var indices = this.indices;\n\n        // If rawIndex === dataIndex\n        var rawDataIndex = indices[rawIndex];\n        if (rawDataIndex != null && rawDataIndex === rawIndex) {\n            return rawIndex;\n        }\n\n        var left = 0;\n        var right = indices.length - 1;\n        while (left <= right) {\n            var mid = (left + right) / 2 | 0;\n            if (indices[mid] < rawIndex) {\n                left = mid + 1;\n            }\n            else if (indices[mid] > rawIndex) {\n                right = mid - 1;\n            }\n            else {\n                return mid;\n            }\n        }\n        return -1;\n    };\n\n    /**\n     * Retreive the index of nearest value\n     * @param {string} dim\n     * @param {number} value\n     * @param {boolean} stack If given value is after stacked\n     * @param {number} [maxDistance=Infinity]\n     * @return {Array.<number>} Considere multiple points has the same value.\n     */\n    listProto.indicesOfNearest = function (dim, value, stack, maxDistance) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var nearestIndices = [];\n\n        if (!dimData) {\n            return nearestIndices;\n        }\n\n        if (maxDistance == null) {\n            maxDistance = Infinity;\n        }\n\n        var minDist = Number.MAX_VALUE;\n        var minDiff = -1;\n        for (var i = 0, len = this.count(); i < len; i++) {\n            var diff = value - this.get(dim, i, stack);\n            var dist = Math.abs(diff);\n            if (diff <= maxDistance && dist <= minDist) {\n                // For the case of two data are same on xAxis, which has sequence data.\n                // Show the nearest index\n                // https://github.com/ecomfe/echarts/issues/2869\n                if (dist < minDist || (diff >= 0 && minDiff < 0)) {\n                    minDist = dist;\n                    minDiff = diff;\n                    nearestIndices.length = 0;\n                }\n                nearestIndices.push(i);\n            }\n        }\n        return nearestIndices;\n    };\n\n    /**\n     * Get raw data index\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawIndex = function (idx) {\n        var rawIdx = this.indices[idx];\n        return rawIdx == null ? -1 : rawIdx;\n    };\n\n    /**\n     * Get raw data item\n     * @param {number} idx\n     * @return {number}\n     */\n    listProto.getRawDataItem = function (idx) {\n        return this._rawData.getItem(this.getRawIndex(idx));\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getName = function (idx) {\n        return this._nameList[this.indices[idx]] || '';\n    };\n\n    /**\n     * @param {number} idx\n     * @param {boolean} [notDefaultIdx=false]\n     * @return {string}\n     */\n    listProto.getId = function (idx) {\n        return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');\n    };\n\n\n    function normalizeDimensions(dimensions) {\n        if (!zrUtil.isArray(dimensions)) {\n            dimensions = [dimensions];\n        }\n        return dimensions;\n    }\n\n    /**\n     * Data iteration\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     *\n     * @example\n     *  list.each('x', function (x, idx) {});\n     *  list.each(['x', 'y'], function (x, y, idx) {});\n     *  list.each(function (idx) {})\n     */\n    listProto.each = function (dims, cb, stack, context) {\n        if (typeof dims === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dims;\n            dims = [];\n        }\n\n        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n\n        var value = [];\n        var dimSize = dims.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            // Simple optimization\n            switch (dimSize) {\n                case 0:\n                    cb.call(context, i);\n                    break;\n                case 1:\n                    cb.call(context, this.get(dims[0], i, stack), i);\n                    break;\n                case 2:\n                    cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);\n                    break;\n                default:\n                    for (var k = 0; k < dimSize; k++) {\n                        value[k] = this.get(dims[k], i, stack);\n                    }\n                    // Index\n                    value[k] = i;\n                    cb.apply(context, value);\n            }\n        }\n    };\n\n    /**\n     * Data filter\n     * @param {string|Array.<string>}\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     */\n    listProto.filterSelf = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var newIndices = [];\n        var value = [];\n        var dimSize = dimensions.length;\n        var indices = this.indices;\n\n        context = context || this;\n\n        for (var i = 0; i < indices.length; i++) {\n            var keep;\n            // Simple optimization\n            if (!dimSize) {\n                keep = cb.call(context, i);\n            }\n            else if (dimSize === 1) {\n                keep = cb.call(\n                    context, this.get(dimensions[0], i, stack), i\n                );\n            }\n            else {\n                for (var k = 0; k < dimSize; k++) {\n                    value[k] = this.get(dimensions[k], i, stack);\n                }\n                value[k] = i;\n                keep = cb.apply(context, value);\n            }\n            if (keep) {\n                newIndices.push(indices[i]);\n            }\n        }\n\n        this.indices = newIndices;\n\n        // Reset data extent\n        this._extent = {};\n\n        return this;\n    };\n\n    /**\n     * Data mapping to a plain array\n     * @param {string|Array.<string>} [dimensions]\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.mapArray = function (dimensions, cb, stack, context) {\n        if (typeof dimensions === 'function') {\n            context = stack;\n            stack = cb;\n            cb = dimensions;\n            dimensions = [];\n        }\n\n        var result = [];\n        this.each(dimensions, function () {\n            result.push(cb && cb.apply(this, arguments));\n        }, stack, context);\n        return result;\n    };\n\n    function cloneListForMapAndSample(original, excludeDimensions) {\n        var allDimensions = original.dimensions;\n        var list = new List(\n            zrUtil.map(allDimensions, original.getDimensionInfo, original),\n            original.hostModel\n        );\n        // FIXME If needs stackedOn, value may already been stacked\n        transferProperties(list, original);\n\n        var storage = list._storage = {};\n        var originalStorage = original._storage;\n        // Init storage\n        for (var i = 0; i < allDimensions.length; i++) {\n            var dim = allDimensions[i];\n            var dimStore = originalStorage[dim];\n            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n                storage[dim] = new dimStore.constructor(\n                    originalStorage[dim].length\n                );\n            }\n            else {\n                // Direct reference for other dimensions\n                storage[dim] = originalStorage[dim];\n            }\n        }\n        return list;\n    }\n\n    /**\n     * Data mapping to a new List with given dimensions\n     * @param {string|Array.<string>} dimensions\n     * @param {Function} cb\n     * @param {boolean} [stack=false]\n     * @param {*} [context=this]\n     * @return {Array}\n     */\n    listProto.map = function (dimensions, cb, stack, context) {\n        dimensions = zrUtil.map(\n            normalizeDimensions(dimensions), this.getDimension, this\n        );\n\n        var list = cloneListForMapAndSample(this, dimensions);\n        // Following properties are all immutable.\n        // So we can reference to the same value\n        var indices = list.indices = this.indices;\n\n        var storage = list._storage;\n\n        var tmpRetValue = [];\n        this.each(dimensions, function () {\n            var idx = arguments[arguments.length - 1];\n            var retValue = cb && cb.apply(this, arguments);\n            if (retValue != null) {\n                // a number\n                if (typeof retValue === 'number') {\n                    tmpRetValue[0] = retValue;\n                    retValue = tmpRetValue;\n                }\n                for (var i = 0; i < retValue.length; i++) {\n                    var dim = dimensions[i];\n                    var dimStore = storage[dim];\n                    var rawIdx = indices[idx];\n                    if (dimStore) {\n                        dimStore[rawIdx] = retValue[i];\n                    }\n                }\n            }\n        }, stack, context);\n\n        return list;\n    };\n\n    /**\n     * Large data down sampling on given dimension\n     * @param {string} dimension\n     * @param {number} rate\n     * @param {Function} sampleValue\n     * @param {Function} sampleIndex Sample index for name and id\n     */\n    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n        var list = cloneListForMapAndSample(this, [dimension]);\n        var storage = this._storage;\n        var targetStorage = list._storage;\n\n        var originalIndices = this.indices;\n        var indices = list.indices = [];\n\n        var frameValues = [];\n        var frameIndices = [];\n        var frameSize = Math.floor(1 / rate);\n\n        var dimStore = targetStorage[dimension];\n        var len = this.count();\n        // Copy data from original data\n        for (var i = 0; i < storage[dimension].length; i++) {\n            targetStorage[dimension][i] = storage[dimension][i];\n        }\n        for (var i = 0; i < len; i += frameSize) {\n            // Last frame\n            if (frameSize > len - i) {\n                frameSize = len - i;\n                frameValues.length = frameSize;\n            }\n            for (var k = 0; k < frameSize; k++) {\n                var idx = originalIndices[i + k];\n                frameValues[k] = dimStore[idx];\n                frameIndices[k] = idx;\n            }\n            var value = sampleValue(frameValues);\n            var idx = frameIndices[sampleIndex(frameValues, value) || 0];\n            // Only write value on the filtered data\n            dimStore[idx] = value;\n            indices.push(idx);\n        }\n\n        return list;\n    };\n\n    /**\n     * Get model of one data item.\n     *\n     * @param {number} idx\n     */\n    // FIXME Model proxy ?\n    listProto.getItemModel = function (idx) {\n        var hostModel = this.hostModel;\n        idx = this.indices[idx];\n        return new Model(this._rawData.getItem(idx), hostModel, hostModel && hostModel.ecModel);\n    };\n\n    /**\n     * Create a data differ\n     * @param {module:echarts/data/List} otherList\n     * @return {module:echarts/data/DataDiffer}\n     */\n    listProto.diff = function (otherList) {\n        var idList = this._idList;\n        var otherIdList = otherList && otherList._idList;\n        var val;\n        // Use prefix to avoid index to be the same as otherIdList[idx],\n        // which will cause weird udpate animation.\n        var prefix = 'e\\0\\0';\n\n        return new DataDiffer(\n            otherList ? otherList.indices : [],\n            this.indices,\n            function (idx) {\n                return (val = otherIdList[idx]) != null ? val : prefix + idx;\n            },\n            function (idx) {\n                return (val = idList[idx]) != null ? val : prefix + idx;\n            }\n        );\n    };\n    /**\n     * Get visual property.\n     * @param {string} key\n     */\n    listProto.getVisual = function (key) {\n        var visual = this._visual;\n        return visual && visual[key];\n    };\n\n    /**\n     * Set visual property\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setVisual('color', color);\n     *  setVisual({\n     *      'color': color\n     *  });\n     */\n    listProto.setVisual = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setVisual(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._visual = this._visual || {};\n        this._visual[key] = val;\n    };\n\n    /**\n     * Set layout property.\n     * @param {string|Object} key\n     * @param {*} [val]\n     */\n    listProto.setLayout = function (key, val) {\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    this.setLayout(name, key[name]);\n                }\n            }\n            return;\n        }\n        this._layout[key] = val;\n    };\n\n    /**\n     * Get layout property.\n     * @param  {string} key.\n     * @return {*}\n     */\n    listProto.getLayout = function (key) {\n        return this._layout[key];\n    };\n\n    /**\n     * Get layout of single data item\n     * @param {number} idx\n     */\n    listProto.getItemLayout = function (idx) {\n        return this._itemLayouts[idx];\n    };\n\n    /**\n     * Set layout of single data item\n     * @param {number} idx\n     * @param {Object} layout\n     * @param {boolean=} [merge=false]\n     */\n    listProto.setItemLayout = function (idx, layout, merge) {\n        this._itemLayouts[idx] = merge\n            ? zrUtil.extend(this._itemLayouts[idx] || {}, layout)\n            : layout;\n    };\n\n    /**\n     * Clear all layout of single data item\n     */\n    listProto.clearItemLayouts = function () {\n        this._itemLayouts.length = 0;\n    };\n\n    /**\n     * Get visual property of single data item\n     * @param {number} idx\n     * @param {string} key\n     * @param {boolean} [ignoreParent=false]\n     */\n    listProto.getItemVisual = function (idx, key, ignoreParent) {\n        var itemVisual = this._itemVisuals[idx];\n        var val = itemVisual && itemVisual[key];\n        if (val == null && !ignoreParent) {\n            // Use global visual property\n            return this.getVisual(key);\n        }\n        return val;\n    };\n\n    /**\n     * Set visual property of single data item\n     *\n     * @param {number} idx\n     * @param {string|Object} key\n     * @param {*} [value]\n     *\n     * @example\n     *  setItemVisual(0, 'color', color);\n     *  setItemVisual(0, {\n     *      'color': color\n     *  });\n     */\n    listProto.setItemVisual = function (idx, key, value) {\n        var itemVisual = this._itemVisuals[idx] || {};\n        this._itemVisuals[idx] = itemVisual;\n\n        if (isObject(key)) {\n            for (var name in key) {\n                if (key.hasOwnProperty(name)) {\n                    itemVisual[name] = key[name];\n                }\n            }\n            return;\n        }\n        itemVisual[key] = value;\n    };\n\n    /**\n     * Clear itemVisuals and list visual.\n     */\n    listProto.clearAllVisual = function () {\n        this._visual = {};\n        this._itemVisuals = [];\n    };\n\n    var setItemDataAndSeriesIndex = function (child) {\n        child.seriesIndex = this.seriesIndex;\n        child.dataIndex = this.dataIndex;\n        child.dataType = this.dataType;\n    };\n    /**\n     * Set graphic element relative to data. It can be set as null\n     * @param {number} idx\n     * @param {module:zrender/Element} [el]\n     */\n    listProto.setItemGraphicEl = function (idx, el) {\n        var hostModel = this.hostModel;\n\n        if (el) {\n            // Add data index and series index for indexing the data by element\n            // Useful in tooltip\n            el.dataIndex = idx;\n            el.dataType = this.dataType;\n            el.seriesIndex = hostModel && hostModel.seriesIndex;\n            if (el.type === 'group') {\n                el.traverse(setItemDataAndSeriesIndex, el);\n            }\n        }\n\n        this._graphicEls[idx] = el;\n    };\n\n    /**\n     * @param {number} idx\n     * @return {module:zrender/Element}\n     */\n    listProto.getItemGraphicEl = function (idx) {\n        return this._graphicEls[idx];\n    };\n\n    /**\n     * @param {Function} cb\n     * @param {*} context\n     */\n    listProto.eachItemGraphicEl = function (cb, context) {\n        zrUtil.each(this._graphicEls, function (el, idx) {\n            if (el) {\n                cb && cb.call(context, el, idx);\n            }\n        });\n    };\n\n    /**\n     * Shallow clone a new list except visual and layout properties, and graph elements.\n     * New list only change the indices.\n     */\n    listProto.cloneShallow = function () {\n        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n        var list = new List(dimensionInfoList, this.hostModel);\n\n        // FIXME\n        list._storage = this._storage;\n\n        transferProperties(list, this);\n\n\n        // Clone will not change the data extent and indices\n        list.indices = this.indices.slice();\n\n        if (this._extent) {\n            list._extent = zrUtil.extend({}, this._extent);\n        }\n\n        return list;\n    };\n\n    /**\n     * Wrap some method to add more feature\n     * @param {string} methodName\n     * @param {Function} injectFunction\n     */\n    listProto.wrapMethod = function (methodName, injectFunction) {\n        var originalMethod = this[methodName];\n        if (typeof originalMethod !== 'function') {\n            return;\n        }\n        this.__wrappedMethods = this.__wrappedMethods || [];\n        this.__wrappedMethods.push(methodName);\n        this[methodName] = function () {\n            var res = originalMethod.apply(this, arguments);\n            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n        };\n    };\n\n    // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n    listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];\n    // Methods that change indices of this list should be listed here.\n    listProto.CHANGABLE_METHODS = ['filterSelf'];\n\n    module.exports = List;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/data/List.js\n// module id = 987\n// module chunks = 0 1 2","\n\n    var OrdinalScale = require('../scale/Ordinal');\n    var IntervalScale = require('../scale/Interval');\n    require('../scale/Time');\n    require('../scale/Log');\n    var Scale = require('../scale/Scale');\n\n    var numberUtil = require('../util/number');\n    var zrUtil = require('zrender/lib/core/util');\n    var textContain = require('zrender/lib/contain/text');\n    var axisHelper = {};\n\n    /**\n     * Get axis scale extent before niced.\n     * Item of returned array can only be number (including Infinity and NaN).\n     */\n    axisHelper.getScaleExtent = function (scale, model) {\n        var scaleType = scale.type;\n\n        var min = model.getMin();\n        var max = model.getMax();\n        var fixMin = min != null;\n        var fixMax = max != null;\n        var originalExtent = scale.getExtent();\n\n        var axisDataLen;\n        var boundaryGap;\n        var span;\n        if (scaleType === 'ordinal') {\n            axisDataLen = (model.get('data') || []).length;\n        }\n        else {\n            boundaryGap = model.get('boundaryGap');\n            if (!zrUtil.isArray(boundaryGap)) {\n                boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n            }\n            if (typeof boundaryGap[0] === 'boolean') {\n                if (__DEV__) {\n                    console.warn('Boolean type for boundaryGap is only '\n                        + 'allowed for ordinal axis. Please use string in '\n                        + 'percentage instead, e.g., \"20%\". Currently, '\n                        + 'boundaryGap is set to be 0.');\n                }\n                boundaryGap = [0, 0];\n            }\n            boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n            boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n            span = (originalExtent[1] - originalExtent[0])\n                || Math.abs(originalExtent[0]);\n        }\n\n        // Notice: When min/max is not set (that is, when there are null/undefined,\n        // which is the most common case), these cases should be ensured:\n        // (1) For 'ordinal', show all axis.data.\n        // (2) For others:\n        //      + `boundaryGap` is applied (if min/max set, boundaryGap is\n        //      disabled).\n        //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should\n        //      be the result that originalExtent enlarged by boundaryGap.\n        // (3) If no data, it should be ensured that `scale.setBlank` is set.\n\n        // FIXME\n        // (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?\n        // (2) When `needCrossZero` and all data is positive/negative, should it be ensured\n        // that the results processed by boundaryGap are positive/negative?\n\n        if (min == null) {\n            min = scaleType === 'ordinal'\n                ? (axisDataLen ? 0 : NaN)\n                : originalExtent[0] - boundaryGap[0] * span;\n        }\n        if (max == null) {\n            max = scaleType === 'ordinal'\n                ? (axisDataLen ? axisDataLen - 1 : NaN)\n                : originalExtent[1] + boundaryGap[1] * span;\n        }\n\n        if (min === 'dataMin') {\n            min = originalExtent[0];\n        }\n        else if (typeof min === 'function') {\n            min = min({\n                min: originalExtent[0],\n                max: originalExtent[1]\n            });\n        }\n\n        if (max === 'dataMax') {\n            max = originalExtent[1];\n        }\n        else if (typeof max === 'function') {\n            max = max({\n                min: originalExtent[0],\n                max: originalExtent[1]\n            });\n        }\n\n        (min == null || !isFinite(min)) && (min = NaN);\n        (max == null || !isFinite(max)) && (max = NaN);\n\n        scale.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max));\n\n        // Evaluate if axis needs cross zero\n        if (model.getNeedCrossZero()) {\n            // Axis is over zero and min is not set\n            if (min > 0 && max > 0 && !fixMin) {\n                min = 0;\n            }\n            // Axis is under zero and max is not set\n            if (min < 0 && max < 0 && !fixMax) {\n                max = 0;\n            }\n        }\n\n        return [min, max];\n    };\n\n    axisHelper.niceScaleExtent = function (scale, model) {\n        var extent = axisHelper.getScaleExtent(scale, model);\n        var fixMin = model.getMin() != null;\n        var fixMax = model.getMax() != null;\n        var splitNumber = model.get('splitNumber');\n\n        if (scale.type === 'log') {\n            scale.base = model.get('logBase');\n        }\n\n        var scaleType = scale.type;\n        scale.setExtent(extent[0], extent[1]);\n        scale.niceExtent({\n            splitNumber: splitNumber,\n            fixMin: fixMin,\n            fixMax: fixMax,\n            minInterval: (scaleType === 'interval' || scaleType === 'time')\n                ? model.get('minInterval') : null,\n            maxInterval: (scaleType === 'interval' || scaleType === 'time')\n                ? model.get('maxInterval') : null\n        });\n\n        // If some one specified the min, max. And the default calculated interval\n        // is not good enough. He can specify the interval. It is often appeared\n        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n        // to be 60.\n        // FIXME\n        var interval = model.get('interval');\n        if (interval != null) {\n            scale.setInterval && scale.setInterval(interval);\n        }\n    };\n\n    /**\n     * @param {module:echarts/model/Model} model\n     * @param {string} [axisType] Default retrieve from model.type\n     * @return {module:echarts/scale/*}\n     */\n    axisHelper.createScaleByModel = function(model, axisType) {\n        axisType = axisType || model.get('type');\n        if (axisType) {\n            switch (axisType) {\n                // Buildin scale\n                case 'category':\n                    return new OrdinalScale(\n                        model.getCategories(), [Infinity, -Infinity]\n                    );\n                case 'value':\n                    return new IntervalScale();\n                // Extended scale, like time and log\n                default:\n                    return (Scale.getClass(axisType) || IntervalScale).create(model);\n            }\n        }\n    };\n\n    /**\n     * Check if the axis corss 0\n     */\n    axisHelper.ifAxisCrossZero = function (axis) {\n        var dataExtent = axis.scale.getExtent();\n        var min = dataExtent[0];\n        var max = dataExtent[1];\n        return !((min > 0 && max > 0) || (min < 0 && max < 0));\n    };\n\n    /**\n     * @param {Array.<number>} tickCoords In axis self coordinate.\n     * @param {Array.<string>} labels\n     * @param {string} font\n     * @param {boolean} isAxisHorizontal\n     * @return {number}\n     */\n    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n        // FIXME\n        // axislabelhorizontalvertical.\n\n        var textSpaceTakenRect;\n        var autoLabelInterval = 0;\n        var accumulatedLabelInterval = 0;\n\n        var step = 1;\n        if (labels.length > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.floor(labels.length / 40);\n        }\n\n        for (var i = 0; i < tickCoords.length; i += step) {\n            var tickCoord = tickCoords[i];\n            var rect = textContain.getBoundingRect(\n                labels[i], font, 'center', 'top'\n            );\n            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n            // FIXME Magic number 1.5\n            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n            if (!textSpaceTakenRect) {\n                textSpaceTakenRect = rect.clone();\n            }\n            // There is no space for current label;\n            else if (textSpaceTakenRect.intersect(rect)) {\n                accumulatedLabelInterval++;\n                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n            }\n            else {\n                textSpaceTakenRect.union(rect);\n                // Reset\n                accumulatedLabelInterval = 0;\n            }\n        }\n        if (autoLabelInterval === 0 && step > 1) {\n            return step;\n        }\n        return (autoLabelInterval + 1) * step - 1;\n    };\n\n    /**\n     * @param {Object} axis\n     * @param {Function} labelFormatter\n     * @return {Array.<string>}\n     */\n    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n        var scale = axis.scale;\n        var labels = scale.getTicksLabels();\n        var ticks = scale.getTicks();\n        if (typeof labelFormatter === 'string') {\n            labelFormatter = (function (tpl) {\n                return function (val) {\n                    return tpl.replace('{value}', val != null ? val : '');\n                };\n            })(labelFormatter);\n            // Consider empty array\n            return zrUtil.map(labels, labelFormatter);\n        }\n        else if (typeof labelFormatter === 'function') {\n            return zrUtil.map(ticks, function (tick, idx) {\n                return labelFormatter(\n                    axisHelper.getAxisRawValue(axis, tick),\n                    idx\n                );\n            }, this);\n        }\n        else {\n            return labels;\n        }\n    };\n\n    axisHelper.getAxisRawValue = function (axis, value) {\n        // In category axis with data zoom, tick is not the original\n        // index of axis.data. So tick should not be exposed to user\n        // in category axis.\n        return axis.type === 'category' ? axis.scale.getLabel(value) : value;\n    };\n\n    module.exports = axisHelper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/coord/axisHelper.js\n// module id = 988\n// module chunks = 0 1 2","'use strict';\n\n\n    var features = {};\n\n    module.exports = {\n        register: function (name, ctor) {\n            features[name] = ctor;\n        },\n\n        get: function (name) {\n            return features[name];\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/component/toolbox/featureManager.js\n// module id = 989\n// module chunks = 0 1 2","'use strict';\n/**\n * \n * @module zrender/core/event\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n */\n\n\n    var Eventful = require('../mixin/Eventful');\n    var env = require('./env');\n\n    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\n    var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;\n\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n    }\n\n    // `calculate` is optional, default false\n    function clientToLocal(el, e, out, calculate) {\n        out = out || {};\n\n        // According to the W3C Working Draft, offsetX and offsetY should be relative\n        // to the padding edge of the target element. The only browser using this convention\n        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n        // not support the properties.\n        // (see http://www.jacklmoore.com/notes/mouse-position/)\n        // In zr painter.dom, padding edge equals to border edge.\n\n        // FIXME\n        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and\n        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y\n        // is too complex. So css-transfrom dont support in this case temporarily.\n        if (calculate || !env.canvasSupported) {\n            defaultGetZrXY(el, e, out);\n        }\n        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n        // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n        // zoom-factor, overflow / opacity layers, transforms ...)\n        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n        // <https://bugs.jquery.com/ticket/8523#comment:14>\n        // BTW3, In ff, offsetX/offsetY is always 0.\n        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n            out.zrX = e.layerX;\n            out.zrY = e.layerY;\n        }\n        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n        else if (e.offsetX != null) {\n            out.zrX = e.offsetX;\n            out.zrY = e.offsetY;\n        }\n        // For some other device, e.g., IOS safari.\n        else {\n            defaultGetZrXY(el, e, out);\n        }\n\n        return out;\n    }\n\n    function defaultGetZrXY(el, e, out) {\n        // This well-known method below does not support css transform.\n        var box = getBoundingClientRect(el);\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n    }\n\n    /**\n     * domtouch.\n     * `calculate` is optional, default false.\n     */\n    function normalizeEvent(el, e, calculate) {\n\n        e = e || window.event;\n\n        if (e.zrX != null) {\n            return e;\n        }\n\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n        if (!isTouch) {\n            clientToLocal(el, e, e, calculate);\n            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType != 'touchend'\n                ? e.targetTouches[0]\n                : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e, calculate);\n        }\n\n        // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;\n        // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js\n        // If e.which has been defined, if may be readonly,\n        // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which\n        var button = e.button;\n        if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {\n            e.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));\n        }\n\n        return e;\n    }\n\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        }\n        else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        }\n        else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n\n    /**\n     * preventDefault and stopPropagation.\n     * Notice: do not do that in zrender. Upper application\n     * do that if necessary.\n     *\n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event\n     */\n    var stop = isDomLevel2\n        ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        }\n        : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n\n    function notLeftMouse(e) {\n        // If e.which is undefined, considered as left mouse event.\n        return e.which > 1;\n    }\n\n    module.exports = {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n        notLeftMouse: notLeftMouse,\n\n        stop: stop,\n        // \n        Dispatcher: Eventful\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/core/event.js\n// module id = 990\n// module chunks = 0 1 2","'use strict';\n/**\n * \n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 1e-4;\n\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n\n    // \n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n             + t * t * (t * p3 + 3 * onet * p2);\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t\n        );\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1  - p0);\n        var d = p0 - val;\n\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n\n        var n = 0;\n\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;  // t1, a is not zero\n                var t2 = -K / 2;  // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} \n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <=1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] \n     * @return {number}\n     */\n    function cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n            d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n\n    /**\n     * \n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} \n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n\n    /**\n     * \n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n\n    /**\n     * \n     * \n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out \n     * @return {number}\n     */\n    function quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        //  t \n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n            var d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    module.exports = {\n\n        cubicAt: cubicAt,\n\n        cubicDerivativeAt: cubicDerivativeAt,\n\n        cubicRootAt: cubicRootAt,\n\n        cubicExtrema: cubicExtrema,\n\n        cubicSubdivide: cubicSubdivide,\n\n        cubicProjectPoint: cubicProjectPoint,\n\n        quadraticAt: quadraticAt,\n\n        quadraticDerivativeAt: quadraticDerivativeAt,\n\n        quadraticRootAt: quadraticRootAt,\n\n        quadraticExtremum: quadraticExtremum,\n\n        quadraticSubdivide: quadraticSubdivide,\n\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/core/curve.js\n// module id = 991\n// module chunks = 0 1 2","/**\n * \n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n\n    var arrySlice = Array.prototype.slice;\n\n    /**\n     * \n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n\n    Eventful.prototype = {\n\n        constructor: Eventful,\n\n        /**\n         * trigger\n         *\n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} context\n         */\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} handler \n         * @param {Object} [context]\n         */\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * \n         * @param  {string}  event\n         * @return {boolean}\n         */\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n\n        /**\n         * \n         * @param {string} event \n         * @param {Function} [handler] \n         */\n        off: function (event, handler) {\n            var _h = this._$handlers;\n\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            }\n            else {\n                delete _h[event];\n            }\n\n            return this;\n        },\n\n        /**\n         * \n         *\n         * @param {string} type \n         */\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(_h[i]['ctx']);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(_h[i]['ctx'], args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * context, context\n         * @param {string} type \n         */\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(ctx);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(ctx, args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(ctx, args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(ctx, args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n\n    //  onxxxx \n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrag\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n\n    module.exports = Eventful;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/mixin/Eventful.js\n// module id = 992\n// module chunks = 0 1 2","/**\n * @module zrender/tool/color\n */\n\n\n    var LRU = require('../core/LRU');\n\n    var kCSSColorTable = {\n        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n        'gray': [128,128,128,1], 'green': [0,128,0,1],\n        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n    };\n\n    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n\n    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n\n    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n\n    function parseCssInt(str) {  // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n\n    function parseCssFloat(str) {  // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2/3 - h) * 6;\n        }\n        return m1;\n    }\n\n    function lerpNumber(a, b, p) {\n        return a + (b - a) * p;\n    }\n\n    function setRgba(out, r, g, b, a) {\n        out[0] = r; out[1] = g; out[2] = b; out[3] = a;\n        return out;\n    }\n    function copyRgba(out, a) {\n        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];\n        return out;\n    }\n    var colorCache = new LRU(20);\n    var lastRemovedArr = null;\n    function putToCache(colorStr, rgbaArr) {\n        // Reuse removed array\n        if (lastRemovedArr) {\n            copyRgba(lastRemovedArr, rgbaArr);\n        }\n        lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()));\n    }\n    /**\n     * @param {string} colorStr\n     * @param {Array.<number>} out\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr, rgbaArr) {\n        if (!colorStr) {\n            return;\n        }\n        rgbaArr = rgbaArr || [];\n\n        var cached = colorCache.get(colorStr);\n        if (cached) {\n            return copyRgba(rgbaArr, cached);\n        }\n\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            copyRgba(rgbaArr, kCSSColorTable[str]);\n            putToCache(colorStr, rgbaArr);\n            return rgbaArr;\n        }\n\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                    (iv & 0xf) | ((iv & 0xf) << 4),\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n            else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;  // Covers NaN.\n                }\n                setRgba(rgbaArr,\n                    (iv & 0xff0000) >> 16,\n                    (iv & 0xff00) >> 8,\n                    iv & 0xff,\n                    1\n                );\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;  // To allow case fallthrough.\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n                // Fall through.\n                case 'rgb':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    setRgba(rgbaArr,\n                        parseCssInt(params[0]),\n                        parseCssInt(params[1]),\n                        parseCssInt(params[2]),\n                        alpha\n                    );\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsla':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsl':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                default:\n                    return;\n            }\n        }\n\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return;\n    }\n\n    /**\n     * @param {Array.<number>} hsla\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla, rgba) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n\n        rgba = rgba || [];\n        setRgba(rgba,\n            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255),\n            1\n        );\n\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n\n        return rgba;\n    }\n\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n\n        var vMin = Math.min(R, G, B); // Min. value of RGB\n        var vMax = Math.max(R, G, B); // Max. value of RGB\n        var delta = vMax - vMin; // Delta RGB value\n\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n\n            if (H < 0) {\n                H += 1;\n            }\n\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n\n        var hsla = [H * 360, S, L];\n\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n\n        return hsla;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n\n    /**\n     * Map value to color. Faster than lerp methods because color is represented by rgba array.\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>} will be null/undefined if input illegal.\n     */\n    function fastLerp(normalizedValue, colors, out) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        out = out || [];\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));\n\n        return out;\n    }\n\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function lerp(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n\n        var color = stringify(\n            [\n                clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))\n            ],\n            'rgba'\n        );\n\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n\n    /**\n     * @param {Array.<number>} arrColor like [12,33,44,0.4]\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color. (If input illegal, return undefined).\n     */\n    function stringify(arrColor, type) {\n        if (!arrColor || !arrColor.length) {\n            return;\n        }\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n\n    module.exports = {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastLerp: fastLerp,\n        fastMapToColor: fastLerp, // Deprecated\n        lerp: lerp,\n        mapToColor: lerp, // Deprecated\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/tool/color.js\n// module id = 993\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../util/format');\n    var classUtil = require('../util/clazz');\n    var modelUtil = require('../util/model');\n    var ComponentModel = require('./Component');\n    var colorPaletteMixin = require('./mixin/colorPalette');\n    var env = require('zrender/lib/core/env');\n    var layout = require('../util/layout');\n\n    var set = classUtil.set;\n    var get = classUtil.get;\n    var encodeHTML = formatUtil.encodeHTML;\n    var addCommas = formatUtil.addCommas;\n\n    var SeriesModel = ComponentModel.extend({\n\n        type: 'series.__base__',\n\n        /**\n         * @readOnly\n         */\n        seriesIndex: 0,\n\n        // coodinateSystem will be injected in the echarts/CoordinateSystem\n        coordinateSystem: null,\n\n        /**\n         * @type {Object}\n         * @protected\n         */\n        defaultOption: null,\n\n        /**\n         * Data provided for legend\n         * @type {Function}\n         */\n        // PENDING\n        legendDataProvider: null,\n\n        /**\n         * Access path of color for visual\n         */\n        visualColorAccessPath: 'itemStyle.normal.color',\n\n        /**\n         * Support merge layout params.\n         * Only support 'box' now (left/right/top/bottom/width/height).\n         * @type {string|Object} Object can be {ignoreSize: true}\n         * @readOnly\n         */\n        layoutMode: null,\n\n        init: function (option, parentModel, ecModel, extraOpt) {\n\n            /**\n             * @type {number}\n             * @readOnly\n             */\n            this.seriesIndex = this.componentIndex;\n\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            var data = this.getInitialData(option, ecModel);\n            if (__DEV__) {\n                zrUtil.assert(data, 'getInitialData returned invalid data.');\n            }\n            /**\n             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}\n             * @private\n             */\n            set(this, 'dataBeforeProcessed', data);\n\n            // If we reverse the order (make data firstly, and then make\n            // dataBeforeProcessed by cloneShallow), cloneShallow will\n            // cause data.graph.data !== data when using\n            // module:echarts/data/Graph or module:echarts/data/Tree.\n            // See module:echarts/data/helper/linkList\n            this.restoreData();\n        },\n\n        /**\n         * Util for merge default and theme to option\n         * @param  {Object} option\n         * @param  {module:echarts/model/Global} ecModel\n         */\n        mergeDefaultAndTheme: function (option, ecModel) {\n            var layoutMode = this.layoutMode;\n            var inputPositionParams = layoutMode\n                ? layout.getLayoutParams(option) : {};\n\n            // Backward compat: using subType on theme.\n            // But if name duplicate between series subType\n            // (for example: parallel) add component mainType,\n            // add suffix 'Series'.\n            var themeSubType = this.subType;\n            if (ComponentModel.hasClass(themeSubType)) {\n                themeSubType += 'Series';\n            }\n            zrUtil.merge(\n                option,\n                ecModel.getTheme().get(this.subType)\n            );\n            zrUtil.merge(option, this.getDefaultOption());\n\n            // Default label emphasis `show`\n            modelUtil.defaultEmphasis(option.label, ['show']);\n\n            this.fillDataTextStyle(option.data);\n\n            if (layoutMode) {\n                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n        },\n\n        mergeOption: function (newSeriesOption, ecModel) {\n            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);\n            this.fillDataTextStyle(newSeriesOption.data);\n\n            var layoutMode = this.layoutMode;\n            if (layoutMode) {\n                layout.mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n            }\n\n            var data = this.getInitialData(newSeriesOption, ecModel);\n            // TODO Merge data?\n            if (data) {\n                set(this, 'data', data);\n                set(this, 'dataBeforeProcessed', data.cloneShallow());\n            }\n        },\n\n        fillDataTextStyle: function (data) {\n            // Default data label emphasis `show`\n            // FIXME Tree structure data ?\n            // FIXME Performance ?\n            if (data) {\n                var props = ['show'];\n                for (var i = 0; i < data.length; i++) {\n                    if (data[i] && data[i].label) {\n                        modelUtil.defaultEmphasis(data[i].label, props);\n                    }\n                }\n            }\n        },\n\n        /**\n         * Init a data structure from data related option in series\n         * Must be overwritten\n         */\n        getInitialData: function () {},\n\n        /**\n         * @param {string} [dataType]\n         * @return {module:echarts/data/List}\n         */\n        getData: function (dataType) {\n            var data = get(this, 'data');\n            return dataType == null ? data : data.getLinkedData(dataType);\n        },\n\n        /**\n         * @param {module:echarts/data/List} data\n         */\n        setData: function (data) {\n            set(this, 'data', data);\n        },\n\n        /**\n         * Get data before processed\n         * @return {module:echarts/data/List}\n         */\n        getRawData: function () {\n            return get(this, 'dataBeforeProcessed');\n        },\n\n        /**\n         * Coord dimension to data dimension.\n         *\n         * By default the result is the same as dimensions of series data.\n         * But in some series data dimensions are different from coord dimensions (i.e.\n         * candlestick and boxplot). Override this method to handle those cases.\n         *\n         * Coord dimension to data dimension can be one-to-many\n         *\n         * @param {string} coordDim\n         * @return {Array.<string>} dimensions on the axis.\n         */\n        coordDimToDataDim: function (coordDim) {\n            return modelUtil.coordDimToDataDim(this.getData(), coordDim);\n        },\n\n        /**\n         * Convert data dimension to coord dimension.\n         *\n         * @param {string|number} dataDim\n         * @return {string}\n         */\n        dataDimToCoordDim: function (dataDim) {\n            return modelUtil.dataDimToCoordDim(this.getData(), dataDim);\n        },\n\n        /**\n         * Get base axis if has coordinate system and has axis.\n         * By default use coordSys.getBaseAxis();\n         * Can be overrided for some chart.\n         * @return {type} description\n         */\n        getBaseAxis: function () {\n            var coordSys = this.coordinateSystem;\n            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n        },\n\n        // FIXME\n        /**\n         * Default tooltip formatter\n         *\n         * @param {number} dataIndex\n         * @param {boolean} [multipleSeries=false]\n         * @param {number} [dataType]\n         */\n        formatTooltip: function (dataIndex, multipleSeries, dataType) {\n            function formatArrayValue(value) {\n                var vertially = zrUtil.reduce(value, function (vertially, val, idx) {\n                    var dimItem = data.getDimensionInfo(idx);\n                    return vertially |= dimItem && dimItem.tooltip !== false && dimItem.tooltipName != null;\n                }, 0);\n\n                var result = [];\n                var tooltipDims = modelUtil.otherDimToDataDim(data, 'tooltip');\n\n                tooltipDims.length\n                    ? zrUtil.each(tooltipDims, function (dimIdx) {\n                        setEachItem(data.get(dimIdx, dataIndex), dimIdx);\n                    })\n                    // By default, all dims is used on tooltip.\n                    : zrUtil.each(value, setEachItem);\n\n                function setEachItem(val, dimIdx) {\n                    var dimInfo = data.getDimensionInfo(dimIdx);\n                    // If `dimInfo.tooltip` is not set, show tooltip.\n                    if (!dimInfo || dimInfo.otherDims.tooltip === false) {\n                        return;\n                    }\n                    var dimType = dimInfo.type;\n                    var valStr = (vertially ? '- ' + (dimInfo.tooltipName || dimInfo.name) + ': ' : '')\n                        + (dimType === 'ordinal'\n                            ? val + ''\n                            : dimType === 'time'\n                            ? (multipleSeries ? '' : formatUtil.formatTime('yyyy/MM/dd hh:mm:ss', val))\n                            : addCommas(val)\n                        );\n                    valStr && result.push(encodeHTML(valStr));\n                }\n\n                return (vertially ? '<br/>' : '') + result.join(vertially ? '<br/>' : ', ');\n            }\n\n            var data = get(this, 'data');\n\n            var value = this.getRawValue(dataIndex);\n            var formattedValue = zrUtil.isArray(value)\n                ? formatArrayValue(value) : encodeHTML(addCommas(value));\n            var name = data.getName(dataIndex);\n\n            var color = data.getItemVisual(dataIndex, 'color');\n            if (zrUtil.isObject(color) && color.colorStops) {\n                color = (color.colorStops[0] || {}).color;\n            }\n            color = color || 'transparent';\n\n            var colorEl = formatUtil.getTooltipMarker(color);\n\n            var seriesName = this.name;\n            // FIXME\n            if (seriesName === '\\0-') {\n                // Not show '-'\n                seriesName = '';\n            }\n            seriesName = seriesName\n                ? encodeHTML(seriesName) + (!multipleSeries ? '<br/>' : ': ')\n                : '';\n            return !multipleSeries\n                ? seriesName + colorEl\n                    + (name\n                        ? encodeHTML(name) + ': ' + formattedValue\n                        : formattedValue\n                    )\n                : colorEl + seriesName + formattedValue;\n        },\n\n        /**\n         * @return {boolean}\n         */\n        isAnimationEnabled: function () {\n            if (env.node) {\n                return false;\n            }\n\n            var animationEnabled = this.getShallow('animation');\n            if (animationEnabled) {\n                if (this.getData().count() > this.getShallow('animationThreshold')) {\n                    animationEnabled = false;\n                }\n            }\n            return animationEnabled;\n        },\n\n        restoreData: function () {\n            set(this, 'data', get(this, 'dataBeforeProcessed').cloneShallow());\n        },\n\n        getColorFromPalette: function (name, scope) {\n            var ecModel = this.ecModel;\n            // PENDING\n            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);\n            if (!color) {\n                color = ecModel.getColorFromPalette(name, scope);\n            }\n            return color;\n        },\n\n        /**\n         * Get data indices for show tooltip content. See tooltip.\n         * @abstract\n         * @param {Array.<string>|string} dim\n         * @param {Array.<number>} value\n         * @param {module:echarts/coord/single/SingleAxis} baseAxis\n         * @return {Object} {dataIndices, nestestValue}.\n         */\n        getAxisTooltipData: null,\n\n        /**\n         * See tooltip.\n         * @abstract\n         * @param {number} dataIndex\n         * @return {Array.<number>} Point of tooltip. null/undefined can be returned.\n         */\n        getTooltipPosition: null\n    });\n\n    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);\n    zrUtil.mixin(SeriesModel, colorPaletteMixin);\n\n    module.exports = SeriesModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/model/Series.js\n// module id = 994\n// module chunks = 0 1 2","/**\n * Complete dimensions by data (guess dimension).\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n    var each = zrUtil.each;\n    var isString = zrUtil.isString;\n    var defaults = zrUtil.defaults;\n    var normalizeToArray = modelUtil.normalizeToArray;\n\n    var OTHER_DIMS = {tooltip: 1, label: 1, itemName: 1};\n\n    /**\n     * Complete the dimensions array, by user defined `dimension` and `encode`,\n     * and guessing from the data structure.\n     * If no 'value' dimension specified, the first no-named dimension will be\n     * named as 'value'.\n     *\n     * @param {Array.<string>} sysDims Necessary dimensions, like ['x', 'y'], which\n     *      provides not only dim template, but also default order.\n     *      `name` of each item provides default coord name.\n     *      [{dimsDef: []}, ...] can be specified to give names.\n     * @param {Array} data Data list. [[1, 2, 3], [2, 3, 4]].\n     * @param {Object} [opt]\n     * @param {Array.<Object|string>} [opt.dimsDef] option.series.dimensions User defined dimensions\n     *      For example: ['asdf', {name, type}, ...].\n     * @param {Object} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3}\n     * @param {string} [opt.extraPrefix] Prefix of name when filling the left dimensions.\n     * @param {string} [opt.extraFromZero] If specified, extra dim names will be:\n     *                      extraPrefix + 0, extraPrefix + extraBaseIndex + 1 ...\n     *                      If not specified, extra dim names will be:\n     *                      extraPrefix, extraPrefix + 0, extraPrefix + 1 ...\n     * @param {number} [opt.dimCount] If not specified, guess by the first data item.\n     * @return {Array.<Object>} [{\n     *      name: string mandatory,\n     *      coordDim: string mandatory,\n     *      coordDimIndex: number mandatory,\n     *      type: string optional,\n     *      tooltipName: string optional,\n     *      otherDims: {\n     *          tooltip: number optional,\n     *          label: number optional\n     *      },\n     *      isExtraCoord: boolean true or undefined.\n     *      other props ...\n     * }]\n     */\n    function completeDimensions(sysDims, data, opt) {\n        data = data || [];\n        opt = opt || {};\n        sysDims = (sysDims || []).slice();\n        var dimsDef = (opt.dimsDef || []).slice();\n        var encodeDef = zrUtil.createHashMap(opt.encodeDef);\n        var dataDimNameMap = zrUtil.createHashMap();\n        var coordDimNameMap = zrUtil.createHashMap();\n        // var valueCandidate;\n        var result = [];\n\n        var dimCount = opt.dimCount;\n        if (dimCount == null) {\n            var value0 = retrieveValue(data[0]);\n            dimCount = Math.max(\n                zrUtil.isArray(value0) && value0.length || 1,\n                sysDims.length,\n                dimsDef.length\n            );\n            each(sysDims, function (sysDimItem) {\n                var sysDimItemDimsDef = sysDimItem.dimsDef;\n                sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));\n            });\n        }\n\n        // Apply user defined dims (`name` and `type`) and init result.\n        for (var i = 0; i < dimCount; i++) {\n            var dimDefItem = isString(dimsDef[i]) ? {name: dimsDef[i]} : (dimsDef[i] || {});\n            var userDimName = dimDefItem.name;\n            var resultItem = result[i] = {otherDims: {}};\n            // Name will be applied later for avoiding duplication.\n            if (userDimName != null && dataDimNameMap.get(userDimName) == null) {\n                // Only if `series.dimensions` is defined in option, tooltipName\n                // will be set, and dimension will be diplayed vertically in\n                // tooltip by default.\n                resultItem.name = resultItem.tooltipName = userDimName;\n                dataDimNameMap.set(userDimName, i);\n            }\n            dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n        }\n\n        // Set `coordDim` and `coordDimIndex` by `encodeDef` and normalize `encodeDef`.\n        encodeDef.each(function (dataDims, coordDim) {\n            dataDims = encodeDef.set(coordDim, normalizeToArray(dataDims).slice());\n            each(dataDims, function (resultDimIdx, coordDimIndex) {\n                // The input resultDimIdx can be dim name or index.\n                isString(resultDimIdx) && (resultDimIdx = dataDimNameMap.get(resultDimIdx));\n                if (resultDimIdx != null && resultDimIdx < dimCount) {\n                    dataDims[coordDimIndex] = resultDimIdx;\n                    applyDim(result[resultDimIdx], coordDim, coordDimIndex);\n                }\n            });\n        });\n\n        // Apply templetes and default order from `sysDims`.\n        var availDimIdx = 0;\n        each(sysDims, function (sysDimItem, sysDimIndex) {\n            var coordDim;\n            var sysDimItem;\n            var sysDimItemDimsDef;\n            var sysDimItemOtherDims;\n            if (isString(sysDimItem)) {\n                coordDim = sysDimItem;\n                sysDimItem = {};\n            }\n            else {\n                coordDim = sysDimItem.name;\n                sysDimItem = zrUtil.clone(sysDimItem);\n                // `coordDimIndex` should not be set directly.\n                sysDimItemDimsDef = sysDimItem.dimsDef;\n                sysDimItemOtherDims = sysDimItem.otherDims;\n                sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex\n                    = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n            }\n\n            var dataDims = normalizeToArray(encodeDef.get(coordDim));\n            // dimensions provides default dim sequences.\n            if (!dataDims.length) {\n                for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n                    while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {\n                        availDimIdx++;\n                    }\n                    availDimIdx < result.length && dataDims.push(availDimIdx++);\n                }\n            }\n            // Apply templates.\n            each(dataDims, function (resultDimIdx, coordDimIndex) {\n                var resultItem = result[resultDimIdx];\n                applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n                if (resultItem.name == null && sysDimItemDimsDef) {\n                    resultItem.name = resultItem.tooltipName = sysDimItemDimsDef[coordDimIndex];\n                }\n                sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n            });\n        });\n\n        // Make sure the first extra dim is 'value'.\n        var extra = opt.extraPrefix || 'value';\n\n        // Set dim `name` and other `coordDim` and other props.\n        for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n            var resultItem = result[resultDimIdx] = result[resultDimIdx] || {};\n            var coordDim = resultItem.coordDim;\n\n            coordDim == null && (\n                resultItem.coordDim = genName(extra, coordDimNameMap, opt.extraFromZero),\n                resultItem.coordDimIndex = 0,\n                resultItem.isExtraCoord = true\n            );\n\n            resultItem.name == null && (resultItem.name = genName(\n                resultItem.coordDim,\n                dataDimNameMap\n            ));\n\n            resultItem.type == null && guessOrdinal(data, resultDimIdx)\n                && (resultItem.type = 'ordinal');\n        }\n\n        return result;\n\n        function applyDim(resultItem, coordDim, coordDimIndex) {\n            if (OTHER_DIMS[coordDim]) {\n                resultItem.otherDims[coordDim] = coordDimIndex;\n            }\n            else {\n                resultItem.coordDim = coordDim;\n                resultItem.coordDimIndex = coordDimIndex;\n                coordDimNameMap.set(coordDim, true);\n            }\n        }\n\n        function genName(name, map, fromZero) {\n            if (fromZero || map.get(name) != null) {\n                var i = 0;\n                while (map.get(name + i) != null) {\n                    i++;\n                }\n                name += i;\n            }\n            map.set(name, true);\n            return name;\n        }\n    }\n\n    // The rule should not be complex, otherwise user might not\n    // be able to known where the data is wrong.\n    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n        for (var i = 0, len = data.length; i < len; i++) {\n            var value = retrieveValue(data[i]);\n\n            if (!zrUtil.isArray(value)) {\n                return false;\n            }\n\n            var value = value[dimIndex];\n            // Consider usage convenience, '1', '2' will be treated as \"number\".\n            // `isFinit('')` get `true`.\n            if (value != null && isFinite(value) && value !== '') {\n                return false;\n            }\n            else if (isString(value) && value !== '-') {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    function retrieveValue(o) {\n        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;\n    }\n\n    module.exports = completeDimensions;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/data/helper/completeDimensions.js\n// module id = 995\n// module chunks = 0 1 2","'use strict';\n// Symbol factory\n\n\n    var graphic = require('./graphic');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n\n    /**\n     * Triangle shape\n     * @inner\n     */\n    var Triangle = graphic.extendShape({\n        type: 'triangle',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy + height);\n            path.lineTo(cx - width, cy + height);\n            path.closePath();\n        }\n    });\n    /**\n     * Diamond shape\n     * @inner\n     */\n    var Diamond = graphic.extendShape({\n        type: 'diamond',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy);\n            path.lineTo(cx, cy + height);\n            path.lineTo(cx - width, cy);\n            path.closePath();\n        }\n    });\n\n    /**\n     * Pin shape\n     * @inner\n     */\n    var Pin = graphic.extendShape({\n        type: 'pin',\n        shape: {\n            // x, y on the cusp\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (path, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var w = shape.width / 5 * 3;\n            // Height must be larger than width\n            var h = Math.max(w, shape.height);\n            var r = w / 2;\n\n            // Dist on y with tangent point and circle center\n            var dy = r * r / (h - r);\n            var cy = y - h + r + dy;\n            var angle = Math.asin(dy / r);\n            // Dist on x with tangent point and circle center\n            var dx = Math.cos(angle) * r;\n\n            var tanX = Math.sin(angle);\n            var tanY = Math.cos(angle);\n\n            path.arc(\n                x, cy, r,\n                Math.PI - angle,\n                Math.PI * 2 + angle\n            );\n\n            var cpLen = r * 0.6;\n            var cpLen2 = r * 0.7;\n            path.bezierCurveTo(\n                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\n                x, y - cpLen2,\n                x, y\n            );\n            path.bezierCurveTo(\n                x, y - cpLen2,\n                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\n                x - dx, cy + dy\n            );\n            path.closePath();\n        }\n    });\n\n    /**\n     * Arrow shape\n     * @inner\n     */\n    var Arrow = graphic.extendShape({\n\n        type: 'arrow',\n\n        shape: {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var height = shape.height;\n            var width = shape.width;\n            var x = shape.x;\n            var y = shape.y;\n            var dx = width / 3 * 2;\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + dx, y + height);\n            ctx.lineTo(x, y + height / 4 * 3);\n            ctx.lineTo(x - dx, y + height);\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n    });\n\n    /**\n     * Map of path contructors\n     * @type {Object.<string, module:zrender/graphic/Path>}\n     */\n    var symbolCtors = {\n        line: graphic.Line,\n\n        rect: graphic.Rect,\n\n        roundRect: graphic.Rect,\n\n        square: graphic.Rect,\n\n        circle: graphic.Circle,\n\n        diamond: Diamond,\n\n        pin: Pin,\n\n        arrow: Arrow,\n\n        triangle: Triangle\n    };\n\n    var symbolShapeMakers = {\n\n        line: function (x, y, w, h, shape) {\n            // FIXME\n            shape.x1 = x;\n            shape.y1 = y + h / 2;\n            shape.x2 = x + w;\n            shape.y2 = y + h / 2;\n        },\n\n        rect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        roundRect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n            shape.r = Math.min(w, h) / 4;\n        },\n\n        square: function (x, y, w, h, shape) {\n            var size = Math.min(w, h);\n            shape.x = x;\n            shape.y = y;\n            shape.width = size;\n            shape.height = size;\n        },\n\n        circle: function (x, y, w, h, shape) {\n            // Put circle in the center of square\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.r = Math.min(w, h) / 2;\n        },\n\n        diamond: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        pin: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        arrow: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        triangle: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        }\n    };\n\n    var symbolBuildProxies = {};\n    for (var name in symbolCtors) {\n        if (symbolCtors.hasOwnProperty(name)) {\n            symbolBuildProxies[name] = new symbolCtors[name]();\n        }\n    }\n\n    var Symbol = graphic.extendShape({\n\n        type: 'symbol',\n\n        shape: {\n            symbolType: '',\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        beforeBrush: function () {\n            var style = this.style;\n            var shape = this.shape;\n            // FIXME\n            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n                style.textPosition = ['50%', '40%'];\n                style.textAlign = 'center';\n                style.textVerticalAlign = 'middle';\n            }\n        },\n\n        buildPath: function (ctx, shape, inBundle) {\n            var symbolType = shape.symbolType;\n            var proxySymbol = symbolBuildProxies[symbolType];\n            if (shape.symbolType !== 'none') {\n                if (!proxySymbol) {\n                    // Default rect\n                    symbolType = 'rect';\n                    proxySymbol = symbolBuildProxies[symbolType];\n                }\n                symbolShapeMakers[symbolType](\n                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\n                );\n                proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n            }\n        }\n    });\n\n    // Provide setColor helper method to avoid determine if set the fill or stroke outside\n    var symbolPathSetColor = function (color) {\n        if (this.type !== 'image') {\n            var symbolStyle = this.style;\n            var symbolShape = this.shape;\n            if (symbolShape && symbolShape.symbolType === 'line') {\n                symbolStyle.stroke = color;\n            }\n            else if (this.__isEmptyBrush) {\n                symbolStyle.stroke = color;\n                symbolStyle.fill = '#fff';\n            }\n            else {\n                // FIXME  onlyStroke ?\n                symbolStyle.fill && (symbolStyle.fill = color);\n                symbolStyle.stroke && (symbolStyle.stroke = color);\n            }\n            this.dirty(false);\n        }\n    };\n\n    var symbolUtil = {\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @param {string} symbolType\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: function (symbolType, x, y, w, h, color) {\n            // TODO Support image object, DynamicImage.\n\n            var isEmpty = symbolType.indexOf('empty') === 0;\n            if (isEmpty) {\n                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n            }\n            var symbolPath;\n\n            if (symbolType.indexOf('image://') === 0) {\n                symbolPath = new graphic.Image({\n                    style: {\n                        image: symbolType.slice(8),\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n            else if (symbolType.indexOf('path://') === 0) {\n                symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));\n            }\n            else {\n                symbolPath = new Symbol({\n                    shape: {\n                        symbolType: symbolType,\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n\n            symbolPath.__isEmptyBrush = isEmpty;\n\n            symbolPath.setColor = symbolPathSetColor;\n\n            symbolPath.setColor(color);\n\n            return symbolPath;\n        }\n    };\n\n    module.exports = symbolUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/util/symbol.js\n// module id = 996\n// module chunks = 0 1 2","\n\n    module.exports = {\n        toolbox: {\n            brush: {\n                title: {\n                    rect: '',\n                    polygon: '',\n                    lineX: '',\n                    lineY: '',\n                    keep: '',\n                    clear: ''\n                }\n            },\n            dataView: {\n                title: '',\n                lang: ['', '', '']\n            },\n            dataZoom: {\n                title: {\n                    zoom: '',\n                    back: ''\n                }\n            },\n            magicType: {\n                title: {\n                    line: '',\n                    bar: '',\n                    stack: '',\n                    tiled: ''\n                }\n            },\n            restore: {\n                title: ''\n            },\n            saveAsImage: {\n                title: '',\n                lang: ['']\n            }\n        }\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/lang.js\n// module id = 997\n// module chunks = 0 1 2","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var coordinateSystemCreators = {};\n\n    function CoordinateSystemManager() {\n\n        this._coordinateSystems = [];\n    }\n\n    CoordinateSystemManager.prototype = {\n\n        constructor: CoordinateSystemManager,\n\n        create: function (ecModel, api) {\n            var coordinateSystems = [];\n            zrUtil.each(coordinateSystemCreators, function (creater, type) {\n                var list = creater.create(ecModel, api);\n                coordinateSystems = coordinateSystems.concat(list || []);\n            });\n\n            this._coordinateSystems = coordinateSystems;\n        },\n\n        update: function (ecModel, api) {\n            zrUtil.each(this._coordinateSystems, function (coordSys) {\n                // FIXME MUST have\n                coordSys.update && coordSys.update(ecModel, api);\n            });\n        },\n\n        getCoordinateSystems: function () {\n            return this._coordinateSystems.slice();\n        }\n    };\n\n    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {\n        coordinateSystemCreators[type] = coordinateSystemCreator;\n    };\n\n    CoordinateSystemManager.get = function (type) {\n        return coordinateSystemCreators[type];\n    };\n\n    module.exports = CoordinateSystemManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/echarts/lib/CoordinateSystem.js\n// module id = 998\n// module chunks = 0 1 2","'use strict';\n/**\n * Path `buildPath``ctx`, pathpathCommands\n *  isInsidePath boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n // TODO getTotalLength, getPointAtLength\n\n\n    var curve = require('./curve');\n    var vec2 = require('./vector');\n    var bbox = require('./bbox');\n    var BoundingRect = require('./BoundingRect');\n    var dpr = require('../config').devicePixelRatio;\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        // Rect\n        R: 7\n    };\n\n    // var CMD_MEM_SIZE = {\n    //     M: 3,\n    //     L: 3,\n    //     C: 7,\n    //     Q: 5,\n    //     A: 9,\n    //     R: 5,\n    //     Z: 1\n    // };\n\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n\n    var hasTypedArray = typeof Float32Array != 'undefined';\n\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function (notSaveData) {\n\n        this._saveData = !(notSaveData || false);\n\n        if (this._saveData) {\n            /**\n             * Path data. Stored as flat array\n             * @type {Array.<Object>}\n             */\n            this.data = [];\n        }\n\n        this._ctx = null;\n    };\n\n    /**\n     * Path\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n\n        constructor: PathProxy,\n\n        _xi: 0,\n        _yi: 0,\n\n        _x0: 0,\n        _y0: 0,\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        _ux: 0,\n        _uy: 0,\n\n        _len: 0,\n\n        _lineDash: null,\n\n        _dashOffset: 0,\n\n        _dashIdx: 0,\n\n        _dashSum: 0,\n\n        /**\n         * @readOnly\n         */\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n\n        getContext: function () {\n            return this._ctx;\n        },\n\n        /**\n         * @param  {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        beginPath: function (ctx) {\n\n            this._ctx = ctx;\n\n            ctx && ctx.beginPath();\n\n            ctx && (this.dpr = ctx.dpr);\n\n            // Reset\n            if (this._saveData) {\n                this._len = 0;\n            }\n\n            if (this._lineDash) {\n                this._lineDash = null;\n\n                this._dashOffset = 0;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n\n            // x0, y0, xi, yi  _dashedXXXXTo \n            // xi, yi , x0, y0  closePath \n            //  beginPath  lineTo x0, y0 \n            //  lineTo dashed line  IE10- \n            this._x0 = x;\n            this._y0 = y;\n\n            this._xi = x;\n            this._yi = y;\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux\n                || mathAbs(y - this._yi) > this._uy\n                // Force draw the first segment\n                || this._len < 5;\n\n            this.addData(CMD.L, x, y);\n\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @param  {number} x3\n         * @param  {number} y3\n         * @return {module:zrender/core/PathProxy}\n         */\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @return {module:zrender/core/PathProxy}\n         */\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n\n        /**\n         * @param  {number} cx\n         * @param  {number} cy\n         * @param  {number} r\n         * @param  {number} startAngle\n         * @param  {number} endAngle\n         * @param  {boolean} anticlockwise\n         * @return {module:zrender/core/PathProxy}\n         */\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(\n                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n            );\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n            this._xi = mathCos(endAngle) * r + cx;\n            this._yi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n\n        // TODO\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n\n        // TODO\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/PathProxy}\n         */\n        closePath: function () {\n            this.addData(CMD.Z);\n\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n\n        /**\n         * Context  rebuildPath  fill\n         * stroke \n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n\n                this._dashIdx = 0;\n\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n\n        /**\n         * \n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n\n        /**\n         *\n         * @return {boolean}\n         */\n        len: function () {\n            return this._len;\n        },\n\n        /**\n         *  Path \n         */\n        setData: function (data) {\n\n            var len = data.length;\n\n            if (! (this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n\n            this._len = len;\n        },\n\n        /**\n         * \n         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n         */\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n\n        /**\n         *  Path \n         * \n         */\n        addData: function (cmd) {\n            if (!this._saveData) {\n                return;\n            }\n\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                //  Float32Array\n                // \n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n\n            this._prevCmd = cmd;\n        },\n\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n\n        /**\n         * If needs js implemented dashed line\n         * @return {boolean}\n         * @private\n         */\n        _needsDash: function () {\n            return this._lineDash;\n        },\n\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n\n            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n                );\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        // Not accurate dashed line to\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n\n            var x;\n            var y;\n\n            var tmpLen = 0;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n\n            while (t <= 1) {\n\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n\n                t += lineDash[idx] / bezierLen;\n\n                idx = (idx + 1) % nDash;\n            }\n\n            // Finish the last segment and calculate the new offset\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n\n        /**\n         *  Float32Array \n         * Convert dynamic array to static Float32Array\n         */\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = data[i];\n                    yi = data[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n\n                switch (cmd) {\n                    case CMD.M:\n                        // moveTo  subpath, \n                        //  closePath \n                        x0 = data[i++];\n                        y0 = data[i++];\n                        xi = x0;\n                        yi = y0;\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        bbox.fromCubic(\n                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        bbox.fromQuadratic(\n                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        // TODO Arc \n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        // TODO Arc \n                        var psi = data[i++];\n                        var anticlockwise = 1 - data[i++];\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(startAngle) * rx + cx;\n                            y0 = mathSin(startAngle) * ry + cy;\n                        }\n\n                        bbox.fromArc(\n                            cx, cy, rx, ry, startAngle, endAngle,\n                            anticlockwise, min2, max2\n                        );\n\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        // Use fromLine\n                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n\n            return new BoundingRect(\n                min[0], min[1], max[0] - min[0], max[1] - min[1]\n            );\n        },\n\n        /**\n         * Rebuild path from current data\n         * Rebuild path will not consider javascript implemented line dash.\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n\n                if (i == 1) {\n                    //  L, C, Q\n                    //  previous point  point\n                    //\n                    //  Arc \n                    xi = d[i];\n                    yi = d[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        x0 = xi = d[i++];\n                        y0 = yi = d[i++];\n                        ctx.moveTo(xi, yi);\n                        break;\n                    case CMD.L:\n                        x = d[i++];\n                        y = d[i++];\n                        // Not draw too small seg between\n                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                            ctx.lineTo(x, y);\n                            xi = x;\n                            yi = y;\n                        }\n                        break;\n                    case CMD.C:\n                        ctx.bezierCurveTo(\n                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                        );\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.Q:\n                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var theta = d[i++];\n                        var dTheta = d[i++];\n                        var psi = d[i++];\n                        var fs = d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var scaleX = (rx > ry) ? 1 : rx / ry;\n                        var scaleY = (rx > ry) ? ry / rx : 1;\n                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n                        var endAngle = theta + dTheta;\n                        if (isEllipse) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                        }\n\n                        if (i == 1) {\n                            //  arc \n                            // \n                            x0 = mathCos(theta) * rx + cx;\n                            y0 = mathSin(theta) * ry + cy;\n                        }\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = d[i];\n                        y0 = yi = d[i + 1];\n                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.Z:\n                        ctx.closePath();\n                        xi = x0;\n                        yi = y0;\n                }\n            }\n        }\n    };\n\n    PathProxy.CMD = CMD;\n\n    module.exports = PathProxy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/zrender/lib/core/PathProxy.js\n// module id = 999\n// module chunks = 0 1 2"],"sourceRoot":""}